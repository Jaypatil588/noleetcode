problem_title,python_solutions
two sum,"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        
        d = {}
        for i, j in enumerate(nums):
            r = target - j
            if r in d: return [d[r], i]
            d[j] = i
		
		# An Upvote will be encouraging"
two sum,"class Solution:
def twoSum(self, nums: List[int], target: int) -> List[int]:
    store = dict()
    for i in range(len(nums)):
        sec = target - nums[i]
        if sec not in store:
            store[nums[i]]=i
        else:
            return [store[sec],i]"
add two numbers,"class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        res = dummy = ListNode()
        carry = 0
        while l1 or l2:
            v1, v2 = 0, 0
            if l1: v1, l1 = l1.val, l1.next
            if l2: v2, l2 = l2.val, l2.next
            
            val = carry + v1 + v2
            res.next = ListNode(val%10)
            res, carry = res.next, val//10
            
        if carry:
            res.next = ListNode(carry)
            
        return dummy.next"
add two numbers,"class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        _ = l1.val + l2.val
        digit, tenth = _ % 10, _ // 10
        answer = ListNode(digit)
        if any((l1.next, l2.next, tenth)):
            l1 = l1.next if l1.next else ListNode(0)
            l2 = l2.next if l2.next else ListNode(0)
            l1.val += tenth
            answer.next = self.addTwoNumbers(l1, l2)    
        return answer"
longest substring without repeating characters,"class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """"""
        :type s: str
        :rtype: int abcabcbb
        """"""
        if len(s) == 0:
            return 0
        seen = {}
        left, right = 0, 0
        longest = 1
        while right < len(s):
            if s[right] in seen:
                left = max(left,seen[s[right]]+1)
            longest = max(longest, right - left + 1)
            seen[s[right]] = right
            right += 1
            print(left, right, longest)
        return longest"
longest substring without repeating characters,"class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        res = 0
        seen = set()
        for start_idx in range(len(s)):
            seen.clear()
            end_idx = start_idx
            while end_idx < len(s):
                if s[end_idx] in seen:
                    break
                seen.add(s[end_idx])
                end_idx += 1
            res = max(res, end_idx - start_idx)
        return res"
median of two sorted arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
	    # Get the lengths of both lists
        l1,l2 = len(nums1), len(nums2)
		# Determine the middle
        middle = (l1 + l2) / 2
		
		# EDGE CASE:
		# If we only have 1 value (e.g. [1], []), return nums1[0] if the length of
		# that list is greater than the length of l2, otherwise return nums2[1]
		if middle == 0.5: return float(nums1[0]) if l1 > l2 else float(nums2[0])

		# Initialize 2 pointers
        x =  y = 0
		# Initialize 2 values to store the previous and current value (in case of an even
		# amount of values, we need to average 2 values)
        cur = prev = 0
		# Determine the amount of loops we need. If the middle is even, loop that amount + 1:
		# eg: [1, 2, 3, 4, 5, 6]        6 values, middle = 3, loops = 3+1
		#            ^  ^ 
		#            |  +-- cur
		#            +----- prev
 		# If the middle is odd, loop that amount + 0.5
		# eg: [1, 2, 3, 4, 5]           5 values, middle = 2.5, loops = 2.5+0.5
		#            ^
        #            +--- cur
        loops = middle+1 if middle % 1 == 0 else middle+0.5

		# Walk forward the amount of loops
        for _ in range(int(loops)):
            # Store the value of cur in prev
			prev = cur
			# If the x pointer is equal to the amount of elements of nums1 (l1 == len(nums1))
            if x == l1:
			    # Store nums2[y] in cur, 'cause we hit the end of nums1
                cur =  nums2[y]
				# Move the y pointer one ahead
                y += 1
		    # If the y pointer is equal to the amount of elements of nums2 (l2 == len(nums2))
            elif y == l2:
			    # Store nums1[x] in cur, 'cause we hit the end of nums2
                cur =  nums1[x]
				# Move the x pointer one ahead
                x += 1
		    # If the value in nums1 is bigger than the value in nums2
            elif nums1[x] > nums2[y]:
			    # Store nums2[y] in cur, because it's the lowest value
                cur =  nums2[y]
				# Move the y pointer one ahead
                y += 1
			# If the value in nums2 is bigger than the value in nums1
            else:
				# Store nums1[x] in, because it's the lowest value
                cur =  nums1[x]
				# Move the x pointer one ahead
                x += 1
        
		# If middle is even
        if middle % 1 == 0.0:
			# Return the average of the cur + prev values (which will return a float)
            return (cur+prev)/2
		# If middle is odd
        else:
			# Return the cur value, as a float
            return float(cur)"
median of two sorted arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        mid = (m + n) // 2 + 1
        prev2 = prev1 = None
        i = j = 0

        for _ in range(mid):
            prev2 = prev1
            if j == n or (i != m and nums1[i] <= nums2[j]):
                prev1 = nums1[i]
                i += 1
            else:
                prev1 = nums2[j]
                j += 1
        
        return prev1 if (m + n) % 2 else (prev1 + prev2) / 2"
longest palindromic substring,"class Solution:
    def longestPalindrome(self, s: str) -> str:
        n=len(s)
        def expand_pallindrome(i,j):            
            while 0<=i<=j<n and s[i]==s[j]:
                i-=1
                j+=1                            
            return (i+1, j)
        
        res=(0,0)
        for i in range(n):
            b1 = expand_pallindrome(i,i)
            b2 = expand_pallindrome(i,i+1)            
            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.
                    
        return s[res[0]:res[1]]"
longest palindromic substring,"class Solution:
    def longestPalindrome(self, s: str) -> str:
        n=len(s)
        def expand_center(i,j):            
            while 0<=i<=j<n and s[i]==s[j]:
                i-=1
                j+=1                
            
            return (i+1, j)                
        
        res=max([expand_center(i,i+offset) for i in range(n) for offset in range(2)], key=lambda x: x[1]-x[0]+1)
        
        return s[res[0]:res[1]]"
zigzag conversion,"class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
            
        row_arr = [""""] * numRows
        row_idx = 1
        going_up = True

        for ch in s:
            row_arr[row_idx-1] += ch
            if row_idx == numRows:
                going_up = False
            elif row_idx == 1:
                going_up = True
            
            if going_up:
                row_idx += 1
            else:
                row_idx -= 1
        
        return """".join(row_arr)"
zigzag conversion,"class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows < 2:
            return s
        i = 0
        res = [""""]*numRows      # We will fill in each line in the zigzag
        for letter in s:
            if i == numRows-1:  # If this is the last line in the zigzag we go up
                grow = False
            elif i == 0:        #Otherwise we go down
                grow = True 
            res[i] += letter    #Add the letter to its row
            i = (i+1) if grow else i-1  # We increment (add 1) if grow is True, 
			                            # and decrement otherwise
										
        return """".join(res)     # return the joined rows"
reverse integer,"class Solution:
    def reverse(self, x: int) -> int:
        retval = int(str(abs(x))[::-1])
        
        if(retval.bit_length()>31):
            return 0
    
        if x<0:
            return -1*retval
        else:
            return retval"
reverse integer,"class Solution:
    def reverse(self, x: int) -> int:
        if x not in range(-9,9):
            x = int(str(x)[::-1].lstrip('0')) if x >= 0 else int(f""-{str(x)[:0:-1]}"".lstrip('0'))
        return x if (x < 2**31-1 and x > -2**31) else 0"
string to integer (atoi),"class Solution:
    def myAtoi(self, s: str) -> int:
     
        if not s:
            return 0
        sign = 1
        integer = 0
        i = 0
        while i < len(s) and s[i] == ' ':
            i+=1    #skipping leading white space
        if i < len(s) and (s[i] == '-' or s[i] == '+'):
            if s[i] == '-':
                sign = -1
            i+=1
        while(i < len(s) and s[i].isdigit()):
            integer = integer * 10 + int(s[i])
            i+=1
            
        integer = sign*integer
        ans = self.limit(integer)
        return ans
    
    def limit(self, num):
        if num > pow(2, 31) -1:
            return pow(2, 31) -1
        if num < -1*pow(2, 31):
            return -1*pow(2, 31)
        return num"
string to integer (atoi),"class Solution:
    def myAtoi(self, s: str) -> int:
        if not s:
            return 0

        # remove leading and trailing whitespace
        s = s.strip()

        # save sign if one exists
        pos = True
        if s and s[0] == '-':
            pos = False
            s = s[1:]
        elif s and s[0] == '+':
            s = s[1:]
        
        # ignore leading zeros
        i = 0
        while i < len(s) and s[i] == '0':
            i += 1

        # apply relevant digits
        res = None
        while i < len(s) and s[i] in '0123456789':
            if res is None:
                res = int(s[i])
            else:
                res = (res * 10) + int(s[i])
            i += 1
        res = 0 if res is None else res

        # apply sign
        res = res if pos else -res

        # clip result
        res = max(res, -2**31)
        res = min(res, (2**31)-1)

        return res"
palindrome number,"class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        
        res = 0
        temp = x
        
        while temp:
            temp, n = divmod(temp, 10)
            res = (res * 10) + n
                
        return res == x"
palindrome number,"class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        length, temp = -1, x
        while temp:
            temp = temp // 10
            length += 1
        
        temp = x
        while temp:
            left, right = temp // 10**length, temp % 10
            if left != right:
                return False
            temp = (temp % 10**length) // 10
            length -= 2
        return True"
regular expression matching,"class Solution:
   def isMatch(self, s, p):
       n = len(s)
       m = len(p)
       dp = [[False for _ in range (m+1)] for _ in range (n+1)]
       dp[0][0] = True
       for c in range(1,m+1):
           if p[c-1] == '*' and c > 1:
               dp[0][c] = dp[0][c-2]
       for r in range(1,n+1):
           for c in range(1,m+1):
               if p[c-1] == s[r-1] or p[c-1] == '.':
                   dp[r][c] = dp[r-1][c-1]
               elif c > 1 and p[c-1] == '*':
                   if  p[c-2] =='.' or s[r-1]==p[c-2]:
                       dp[r][c] =dp[r][c-2] or dp[r-1][c]
                   else:
                       dp[r][c] = dp[r][c-2]
       return dp[n][m]"
regular expression matching,"class Solution:
    def isMatch(self, s, p):
        n = len(s)
        m = len(p)
        dp = [[False for _ in range (m+1)] for _ in range (n+1)]
        dp[0][0] = True
        for c in range(1,m+1):
            if p[c-1] == '*' and c > 1:
                dp[0][c] = dp[0][c-2]
        for r in range(1,n+1):
            for c in range(1,m+1):
                if p[c-1] == s[r-1] or p[c-1] == '.':
                    dp[r][c] = dp[r-1][c-1]
                elif c > 1 and p[c-1] == '*':
                    if  p[c-2] =='.' or s[r-1]==p[c-2]:
                        dp[r][c] =dp[r][c-2] or dp[r-1][c]
                    else:
                        dp[r][c] = dp[r][c-2]
        return dp[n][m]"
container with most water,"class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r, area = 0, len(height) - 1, 0
        while l < r:
            area = max(area, (r - l) * min(height[l], height[r]))
            if height[l] < height[r]:
				l += 1
            else:
				r -= 1
				
        return area"
container with most water,"class Solution:
    def maxArea(self, height: List[int]) -> int:
        l = 0
        r = len(height)-1
        res = 0
        while l < r:
            area = (r - l) * min(height[l], height[r])
            res = max(area,res)
            if height[l]<height[r]:
                l = l+1
            else:
                r = r-1
        return res"
integer to roman,"class Solution:
    def intToRoman(self, num: int) -> str:
        # Creating Dictionary for Lookup
        num_map = {
            1: ""I"",
            5: ""V"",    4: ""IV"",
            10: ""X"",   9: ""IX"",
            50: ""L"",   40: ""XL"",
            100: ""C"",  90: ""XC"",
            500: ""D"",  400: ""CD"",
            1000: ""M"", 900: ""CM"",
        }
        
        # Result Variable
        r = ''
        
        
        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:
            # If n in list then add the roman value to result variable
            while n <= num:
                r += num_map[n]
                num-=n
        return r"
integer to roman,"class Solution:
    def intToRoman(self, num: int) -> str:
        i=1
        dic={1:'I',5:'V',10:'X',50:'L',100:'C',500:'D',1000:'M'}
        s=""""
        while num!=0:
            y=num%pow(10,i)//pow(10,i-1)
            if y==5:
                s=dic[y*pow(10,i-1)]+s
            elif y==1:
                s=dic[y*pow(10,i-1)]+s
            elif y==4:
                s=dic[1*pow(10,i-1)]+dic[5*pow(10,i-1)]+s
            elif y==9:
                s=dic[1*pow(10,i-1)]+dic[1*pow(10,i)]+s
            elif y<4:
                s=dic[pow(10,i-1)]*y+s
            elif y>5 and y<9:
                y-=5
                s=dic[5*pow(10,i-1)]+dic[pow(10,i-1)]*y+s
            num=num//pow(10,i)
            num*=pow(10,i)
            i+=1
        return s"
roman to integer,"class Solution:
    def romanToInt(self, s: str) -> int:
        translations = {
            ""I"": 1,
            ""V"": 5,
            ""X"": 10,
            ""L"": 50,
            ""C"": 100,
            ""D"": 500,
            ""M"": 1000
        }
        number = 0
        s = s.replace(""IV"", ""IIII"").replace(""IX"", ""VIIII"")
        s = s.replace(""XL"", ""XXXX"").replace(""XC"", ""LXXXX"")
        s = s.replace(""CD"", ""CCCC"").replace(""CM"", ""DCCCC"")
        for char in s:
            number += translations[char]
        return number"
roman to integer,"class Solution:
    def romanToInt(self, s: str) -> int:
        roman_to_integer = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000,
        }
        s = s.replace(""IV"", ""IIII"").replace(""IX"", ""VIIII"").replace(""XL"", ""XXXX"").replace(""XC"", ""LXXXX"").replace(""CD"", ""CCCC"").replace(""CM"", ""DCCCC"")
        return sum(map(lambda x: roman_to_integer[x], s))"
longest common prefix,"class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        
        pre = strs[0]
        
        for i in strs:
            while not i.startswith(pre):
                pre = pre[:-1]
        
        return pre"
longest common prefix,"class Solution:
    def longestCommonPrefix(self, S: List[str]) -> str:
        if not S: return ''
        m, M, i = min(S), max(S), 0
        for i in range(min(len(m),len(M))):
            if m[i] != M[i]: break
        else: i += 1
        return m[:i]
		
		
- Junaid Mansuri
- Chicago, IL"
binary tree level order traversal,"class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        levels = []
        
        def order(node, level):
            if level >= len(levels):
                levels.append([])
            
            if node:
                levels[level].append(node.val)
            
                if node.left:
                    order(node.left, level + 1)
                
                if node.right:
                    order(node.right, level + 1)
        
        if not root:
            return []
        
        order(root, 0)
        return levels"
binary tree zigzag level order traversal,"class Solution:
    def zigzagLevelOrder(self, root):
        
        res = []
        if not root: return res
        zigzag = True
        
        q = collections.deque()
        q.append(root)
        
        while q:
            n = len(q)
            nodesOfThisLevel = []
            
            for i in range(n):
                node = q.popleft()
                nodesOfThisLevel.append(node.val)
                
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
                    
            if zigzag:
                res.append(nodesOfThisLevel)
                zigzag = False
            else:
                res.append(nodesOfThisLevel[::-1])
                zigzag = True
        
        return res
    
# Time: O(N)
# Space: O(N)"
binary tree zigzag level order traversal,"class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        
        res = []
        q = deque()
        q.append(root)
        switch = False  #check if we need to reverse in that layer 
        
        while q:
            tmp = []
            for i in range(len(q)):
                node = q.popleft()
                tmp.append(node.val)
                
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
			
            if switch: # need to reverse the order in this layer
                tmp.reverse()
            res.append(tmp)
			# remember to turn on and off
            switch = not switch
        return res"
maximum depth of binary tree,"class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        def dfs(root, depth):
            if not root: return depth
            return max(dfs(root.left, depth + 1), dfs(root.right, depth + 1))
                       
        return dfs(root, 0)"
maximum depth of binary tree,"class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"
construct binary tree from preorder and inorder traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        loc = {x : i for i, x in enumerate(inorder)}
        root = None
        stack = []
        for x in preorder: 
            if not root: root = node = TreeNode(x)
            elif loc[x] < loc[node.val]: 
                stack.append(node)
                node.left = node = TreeNode(x)
            else: 
                while stack and loc[stack[-1].val] < loc[x]: node = stack.pop() # backtracking
                node.right = node = TreeNode(x)
        return root"
construct binary tree from preorder and inorder traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        loc = {x: i for i, x in enumerate(inorder)}
        pre = iter(preorder)
        
        def fn(lo, hi): 
            """"""Return node constructed from inorder[lo:hi].""""""
            if lo == hi: return None
            k = loc[next(pre)]
            return TreeNode(inorder[k], fn(lo, k), fn(k+1, hi))
        
        return fn(0, len(inorder))"
construct binary tree from inorder and postorder traversal,"class Solution:
    def buildTree(self, inorder, postorder):
        inorderIndexDict = {ch : i for i, ch in enumerate(inorder)}
        self.rootIndex = len(postorder) - 1
        
        def solve(l, r):
            if l > r: return None
            
            root = TreeNode(postorder[self.rootIndex]) 
            self.rootIndex -= 1
            
            i = inorderIndexDict[root.val]
            
            # As we a approaching from end and all right side nodes of i in inorder are
            # from right sub-tree so first call solve for right then left.
            root.right = solve(i+1, r)
            root.left =  solve(l, i-1)
            
            return root
        
        return solve(0, len(inorder)-1)
    
    
# Time: O(N)
# Space: O(1)"
construct binary tree from inorder and postorder traversal,"class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not postorder:
            return
        
        root = TreeNode(preorder[0])
        if len(preorder) == 1:
            return root
        index = postorder.index(preorder[1])
        root.left = self.constructFromPrePost(preorder[1:index+2], postorder[:index+1])
        root.right = self.constructFromPrePost(preorder[index+2:], postorder[index+1:-1])
        return root"
binary tree level order traversal ii,"class Solution:
    def helper(self, result, depth, node):
        if not node:
            return
        
        if len(result) < depth:
            result.append([])
            
        result[depth-1].append(node.val)
        self.helper(result, depth+1, node.left)
        self.helper(result, depth+1, node.right)
        
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        
        result = []
        depth = 1
        self.helper(result, depth, root)
        result.reverse()
        return result"
binary tree level order traversal ii,"class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        ans, queue = [], [root]
        while queue: 
            tmp, val = [], []
            for node in queue: 
                if node: 
                    val.append(node.val)
                    tmp.extend([node.left, node.right])
            if val: ans.append(val)
            queue = tmp
        return ans[::-1]"
convert sorted array to binary search tree,"class Solution(object):
    def sortedArrayToBST(self, nums):
        # Base condition...
        if len(nums) == 0:
            return None
        # set the middle node...
        mid = len(nums)//2
        # Initialise root node with value same as nums[mid]
        root = TreeNode(nums[mid])
        # Assign left subtrees as the same function called on left subranges...
        root.left = self.sortedArrayToBST(nums[:mid])
        # Assign right subtrees as the same function called on right subranges...
        root.right = self.sortedArrayToBST(nums[mid+1:])
        # Return the root node...
        return root"
convert sorted array to binary search tree,"class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        # Base condition...
        if len(nums) == 0:
            return None
        # set the middle node...
        mid = len(nums)//2
        # Initialise root node with value same as nums[mid]
        root = TreeNode(nums[mid])
        # Assign left subtrees as the same function called on left subranges...
        root.left = self.sortedArrayToBST(nums[:mid])
        # Assign right subtrees as the same function called on right subranges...
        root.right = self.sortedArrayToBST(nums[mid+1:])
        # Return the root node...
        return root"
convert sorted list to binary search tree,"class Solution:
    l = 'left'
    r = 'right'
    
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        if not head: return None
        
        nums = []
        while head:
            nums.append(head.val)
            head = head.next
        
        mid = len(nums) // 2
        treeNode = TreeNode(nums[mid])
        
        self.binarySearchTree(nums[:mid], self.l, treeNode)
        self.binarySearchTree(nums[(mid + 1):], self.r, treeNode)
        
        return treeNode
            
            
    def binarySearchTree(self, nums, direction, treeNode):
        if len(nums) <= 0: return
        
        mid = len(nums) // 2
        left, right = nums[:mid], nums[(mid + 1):]
        
        if direction == self.l:
            treeNode.left = TreeNode(nums[mid])
            self.binarySearchTree(left, self.l, treeNode.left)
            self.binarySearchTree(right, self.r, treeNode.left)
        else:
            treeNode.right = TreeNode(nums[mid])
            self.binarySearchTree(left, self.l, treeNode.right)
            self.binarySearchTree(right, self.r, treeNode.right)"
convert sorted list to binary search tree,"class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        if not head:
            return head
        if not head.next:
            return TreeNode(head.val)
        
        fast = slow = prev_of_slow = head
        # looking for median of list
        while fast and fast.next:
            prev_of_slow, slow, fast = slow, slow.next, fast.next.next
            
        # median = slow.val
        prev_of_slow.next = None
        return TreeNode(slow.val, left=self.sortedListToBST(head), right=self.sortedListToBST(slow.next))"
balanced binary tree,"class Solution(object):
    def isBalanced(self, root):
        return (self.Height(root) >= 0)
    def Height(self, root):
        if root is None:  return 0
        leftheight, rightheight = self.Height(root.left), self.Height(root.right)
        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1
        return max(leftheight, rightheight) + 1"
balanced binary tree,"class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        return (self.Height(root) >= 0)
    def Height(self, root: Optional[TreeNode]) -> bool:
        if root is None:  return 0
        leftheight, rightheight = self.Height(root.left), self.Height(root.right)
        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1
        return max(leftheight, rightheight) + 1"
minimum depth of binary tree,"class Solution(object):
    def minDepth(self, root):
        # Base case...
        # If the subtree is empty i.e. root is NULL, return depth as 0...
        if root is None:  return 0
        # Initialize the depth of two subtrees...
        leftDepth = self.minDepth(root.left)
        rightDepth = self.minDepth(root.right)
        # If the both subtrees are empty...
        if root.left is None and root.right is None:
            return 1
        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...
        if root.left is None:
            return 1 + rightDepth
        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...
        if root.right is None:
            return 1 + leftDepth
        # When the two child function return its depth...
        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...
        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees..."
minimum depth of binary tree,"class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        # Base case...
        # If the subtree is empty i.e. root is NULL, return depth as 0...
        if root is None:  return 0
        # Initialize the depth of two subtrees...
        leftDepth = self.minDepth(root.left)
        rightDepth = self.minDepth(root.right)
        # If the both subtrees are empty...
        if root.left is None and root.right is None:
            return 1
        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...
        if root.left is None:
            return 1 + rightDepth
        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...
        if root.right is None:
            return 1 + leftDepth
        # When the two child function return its depth...
        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...
        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees..."
path sum,"class Solution:
    """"""
    Time:   O(n)
    Memory: O(n)
    """"""

    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:
        if root is None:
            return False
        if root.left is None and root.right is None:
            return target == root.val
        return self.hasPathSum( root.left, target - root.val) or \
               self.hasPathSum(root.right, target - root.val)"
path sum,"class Solution(object):
    def hasPathSum(self, root, targetSum):
        # If the tree is empty i.e. root is NULL, return false...
	    if root is None: return 0
        # If there is only a single root node and the value of root node is equal to the targetSum...
	    if root.val == targetSum and (root.left is None and root.right is None):  return 1
        # Call the same function recursively for left and right subtree...
	    return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"
path sum ii,"class Solution:
    def pathSum(self, R: TreeNode, S: int) -> List[List[int]]:
        A, P = [], []
        def dfs(N):
            if N == None: return
            P.append(N.val)
            if (N.left,N.right) == (None,None) and sum(P) == S: A.append(list(P))
            else: dfs(N.left), dfs(N.right)
            P.pop()
        dfs(R)
        return A
		
		
- Junaid Mansuri
- Chicago, IL"
path sum ii,"class Solution:        
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        if root is None:
            return []
        q, paths = deque([(root, targetSum, [])]), []
        
        while q:
            cur, target, path = q.pop()  
            if not (cur.left or cur.right) and cur.val == target:
                paths.append(path + [cur.val])
            else:
                if cur.left:
                    q.appendleft((cur.left, target - cur.val, path + [cur.val]))
                if cur.right:
                    q.appendleft((cur.right, target - cur.val, path + [cur.val]))
                                 
        return paths"
flatten binary tree to linked list,"class Solution:
    def __init__(self):
        self.prev = None
        
    def flatten(self, root: Optional[TreeNode]) -> None:
        
        if not root: return 
        self.flatten(root.right)
        self.flatten(root.left)
        root.right = self.prev
        root.left = None
        self.prev = root"
flatten binary tree to linked list,"class Solution:
    
    def __init__(self):
        self.prev = None
    
    def flatten(self, root):
        if not root:
            return None
        self.flatten(root.right)
        self.flatten(root.left)

        root.right = self.prev
        root.left = None
        self.prev = root"
distinct subsequences,"class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m = len(s)
        n = len(t)
        dp = [[0] * (n+1) for _ in range(m+1)]
        
        for i in range(m+1):
            dp[i][0] = 1
        
        """"""redundant, as we have initialised dp table with full of zeros""""""
#         for i in range(1, n+1): 
#             dp[0][i] = 0
        
        for i in range(1, m+1):
            for j in range(1, n+1):
                dp[i][j] += dp[i-1][j] 			#if current character is skipped
                if s[i-1] == t[j-1]:
                    dp[i][j] += dp[i-1][j-1]	#if current character is used
        
        return dp[-1][-1]"
distinct subsequences,"class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        ## RC ##
		## APPROACH : DP ##
		## LOGIC ##
		#	1. Point to be noted, empty seq is also subsequence of any sequence i.e """", """" should return 1. so we fill the first row accordingly
		#	2. if chars match, we get the maximum of [diagonal + upper, upper + 1] (Try below example)
		#	3. if no match, we pull the upper value
		
        ## EXAMPLE : ""axacccax"" ""aca""	##
		## STACK TRACE ##
        # [      """"  a  c  a
        #     """" [1, 0, 0, 0], 
        #     a  [1, 1, 0, 0], 
        #     x  [1, 1, 0, 0], 
        #     a  [1, 2, 0, 0], 
        #     c  [1, 2, 2, 0], 
        #     c  [1, 2, 4, 0], 
        #     c  [1, 2, 6, 0], 
        #     a  [1, 3, 6, 6], 
        # ]
        
		## TIME COMPLEXITY : O(MxN) ##
		## SPACE COMPLEXITY : O(MxN) ##

        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]
        
        for k in range(len(dp)):
            dp[k][0] = 1
        
        for i in range(1, len(dp)):
            for j in range(1, len(dp[0])):
                if(s[i-1] == t[j-1] and dp[i-1][j-1]):
                    dp[i][j] = max(dp[i-1][j-1] + dp[i-1][j], dp[i-1][j]+1)
                else:
                    dp[i][j] = dp[i-1][j]
        # print(dp)
        return dp[-1][-1]"
populating next right pointers in each node,"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        # edge case check
        if not root:
            return None
        
        # initialize the queue with root node (for level order traversal)
        queue = collections.deque([root])
        
        # start the traversal
        while queue:
            size = len(queue) # get number of nodes on the current level
            for i in range(size):
                node = queue.popleft() # pop the node
                
                # An important check so that we do not wire the node to the node on the next level.
                if i < size-1:
                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. 
                    
                if node.left:
                    queue.append(node.left) 
                if node.right:
                    queue.append(node.right)           
                
        return root"
populating next right pointers in each node,"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        # edge case check
        if not root:
            return None
        
        node = root # create a pointer to the root node
        
        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)
        while node.left:
            head = node
            while head:
                head.left.next = head.right
                if head.next:
                    head.right.next = head.next.left
                    
                head = head.next
                
            node = node.left

        return root"
populating next right pointers in each node ii,"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        q = deque()
        q.append(root)
        dummy=Node(-999) # to initialize with a not null prev
        while q:
            length=len(q) # find level length
            
            prev=dummy
            for _ in range(length): # iterate through all nodes in the same level
                popped=q.popleft()
                if popped.left:
                    q.append(popped.left)
                    prev.next=popped.left
                    prev=prev.next
                if popped.right:
                    q.append(popped.right)
                    prev.next=popped.right
                    prev=prev.next                
                 
        return root"
populating next right pointers in each node ii,"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        
        curr=root
        dummy=Node(-999)        
        head=root        

		while head:
            curr=head # initialize current level's head
            prev=dummy # init prev for next level linked list traversal
			# iterate through the linked-list of the current level and connect all the siblings in the next level
            while curr:  
                if curr.left:
                    prev.next=curr.left
                    prev=prev.next
                if curr.right:
                    prev.next=curr.right
                    prev=prev.next                                                
                curr=curr.next
            head=dummy.next # update head to the linked list of next level
            dummy.next=None # reset dummy node
        return root"
pascals triangle,"class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        l=[0]*numRows
        for i in range(numRows):
            l[i]=[0]*(i+1)
            l[i][0]=1
            l[i][i]=1
            for j in range(1,i):
                l[i][j]=l[i-1][j-1]+l[i-1][j]
        return l"
pascals triangle,"class Solution(object):
    def generate(self, numRows):
        # Create an array list to store the output result...
        output = []
        for i in range(numRows):
            if(i == 0):
                # Create a list to store the prev triangle value for further addition...
                # Inserting for the first row &amp; store the prev array to the output array...
                prev = [1]
                output.append(prev)
            else:
                curr = [1]
                j = 1
                # Calculate for each of the next values...
                while(j < i):
                    # Inserting the addition of the prev arry two values...
                    curr.append(prev[j-1] + prev[j])
                    j+=1
                # Store the number 1...
                curr.append(1)
                # Store the value in the Output array...
                output.append(curr)
                # Set prev is equal to curr...
                prev = curr
        return output       # Return the output list of pascal values..."
pascals triangle ii,"class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        
        if rowIndex == 0:
            # Base case
            return [1]
        
        elif rowIndex == 1:
            # Base case
            return [1, 1]
        
        else:
            # General case:
            last_row = self.getRow( rowIndex-1 )
            size = len(last_row)
            return [ last_row[0] ] + [ last_row[idx] + last_row[idx+1] for idx in range( size-1) ] + [ last_row[-1] ]"
pascals triangle ii,"class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        res=[]
        for i in range(rowIndex+1):
            res.append([])
            for j in range(i+1):
                if j == 0 or j == i:
                    res[i].append(1)
                else:
                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])
        return res[rowIndex]"
triangle,"class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for i in range(1, len(triangle)):  # for each row in triangle (skipping the first),
            for j in range(i+1):           # loop through each element in the row
                triangle[i][j] += min(triangle[i-1][j-(j==i)],  # minimum sum from coordinate (x-1, y)
                                      triangle[i-1][j-(j>0)])   # minimum sum from coordinate (x-1, y-1)
        return min(triangle[-1])  # obtain minimum sum from last row"
triangle,"class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for i in range(len(triangle)-2, -1, -1):  # for each row in triangle (skipping the last),
            for j in range(i+1):                  # loop through each element in the row
                triangle[i][j] += min(triangle[i+1][j],    # minimum sum from coordinate (x+1, y)
                                      triangle[i+1][j+1])  # minimum sum from coordinate (x+1, y+1)
        return triangle[0][0]"
best time to buy and sell stock,"class Solution(object):
    def maxProfit(self, prices):
        n = len(prices)
        dp = [0]*n # initializing the dp table
        dp[0] = [prices[0],0] # filling the the first dp table --> low_price = prices[0] max_profit=0
        min_price = max_profit = 0
        # Note that ---> indixing the dp table --> dp[i-1][0] stores minimum price and dp[i-1][1] stores maximum profit
        for i in range(1,n):
            min_price = min(dp[i-1][0], prices[i]) # min(previous_min_price, cur_min_price)
            max_profit = max(dp[i-1][1], prices[i]-dp[i-1][0]) # max(previoius_max_profit, current_profit)
            dp[i] =[min_price,max_profit]
                
        return dp[n-1][1]
		#Runtime: 1220 ms, 
		#Memory Usage: 32.4 MB,"
best time to buy and sell stock,"class Solution(object):
    def maxProfit(self, prices):
        if len(prices) == 0: return 0
        else:
            profit = 0
            minBuy = prices[0]
            for i in range(len(prices)):
                profit = max(prices[i] - minBuy, profit)
                minBuy = min(minBuy, prices[i])
            return profit"
best time to buy and sell stock ii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        @cache
        def trade(day_d):
            
            if day_d == 0:
                
                # Hold on day_#0 = buy stock at the price of day_#0
                # Not-hold on day_#0 = doing nothing on day_#0
                return -prices[day_d], 0
            
            prev_hold, prev_not_hold = trade(day_d-1)
            
            hold = max(prev_hold, prev_not_hold - prices[day_d] )
            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )
            
            return hold, not_hold
        
        # --------------------------------------------------
        last_day= len(prices)-1
        
        # Max profit must come from not_hold state (i.e., no stock position) on last day
        return trade(last_day)[1]"
best time to buy and sell stock ii,"class Solution(object):
    def maxProfit(self, prices):
        # Initialize the max profit...
        maximumProfit = 0
        # Traverse all the element through loop...
        for i in range(1, len(prices)):
            # check if the price is greater at i...
            if prices[i] > prices[i-1]:
                # Add the difference to profit and increse it...
                maximumProfit += prices[i] - prices[i-1]
        return maximumProfit        # Return the max profit..."
best time to buy and sell stock iii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = [inf]*2, [0]*2
        for x in prices:
            for i in range(2): 
                if i: buy[i] = min(buy[i], x - sell[i-1])
                else: buy[i] = min(buy[i], x)
                sell[i] = max(sell[i], x - buy[i])
        return sell[1]"
best time to buy and sell stock iii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        
        A = -prices[0]
        B = float('-inf')
        C = float('-inf')
        D = float('-inf')
        
        for price in prices:
            A = max(A, -price)
            B = max(B, A + price)
            C = max(C, B - price)
            D = max(D, C + price)
            
        return D"
binary tree maximum path sum,"class Solution:
    def __init__(self):
        self.maxSum = float('-inf')
    def maxPathSum(self, root: TreeNode) -> int:
        def traverse(root):
            if root:
                left = traverse(root.left)
                right = traverse(root.right)
                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)
                return max(root.val,root.val + left,root.val + right)
            else:
                return 0
        traverse(root)
        return self.maxSum"
binary tree maximum path sum,"class Solution:
    def __init__(self):
        self.maxSum = float('-inf')
    def maxPathSum(self, root: TreeNode) -> int:
        def traverse(root):
            if root:
                left = traverse(root.left)
                right = traverse(root.right)
                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)
                return max(root.val,root.val + left,root.val + right)
            else:
                return 0
        traverse(root)
        return self.maxSum"
valid palindrome,"class Solution:
    def isPalindrome(self, s: str) -> bool:
    	s = [i for i in s.lower() if i.isalnum()]
    	return s == s[::-1]"
valid palindrome,"class Solution:
    def isPalindrome(self, s: str) -> bool:
    	i, j = 0, len(s) - 1
    	while i < j:
    		a, b = s[i].lower(), s[j].lower()
    		if a.isalnum() and b.isalnum():
    			if a != b: return False
    			else:
    				i, j = i + 1, j - 1
    				continue
    		i, j = i + (not a.isalnum()), j - (not b.isalnum())
    	return True


- Junaid Mansuri
(LeetCode ID)@hotmail.com"
word ladder ii,"class Solution:
		def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
			d = defaultdict(list)
			for word in wordList:
				for i in range(len(word)):
					d[word[:i]+""*""+word[i+1:]].append(word)

			if endWord not in wordList:
				return []

			visited1 = defaultdict(list)
			q1 = deque([beginWord])
			visited1[beginWord] = []

			visited2 = defaultdict(list)
			q2 = deque([endWord])
			visited2[endWord] = []

			ans = []
			def dfs(v, visited, path, paths):
				path.append(v)
				if not visited[v]:
					if visited is visited1:
						paths.append(path[::-1])
					else:
						paths.append(path[:])
				for u in visited[v]:
					dfs(u, visited, path, paths)
				path.pop()

			def bfs(q, visited1, visited2, frombegin):
				level_visited = defaultdict(list)
				for _ in range(len(q)):
					u = q.popleft()

					for i in range(len(u)):
						for v in d[u[:i]+""*""+u[i+1:]]:
							if v in visited2:
								paths1 = []
								paths2 = []
								dfs(u, visited1, [], paths1)
								dfs(v, visited2, [], paths2)
								if not frombegin:
									paths1, paths2 = paths2, paths1
								for a in paths1:
									for b in paths2:
										ans.append(a+b)
							elif v not in visited1:
								if v not in level_visited:
									q.append(v)
								level_visited[v].append(u)
				visited1.update(level_visited)

			while q1 and q2 and not ans:
				if len(q1) <= len(q2):
					bfs(q1, visited1, visited2, True)
				else:
					bfs(q2, visited2, visited1, False)

			return ans"
word ladder ii,"class Solution:
		def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
			res = []
			edge = collections.defaultdict(set)
			wordList = set(wordList)
			for word in wordList:
				for i in range(len(word)):
					edge[word[:i] +'*'+word[i+1:]].add(word)
			bfsedge = {}

			def bfs():
				minl = 0
				queue = set()
				queue.add(beginWord)
				while queue:
					next_queue = set()
					for word in queue:
						if word in wordList:
							wordList.remove(word)
					bfsedge[minl] = collections.defaultdict(set)
					for word in queue:
						if word == endWord:
							return minl
						for i in range(len(word)):
							for w in edge[word[:i]+'*'+word[i+1:]]:
								if w in wordList:
									next_queue.add(w)
									bfsedge[minl][w].add(word)
					queue = next_queue
					minl += 1
				return minl

			def dfs(seq, endWord):
				if seq[-1] == endWord:
					res.append(seq.copy())
					return
				for nextWord in bfsedge[minl-len(seq)][seq[-1]]:
					if nextWord not in seq:
						dfs(seq+[nextWord], endWord)

			minl = bfs()
			dfs([endWord], beginWord)
			# reverse the sequence
			for sq in res:
				sq.reverse()
			return res"
word ladder,"class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):

        graph = defaultdict(list)
        for word in wordList:
            for index in range(len(beginWord)):
                graph[word[:index] + ""_"" + word[index+1:]].append(word)

        queue = deque()
        queue.append((beginWord, 1))
        visited = set()
        while queue:
            current_node, current_level = queue.popleft()
            if current_node == endWord: return current_level
            for index in range(len(beginWord)):
                node = current_node[:index] + ""_"" + current_node[index+1:]
                for neighbour in graph[node]:
                    if neighbour not in visited:
                        queue.append((neighbour, current_level + 1))
                        visited.add(neighbour)
                graph[node] = []
                
        return 0"
word ladder,"class Solution:
	def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
		if endWord not in wordList:
			return 0
		nei = collections.defaultdict(list)
		wordList.append(beginWord)

		for word in wordList:
			for j in range(len(word)):
				pattern = word[:j] + ""*"" + word[j + 1:]
				nei[pattern].append(word)

		visit = set([beginWord])
		q = deque([beginWord])
		res = 1
		while q:
			for i in range(len(q)):
				word = q.popleft()
				if word == endWord:
					return res
				for j in range(len(word)):
					pattern = word[:j] + ""*"" + word[j + 1:]
					for neiWord in nei[pattern]:
						if neiWord not in visit:
							visit.add(neiWord)
							q.append(neiWord)

			res += 1
		return 0"
longest consecutive sequence,"class Node:
    def __init__(self, val):
        self.val = val
        self.parent = self
        self.size = 1
    
class UnionFind:
        
    def find(self, node):
        if node.parent != node:
            node.parent = self.find(node.parent)
        return node.parent
    
    def union(self, node1, node2):
        parent_1 = self.find(node1)
        parent_2 = self.find(node2)
        if parent_1 != parent_2:
            parent_2.parent = parent_1
            parent_1.size += parent_2.size
        return parent_1.size
                
        
        
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        uf = UnionFind()
        nodes = {}
        max_size = 0
        for num in nums:
            if num not in nodes:
                node = Node(num)
                nodes[num] = node
                size = 1
                if num + 1 in nodes:
                    size = uf.union(node, nodes[num+1])
                if num - 1 in nodes:
                    size = uf.union(node, nodes[num-1])
                max_size = max(max_size, size)
                
        return max_size
		```"
longest consecutive sequence,"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        num_set = set(nums)
        longest = 0
        for n in nums:
            if n-1 not in num_set:
                length = 0
                while n in num_set:
                    length += 1
                    n += 1
                longest = max(longest, length)
        return longest"
sum root to leaf numbers,"class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        def helper(node, num):
            if node is None:
                return 0
            num = num * 10 + node.val
            if node.left is None and node.right is None:
                return num
            return helper(node.left, num) + helper(node.right, num)
        
        return helper(root, 0)"
sum root to leaf numbers,"class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        ans = 0 
        stack = [(root, 0)]
        while stack: 
            node, val = stack.pop()
            val = 10*val + node.val 
            if not node.left and not node.right: ans += val 
            if node.left: stack.append((node.left, val))
            if node.right: stack.append((node.right, val))
        return ans"
surrounded regions,"class Solution:
    
    def dfs(self,board,i,j):
            
        if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or board[i][j]!='O':
            return
        board[i][j]='$'  # converting to  a dollar sign 
            
        self.dfs(board,i+1,j)
        self.dfs(board,i-1,j)
        self.dfs(board,i,j+1)
        self.dfs(board,i,j-1)
        
    def solve(self, board: List[List[str]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        if len(board)==0:
            return None
        
        m=len(board)
        n=len(board[0])
        
        
        for i in range(m):  # call dfs on all border 'O's and turn them to '$'
            for j in range(n):
                if i==0 or i==m-1:
                    self.dfs(board,i,j)
                        
                if j==0 or j==n-1:
                    self.dfs(board,i,j)
                    
        
   
#all border O and others connected them were already converted to $ sign 
#so left out zeros are surely surrounded by 'X' . Turn all of them to 'X'
        for i in range(m):   
            for j in range(n):
                if board[i][j]=='O':
                    board[i][j]='X'
        
# turn the border zeros and their adjacents to their initial form. ie $ -> O 
        for i in range(m):
            for j in range(n):
                if board[i][j]=='$':
                    board[i][j]='O'"
surrounded regions,"class Solution:
	def solve(self, board: List[List[str]]) -> None:
		""""""
		Do not return anything, modify board in-place instead.
		""""""
		m,n = len(board),len(board[0])
		def dfs(i,j):
			if i<0 or i>=m or j<0 or j>=n or board[i][j]!=""O"":
				return

			board[i][j] = ""*""
			dfs(i+1,j)
			dfs(i-1,j)
			dfs(i,j+1)
			dfs(i,j-1)
			return

		for i in range(m):
			dfs(i,0)
			dfs(i,n-1)

		for j in range(n):
			dfs(0,j)
			dfs(m-1,j)

		for i in range(m):
			for j in range(n):
				if board[i][j] == ""*"":
					board[i][j] = ""O""
				elif board[i][j] == ""O"":
					board[i][j] = ""X""
		return"
palindrome partitioning,"class Solution(object):
    @cache  # the memory trick can save some time
    def partition(self, s):
        if not s: return [[]]
        ans = []
        for i in range(1, len(s) + 1):
            if s[:i] == s[:i][::-1]:  # prefix is a palindrome
                for suf in self.partition(s[i:]):  # process suffix recursively
                    ans.append([s[:i]] + suf)
        return ans"
palindrome partitioning,"class Solution(object):
    def __init__(self):
        self.memory = collections.defaultdict(list)
        
    def partition(self, s):
        if not s: return [[]]
        if s in self.memory: return self.memory[s]  # the memory trick can save some time
        ans = []
        for i in range(1, len(s) + 1):
            if s[:i] == s[:i][::-1]:  # prefix is a palindrome
                for suf in self.partition(s[i:]):  # process suffix recursively
                    ans.append([s[:i]] + suf)
        self.memory[s] = ans
        return ans"
palindrome partitioning ii,"class Solution:
    def minCut(self, s: str) -> int:
        #pre-processing
        palin = dict()
        for k in range(len(s)):
            for i, j in (k, k), (k, k+1):
                while 0 <= i and j < len(s) and s[i] == s[j]: 
                    palin.setdefault(i, []).append(j)
                    i, j = i-1, j+1
                
        #dp 
        @lru_cache(None)
        def fn(i):
            """"""Return minimum palindrome partitioning of s[i:]""""""
            if i == len(s): return 0
            return min(1 + fn(ii+1) for ii in palin[i])
        
        return fn(0)-1"
palindrome partitioning ii,"class Solution:
    def minCut(self, s: str) -> int:
        ans = [inf]*len(s) + [0] #min palindrome partition for s[i:]
        for k in reversed(range(len(s))): 
            for i, j in (k, k), (k, k+1):
                while 0 <= i and j < len(s) and s[i] == s[j]: 
                    ans[i] = min(ans[i], 1 + ans[j+1])
                    i, j = i-1, j+1
        return ans[0]-1"
clone graph,"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node: return node
        
        q, clones = deque([node]), {node.val: Node(node.val, [])}
        while q:
            cur = q.popleft() 
            cur_clone = clones[cur.val]            

            for ngbr in cur.neighbors:
                if ngbr.val not in clones:
                    clones[ngbr.val] = Node(ngbr.val, [])
                    q.append(ngbr)
                    
                cur_clone.neighbors.append(clones[ngbr.val])
                
        return clones[node.val]"
clone graph,"class Solution(object):
    def cloneGraph(self, node):
        """"""
        :type node: Node
        :rtype: Node
        """"""
        if node == None:
            return None
        
        self.visited = dict()
        node_copy = Node(node.val, [])
        self.visited[node] = node_copy
        self.dfs(node)
        return node_copy
    
    def dfs(self, node):
        for neighbor in node.neighbors:
            if neighbor not in self.visited:    # add the neighbor node to visited dict
                neighbor_copy = Node(neighbor.val, [])
                self.visited[neighbor] = neighbor_copy
                self.visited[node].neighbors.append(neighbor_copy)
                self.dfs(neighbor)
            else:   # use the neighbor node in the visited dict
                self.visited[node].neighbors.append(self.visited[neighbor])"
gas station,"class Solution:
	def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
		
		# base case
		if sum(gas) - sum(cost) < 0:
			return -1

		gas_tank = 0  # gas available in car till now
		start_index = 0  # Consider first gas station as starting point

		for i in range(len(gas)):

			gas_tank += gas[i] - cost[i]

			if gas_tank < 0:  # the car has deficit of petrol
				start_index = i+1  # change the starting point
				gas_tank = 0  # make the current gas to 0, as we will be starting again from next station

		return start_index"
gas station,"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        diff = [g-c for g, c in zip(gas, cost)]       # get difference between gas &amp; cost
        idx, min_val, cur = 0, sys.maxsize, 0         # get cumulative sum and find the smallest, the place after the smallest idx will be where we start
        for i, v in enumerate(diff):
            cur += v 
            if cur <= min_val: min_val, idx = cur, i  # maintain smallest &amp; its index
        return (idx+1)%len(diff) if cur >= 0 else -1  # if total sum is less than 0, meaning no possible place to start"
candy,"class Solution:
    def candy(self, ratings: List[int]) -> int:
        n=len(ratings)
        temp = [1]*n
        
        for i in range(1,n):
            if(ratings[i]>ratings[i-1]):
                temp[i]=temp[i-1]+1
        if(n>1):
            if(ratings[0]>ratings[1]):
                temp[0]=2
                
            
        for i in range(n-2,-1,-1):
            if(ratings[i]>ratings[i+1] and temp[i]<=temp[i+1]):
                temp[i]=temp[i+1]+1

                
        return sum(temp)"
candy,"class Solution:
    def candy(self, ratings: List[int]) -> int:
        length = len(ratings)
        candies = [1] * length
        for i in range(1, length):
            if ratings[i] > ratings[i-1] and candies[i] <= candies[i-1]:
                candies[i] = candies[i-1] + 1
        for i in range(length - 2, -1, -1):
            if ratings[i] > ratings[i + 1] and candies[i] <= candies[i+1]:
                candies[i] = candies[i+1] + 1
        return sum(candies)"
single number,"class Solution(object):
    def singleNumber(self, nums):
        # Initialize the unique number...
        uniqNum = 0;
        # TRaverse all elements through the loop...
        for idx in nums:
            # Concept of XOR...
            uniqNum ^= idx;
        return uniqNum;       # Return the unique number..."
single number,"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # Initialize the unique number...
        uniqNum = 0;
        # TRaverse all elements through the loop...
        for idx in nums:
            # Concept of XOR...
            uniqNum ^= idx;
        return uniqNum;       # Return the unique number..."
single number ii,"class Solution(object):
    def singleNumber(self, nums):
        a, b = 0, 0
        for x in nums:
            a, b = (~x&amp;a&amp;~b)|(x&amp;~a&amp;b), ~a&amp;(x^b)
        return b"
single number ii,"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        d = {}
        for i in nums:
            if i in d:
                d[i] += 1
            else:
                d[i] = 1
        for a,b in d.items():
            print(a,b)
            if b == 1:
                return a"
copy list with random pointer,"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        hm, zero = dict(), Node(0)
        
        cur, copy = head, zero
        while cur:
            copy.next = Node(cur.val)
            hm[cur] = copy.next
            cur, copy = cur.next, copy.next
            
        cur, copy = head, zero.next
        while cur:
            copy.random = hm[cur.random] if cur.random else None
            cur, copy = cur.next, copy.next
                
        return zero.next"
copy list with random pointer,"class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        
        # --------------------------------------------------------
        
        # Create mirror node for each node in linked list
        
        cur = head
        
        while cur:
            
            # backup original next node of input linkied list
            original_next_hop = cur.next
            
            # create mirror node with original order
            cur.next = Node( x = cur.val, next = original_next_hop, random = None)
            
            # move to next position
            cur = original_next_hop
        
        
        # --------------------------------------------------------
        
        # Let mirror node get the random pointer
        
        cur = head
        
        while cur:
            
            if cur.random:
                # assign random pointer to mirror node
                cur.next.random = cur.random.next
                
            try:
                # move to next position
                cur = cur.next.next
            except AttributeError:
                break
                
        
        # --------------------------------------------------------
                
        # Separate copy linked list from original linked list
        
        try:
            # locate the head node of copy linked list
            head_of_copy_list = head.next
            cur = head_of_copy_list
            
        except AttributeError:
            # original input is an empty linked list
            return None
        
        while cur:
            
            try:
                # link mirror node to copy linked list
                cur.next = cur.next.next
            except AttributeError:
                break
            
            # move to next position
            cur = cur.next
            
        return head_of_copy_list"
word break,"class Solution:
    def wordBreak(self, s, wordDict):
		dp = [False]*(len(s)+1)
        dp[0] = True
        
        for i in range(1, len(s)+1):
            for j in range(i):
                if dp[j] and s[j:i] in wordDict:
					dp[i] = True
                    break
                    
        return dp[-1]"
word break,"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dp = [True] + [False] * len(s)
        
        for indx in range(1, len(s) + 1):
            
            for word in wordDict:
                if dp[indx - len(word)] and s[:indx].endswith(word):
                    dp[indx] = True
            
        return dp[-1]"
word break ii,"class Solution(object):
    def wordBreak(self, s, wordDict):
        """"""
        :type s: str
        :type wordDict: List[str]
        :rtype: List[str]
        """"""
        def wordsEndingIn(i):
            if i == len(s):
                return [""""]
            ans = []
            for j in range(i+1, len(s)+1):
                if s[i:j] in wordDict:
                    for tail in wordsEndingIn(j):
                        if tail != '':
                            ans.append(s[i:j] + "" "" + tail) 
                        else:
                            ans.append(s[i:j])
            return ans
        return wordsEndingIn(0)"
word break ii,"class Solution:
    def _wordBreak(self, s, wordDict, start, cur, res):
        # Base Case
        if start == len(s) and cur:
            res.append(' '.join(cur))
            
        for i in range(start, len(s)):
            word = s[start: i+1]
            
            if word in wordDict:
                
                # Append the word since it is in the dictionary
                cur.append(word)
                
                # Recursive Step
                self._wordBreak(s, wordDict, i+1, cur, res)
                
                # Backtracking / Post-processing / Pop the word we appended
                cur.pop()
        
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        res = []
        self._wordBreak(s, set(wordDict), 0, [], res)
        return res"
linked list cycle,"class Solution(object):
    def hasCycle(self, head):
        """"""
        :type head: ListNode
        :rtype: bool
        """"""
		if head is None or head.next is None return False
        slow_ref = head
        fast_ref = head
        while fast_ref and fast_ref.next:
            slow_ref = slow_ref.next
            fast_ref = fast_ref.next.next
            if slow_ref == fast_ref:
                return True
        return False
		
	If you get it please Upvote."
linked list cycle,"class Solution(object):
    def hasCycle(self, head):
        # Initialize two node slow and fast point to the hesd node...
        fastptr = head
        slowptr = head
        while fastptr is not None and fastptr.next is not None:
            # Move slow pointer by 1 node and fast at 2 at each step.
            slowptr = slowptr.next
            fastptr = fastptr.next.next
            # If both the pointers meet at any point, then the cycle is present and return true...
            if slowptr == fastptr:
                return 1
        return 0"
linked list cycle ii,"class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast, slow = head, head
        while(fast and fast.next):
            fast = fast.next.next
            slow = slow.next
            if(fast == slow):
                slow = head
                while(slow is not fast):
                    fast = fast.next
                    slow = slow.next
                return slow
        return None"
linked list cycle ii,"class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast ,slow = head ,head
    
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

            if slow == fast:
                slow = head
                while fast != slow:
                    slow = slow.next
                    fast = fast.next         
                return fast 

        return None"
reorder list,"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        if not head.next or not head.next.next:
            return
        
        # search for the middle
        slow, fast = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next

        tail, cur = None, slow.next
        slow.next = None # detach list on the middle
        
        # reverse right part
        while cur:
            cur.next, tail, cur = tail, cur, cur.next
        
		# rearrange nodes as asked
        headCur, headNext = head, head.next
        tailCur, tailNext = tail, tail.next
        while True:
            headCur.next, tailCur.next = tailCur, headNext
             
            if not tailNext:
                return
            
            tailCur, headCur = tailNext, headNext
            tailNext, headNext = tailNext.next, headNext.next"
reorder list,"class Solution:
	def reorderList(self, head: ListNode) -> None:
		if not head: return head
		slow, fast = head, head
		while fast.next and fast.next.next:
			slow = slow.next
			fast = fast.next.next
		
		prev, cur = None, slow.next
		while cur:
			save = cur.next
			cur.next = prev
			prev = cur
			cur = save
		slow.next = None
		
		head2 = prev
		while head2:
			save1 = head.next
			head.next = head2
			head = head2
			head2 = save1"
binary tree preorder traversal,"class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        stack = [root]
        
        while stack:
            temp = stack.pop()
            
            if temp:
                ans.append(temp.val)
                stack.append(temp.right) #as we are using stack which works on LIFO, we need to push right tree first so that left will be popped out
                stack.append(temp.left)
                
        return ans"
binary tree preorder traversal,"class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        if not root:
            return ans
        
        def preorder(node):
            if node:
                ans.append(node.val)
                preorder(node.left)
                preorder(node.right)
            
        preorder(root)
        return ans"
binary tree postorder traversal,"class Solution(object):
    def postorderTraversal(self, root):
        # Base case...
        if not root: return []
        # Create an array list to store the solution result...
        sol = []
        # Create an empty stack and push the root node...
        bag = [root]
        # Loop till stack is empty...
        while bag:
            # Pop a node from the stack...
            node = bag.pop()
            sol.append(node.val)
            # Push the left child of the popped node into the stack...
            if node.left:
                bag.append(node.left)
            # Append the right child of the popped node into the stack...
            if node.right:
                bag.append(node.right)
        return sol[::-1]       # Return the solution list..."
binary tree postorder traversal,"class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result=[]
        stack=[]
        while root or stack:
            while root:
                stack.append(root) # push nodes into the stack
                root=root.left if root.left else root.right
            root=stack.pop()
            result.append(root.val) #Deal with the root node whenever it is popped from stack
            if stack and stack[len(stack)-1].left==root: #check whether it has been traversed 
                root=stack[len(stack)-1].right
            else:
                root=None #Force to quit the loop
        return(result)"
lru cache,"class ListNode:
    def __init__(self, key=0, val=0, prev=None, next=None):
        self.key = key
        self.val = val
        self.prev = prev
        self.next = next
        

class LRUCache:

    def __init__(self, capacity: int):
        """"""Initialize hash table &amp; dll""""""
        self.cpty = capacity
        self.htab = dict() #hash table 
        self.head = ListNode() #doubly linked list
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head 
        
    def _del(self, key: int) -> int: 
        """"""Delete given key from hash table &amp; dll""""""
        node = self.htab.pop(key)
        node.prev.next = node.next
        node.next.prev = node.prev
        return node.val

    def _ins(self, key: int, value: int) -> None: 
        """"""Insert at tail""""""
        node = ListNode(key, value, self.tail.prev, self.tail)
        self.tail.prev.next = self.tail.prev = node
        self.htab[key] = node
        
    def get(self, key: int) -> int:
        if key not in self.htab: return -1
        value = self._del(key)
        self._ins(key, value)
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.htab: self._del(key)
        self._ins(key, value)
        if len(self.htab) > self.cpty: 
            self._del(self.head.next.key)


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)"
lru cache,"class LRUCache:

    def __init__(self, capacity: int):
        self.cpty = capacity
        self.data = dict()
        
    def get(self, key: int) -> int:
        if key not in self.data: return -1
        value = self.data.pop(key)
        self.data[key] = value
        return value        

    def put(self, key: int, value: int) -> None:
        if key in self.data: self.data.pop(key)
        self.data[key] = value
        if len(self.data) > self.cpty: 
            self.data.pop(next(iter(self.data.keys())))"
insertion sort list,"class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        
        # No need to sort for empty list or list of size 1
        if not head or not head.next:
            return head
        
        # Use dummy_head will help us to handle insertion before head easily
        dummy_head = ListNode(val=-5000, next=head)
        last_sorted = head # last node of the sorted part
        cur = head.next # cur is always the next node of last_sorted
        while cur:
            if cur.val >= last_sorted.val:
                last_sorted = last_sorted.next
            else:
                # Search for the position to insert
                prev = dummy_head
                while prev.next.val <= cur.val:
                    prev = prev.next
                    
                # Insert
                last_sorted.next = cur.next
                cur.next = prev.next
                prev.next = cur
                
            cur = last_sorted.next
            
        return dummy_head.next"
insertion sort list,"class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        sort = ListNode() #dummy node

        cur = head
        while cur:
            sortCur = sort
            while sortCur.next and cur.val >= sortCur.next.val:
                sortCur = sortCur.next
                
            tmp, sortCur.next = sortCur.next, cur
            cur = cur.next
            sortCur.next.next = tmp
            
        return sort.next"
sort list,"class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # Split the list into two halfs
        left = head
        right = self.getMid(head)
        tmp = right.next
        right.next = None
        right = tmp
        
        left = self.sortList(left)
        right = self.sortList(right)
        
        return self.merge(left, right)
    
    def getMid(self, head):
        slow = head
        fast = head.next
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
    
    # Merge the list
    def merge(self, list1, list2):
        newHead = tail = ListNode()
        while list1 and list2:
            if list1.val > list2.val:
                tail.next = list2
                list2 = list2.next
            else:
                tail.next = list1
                list1 = list1.next
            tail = tail.next
        
        if list1:
            tail.next = list1
        if list2:
            tail.next = list2
        
        return newHead.next"
sort list,"class Solution:
	def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:

		new_node=head

		result = new_node

		array = []

		while head != None:
			array.append(head.val)
			head=head.next

		array = sorted(array)

		for num in array:
			new_node.val = num
			new_node = new_node.next

		return result"
max points on a line,"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        if len(points) <= 2:
            return len(points)
        
        def find_slope(p1, p2):
            x1, y1 = p1
            x2, y2 = p2
            if x1-x2 == 0:
                return inf
            return (y1-y2)/(x1-x2)
        
        ans = 1
        for i, p1 in enumerate(points):
            slopes = defaultdict(int)
            for j, p2 in enumerate(points[i+1:]):
                slope = find_slope(p1, p2)
                slopes[slope] += 1
                ans = max(slopes[slope], ans)
        return ans+1"
max points on a line,"class Solution:
    def maxPoints(self, P: List[List[int]]) -> int:
        L, M, gcd = len(P), 1, math.gcd
        for i,(x1,y1) in enumerate(P):
            s, D = 1, collections.defaultdict(int, {0:0})
            for (x2,y2) in P[i+1:]:
                g = gcd(y2-y1, x2-x1)
                if g == 0:
                    s += 1
                    continue
                m = ((y2-y1)//g, (x2-x1)//g)
                if m[1] == 0: m = (1,0)
                if m[1] < 0: m = (-m[0],-m[1])
                D[m] += 1
            M = max(M, s + max(D.values()))
        return M if P else 0
		
		
- Junaid Mansuri
- Chicago, IL"
evaluate reverse polish notation,"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        
        def update(sign):
            n2,n1=stack.pop(),stack.pop()
            if sign==""+"": return n1+n2
            if sign==""-"": return n1-n2
            if sign==""*"": return n1*n2
            if sign==""/"": return int(n1/n2)
			
        stack=[]
        
        for n in tokens:
            if n.isdigit() or len(n)>1:
                stack.append(int(n))
            else:
                stack.append(update(n))
        return stack.pop()"
evaluate reverse polish notation,"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []      
        for i in tokens:
            if i == ""+"":
                stack[-1] = stack[-2] + stack.pop()
            elif i == ""-"":
                stack[-1] = stack[-2] - stack.pop()
            elif i == ""*"":
                stack[-1] = stack[-2] * stack.pop()
            elif i == ""/"":
                stack[-1] = int(stack[-2] / stack.pop())
            else:
                stack.append(int(i))
                
        return stack.pop()"
reverse words in a string,"class Solution:
    def reverseWords(self, s: str) -> str:
        #Time: O(n) since we scan through the input, where n = len(s)
        #Space: O(n)
        words = []
        slow, fast = 0, 0
        
        #Use the first char to determine if we're starting on a "" "" or a word
        mode = 'blank' if s[0] == ' ' else 'word'
        
        while fast < len(s):
            #If we start on a word and our fast ptr lands on a white space
            #means that we have singled out a word
            if mode == 'word' and s[fast] == ' ':
                words.append(s[slow:fast])
                slow = fast #Make the slow ptr catch up
                mode = 'blank'
                
            #If we start on a white space and our fast ptr runs into a character
            #means we are at the start of a word   
            elif mode == 'blank' and s[fast] != ' ':
                slow = fast #Make the slow ptr catch up
                mode = 'word'
        
            fast += 1 #Increment the fast pointer
        
        #Append the last word
        #Edge cases where the last chunk of string are white spaces
        if (lastWord := s[slow:fast]).isalnum():
            words.append(lastWord)
        
        return ' '.join(words[::-1])"
reverse words in a string,"class Solution:
    def reverseWords(self, s: str) -> str:
        res = []
        temp = """"
        for c in s:
            if c != "" "":
                temp += c 
            elif temp != """":
                res.append(temp)
                temp = """"
        if temp != """":
            res.append(temp)
        return "" "".join(res[::-1])"
maximum product subarray,"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        curMax, curMin = 1, 1
        res = nums[0]
        
        for n in nums:
            vals = (n, n * curMax, n * curMin)
            curMax, curMin = max(vals), min(vals)
			
            res = max(res, curMax)
            
        return res"
maximum product subarray,"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        if len(nums) == 1:
            return nums[0]
        
        min_so_far, max_so_far, max_global = nums[0], nums[0], nums[0]
        for i in range(1, len(nums)):
            max_so_far, min_so_far = max(min_so_far*nums[i], max_so_far*nums[i], nums[i]), min(min_so_far*nums[i], max_so_far*nums[i], nums[i])
            max_global = max(max_global, max_so_far)
        
        return max_global"
find minimum in rotated sorted array,"class Solution:
    def findMin(self, nums: List[int]) -> int:
        start = 0
        end = len(nums) - 1
        
        if(nums[start] <= nums[end]):
            return nums[0]
        
        while start <= end:
            mid = (start + end) // 2
            
            if(nums[mid] > nums[mid+1]):
                return nums[mid+1]
            
            if(nums[mid-1] > nums[mid]):
                return nums[mid]
            
            if(nums[mid] > nums[0]):
                start = mid + 1
            else:
                end = mid - 1
                
        return nums[start]"
find minimum in rotated sorted array,"class Solution:
    def findMin(self, nums: List[int]) -> int:
        hi, lo = len(nums) - 1, 0
        while hi - 1 > lo:
            mid = (hi + lo)//2
            if nums[lo] > nums[mid]: 
                hi = mid
            else: # drop must be to the left
                lo = mid

        if nums[hi] > nums[lo]:
            return nums[0]
        return nums[hi]"
find minimum in rotated sorted array ii,"class Solution:
    def findMin(self, a: List[int]) -> int:
        
        def solve(l,h):
            while l<h:
                m=(l+h)//2
                
                if a[m]<a[m-1]:
                    return a[m]
                
                elif a[m]>a[h-1]:
                    l=m+1
                
                elif a[m]<a[h-1]:
                    h=m
                
                else:
                
                    if len(set(a[l:m+1]))==1:
                        return min(a[m],solve(m+1,h))
                    
                    else:
                        return min(a[m],solve(l,m))
            
            return a[min(l,len(a)-1)]
        
        return solve(0,len(a))"
find minimum in rotated sorted array ii,"class Solution:
    def findMin(self, nums: List[int]) -> int:
        lo, hi = 0, len(nums)-1
        while lo < hi: 
            mid = lo + hi >> 1
            if nums[mid] < nums[hi]: hi = mid
            elif nums[mid] == nums[hi]: hi -= 1 # duplicates
            else: lo = mid + 1
        return nums[lo]"
min stack,"class MinStack:

    stackWithMinElements = collections.namedtuple(""stackWithMinElements"", (""element"", ""minimum""))
    
    def __init__(self):        
        self.stack : List[self.stackWithMinElements] = []

    def push(self, x: int) -> None:
        self.stack.append(self.stackWithMinElements(
                        x, min(x, self.getMin()) if len(self.stack)>0 else x))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1].element

    def getMin(self) -> int:
        return self.stack[-1].minimum"
min stack,"class MinStack:

    def __init__(self):
        self.stack = []
        self.count = 0

    def push(self, val: int) -> None:
        topMin = val
        if self.count > 0:
            topMin = min(self.stack[-1][1], val)
        self.stack.append((val, topMin))
        self.count += 1
            
    def pop(self) -> None:
        self.stack.pop()
        self.count -= 1
        
    def top(self) -> int:
        return self.stack[-1][0] 
        
    def getMin(self) -> int:
        return self.stack[-1][1]"
intersection of two linked lists,"class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        first_set=set()
        curr=headA
        
        while curr:
            first_set.add(curr)
            curr=curr.next
        
        curr = headB
        while curr:
            if curr in first_set:
                return curr
            curr=curr.next

        return None"
intersection of two linked lists,"class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        one = headA
        two = headB

        while one != two:
            one = headB if one is None else one.next
            two = headA if two is None else two.next
        return one"
find peak element,"class Solution:
	def findPeakElement(self, lst: List[int]) -> int:
		start, end = 0, len(lst) - 1

		while start < end:

			mid = start + (end - start) // 2

			if lst[mid] > lst[mid + 1]:
				end = mid
			else:
				start = mid + 1

		return start"
find peak element,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        
        if len(nums)==1:
            return 0
        if nums[0]>nums[1]:
            return 0
        if nums[-1]>nums[-2]:
            return len(nums)-1
        
        l=1
        h=len(nums)-1
        while l<h:
            m=(l+h)//2
            if nums[m-1]<nums[m]>nums[m+1]:
                return m
            elif nums[m-1]<nums[m]<nums[m+1]:
                l=m+1
            else:
                h=m
            
        return l"
maximum gap,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0 #edge case 
        mn, mx = min(nums), max(nums)
        step = max(1, (mx - mn)//(len(nums)-1)) #n-1 holes 
        size = (mx - mn)//step + 1
        buckets = [[inf, -inf] for _ in range(size)]
        
        for num in nums: 
            i = (num - mn)//step
            x, xx = buckets[i]
            buckets[i] = min(x, num), max(xx, num)
        
        ans = 0
        prev = mn
        for i in range(size):
            x, xx = buckets[i]
            if x < inf:
                ans = max(ans, x - prev)
                prev = xx 
        return ans"
maximum gap,"class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if len(nums)==1: return 0
        nums.sort()
        max_diff=0
        for i in range(len(nums)-1):
            max_diff=max(max_diff,nums[i+1]-nums[i])
        return max_diff"
compare version numbers,"class Solution:
    def compareVersion(self, v1: str, v2: str) -> int:
        v1, v2 = list(map(int, v1.split('.'))), list(map(int, v2.split('.')))  
        for rev1, rev2 in zip_longest(v1, v2, fillvalue=0):
            if rev1 == rev2:
                continue

            return -1 if rev1 < rev2 else 1 

        return 0"
compare version numbers,"class Solution:
    '''
	Space complexity: `O(m + n)`
	 
	Since split operation will be taking extra space to populate the array
	'''
    def compareVersion(self, version1: str, version2: str) -> int:
        version1, version2 = version1.split('.'), version2.split('.')
        m, n = len(version1), len(version2)
        i = j = 0
        while(i < m or j < n):
            revision1 = int(version1[i]) if(i < m) else 0
            revision2 = int(version2[j]) if(j < n) else 0
            if(revision1 < revision2):  return -1
            if(revision1 > revision2):  return 1
            i, j = i + 1, j + 1
        
        return 0"
fraction to recurring decimal,"class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        
        if numerator % denominator == 0: 
			return str(numerator // denominator)
        
        prefix = ''
        if (numerator > 0) != (denominator > 0):
            prefix = '-'
        
        # Operation must be on positive values
        if numerator < 0:
            numerator = - numerator
        if denominator < 0:
            denominator = - denominator

        digit, remainder = divmod(numerator, denominator)
            
        res = prefix + str(digit) + '.' # EVERYTHING BEFORE DECIMAL
        
        table = {}
        suffix = ''
        
        while remainder not in table.keys():
            
            # Store index of the reminder in the table
            table[remainder] = len(suffix)
            
            val, remainder = divmod(remainder*10, denominator)
            
            suffix += str(val)
            
            # No repeating
            if remainder == 0:
                return res + suffix
        
        indexOfRepeatingPart = table[remainder]
        
        decimalTillRepeatingPart = suffix[:indexOfRepeatingPart]
        
        repeatingPart = suffix[indexOfRepeatingPart:]

        return res + decimalTillRepeatingPart + '(' + repeatingPart + ')'

s = Solution()

print(s.fractionToDecimal(2, 3))"
fraction to recurring decimal,"class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        neg = True if numerator/denominator < 0 else False
        numerator = -numerator if numerator < 0 else numerator
        denominator = -denominator if denominator < 0 else denominator
        out = str(numerator//denominator)
        if numerator % denominator:
            out += "".""
        remainders = []
        quotients = []
        numerator %= denominator
        while numerator:
            numerator *= 10
            if str(numerator) in remainders:
                duplicateStart = remainders.index(str(numerator))
                out += """".join(quotients[:duplicateStart])
                out += ""(""+"""".join(quotients[duplicateStart:])+"")""
                return ""-""+out if neg else out
            else:
                remainders.append(str(numerator))
                quotients.append(str(numerator // denominator))
                numerator %= denominator
        out += """".join(quotients)
        return ""-""+out if neg else out"
two sum ii input array is sorted,"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        i = 0
        j = len(numbers) -1
        
        while i<j:
            s = numbers[i] + numbers[j]
            if s == target:
                return [i + 1 , j + 1]
            
            if s > target:
                j-=1
            else:
               i+=1 
        
        return []"
two sum ii input array is sorted,"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        i = 0
        j = len(numbers) -1
        
        while numbers[i] + numbers[j]!=target:
            s = numbers[i] + numbers[j]        
            if s > target:
                j-=1
            else:
               i+=1 
        
        return [i + 1 , j + 1]"
excel sheet column title,"class Solution(object):
    def convertToTitle(self, columnNumber):
        # Create an empty string for storing the characters...
        output = """"
        # Run a while loop while columnNumber is positive...
        while columnNumber > 0:
            # Subtract 1 from columnNumber and get current character by doing modulo of columnNumber by 26...
            output = chr(ord('A') + (columnNumber - 1) % 26) + output
            # Divide columnNumber by 26...
            columnNumber = (columnNumber - 1) // 26
        # Return the output string.
        return output"
excel sheet column title,"class Solution:
    def convertToTitle(self, n: int) -> str:
    	s = ''
    	while n > 0:
    		r = n%26
    		if r == 0: r = 26
    		s = chr(64+r)+s
    		n = int((n-r)/26)
    	return(s)
		
		
- Python 3
- Junaid Mansuri"
majority element,"class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        curr, count = nums[0], 1              # curr will store the current majority element, count will store the count of the majority
        for i in range(1,len(nums)):
            count += (1 if curr == nums[i] else -1)    # if i is equal to current majority, they're in same team, hence added, else one current majority and i both will be dead
            if not count:                   # if count is 0 means King is de-throwned
                curr = nums[i+1] if i + 1 < len(nums) else None        # the next element is the new King
                count = 0         # starting it with 0 because we can't increment the i of the for loop, the count will be 1 in next iteration, and again the battle continues after next iteration
        return curr"
majority element,"class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        curr, count = nums[0], 1                   # curr will store the current majority element, count will store the count of the majority
        for i in nums[1:]:
            count += (1 if curr == i else -1)      # if i is equal to current majority, they're in same team, hence added, else one current majority and i both will be dead
            if not count:                          # if count of current majority is zero, then change the majority element, and start its count from 1
                curr = i
                count = 1
        return curr"
excel sheet column number,"class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        ans, pos = 0, 0
        for letter in reversed(columnTitle):
            digit = ord(letter)-64
            ans += digit * 26**pos
            pos += 1
            
        return ans"
excel sheet column number,"class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        ans = 0
        for i in columnTitle:
            ans = ans * 26 + ord(i) - ord('A') + 1
        return ans"
factorial trailing zeroes,"class Solution:
    def trailingZeroes(self, n: int) -> int:
        quotient = n // 5
        return quotient + self.trailingZeroes(quotient) if quotient >= 5 else quotient"
factorial trailing zeroes,"class Solution(object):
    def trailingZeroes(self, n):
        # Negative Number Edge Case
        if(n < 0):
            return -1
        # Initialize output...
        output = 0
        # Keep dividing n by 5 &amp; update output...
        while(n >= 5):
            n //= 5
            output += n
        return output    # Return the output..."
binary search tree iterator,"class BSTIterator:
    def __init__(self, root: Optional[TreeNode]):
        self.iter = self._inorder(root)
        self.nxt = next(self.iter, None)
    
    def _inorder(self, node: Optional[TreeNode]) -> Generator[int, None, None]:
        if node:
            yield from self._inorder(node.left)
            yield node.val
            yield from self._inorder(node.right)

    def next(self) -> int:
        res, self.nxt = self.nxt, next(self.iter, None)
        return res

    def hasNext(self) -> bool:
        return self.nxt is not None"
binary search tree iterator,"class BSTIterator:

    def __init__(self, root: TreeNode):

        self.root = root
        self._stack_inorder = []

        self.push_left_children( root )
        
    
    def push_left_children(self, node: TreeNode):
        
        while node:
            # push left child into stack
            self._stack_inorder.append( node )

            # update node as left child
            node = node.left

            
            

    def next(self) -> int:
        """"""
        @return the next smallest number
        """"""

        # pop next element with inorder
        node =  self._stack_inorder.pop()

        # keep inorder collection on right subtree of node
        self.push_left_children( node.right )

        return node.val
        

    def hasNext(self) -> bool:
        """"""
        @return whether we have a next smallest number
        """"""
        return len(self._stack_inorder) != 0"
dungeon game,"class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        
        @cache
        def fn(i, j):
            """"""Return min health at (i,j).""""""
            if i == m or j == n: return inf
            if i == m-1 and j == n-1: return max(1, 1 - dungeon[i][j])
            return max(1, min(fn(i+1, j), fn(i, j+1)) - dungeon[i][j])
        
        return fn(0, 0)"
dungeon game,"class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        ans = [inf]*(n-1) + [1, inf]
        for i in reversed(range(m)): 
            for j in reversed(range(n)): 
                ans[j] = max(1, min(ans[j], ans[j+1]) - dungeon[i][j])
        return ans[0]"
largest number,"class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        nums = sorted(nums,key=lambda x:x / (10 ** len(str(x)) - 1 ), reverse=True)
        str_nums = [str(num) for num in nums]
        res = ''.join(str_nums)
        res = str(int(res))
        return res"
largest number,"class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        nums=list(map(str, nums)) ; cmp=lambda x,y:((x+y)>(y+x))-((x+y)<(y+x))
        nums=sorted(nums,key=cmp_to_key(cmp))
        return str(int(''.join(nums[::-1])))"
repeated dna sequences,"class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        
        res, d = [], {}
        for i in range(len(s)):
            
            if s[i:i+10] not in d: d[s[i:i+10]] = 0
            elif s[i:i+10] not in res: res.append(s[i:i+10])
                
        return res
		
		# An Upvote will be encouraging"
repeated dna sequences,"class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        seen = {}
        res = []
        
        for i in range(len(s) - 9):
            sequence = s[i:i+10]
            if sequence in seen:
                if not seen[sequence]:
                    seen[sequence] = True
                    res.append(sequence)
            else:
                seen[sequence] = False
            
        return res"
best time to buy and sell stock iv,"class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        # no transaction, no profit
        if k == 0: return 0
        # dp[k][0] = min cost you need to spend at most k transactions
        # dp[k][1] = max profit you can achieve at most k transactions
        dp = [[1000, 0] for _ in range(k + 1)]
        for price in prices:
            for i in range(1, k + 1):
                # price - dp[i - 1][1] is how much you need to spend
                # i.e use the profit you earned from previous transaction to buy the stock
                # we want to minimize it
                dp[i][0] = min(dp[i][0], price - dp[i - 1][1])
                # price - dp[i][0] is how much you can achieve from previous min cost
                # we want to maximize it
                dp[i][1] = max(dp[i][1], price - dp[i][0])
        # return max profit at most k transactions
		# or you can write `return dp[-1][1]`
        return dp[k][1]"
best time to buy and sell stock iv,"class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))
        buy, sell = [inf]*k, [0]*k
        for x in prices:
            for i in range(k):
                if i: buy[i] = min(buy[i], x - sell[i-1])
                else: buy[i] = min(buy[i], x)
                sell[i] = max(sell[i], x - buy[i])
        return sell[-1] if k and prices else 0"
rotate array,"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
            
        def twopt(arr, i, j):
            while (i < j):
                arr[i], arr[j] = arr[j], arr[i]
                i += 1
                j -= 1
            return arr
        
        if k > len(nums):
            k %= len(nums)
            
        if (k > 0):
            twopt(nums, 0, len(nums) - 1)  # rotate entire array
            twopt(nums, 0, k - 1)          # rotate array upto k elements
            twopt(nums, k, len(nums) - 1)  # rotate array from k to end of array"
rotate array,"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        k = k % len(nums)
        nums[:] = nums[-k:] + nums[:-k]"
reverse bits,"class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for _ in range(32):
            res = (res<<1) + (n&amp;1)
            n>>=1
        return res"
reverse bits,"class Solution:
    def reverseBits(self, n: int) -> int:
        return int((('{0:032b}'.format(n))[::-1]),2)"
number of 1 bits,"class Solution:
    def hammingWeight(self, n: int) -> int: 
        return sum((n &amp; (1<<i))!=0 for i in range(32))"
number of 1 bits,"class Solution:
    def hammingWeight(self, n: int) -> int:
        cnt = 0
        while n :
            cnt+=1
            n = n &amp; (n-1)
        return cnt"
house robber,"class Solution:
    def __init__(self):
        self.cache = {}
        
    def rob_rec(self, nums, start):
        if start >= len(nums):
            return 0
        
        if start in self.cache:
            return self.cache[start]
        
        self.cache[start] = nums[start] + max(self.rob_rec(nums, start+2), self.rob_rec(nums, start+3))
        return self.cache[start]
        
    def rob(self, nums: List[int]) -> int:
        return max(self.rob_rec(nums, 0), self.rob_rec(nums, 1))"
house robber,"class Solution:
    
    def __init__(self):
        self.cache = {}
    
    def rob_rec(self, nums, current):
        if current < 0: # Beyond array boundary
            return 0
        
        try:
            return self.cache[current]
        except:
        
            self.cache[current] = max(self.rob_rec(nums, current - 1),
                                      nums[current] + self.rob_rec(nums, current - 2))
        return self.cache[current]
    
    def rob(self, nums: List[int]) -> int:
        return self.rob_rec(nums, len(nums) - 1)"
binary tree right side view,"class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        
        def solve(root, lvl):
        	if root:
        		if len(res)==lvl:
        			res.append(root.val)
        		solve(root.right, lvl + 1)
        		solve(root.left, lvl + 1)
        	return 

        res = []
        solve(root,0)
        return res"
binary tree right side view,"class Solution:
                        # The plan here is to dfs the tree, right-first
                        # (opposite of  the usual left-first method), and
                        # keeping track of the tree levels as we proceed. The 
                        # first node we visit on each level is the right-side view 
                        # node. We know it's the first because the level will be
                        # one greater than the length of the current answer list.

    def rightSideView(self, root: TreeNode) -> list[int]:
        ans =[]
        
        def dfs(node =root,level=1):
            if not node: return
            
            if len(ans) < level: 
                ans.append(node.val)
            dfs(node.right,level+1)         #  <--- right first
            dfs(node.left ,level+1)         #  <--- then left

            return 

        dfs()
        return ans"
number of islands,"class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid: return 0
        m, n = len(grid), len(grid[0])
        ans = 0
        def dfs(i, j):
            grid[i][j] = '2'
            for di, dj in (0, 1), (0, -1), (1, 0), (-1, 0):
                ii, jj = i+di, j+dj
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == '1':
                    dfs(ii, jj)
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    dfs(i, j)
                    ans += 1
        return ans"
number of islands,"class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid: return 0
        m, n = len(grid), len(grid[0])
        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    q = collections.deque([(i, j)])
                    grid[i][j] = '2'
                    while q:
                        x, y = q.popleft()
                        for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):
                            xx, yy = x+dx, y+dy
                            if 0 <= xx < m and 0 <= yy < n and grid[xx][yy] == '1':
                                q.append((xx, yy))
                                grid[xx][yy] = '2'
                    ans += 1            
        return ans"
bitwise and of numbers range,"class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        
        shift = 0
        
        # find the common MSB bits.
        while m != n:
            
            m = m >> 1
            n = n >> 1
        
            shift += 1
        
        
        return m << shift"
bitwise and of numbers range,"class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        leftb = ""{0:b}"".format(left)
        rightb = ""{0:b}"".format(right)
        
        if len(rightb) > len(leftb):
            return 0
        
        res = left
        for i in range(left + 1, right + 1):
            res = res &amp; i
        
        return res"
happy number,"class Solution(object):
    def isHappy(self, n):
        hset = set()
        while n != 1:
            if n in hset: return False
            hset.add(n)
            n = sum([int(i) ** 2 for i in str(n)])
        else:
            return True"
happy number,"class Solution:
    def isHappy(self, n: int) -> bool:
        hset = set()
        while n != 1:
            if n in hset: return False
            hset.add(n)
            n = sum([int(i) ** 2 for i in str(n)])
        else:
            return True"
remove linked list elements,"class Solution:
    def removeElements(self, head, val):
        """"""
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """"""
        
        dummy_head = ListNode(-1)
        dummy_head.next = head
        
        current_node = dummy_head
        while current_node.next != None:
            if current_node.next.val == val:
                current_node.next = current_node.next.next
            else:
                current_node = current_node.next
                
        return dummy_head.next"
remove linked list elements,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        prev, curr = None, head
        while curr:
            if curr.val == val:  # cases 1-3
                if prev:  # cases 1-2
                    prev.next = curr.next
                else:  # case 3
                    head = curr.next
                curr = curr.next  # for all cases
            else:  # case 4
                prev, curr = curr, curr.next
        return head"
count primes,"class Solution:
    def countPrimes(self, n: int) -> int:
        
        if n<2:
            return 0
        
        #initialize a list of length n
        prime=[1]*n
		#mark 0th  and 1st index as 0
        prime[0]=prime[1]=0
        
		#we will check for multiple from range 2 to sqrt(n)
        for i in range(2,int(sqrt(n))+1):
            if prime[i] == 1:
			#mark all multiple of prime number as  0
                prime[i*i:n:i] = [0] * ((n-1-i*i)//i + 1)
    #return total count of prime 
        return sum(prime)"
count primes,"class Solution:
    def countPrimes(self, n: int) -> int:
        nums = [0, 0] + [1] * (n - 2)
        for i in range(2,int(sqrt(n)+1)):
            if nums[i]==1:
                for j in range(i*i,n,i):
                    nums[j]=0
        return sum(nums)"
isomorphic strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return [*map(s.index, s)] == [*map(t.index, t)]"
isomorphic strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        zipped_set = set(zip(s, t))
        return len(zipped_set) == len(set(s)) == len(set(t))"
reverse linked list,"class Solution(object):
    def reverseList(self, head):
        # Initialize prev pointer as NULL...
        prev = None
        # Initialize the curr pointer as the head...
        curr = head
        # Run a loop till curr points to NULL...
        while curr:
            # Initialize next pointer as the next pointer of curr...
            next = curr.next
            # Now assign the prev pointer to currs next pointer.
            curr.next = prev
            # Assign curr to prev, next to curr...
            prev = curr
            curr = next
        return prev       # Return the prev pointer to get the reverse linked list..."
reverse linked list,"class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Initialize prev pointer as NULL...
        prev = None
        # Initialize the curr pointer as the head...
        curr = head
        # Run a loop till curr points to NULL...
        while curr:
            # Initialize next pointer as the next pointer of curr...
            next = curr.next
            # Now assign the prev pointer to currs next pointer.
            curr.next = prev
            # Assign curr to prev, next to curr...
            prev = curr
            curr = next
        return prev       # Return the prev pointer to get the reverse linked list..."
course schedule,"class Solution:
	def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
		graph=defaultdict(list)
		indegree={}

		#initialising dictionary
		for i in range(numCourses):
			indegree[i]=0	

		#filling graph and indegree dictionaries
		for child,parent in prerequisites:
			graph[parent].append(child)
			indegree[child]+=1

		queue=deque()
		for key,value in indegree.items():
			if value==0:
				queue.append(key)

		courseSequence=[]
		while queue:
			course=queue.popleft()
			courseSequence.append(course)
			for neighbour in graph[course]:
				indegree[neighbour]-=1
				if indegree[neighbour]==0:
					queue.append(neighbour)

		return len(courseSequence)==numCourses:"
course schedule,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = { courseNum : [] for courseNum in range(numCourses) }
        
        for course, prerequisite in prerequisites:
            graph[course].append(prerequisite)
         
        Course = namedtuple('Course', ['number', 'backtrack'])
        
        for courseNum in range(numCourses):
            
            currCourse = Course(courseNum, False)
            
            stack = [currCourse]            
            visited = set([currCourse.number])
            
            while stack:
                currCourse = stack.pop()
                
                if currCourse.backtrack:
                    graph[currCourse.number] = []
                    visited.discard(currCourse.number)                    
                    continue
                
                stack.append(Course(currCourse.number, True))
                visited.add(currCourse.number)
                
                for prereqCourseNum in graph[currCourse.number]:
                    if prereqCourseNum in visited:
                        return False
                    
                    stack.append(Course(prereqCourseNum, False))
                    
        return True"
minimum size subarray sum,"class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        
        left = 0 # keep track of left pointer
        rsum = 0 # keep the running sum
        res = None # Answer we will return
        
        # Iterate through the array, the index will be your right pointer
        for right in range(len(nums)):
            
            # Add the current value to the running sum
            rsum += nums[right]
            
            # Once you reach a value at or equal to the target you
            # can use a while loop to start subtracting the values from left
            # to right so that you can produce the minimum size subarray
            while rsum >= target:
                
                # The result is either the current result you have, 
                # or the count of numbers from the current left position 
                # to the rightmost position. You need it to be right + 1 
                # because index starts at 0 (if you based the right as the 
                # last index it would be 4 or len(nums) - 1)
                
                # If res is None we compare it against the max float, 
                # saves us from having an if/else
                res = min(res or float('inf'), right + 1 - left)
                
                # Subtract the number to see if we can continue subtracting based
                # on the while loop case and increment the left pointer
                rsum -= nums[left]
                left += 1

        return res or 0"
minimum size subarray sum,"class Solution:
    def minSubArrayLen(self, target, nums):
		# Init left pointer and answer
        l, ans = 0, len(nums) + 1
		# Init sum of subarray
        s = 0 
		# Iterate through all numbers as right subarray 
        for r in range(len(nums)):
			# Add right number to sum
            s += nums[r]
			# Check for subarray greater than or equal to target
            while s >= target:
				# Calculate new min
                ans = min(ans, r - l + 1)
				# Remove current left nubmer from sum
                s -= nums[l]
				# Move left index up one
                l += 1
		# No solution
        if ans == len(nums) + 1:
            return 0
		# Solution
        return ans"
course schedule ii,"class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        
        # Handle edge case.
        if not prerequisites: return [course for course in range(numCourses)]
        
        # 'parents' maps each course to a list of its pre
		# -requisites.
        parents = {course: [] for course in range(numCourses)}
        for course, prerequisite in prerequisites:
            parents[course].append(prerequisite)
            
        topological_order = []
        visited, current_path = [False]*numCourses, [False]*numCourses
        
        # Returns False if the digraph rooted at 'course'
		# is acyclic, else, appends courses to 'topological
        # _order' in topological order and returns True.
        def dfs(course):
            if current_path[course]: return False
            if visited[course]: return True
            visited[course], current_path[course] = True, True
            if parents[course]:
                for parent in parents[course]:
                    if not dfs(parent): return False
            topological_order.append(course)
            current_path[course] = False
            return True
        
        for course in range(numCourses):
            if not dfs(course): return []
            
        return topological_order"
course schedule ii,"class Solution:
    def findOrder(self, numCourses: int, pr: List[List[int]]) -> List[int]:
	
        # Build adjacency list
        adj = defaultdict(list)
        for a, b in prerequisites:
            adj[b].append(a)
            
        # TopoSort
        topo = list()
        vis = set()
        processed = set()
        for node in range(numCourses):
            if node in vis:
                continue
                
            st = [node]
            while st:
                cur = st[-1]
                vis.add(cur)
                
                if cur in processed:
                    st.pop()
                    continue
                
				for ch in adj[cur]:
					if not ch in vis:
						st.append(ch)
                    
                if cur == st[-1]:
                    topo.append(st.pop())
                    processed.add(cur)

        # Result
        res = []
        i = 0
        pos = dict()
        while topo:
            node = topo.pop()
            pos[node] = i
            i += 1
            res.append(node)
        
        # Check for cycles
        for parent, children in adj.items():
            for child in children:
                if pos[parent] > pos[child]:
                    return []
        
        return res"
word search ii,"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        m = len(board)
        n = len(board[0])
        res = []

        d = [[0, 1], [0, -1], [1, 0], [-1, 0]]

        ref = set()
        for i in range(m):
            for j in range(n-1):
                ref.add(board[i][j] + board[i][j+1])
        for j in range(n):
            for i in range(m-1):
                ref.add(board[i][j] + board[i+1][j])

        for word in words:
            f = True
            for i in range(len(word)-1):
                if word[i:i+2] not in ref and word[i+1] + word[i] not in ref:
                    f = False
                    break
            if not f:
                continue
            if self.findWord(word, m, n, board, d):
                res.append(word)
        return res
    
    def findWord(self, word, m, n, board, d) -> bool:
        if word[:4] == word[0] * 4:
            word = ''.join([c for c in reversed(word)])
        starts = []
        stack = []
        visited = set()
        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    if len(word) == 1:
                        return True
                    starts.append((i, j))
        for start in starts:
            stack.append(start)
            visited.add((start, ))
            l = 1
            while stack != [] and l < len(word):
                x, y = stack[-1]
                for dxy in d:
                    nx, ny = x + dxy[0], y + dxy[1]
                    if 0 <= nx < m and 0 <= ny < n:
                        if board[nx][ny] == word[l]:
                            if (nx, ny) not in stack and tuple(stack) + ((nx, ny),) not in visited:
                                stack.append((nx, ny))
                                visited.add(tuple(stack))
                                l += 1
                                if l == len(word):
                                    return True
                                break
                else:
                    stack.pop()
                    l -= 1
        else:
            return False"
word search ii,"class Solution:
    
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:    
        
                     
        @functools.lru_cache(None)
        def backtrack(i, j, path):
            
            # 1) terminate
            if i not in range(0, len(board)): return
            if j not in range(0, len(board[0])): return
            if board[i][j] == ""#"": return
            
            # 2) success
            path += board[i][j]
            if path in self.words:
                self.result.add(path)
                
            # 3) backtrack
            c = board[i][j]
            board[i][j] = ""#""
            
            for x, y in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:
                backtrack(x, y, path)
            
            board[i][j] = c
            
    
    
        self.words = set(words)
        self.result = set()
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                backtrack(i, j, """")        
        
        return self.result"
house robber ii,"class Solution:
    def rob(self, nums: List[int]) -> int:
        
        if len(nums) == 1:
            return nums[0]
        
        dp = {}
        def getResult(a,i):
            if i>=len(a):
                return 0
            if i in dp:
                return dp[i]
            
            sum = 0
            if i<len(a)-1:
                sum+= max(a[i]+getResult(a,i+2),a[i+1]+getResult(a,i+3))
            else:
                sum+=a[i]+getResult(a,i+2)
            dp[i] = sum
            return sum
            
        x = getResult(nums[:len(nums)-1],0)
        dp = {}
        y = getResult(nums[1:],0)
            
        return max(x, y)"
house robber ii,"class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        a1 = 0
        b1 = nums[0]
        a2 = 0
        b2 = nums[1]
        for i in range(1, len(nums) - 1):
            a1, b1 = b1, max(a1 + nums[i], b1)
            a2, b2 = b2, max(a2 + nums[i + 1], b2)
        return max(b1, b2)"
shortest palindrome,"class Solution:
    def shortestPalindrome(self, s: str) -> str:
        
        end = 0
        
        # if the string itself is a palindrome return it
        if(s == s[::-1]):
            return s
        
        # Otherwise find the end index of the longest palindrome that starts
        # from the first character of the string
        
        for i in range(len(s)+1):
            if(s[:i]==s[:i][::-1]):
                end=i-1
        
        # return the string with the remaining characters other than
        # the palindrome reversed and added at the beginning
        
        return (s[end+1:][::-1])+s"
shortest palindrome,"class Solution1:
    def shortestPalindrome(self, s: str) -> str:
        """"""We create two new arrays to represent the original string. We use
        `groupby` to count the number of repeats of each consecutive letters
        and record them in two arrays. One is letters, recording all
        consecutively distinct letters. The other is indices, recording the
        index of the last appearance of the corresponding letter in letters.

        Let idx = len(indices) - 2. We want to examine whether a palindrome can
        be formed from the start of s with the repeats of letters[idx] being in
        the middle. There are three scenarios.

        1. idx reaches the first letter and still no palindrome insight. We
        need to reverse the substring starting from indices[idx + 1] to the end
        and add it to the front of s.
        
        2. A palindrome is found when idx is not pointing to the first letter
        of s. This means we just need to reverse the remaining of s outside the
        palindrome and add it to the front of s.

        3. idx has not reached the first letter of s, yet a palindrome almost
        forms. By almost forms, it means that the palindrome check has reaches
        the first letter and the first letter is equal to the last letter in
        the current palindrome check, yet the number of repeats of these two
        do not match. In particular, the number of repeats of the first letter
        is smaller than that of the last letter in check. In this case, we can
        simply add to the front the difference in count between the first and
        the last letter to form the palindrome, and then add the reversed
        remaining substring to the front.

        O(N), 56 ms, 73% ranking.
        """"""
        letters = ['#']
        indices = [-1]
        for k, g in groupby(s):
            letters.append(k)
            indices.append(indices[-1] + len(list(g)))
        idx = len(indices) - 2
        while idx >= 0:
            # scenario 1
            if idx == 1:
                return s[:indices[1]:-1] + s
            # palindrome check
            lo, hi = idx - 1, idx + 1
            while lo >= 1 and hi < len(indices):
                if letters[lo] != letters[hi] or (indices[lo] - indices[lo - 1]) != (indices[hi] - indices[hi - 1]):
                    break
                lo -= 1
                hi += 1
            # scenario 2
            if lo == 0:
                return s[:indices[hi - 1]:-1] + s
            # scenario 3
            if lo == 1 and hi < len(indices) and letters[lo] == letters[hi]:
                dif = (indices[hi] - indices[hi - 1]) - (indices[lo] - indices[lo - 1])
                if dif > 0:
                    return s[:indices[hi]:-1] + letters[lo] * dif + s
            idx -= 1
        return s"
kth largest element in an array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:                    
        n = len(nums)
        
        def partition(l, r, pivot):
            pivot_elem=nums[pivot]
            nums[r],nums[pivot]=nums[pivot],nums[r]
            
            index=l
            for i in range(l, r):
                if nums[i]<pivot_elem:
                    nums[i],nums[index]=nums[index],nums[i]
                    index+=1
            
            nums[index],nums[r]=nums[r],nums[index]
            return index
        
        def quick_select(l,r,kth_index):
            if l==r:
                return nums[l]
            
            pivot_index=partition(l,r,l)
            
            if pivot_index==kth_index:
                return nums[pivot_index]
            
            if kth_index>pivot_index:
                return quick_select(pivot_index+1, r, kth_index)
            else:
                return quick_select(l,pivot_index-1, kth_index)
        
        return quick_select(0, n - 1, n - k)"
kth largest element in an array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:                    
        return sorted(nums)[-k]"
combination sum iii,"class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        
        current_combination, combinations = [], []
        integer, combination_sum = 1, 0
        queue = [(integer, current_combination, combination_sum)]
        while queue:
            integer, current_combination, combination_sum = queue.pop()
            if combination_sum == n and len(current_combination) == k: combinations.append(current_combination)
            else:
                for i in range(integer, 10):
                    if combination_sum + i > n: break
                    queue.append((i+1, current_combination + [i], combination_sum + i))
        
        return combinations"
combination sum iii,"class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        
        combinations = []
        counter = [(integer, 1) for integer in range(1, 10)]
        
        def recursion(integer = 0, current_combination = [], combination_sum = 0):
            if combination_sum > n or len(current_combination) > k or integer not in range(9): return
            elif combination_sum == n and len(current_combination) == k: combinations.append(current_combination.copy())
            else:
                candidate, frequency = counter[integer]
                if frequency == 1:
                    counter[integer] = (candidate, 0)
                    recursion(integer, current_combination + [candidate], combination_sum + candidate)
                counter[integer] = (candidate, frequency)
                recursion(integer+1, current_combination, combination_sum)
                
        recursion()
        return combinations"
contains duplicate,"class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) != len(nums)"
contains duplicate,"class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) != len(nums)"
the skyline problem,"class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        # for the same x, (x, -H) should be in front of (x, 0)
        # For Example 2, we should process (2, -3) then (2, 0), as there's no height change
        x_height_right_tuples = sorted([(L, -H, R) for L, R, H in buildings] + [(R, 0, ""doesn't matter"") for _, R, _ in buildings])   
        # (0, float('inf')) is always in max_heap, so max_heap[0] is always valid
        result, max_heap = [[0, 0]], [(0, float('inf'))]
        for x, negative_height, R in x_height_right_tuples:
            while x >= max_heap[0][1]:
                # reduce max height up to date, i.e. only consider max height in the right side of line x
                heapq.heappop(max_heap)
            if negative_height:
                # Consider each height, as it may be the potential max height
                heapq.heappush(max_heap, (negative_height, R))
            curr_max_height = -max_heap[0][0]
            if result[-1][1] != curr_max_height:
                result.append([x, curr_max_height])
        return result[1:]"
the skyline problem,"class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        events = []
        for L, R, H in buildings:
            # append start point of building
            events.append((L, -H, R))
            # append end point of building
            events.append((R, 0, 0))
            
        # sort the event
        events.sort()
        
        # init for result and heap
        res = [[0, 0]]
        hp = [(0, float(""inf""))]
        
        for pos, negH, R in events:
            # pop out building which is end
            while hp[0][1] <= pos:
                heapq.heappop(hp)
            
            # if it is a start of building, push it into heap as current building
            if negH != 0:
                heapq.heappush(hp, (negH, R))
            
            # if change in height with previous key point, append to result
            if res[-1][1] != -hp[0][0]:
                res.append([pos, -hp[0][0]])
        
        return res[1:]"
contains duplicate ii,"class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        # Create hset for storing previous of k elements...
        hset = {}
        # Traverse for all elements of the given array in a for loop...
        for idx in range(len(nums)):
            # If duplicate element is present at distance less than equal to k, return true...
            if nums[idx] in hset and abs(idx - hset[nums[idx]]) <= k:
                return True
            hset[nums[idx]] = idx
        # If no duplicate element is found then return false...
        return False"
contains duplicate ii,"class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        # Create dictionary for Lookup
        lookup = {}
        
        for i in range(len(nums)):
            
            # If num is present in lookup and satisfy the condition return True
            if nums[i] in lookup and abs(lookup[nums[i]]-i) <= k:
                return True
            
            # If num is not present in lookup then add it to lookup
            lookup[nums[i]] = i
        
        return False"
contains duplicate iii,"class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for x in nums:
            if x in seen: return True 
            seen.add(x)
        return False"
contains duplicate iii,"class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        seen = {}
        for i, x in enumerate(nums): 
            if x in seen and i - seen[x] <= k: return True 
            seen[x] = i
        return False"
maximal square,"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        result = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                curr = 0  # current length of the square at (i, j)
                flag = True  # indicates if there still exists a valid square
                while flag:
                    for k in range(curr+1):
                        # check outer border of elements for '1's.
                        """"""
                        eg curr = 2, ie a valid 2x2 square exists
                        'O' is valid, check 'X':
                        X X X
                        X O O
                        X O O
                        """"""
                        if i < curr or j < curr or \
                                matrix[i-curr][j-k] == '0' or \
                                matrix[i-k][j-curr] == '0':
                            flag = False
                            break
                    curr += flag
                if curr > result:  # new maximum length of square obtained
                    result = curr
        return result*result  # area = length x length"
maximal square,"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        result = 0
        dp = [[0]*n for _ in range(m)]  # dp[x][y] is the length of the maximal square at (x, y)
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':  # ensure this condition first
                    # perform computation, mind border restrictions
                    dp[i][j] = min(dp[i-1][j] if i > 0 else 0,
                                   dp[i][j-1] if j > 0 else 0,
                                   dp[i-1][j-1] if i > 0 and j > 0 else 0) + 1
                    if dp[i][j] > result:
                        result = dp[i][j]
        return result*result"
count complete tree nodes,"class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root: return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"
count complete tree nodes,"class Solution:
	def countNodes(self, root: Optional[TreeNode]) -> int:

		self.result = 0

		def DFS(node):

			if node == None:
				return None

			self.result = self.result + 1

			DFS(node.left)
			DFS(node.right)

		DFS(root)
		return self.result"
rectangle area,"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        coxl=max(ax1,bx1)
        coxr=min(ax2,bx2)
        coyl=max(ay1,by1)
        coyr=min(ay2,by2)
        dx=coxr-coxl
        dy=coyr-coyl
        comm=0
        if dx>0 and dy>0:
            comm=dx*dy
        a=abs(ax2-ax1)*abs(ay2-ay1)
        b=abs(bx2-bx1)*abs(by2-by1)
        area=a+b-comm
        return area"
rectangle area,"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        Sa = (ax2-ax1) * (ay2-ay1)
        Sb = (bx2-bx1) * (by2-by1)
        S = Sa + Sb
        
        w_ov = min(ax2, bx2) - max(ax1, bx1)
        if w_ov <= 0:
            return S
        
        h_ov = min(ay2, by2) - max(ay1, by1)
        if h_ov <= 0:
            return S
        
        S_ov = w_ov * h_ov
        
        return S - S_ov"
basic calculator,"class Solution:
    def calculate(self, s: str) -> int:
        output, curr, sign, stack = 0, 0, 1, []
        for c in s:
            if c.isdigit():
                curr = (curr * 10) + int(c)
            
            elif c in '+-':
                output += curr * sign
                curr = 0
                if c == '+':
                    sign = 1

                else:
                    sign = -1
            
            elif c == '(':
                stack.append(output)
                stack.append(sign)
                sign = 1
                output = 0
            
            elif c == ')':
                output += curr * sign
                output *= stack.pop()    #sign
                output += stack.pop()    #last output
                curr = 0

        return output + (curr * sign)"
basic calculator,"class Solution:
    def update(self, sign, num, stack):
        if sign == ""+"":
            stack.append(num)
        if sign == ""-"":
            stack.append(-num)
        return stack

    def solve(self, i, s):
        stack, num, sign = [], 0, ""+""
        while i < len(s):
            if s[i].isdigit():
                num = num * 10 + int(s[i])
            elif s[i] == ""+"" or s[i] == ""-"":
                stack = self.update(sign, num, stack)
                num, sign = 0, s[i]
            elif s[i] == ""("":
                num, i = self.solve(i + 1, s)
            elif s[i] == "")"":
                stack = self.update(sign, num, stack)
                return sum(stack), i
            i += 1
        # print(num, sign)
        stack = self.update(sign, num, stack)
        return sum(stack)

    def calculate(self, s: str) -> int:
        return self.solve(0, s)"
invert binary tree,"class Solution(object):
    def invertTree(self, root):
        # Base case...
        if root == None:
            return root
        # swapping process...
        root.left, root.right = root.right, root.left
        # Call the function recursively for the left subtree...
        self.invertTree(root.left)
        # Call the function recursively for the right subtree...
        self.invertTree(root.right)
        return root     # Return the root..."
invert binary tree,"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if(root==None):return
        root.left,root.right=root.right,root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root"
basic calculator ii,"class Solution:
    def calculate(self, s: str) -> int:
        curr_res = 0
        res = 0
        num = 0
        op = ""+""  # keep the last operator we have seen
        
		# append a ""+"" sign at the end because we can catch the very last item
        for ch in s + ""+"":
            if ch.isdigit():
                num = 10 * num + int(ch)

            # if we have a symbol, we would start to calculate the previous part.
            # note that we have to catch the last chracter since there will no sign afterwards to trigger calculation
            if ch in (""+"", ""-"", ""*"", ""/""):
                if op == ""+"":
                    curr_res += num
                elif op == ""-"":
                    curr_res -= num
                elif op == ""*"":
                    curr_res *= num
                elif op == ""/"":
                    # in python if there is a negative number, we should alway use int() instead of //
                    curr_res = int(curr_res / num)
                
                # if the chracter is ""+"" or ""-"", we do not need to worry about
                # the priority so that we can add the curr_res to the eventual res
                if ch in (""+"", ""-""):
                    res += curr_res
                    curr_res = 0
                
                op = ch
                num = 0
        
        return res"
basic calculator ii,"class Solution:
    def calculate(self, s: str) -> int:
        num, ope, stack = 0, '+', []
        
        for cnt, i in enumerate(s):
            if i.isnumeric():
                num = num * 10 + int(i)
            if i in '+-*/' or cnt == len(s) - 1:
                if ope == '+':
                    stack.append(num)
                elif ope == '-':
                    stack.append(-num)
                elif ope == '*':
                    j = stack.pop() * num
                    stack.append(j)
                elif ope == '/':
                    j = int(stack.pop() / num)
                    stack.append(j)
            
                ope = i
                num = 0
       
        return sum(stack)"
summary ranges,"class Solution:
	def summaryRanges(self, nums: List[int]) -> List[str]:

		start = 0
		end = 0

		result = []

		while start < len(nums) and end<len(nums):

			if end+1 < len(nums) and nums[end]+1 == nums[end+1]:
				end=end+1

			else:
				if start == end:
					result.append(str(nums[start]))
					start = start + 1
					end = end + 1
				else:
					result.append(str(nums[start])+'->'+str(nums[end]))
					start = end + 1
					end = end + 1

		return result"
summary ranges,"class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        ans, i = [], 0                # take i to traverse the array, ans to fill the ranges
        while i < len(nums):          # traverse the array
            lower = upper = nums[i]   # for a range we need to find the upper and lower values
            while i < len(nums) and nums[i] == upper:  # increment the i and upper as well in order to check they are equal.
                i += 1
                upper += 1
            ans.append(str(lower) + (""->"" + str(upper-1) if upper-lower-1 else """"))  # if upper-1 and lower both are equal append only lower, else append the range
        return ans"
majority element ii,"class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        return [x for x in set(nums) if nums.count(x) > len(nums)/3]"
majority element ii,"class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        dc=defaultdict(lambda:0)
        n=len(nums)//3
        for a in nums:
            dc[a]+=1
        ans=[]
        for a in dc:
            if(dc[a]>n):
                ans.append(a)
        return ans"
kth smallest element in a bst,"class Solution:
    import heapq
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        
        heap = []
        def inorder(r):
            if r:
                inorder(r.left)
                heapq.heappush(heap,-(r.val))
                if len(heap) > k:
                    heapq.heappop(heap)
                inorder(r.right)
        inorder(root)
        
        return -heapq.heappop(heap)"
kth smallest element in a bst,"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        
        res = []
        
        def bst(node):
            if (not node or (len(res) >= k)):
                return
            
            bst(node.left)
            res.append(node.val)
            bst(node.right)
            
        bst(root)
        
        return res[k - 1]"
power of two,"class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n>0 and n&amp;(n-1)==0"
power of two,"class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n>0 and sum(list(map(int,bin(n)[2:])))==1"
number of digit one,"class Solution:
    def countDigitOne(self, n: int) -> int:
        
        #O(logn) mathematical solution
        #intervals of new 1s: 0-9, 10-99, 100-999, 1000,9999... 
            #each interval yields 1,10,100,etc. new '1's respectively
		#first and foremost, we want to check how many of each interval repeats 
        #conditions for FULL yield when curr%upper bound+1: 1 <=, 19 <=, 199 <=...
        #conditions for PARTIAL yielf when curr%upper bound+1: None, 10 <= < 19,  100 <= < 199, 1000 <= < 1999 ... 
        
        ans = 0
        for i in range(len(str(n))):
            curr = 10**(i+1)
            hi,lo = int('1'+'9'*i), int('1'+'0'*i)
            ans += (n//curr) * 10**i
            if (pot:=n%curr) >= hi: ans += 10**i
            elif lo <= pot < hi: 
                ans += pot - lo + 1
        return ans"
number of digit one,"class Solution:
    def countDigitOne(self, n: int) -> int:
        res, cur = 0, 1
        while cur <= n:
            res += n // (cur * 10) * cur + min(max(n % (cur * 10) - cur + 1, 0), cur)
            cur *= 10
        return res"
palindrome linked list,"class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        def reverse(node):
            prev = None
            while node:
                next_node = node.next
                node.next = prev 
                prev, node = node, next_node
                
            return prev
        
        slow = head
        fast = head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        n1 = head
        n2 = reverse(slow.next)
        while n2:
            if n1.val != n2.val:
                return False
            
            n1 = n1.next
            n2 = n2.next
            
        return True"
palindrome linked list,"class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        
		#vList = valueList
        vList = [] 
		
		#Converting to list
        while head != None:
            if head.val == 0:
                vList.append(0)
            else:
                vList.append(head.val)
            head = head.next
        
		#nList = newList which will be reverse of vList
        nList = vList[::-1]
        
		#Checking for Palindrome!
        if nList == vList:
            return True
        else:
            return False"
lowest common ancestor of a binary search tree,"class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        while True:
            if root.val > p.val and root.val > q.val:
                root = root.left
            elif root.val < p.val and root.val < q.val:
                root = root.right
            else:
                return root"
lowest common ancestor of a binary search tree,"class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        if root:
            # If the value of p node and the q node is greater than the value of root node...
            if root.val > p.val and root.val > q.val:
                return self.lowestCommonAncestor(root.left, p, q)
            # If the value of p node and the q node is less than the value of root node...
            elif root.val < p.val and root.val < q.val:
                return self.lowestCommonAncestor(root.right, p, q)
            else:
                return root"
lowest common ancestor of a binary tree,"class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root==None or root.val==p.val or root.val==q.val:
            return root
        left=self.lowestCommonAncestor(root.left,p,q)
        right=self.lowestCommonAncestor(root.right,p,q)
        if left!=None and right!=None:
            return root
        elif left!=None:
            return left
        else:
            return right"
lowest common ancestor of a binary tree,"class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # if in the current recursion level
        # you find either p or q, return that node
        # if you instead find a None, return None
        # since we're handling both the cases below
        if root is None or root == p or root == q:
            return root
        
        # find either p or q in the left subtree
        # we're expecting this to return one of
        # [None, p, q] and for both the left and right
        # subtree
        l = self.lowestCommonAncestor(root.left, p, q)
        r = self.lowestCommonAncestor(root.right, p , q)
        
        # since values in the tree are unique
        # and this root's left and right subtree
        # has either p and q each, this is the root
        # we're looking for. We're not worried about
        # what values are returned, it's more like
        # we have presence of either p or q in both
        # subtrees, so this has to be our result
        if l and r:
            return root
        
        # if either of the node doesn't contain
        # p or q, just return either None or the
        # one node which has either p or q
        return l if l else r"
delete node in a linked list,"class Solution:
    def deleteNode(self, node):

        nextNode = node.next
        node.val = nextNode.val
        node.next = nextNode.next"
delete node in a linked list,"class Solution(object):
    def deleteNode(self, node):
        """"""
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """"""
        cur = node
        while node.next!=None:
            node.val = node.next.val
            cur = node
            node = node.next
        cur.next = None"
product of array except self,"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        leftProducts = [0]*len(nums) # initialize left array 
        rightProducts = [0]*len(nums) # initialize right array
        
        leftProducts[0] = 1 # the left most is 1
        rightProducts[-1] = 1 # the right most is 1
        res = [] # output
        
        for i in range(1, len(nums)):
            leftProducts[i] = leftProducts[i-1]*nums[i-1]
            rightProducts[len(nums) - i - 1] = rightProducts[len(nums) - i]*nums[len(nums) - i]
            
        for i in range(len(nums)):
            res.append(leftProducts[i]*rightProducts[i])
        
        return res"
product of array except self,"class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = []
        
        p = 1
        for i in range(len(nums)):
            res.append(p)
            p = p * nums[i]
        
        p = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] = res[i] * p #1
            p = p*nums[i]
        
        return res"
sliding window maximum,"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        res = []
        window = collections.deque()
        for i, num in enumerate(nums):
            while window and num >= nums[window[-1]]:
                window.pop()
            window.append(i)
            
            if i + 1 >= k:
                res.append(nums[window[0]])
            
            if i - window[0] + 1 == k:
                window.popleft()
        
        return res"
sliding window maximum,"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        queue = deque() # decreasing queue 
        ans = []
        for i, x in enumerate(nums): 
            while queue and queue[-1][1] <= x: queue.pop()
            queue.append((i, x))
            if queue and queue[0][0] <= i-k: queue.popleft()
            if i >= k-1: ans.append(queue[0][1])
        return ans"
search a 2d matrix ii,"class Solution:
    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:
        
        m=len(mat)
        n=len(mat[0])
        
        i=m-1
        j=0
        
        while i>=0 and j<n:
            if mat[i][j]==target:
                return True
            elif mat[i][j]<target:
                j+=1
            else:
                i-=1
                
        return False"
search a 2d matrix ii,"class Solution:
    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:
        
        m=len(mat)
        n=len(mat[0])
        
        for i in range(m):
            if mat[i][0]<=target and mat[i][-1]>=target:
                lo=0
                hi=n
                while (lo<hi):
                    mid=(lo+hi)//2
                    
                    if mat[i][mid]==target:
                        return True
                    elif mat[i][mid]<target:
                        lo = mid + 1
                    else:
                        hi = mid
                        
        return False"
different ways to add parentheses,"class Solution(object):
    def diffWaysToCompute(self, s, memo=dict()):
        if s in memo:
            return memo[s]
        if s.isdigit(): # base case
            return [int(s)]
        calculate = {'*': lambda x, y: x * y,
                     '+': lambda x, y: x + y,
                     '-': lambda x, y: x - y
                    }
        result = []
        for i, c in enumerate(s):
            if c in '+-*':
                left = self.diffWaysToCompute(s[:i], memo)
                right = self.diffWaysToCompute(s[i+1:], memo)
                for l in left:
                    for r in right:
                        result.append(calculate[c](l, r))
        memo[s] = result
        return result"
different ways to add parentheses,"class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        ops = {
            ""+"": lambda x, y : x + y,
            ""-"": lambda x, y : x - y,
            ""*"": lambda x, y : x * y
        }
        res = []
        for x, char in enumerate(expression):
            if char in ops:
                leftResults = self.diffWaysToCompute(expression[:x])
                rightResults = self.diffWaysToCompute(expression[x + 1:])
                
                for leftNum in leftResults:
                    for rightNum in rightResults:
                        res.append(ops[char](leftNum, rightNum))
        
        # no operations means expression is a sole number
        if not res:
            res.append(int(expression))
        return res"
valid anagram,"class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        tracker = collections.defaultdict(int)
        for x in s: tracker[x] += 1
        for x in t: tracker[x] -= 1
        return all(x == 0 for x in tracker.values())"
valid anagram,"class Solution(object):
    def isAnagram(self, s, t):
        # In case of different length of thpse two strings...
        if len(s) != len(t):
            return False
        for idx in set(s):
            # Compare s.count(l) and t.count(l) for every index i from 0 to 26...
            # If they are different, return false...
            if s.count(idx) != t.count(idx):
                return False
        return True     # Otherwise, return true..."
binary tree paths,"class Solution:
    def binaryTreePaths(self, R: TreeNode) -> List[str]:
        A, P = [], []
        def dfs(N):
            if N == None: return
            P.append(N.val)
            if (N.left,N.right) == (None,None): A.append('->'.join(map(str,P)))
            else: dfs(N.left), dfs(N.right)
            P.pop()
        dfs(R)
        return A
		
		
- Junaid Mansuri
- Chicago, IL"
binary tree paths,"class Solution:
    def _dfs(self, root: Optional[TreeNode], cur, res) -> None:
        
        # Base Case
        if not root:
            return
        
        # Append node to path
        cur.append(str(root.val))
        
        # If root is a leaf, append path to result
        if not root.left and not root.right:
            res.append('->'.join(cur))
            
        # Recursive Step
        self._dfs(root.left, cur, res)
        self._dfs(root.right, cur, res)
        
        # Backtracking / Post-processing / pop node from path
        cur.pop()
        
        
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        self._dfs(root, [], res)
        return res"
add digits,"class Solution(object):
    def addDigits(self, num):
        while num > 9:
            num = num % 10 + num // 10
        return num"
add digits,"class Solution:
    def addDigits(self, num: int) -> int:
        while num > 9:
            num = num % 10 + num // 10
        return num"
single number iii,"class Solution:

    def singleNumber(self, nums: List[int]) -> List[int]:
        dc=defaultdict(lambda:0)
        for a in(nums):
            dc[a]+=1
        ans=[]
        for a in dc:
            if(dc[a]==1):
                ans.append(a)
        return ans"
single number iii,"class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        x = Counter(nums)
        return([y for y in x if x[y] == 1])"
ugly number,"class Solution:
    def isUgly(self, num: int) -> bool:
        if num == 0: return False
        while num % 5 == 0: num /= 5
        while num % 3 == 0: num /= 3
        while num % 2 == 0: num /= 2
        return num == 1
		

- Junaid Mansuri"
ugly number,"class Solution:
    def isUgly(self, n: int) -> bool:
        if n<=0: 
            return False
        for i in [2,3,5]:
            while n%i==0:
                n=n//i
        return n==1"
ugly number ii,"class Solution:
    def nthUglyNumber(self, n: int) -> int:
        k = [0] * n
        t1 = t2 = t3 = 0
        k[0] = 1
        for i in range(1,n):
            k[i] = min(k[t1]*2,k[t2]*3,k[t3]*5)
            if(k[i] == k[t1]*2): t1 += 1
            if(k[i] == k[t2]*3): t2 += 1
            if(k[i] == k[t3]*5): t3 += 1
        return k[n-1]"
ugly number ii,"class Solution:
    def nthUglyNumber(self, n: int) -> int:
    	N, I = [1], {2:0, 3:0, 5:0}
    	for _ in range(n-1):
    		I = {i:bisect.bisect(N, N[-1]//i, I[i]) for i in [2,3,5]}
    		N.append(min(N[I[2]]*2,N[I[3]]*3,N[I[5]]*5))
    	return N[-1]"
missing number,"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        return (len(nums) * (len(nums) + 1))//2 - sum(nums)"
missing number,"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        return reduce(lambda x,y: x ^ y, list(range(len(nums)+1)) + nums)"
integer to english words,"class Solution:
    def numberToWords(self, num: int) -> str:
        mp = {1: ""One"",   11: ""Eleven"",    10: ""Ten"", 
              2: ""Two"",   12: ""Twelve"",    20: ""Twenty"", 
              3: ""Three"", 13: ""Thirteen"",  30: ""Thirty"", 
              4: ""Four"",  14: ""Fourteen"",  40: ""Forty"",
              5: ""Five"",  15: ""Fifteen"",   50: ""Fifty"", 
              6: ""Six"",   16: ""Sixteen"",   60: ""Sixty"", 
              7: ""Seven"", 17: ""Seventeen"", 70: ""Seventy"", 
              8: ""Eight"", 18: ""Eighteen"",  80: ""Eighty"",
              9: ""Nine"",  19: ""Nineteen"",  90: ""Ninety""}
        
        def fn(n):
            """"""Return English words of n (0-999) in array.""""""
            if not n: return []
            elif n < 20: return [mp[n]]
            elif n < 100: return [mp[n//10*10]] + fn(n%10)
            else: return [mp[n//100], ""Hundred""] + fn(n%100)
        
        ans = []
        for i, unit in zip((9, 6, 3, 0), (""Billion"", ""Million"", ""Thousand"", """")): 
            n, num = divmod(num, 10**i)
            ans.extend(fn(n))
            if n and unit: ans.append(unit)
        return "" "".join(ans) or ""Zero"""
integer to english words,"class Solution:        
    def numberToWords(self, num: int) -> str:
        if num == 0 : return 'Zero' #if condition to handle zero
        d = {1000000000 : 'Billion',1000000 : 'Million',1000 : 'Thousand',100 : 'Hundred', 
		90:'Ninety',80:'Eighty',70:'Seventy',60:'Sixty',50: 'Fifty', 40 : 'Forty', 30 : 'Thirty', 20 : 'Twenty',
		19 :'Nineteen',18 :'Eighteen',17:'Seventeen',16:'Sixteen',15:'Fifteen',14:'Fourteen',13:'Thirteen',12:'Twelve',11:'Eleven',
		10:'Ten',9:'Nine',8:'Eight',7:'Seven',6:'Six',5:'Five',4:'Four',3:'Three',2:'Two',1:'One'} #initiating a dictionary to handle number to word mapping
        ans = """"                      #initialising the returnable answer variable
        for key, value in d.items():  #for loop to iterate through each key-value pair in dictionary 
            if num//key>0 :           #checking if number is in the range of current key
                x = num//key          #finding the multiple of key in num
                if key >= 100 :       #logic to add the multiple number x above as word to our answer, We say ""One Hundred"", ""One thoushand"" but we don't say ""One Fifty"", we simply say ""Fifty""
                    ans += self.numberToWords(x) + ' '
                ans  += value + "" ""
                num = num%key         #preparing the number for next loop i.e removing the value from num which we have already appended the words to answer.
        return ans.strip()            #returning answer removing the last blank space"
h index,"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        tmp = [0] * (len(citations) + 1)
		
        for i in range(len(citations)):
            if citations[i] > len(citations):
                tmp[len(citations)] += 1
            else:
                tmp[citations[i]] += 1

        sum_ = 0
        for i in range(len(tmp) - 1, -1, -1):
            sum_ += tmp[i]
            if sum_ >= i:
                return i"
h index,"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations) + 1
        arr = [0] * n
        for c in citations:
            if c >= n:
                arr[n-1] += 1
            else:
                arr[c] += 1
        
        total = 0
        for i in range(n-1, -1, -1):
            total +=  arr[i]
            if total >= i:
                return i
        
        return 0"
h index ii,"class Solution:
    def hIndex(self, A):
        n = len(A)
        l, r = 0, n - 1
        while l < r:
            m = (l + r + 1) // 2
            if A[m] > n - m: r = m - 1
            else: l = m
        return n - l - (A[l] < n - l)"
h index ii,"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        if not citations:
            return 0
        n = len(citations)
        lo, hi = 0, n+1
        while lo < hi:
            mid = (lo + hi)//2
            if citations[-mid] < mid:
                hi = mid
            else:
                lo = mid + 1
        return max(lo-1, 0)"
first bad version,"class Solution:
    def firstBadVersion(self, n: int) -> int:
        left = 1
        right = n
        result = 1
        
        while left<=right:
            mid = (left+right)//2
            if isBadVersion(mid) == False:
                left = mid+1
            else:
                right = mid-1
                result = mid
                
        return result"
first bad version,"class Solution:
	def firstBadVersion(self, n: int) -> int:

		result = 1

		low = 1
		high = n

		while low <= high:

			mid = (low + high) //2

			if isBadVersion(mid) == False:
				low = mid + 1

			else:
				high = mid - 1

				result = mid

		return result"
perfect squares,"class Solution:
    def isSquare(self, n: int) -> bool:
        sq = int(math.sqrt(n))
        return sq*sq == n
        
    def numSquares(self, n: int) -> int:
        # Lagrange's four-square theorem
        if self.isSquare(n):
            return 1
        while (n &amp; 3) == 0:
            n >>= 2
        if (n &amp; 7) == 7:
            return 4
        sq = int(math.sqrt(n)) + 1
        for i in range(1,sq):
            if self.isSquare(n - i*i):
                return 2
        return 3"
perfect squares,"class Solution:
    def numSquares(self, n: int) -> int:
        dp = [float(""inf"")]*(n+1)
        for i in range(len(dp)):
            if int(sqrt(i)) == sqrt(i):
                dp[i] = 1
            else:
                for j in range(int(sqrt(i))+1):
                    dp[i] = min(dp[i], dp[i-j*j]+1)
        return dp[-1]"
expression add operators,"class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        exprs = []
        
        def recurse(idx, value, delta, exp):
            # base case here
            if idx == len(num):
                if value == target:
                    exprs.append("""".join(exp))
            
            # the loop will create the current operand and recursively call
            # the next set of actions to be executed
            for i in range(idx, len(num)):
                # this is to avoid cases where the operand starts with a 0
                # we need to have a case with just the 0 but not something like
                # 05, so the condition will return early if we find such cases
                if num[idx] == '0' and i > idx:
                    return
                
                curr = int(num[idx:i+1])
                curr_str = num[idx:i+1]
                
                # when we start the problem we dont have a preceding operator or operand
                if idx == 0:
                    recurse(i+1, curr, curr, exp + [curr_str])
                else:
                    # We need to do 3 different recursions for each operator
                    # value stores the running value of the expression evaluated so far
                    # the crux of the logic lies in how we use and pass delta
                    # when the operation is '+' or '-' we don't care much about it and can just
                    # add or subtract it from the value 
                    # when '*' is involved, we need to follow the precedence relation,
                    # but we have already evaluated the previous operator. We know the
                    # previous operation that was performed and how much it contributed to the value i.e., delta
                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication
                    recurse(i+1, value+curr, curr, exp + ['+', curr_str])
                    recurse(i+1, value-curr, -curr, exp + ['-', curr_str])
                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + ['*', curr_str])
                            
        recurse(0, 0, 0, [])
        return exprs"
expression add operators,"class Solution:
    def Util(self, num, target, ind, l, mem, exp):
        if ind == l - 1:
            exp += num[ind]
            if eval(exp) == target:
                return [exp]
        if ind >= l:
            return []
        ret1 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + '+')
        ret2 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + '-')
        ret3 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + '*')
        if (exp and exp[-1].isdigit() is True and num[ind] == '0') or num[ind] != '0':
            ret4 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]))
            ret = ret1 + ret2 + ret3 + ret4
        else:
            ret = ret1 + ret2 + ret3
        return ret
        
    def addOperators(self, num: str, target: int) -> List[str]:
        return self.Util(num, target, 0, len(num), dict(), '')"
move zeroes,"class Solution(object):
	def moveZeroes(self, nums):
		i=0
		n = len(nums)
		while i <n:
			if nums[i]==0:
				nums.pop(i)
				nums.append(0)
				n-=1
			else:
				i+=1"
move zeroes,"class Solution(object):
    def moveZeroes(self, nums):
        c=0
        for i in range(len(nums)):
            if nums[i]!=0:
                nums[c],nums[i]=nums[i],nums[c]
                c+=1
        return nums"
find the duplicate number,"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = fast = ans = 0
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        while ans != slow:
            ans = nums[ans]
            slow = nums[slow]
        return ans"
find the duplicate number,"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
    	t, h = nums[0], nums[nums[0]]
    	while t != h: t, h = nums[t], nums[nums[h]]
    	t = 0
    	while t != h: t, h = nums[t], nums[h]
    	return t
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
game of life,"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        
        def is_neighbor(board, i, j):
            return (0 <= i < len(board)) and (0 <= j < len(board[0])) and board[i][j] % 10 == 1
        
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                for d in directions:
                    board[i][j] += 10 if is_neighbor(board, i + d[0], j + d[1]) else 0 # if adj cell is neighbor, add 10
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                neighbors = board[i][j] // 10 # count of neighbors
                is_live = board[i][j] % 10 == 1 # state is live or not
                if is_live: # live(1)
                    if neighbors < 2:   # Rule 1
                        board[i][j] = 0
                    elif neighbors > 3: # Rule 3
                        board[i][j] = 0
                    else:               # Rule 2
                        board[i][j] = 1
                else: # dead(0)
                    if neighbors == 3:  # Rule 4
                        board[i][j] = 1
                    else:
                        board[i][j] = 0"
game of life,"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        m, n = len(board), len(board[0])
        for i in range(m):
            for j in range(n):
                
                # count number of live neighbours
                live_neighbours = 0
                for x in range(max(i-1, 0), min(i+2, m)):
                    for y in range(max(j-1, 0), min(j+2, n)):
                        if i == x and j == y:
                            continue
                        live_neighbours += board[x][y] % 2
                
                # mark the cell if it needs to change states
                if board[i][j] == 0:
                    if live_neighbours == 3:
                        board[i][j] = 2
                elif live_neighbours < 2 or live_neighbours > 3:
                    board[i][j] = 3
        
        # change all required states
        for i in range(m):
            for j in range(n):
                if board[i][j] == 2:
                    board[i][j] = 1
                elif board[i][j] == 3:
                    board[i][j] = 0"
word pattern,"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        li = s.split(' ')
        di = {}
        if len(li) != len(pattern):
            return False
        
        for i, val in enumerate(pattern):
            if val in di and di[val] != li[i]:
                return False
            elif val not in di and li[i] in di.values():
                return False
            elif val not in di:
                di[val] = li[i]
                    
        return True"
word pattern,"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        
        #i/p : pattern = ""abba"" and s = ""dog cat cat dog""
        
        arr1 = list(pattern) #arr1 = [""a"", ""b"", ""b"", ""a""] 
        arr2 = s.split() #arr2 = [""dog"", ""cat"", ""cat"", ""dog""]
        n = len(arr2) #len(arr1) == len(arr2) in all cases where True is possible 
        
        if len(arr1) != len(arr2): #we will never be able to map all characters 
            return False
        
        d1 = {} #to handle character mapping from arr1 to arr2 
        d2 = {} #to handle character mapping from arr2 to arr1
        
        #Below is our character mapping logic
        
        for i in range(0, n):
            
            if arr1[i] in d1 and d1[arr1[i]] != arr2[i]:
                return False
            
            if arr2[i] in d2 and d2[arr2[i]] != arr1[i]:
                return False
            
            d1[arr1[i]] = arr2[i] #after all loops : d1 = {""a"" : ""dog"", ""b"" : ""cat""}
            d2[arr2[i]] = arr1[i] #after all loops : d2 = {""dog"" : ""a"", ""cat"" : ""b""}
        
		#if none of the above condition returns False
		#it means that all characters of arr1 can be legally mapped to arr2, so, return True
        return True"
nim game,"class Solution:
    def canWinNim(self, n: int) -> bool:        
        if n <= 3:
            return True
        new_size = n + 1
        memo = [False] * (new_size)
        
        for i in range(4): 
            memo[i] = True
        
        for i in range(4,new_size):
            for j in range(1,4):
                if memo[i] == True:
                    break
                if memo[i-j] == True:
                    memo[i] = False
                else:
                    memo[i] = True
        
        return memo[n]"
nim game,"class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0"
bulls and cows,"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        
		# The main idea is to understand that cow cases contain the bull cases
		
		# This loop will take care of ""bull"" cases
        bull=0
        for i in range(len(secret)):
            bull += int(secret[i] == guess[i])
        
		# This loop will take care of ""cow"" cases
        cows=0
        for c in set(secret):
            cows += min(secret.count(c), guess.count(c))
        
        return f""{bull}A{cows-bull}B"""
bulls and cows,"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        # Dictionary for Lookup
        lookup = Counter(secret)
        
        x, y = 0, 0
        
        # First finding numbers which are at correct position and updating x
        for i in range(len(guess)):
            if secret[i] == guess[i]:
                x+=1
                lookup[secret[i]]-=1
        
        # Finding numbers which are present in secret but not at correct position 
        for i in range(len(guess)):
            if guess[i] in lookup and secret[i] != guess[i] and lookup[guess[i]]>0:
                y+=1
                lookup[guess[i]]-=1
        
		# The reason for using two for loop is in this problem we have 
		# to give first priority to number which are at correct position,
		# Therefore we are first updating x value
		
        return ""{}A{}B"".format(x, y)"
longest increasing subsequence,"class Solution:     # Suppose, for example:
                    #           nums = [1,8,4,5,3,7],
                    # for which the longest strictly increasing subsequence is arr = [1,4,5,7],
                    # giving len(arr) = 4 as the answer
                    #
                    # Here's the plan:
                    #   1) Initiate arr = [num[0]], which in this example means arr = [1]
                    #     
                    #   2) Iterate through nums. 2a) If n in nums is greater than arr[-1], append n to arr. 2b) If 
                    #      not, determine the furthest position in arr at which n could be placed so that arr
                    #      remains strictly increasing, and overwrite the element at that position in arr with n.

                    #   3) Once completed, return the length of arr.

                    # Here's the iteration for the example:

                    #       nums = [ _1_, 8,4,5,3,7]     arr = [1]              (initial step)
                    #       nums = [1, _8_, 4,5,3,7]     arr = [1, 8]           (8 > 1, so    append 8)
                    #       nums = [1,8, _4_, 5,3,7]     arr = [1, 4]           (4 < 8, so overwrite 8)
                    #       nums = [1_8,4, _5_, 3,7]     arr = [1, 4, 5]        (5 > 4, so    append 5)
                    #       nums = [1_8,4,5, _3_, 7]     arr = [1, 3, 5]        (3 < 5, so overwrite 4)
                    #       nums = [1_8,4,5,3, _7_ ]     arr = [1, 3, 5, 7]     (7 > 5, so    append 7)    

                    # Notice that arr is not the sequence given above as the correct seq. The ordering for [1,3,5,7]
                    # breaks the ""no changing the order"" rule. Cheating? Maybe... However len(arr) = 4 is the 
                    # correct answer. Overwriting 4 with 3 did not alter the sequence's length.
                                
    def lengthOfLIS(self, nums: list[int]) -> int:

        arr = [nums.pop(0)]                  # <-- 1) initial step
 
        for n in nums:                       # <-- 2) iterate through nums
            
            if n > arr[-1]:                  # <--    2a)
                arr.append(n)

            else:                            # <--    2b)
                arr[bisect_left(arr, n)] = n 

        return len(arr)                      # <-- 3) return the length of arr"
longest increasing subsequence,"# Pure Dynamic Proramming Solution
# Time : O(n*(n+1)/2) - O(n^2)
# Space: O(n)
class Solution:
	def lengthOfLIS(self, nums: List[int]) -> int:
		n = len(nums)
		dp = [0]*n
		for i in range(n):
			maX = 0
			for j in range(i+1):
				if nums[j] < nums[i]:
					if dp[j] > maX:
						maX = dp[j]
			dp[i] = maX+1
		return max(dp)

# Dynamic Programming with Binary Search
# Time: O(nlogn), logn for searching the position for the element's and there are n steps.
# Space: O(n)
from bisect import bisect_left
class Solution:
	def lengthOfLIS(self, nums):
		dp = []
		for elem in nums:
			idx = bisect_left(dp, elem)
			if idx == len(dp):
				dp.append(elem)
			else:
				dp[idx] = elem
		return len(dp)

# Dynamic Programming with Binary Search
# Time: O(nlogn), logn for searching the position for the element's and there are n steps.
# Space: O(1)
from bisect import bisect_left
class Solution:
	def lengthOfLIS(self, nums: List[int]) -> int:
		n = len(nums)
		for i in range(n):
			# Here we pass three arg's, which means find the position of nums[i] in the nums array within index i.
			idx = bisect_left(nums, nums[i], hi=i)
			if idx != i:
				nums[idx], nums[i] = nums[i], float(inf)
		return nums.index(float(inf)) if float(inf) in nums else n"
remove invalid parentheses,"class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        
        def valid(s):
            l,r=0,0
            for c in s:
                if c=='(':
                    l+=1
                elif c==')':
                    if  l<=0:
                        r+=1
                    else:
                        l-=1
            return not l and not r
        
        res=[]
        seen=set()
        level={s}
        while True:
            newLevel=set()
            for word in level:
                if valid(word):
                    res.append(word)
            if res: return res
            
            for word in level:
                for i in range(len(word)):
                    if word[i] in '()':
                        newWord=word[:i]+word[i+1:]
                        if newWord not in seen:
                            seen.add(newWord)
                            newLevel.add(newWord)
                  
            level=newLevel
                
        return [""""]"
remove invalid parentheses,"class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        
        def is_valid(expr):
            count = 0
            for ch in expr:
                if ch in '()':
                    if ch == '(':
                        count += 1
                    elif ch == ')':
                        count -= 1
                    if count < 0:
                        return False
            return count == 0
        
        queue = collections.deque()
        queue.append(s)
        
        seen = set()
        seen.add(s)
        
        stay_at_this_level = False
        output = []
        
        while queue:
            
            expression = queue.popleft()
            
            if is_valid(expression):
                output.append(expression)
                stay_at_this_level = True
                
            elif not stay_at_this_level:
                # populate queue with candidiates at the next level i.e. one less ( or )
                for i in range(len(expression)):
                    
                    if expression[i] in '()':
                        candidate = expression[:i] + expression[i+1:]
                        
                        if candidate not in seen:
                            queue.append(candidate)
                            seen.add(candidate)
                            
        return output if output else ['']"
additive number,"class Solution:
    def isAdditiveNumber(self, s: str) -> bool:
        n = len(s)
        for i in range(1, n): # Choose the length of first number
            # If length of 1st number is > 1 and starts with 0 -- skip
            if i != 1 and s[0] == '0':
                continue
            for j in range(1, n): # Choose the length of second number
                # If length of 2nd number is > 1 and starts with 0 -- skip
                if j != 1 and s[i] == '0':
                    continue

                # If the total length of 1st and 2nd number >= n -- skip
                if i + j >= n:
                    break

                # Just use the brute force approach
                a = int(s[0: i])
                b = int(s[i: i+j])
                d = i+j
                while d < n:
                    c = a + b
                    t = str(c)
                    if s[d: d + len(t)] != t:
                        break
                    d += len(t)
                    a = b
                    b = c
                if d == n:
                    return True
        return False"
additive number,"class Solution:
    def isAdditiveNumber(self, num: str):
        return self.backtrack(num)

    def backtrack(self, num: str):
        path = []

        def backtrack(cur_str, cut_size) -> bool:
            ''' retval means: found '''

            # not additive
            if cut_size >= 3 and path[-1] != path[-2] + path[-3]: return False

            # end
            if cur_str == '': return cut_size >= 3

            # backtrack
            for cur_idx in range(1, len(cur_str) + 1):
                cut_str, remain = cur_str[:cur_idx], cur_str[cur_idx:]

                # check start 0
                if cut_str.startswith('0') and cut_str != '0': break

                path.append(int(cut_str))

                if backtrack(remain, cut_size + 1): return True

                path.pop()  # recover

            return False

        return backtrack(num, 0)"
best time to buy and sell stock with cooldown,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0 for i in range(2)] for i in range(n+2)]
        
        dp[n][0] = dp[n][1] = 0
            
        ind = n-1
        while(ind>=0):
		
            for buy in range(2):
                if(buy):
                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])
					
                else:
                    profit = max(prices[ind] + dp[ind+2][1], 0 + dp[ind+1][0])
                    
                dp[ind][buy] = profit
				
            ind -= 1    
			
        return dp[0][1]"
best time to buy and sell stock with cooldown,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0 for i in range(2)] for i in range(n+2)]
        
        dp[n][0] = dp[n][1] = 0
            
        ind = n-1
        while(ind>=0):
            
            dp[ind][1] = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])
            
            dp[ind][0] = max(prices[ind] + dp[ind+2][1], 0 + dp[ind+1][0])
                    
            ind -= 1    
			
        return dp[0][1]"
minimum height trees,"class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1:
            return [0]
        graph = {i:[] for i in range(n)}
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        leaves = []
        for node in graph:
            if len(graph[node]) == 1:
                leaves.append(node)
        
        while len(graph) > 2:
            new_leaves = []
            for leaf in leaves:
                nei = graph[leaf].pop()
                del graph[leaf]
                graph[nei].remove(leaf)
                if len(graph[nei]) == 1:
                    new_leaves.append(nei)
            leaves = new_leaves
        
        return leaves"
minimum height trees,"class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1: return [0]
        
        graph = defaultdict(set)
        for src, dst in edges:
            graph[src].add(dst)
            graph[dst].add(src)
        
        leaves = [node for node in graph if len(graph[node]) == 1]
        
        while n > 2:
            n -= len(leaves)
            temp = []
            for leaf in leaves:
                neighbor = graph[leaf].pop()
                graph[neighbor].remove(leaf)
                if len(graph[neighbor]) == 1:
                    temp.append(neighbor)
            leaves = temp
        return leaves"
burst balloons,"class Solution(object):
    def maxCoins(self, nums):
        n=len(nums)
        nums.insert(n,1)
        nums.insert(0,1)
        self.dp={}
        return self.dfs(1,nums,n)
    def dfs(self,strt,nums,end):
        ans=0
        if strt>end:
            return 0
        if (strt,end) in self.dp:
            return self.dp[(strt,end)]
        for i in range(strt,end+1):
            lmax=self.dfs(strt,nums,i-1)
            rmax=self.dfs(i+1,nums,end)
            curr_coins=nums[strt-1]*nums[i]*nums[end+1]+lmax+rmax
            ans=max(ans,curr_coins)
        self.dp[(strt,end)]=ans
        return self.dp[(strt,end)]"
burst balloons,"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1] # augmented 
        n = len(nums)
        
        dp = [[0]*n for _ in range(n)]
        for i in reversed(range(n)): 
            for j in range(i, n): 
                for k in range(i+1, j): 
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])
        return dp[0][-1]"
super ugly number,"class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        hp=[1]
        dc={1}
        i=1
        while(n):
            mn=heapq.heappop(hp)
            if(n==1):
                return mn
            for p in primes:
                newno=mn*p
                if(newno in dc):
                    continue
                heapq.heappush(hp,newno)
                dc.add(newno)
            n-=1"
super ugly number,"class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        ans = [1]
        ptr = [0]*len(primes) #all pointing to 0th index
        for _ in range(1, n): 
            ans.append(min(ans[ptr[i]]*p for i, p in enumerate(primes)))
            for i, p in enumerate(primes):
                if ans[ptr[i]] * p == ans[-1]: ptr[i] += 1
        return ans[-1]"
count of smaller numbers after self,"class Solution:     # Here's the plan:
                    #   1) Make arr, a sorted copy of the list nums.
                    #   2) iterate through nums. For each element num in nums:
                    #       2a) use a binary search to determine the count of elements
                    #         in the arr that are less than num.
                    #       2b) append that count to the answer list
                    #       2c) delete num from arr
                    #   3) return the ans list 
                    #   
                    #   For example, suppose nums = [5,2,6,1] Then arr = [1,2,5,6].
                    #       num = 5 => binsearch: arr = [1,2,/\5,6], i = 2 => ans = [2,_,_,_], del 5
                    #       num = 2 => binsearch: arr = [1,/\2,6],   i = 1 => ans = [2,1,_,_], del 2
                    #       num = 6 => binsearch: arr = [1,/\6],     i = 1 => ans = [2,1,1,_], del 6
                    #       num = 1 => binsearch: arr = [/\1],       i = 0 => ans = [2,1,1,0], del 1

    def countSmaller(self, nums: List[int]) -> List[int]:
        arr, ans = sorted(nums), []     #   <-- 1)
        
        for num in nums:
            i = bisect_left(arr,num)    #   <-- 2a)
            ans.append(i)               #   <-- 2b)
            del arr[i]                  #   <-- 2c)
            
        return ans                      #   <-- 3)"
count of smaller numbers after self,"class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        counts = [0] * len(nums) # to save counts
        indexed_nums = [(nums[key_index], key_index) for key_index in range(len(nums))] # change the nums into (number, index) pairs
        desc_nums, counts = self.mergeWithCount(indexed_nums, counts) # the helper function returns the descendingly sorted indexed_nums and the counts
        return counts
	
	
    def mergeWithCount(self, nums, counts):
        if len(nums) == 1:
            return nums, counts

        cur_stack = []
        left, counts = self.mergeWithCount(nums[: len(nums) // 2], counts)
        right, counts = self.mergeWithCount(nums[len(nums) // 2 :], counts)
        
        
        while left and right:
            
            if left[0] > right[0]:
                counts[left[0][1]] += len(right) # left[0] gives a (number, index) pair as we defined at the beginning, and left[0][1] returns the original index of the number.
                cur_stack.append(left.pop(0))
            else:
                cur_stack.append(right.pop(0))
                
        if left:
            cur_stack.extend(left)
        else:
            cur_stack.extend(right)
			
        return cur_stack, counts"
remove duplicate letters,"class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        
        for idx, character in enumerate(s):
            if not stack:
                stack.append(character)
            elif character in stack:
                continue
            else:
                while stack and (character < stack[-1]):
                    if stack[-1] in s[idx + 1:]:
                        _ = stack.pop()
                    else:
                        break
                        
                stack.append(character)
                
        return ''.join(stack)"
remove duplicate letters,"class Solution:
    def removeDuplicateLetters(self, string: str) -> str:
        lastIndex = [0] * 26
        self.getLastIndexOfChar(string, lastIndex)
        stack = self.maintainLexoOrder(string, lastIndex)
        
        return ''.join(chr(ord('a') + char) for char in stack)
               
    def getLastIndexOfChar(self, string, lastIndex):
        for idx, char in enumerate(string):
            lastIndex[ord(char)-ord('a')] = idx         

    def maintainLexoOrder(self, string, lastIndex):
        seen = [False] * 26
        stack = []
        
        for idx, char in enumerate(string):
            currentCharVal = (ord(char) - ord('a'))
            if seen[currentCharVal]:
                continue
                
            while (len(stack) > 0 and 
            stack[len(stack)-1] > currentCharVal and
            idx < lastIndex[stack[len(stack)-1]]):
                seen[stack.pop()] = False
                                                                                  
            stack.append(currentCharVal)
            seen[currentCharVal] = True
            
        return stack"
maximum product of word lengths,"class Solution:
    def maxProduct(self, words: List[str]) -> int:
        n=len(words)                        
        char_set = [set(words[i]) for i in range(n)] # precompute hashset for each word                                                  
        max_val = 0
        for i in range(n):
            for j in range(i+1, n):
                if not (char_set[i] &amp; char_set[j]): # if nothing common
                    max_val=max(max_val, len(words[i]) * len(words[j]))
        
        return max_val"
maximum product of word lengths,"class Solution:
    def maxProduct(self, words: List[str]) -> int:
         return max([len(s1) * len(s2) for s1, s2 in combinations(words, 2)  if not (set(s1) &amp; set(s2))], default=0)"
bulb switcher,"class Solution:
    def bulbSwitch(self, n: int) -> int:
        
        # Only those bulds with perferct square number index will keep ""ON"" at last.
        
        return int(n**0.5)"
bulb switcher,"class Solution:
    def bulbSwitch(self, n: int) -> int:
        return int(n**0.5)"
create maximum number,"class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        def maximum_num_each_list(nums: List[int], k_i: int) -> List[int]:
            # monotonically decreasing stack
            s = []
            m = len(nums) - k_i
            for n in nums:
                while s and s[-1] < n and m > 0:
                    s.pop()
                    m -= 1
                s.append(n)
            s = s[:len(s)-m] # very important
            return s
        def greater(a, b, i , j): # get the number which is lexiographically greater
            while i< len(a) or j < len(b): 
                if i == len(a): return False
                if j == len(b): return True
                if a[i] > b[j]: return True
                if a[i] < b[j]: return False
                i += 1 # we increment until each of their elements are same
                j += 1
        
        def merge(x_num, y_num):
            n = len(x_num)
            m = len(y_num)
            i = 0
            j = 0
            s = []
            while i < n or j < m:
                a = x_num[i] if i < n else float(""-inf"") 
                b = y_num[j] if j < m else float(""-inf"") 

                if a > b or greater(x_num, y_num, i , j):
# greater(x_num, y_num, i , j): this function is meant for check which list has element lexicographically greater means it will iterate through both arrays incrementing both at the same time until one of them is greater than other.
                    chosen = a
                    i += 1
                else:
                    chosen = b
                    j += 1
                s.append(chosen)
            return s

        max_num_arr = []
        for i in range(k+1): # we check for all values of k and find the maximum number we can create for that value of k and we repeat this for all values of k and then at eacch time merge the numbers to check if arrive at optimal solution
            first = maximum_num_each_list(nums1, i)
            second = maximum_num_each_list(nums2, k-i)
            merged = merge(first, second)
            # these two conditions are required because list comparison in python only compares the elements even if one of their lengths is greater, so I had to add these conditions to compare elements only if length is equal.
			# Alternatively you can avoid this and convert them both to int and then compare, but I wanted to this as  it is somewhat more efficient.
            if len(merged) == len(max_num_arr) and  merged > max_num_arr:
                max_num_arr = merged
            elif len(merged) > len(max_num_arr):
                max_num_arr = merged
        return max_num_arr"
create maximum number,"class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        
        def fn(arr, k):
            """"""Return largest sub-sequence of arr of size k.""""""
            ans = []
            for i, x in enumerate(arr): 
                while ans and ans[-1] < x and len(ans) + len(arr) - i > k: ans.pop()
                if len(ans) < k: ans.append(x)
            return ans
            
        ans = [0] * k
        for i in range(k+1): 
            if k - len(nums2) <= i <= len(nums1): 
                val1 = fn(nums1, i)
                val2 = fn(nums2, k-i)
                cand = []
                i1 = i2 = 0
                while i1 < len(val1) or i2 < len(val2): 
                    if val1[i1:] >= val2[i2:]: 
                        cand.append(val1[i1])
                        i1 += 1
                    else: 
                        cand.append(val2[i2])
                        i2 += 1
                ans = max(ans, cand)
        return ans"
coin change,"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:        
        dp=[math.inf] * (amount+1)
        dp[0]=0
        
        for coin in coins:
            for i in range(coin, amount+1):
                if i-coin>=0:
                    dp[i]=min(dp[i], dp[i-coin]+1)
        
        return -1 if dp[-1]==math.inf else dp[-1]"
coin change,"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:            
        def coinChangeInner(rem, cache):
            if rem < 0:
                return math.inf
            if rem == 0:                    
                return 0       
            if rem in cache:
                return cache[rem]
            
            cache[rem] = min(coinChangeInner(rem-x, cache) + 1 for x in coins)                         
            return cache[rem]      
        
        ans = coinChangeInner(amount, {})
        return -1 if ans == math.inf else ans"
wiggle sort ii,"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        sortedList = sorted(nums)
        n = len(nums)
        if n%2==0:
            small = sortedList[:((n//2))][::-1]
            large = (sortedList[(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]
        else:
            small = sortedList[:1+((n//2))][::-1]
            large = (sortedList[1+(n//2):])[::-1]
            for i in range(1,n,2):
                nums[i] = large[i//2]
            for i in range(0,n,2):
                nums[i] = small[i//2]"
wiggle sort ii,"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        tmp = nums.copy()
        tmp.sort()        
        n = len(nums)
        i, j = 1, n - 1
        for _ in range(2): 
            for k in range(i, n, 2): # when i == 1 then gt elements and when i == 0 then sm elements with jump of 2
                nums[k] = tmp[j] # sorted array tmp reverse order values assignment
                j -= 1
            i -= 1"
power of three,"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n == 1:
            return True
        if n == 0:
            return False
        else:
            return n % 3 == 0 and self.isPowerOfThree(n // 3)"
power of three,"class Solution:
    def isPowerOfThree(self, n: int) -> bool:  return n in (1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348907,43046721,129140163,387420489,1162261467)"
count of range sum,"class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        def fn(lo, hi): 
            """"""Return count of range sum between prefix[lo:hi].""""""
            if lo+1 >= hi: return 0 
            mid = lo + hi >> 1
            ans = fn(lo, mid) + fn(mid, hi)
            k = kk = mid 
            for i in range(lo, mid): 
                while k < hi and prefix[k] - prefix[i] < lower: k += 1
                while kk < hi and prefix[kk] - prefix[i] <= upper: kk += 1
                ans += kk - k 
            prefix[lo:hi] = sorted(prefix[lo:hi])
            return ans 
        
        return fn(0, len(prefix))"
count of range sum,"class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        ans = prefix = 0 
        seen = [0]
        for x in nums: 
            prefix += x 
            lo = bisect_left(seen, prefix - upper)
            hi = bisect_left(seen, prefix - lower + 1) 
            ans += hi - lo
            insort(seen, prefix)
        return ans"
odd even linked list,"class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if(head is None or  head.next is None):
            return head
        # assign odd = head(starting node of ODD)
        # assign even = head.next(starting node of EVEN)
        odd  , even  =  head , head.next
        
        Even = even # keep starting point of Even Node so later we will connect with Odd Node
        while(odd.next and even.next):
            odd.next = odd.next.next # Connect odd.next to odd Node
            even.next = even.next.next # Connect even,next to Even Node
            
            odd = odd.next # move odd 
            even = even.next # move even
        
        odd.next = Even # now connect odd.next to starting point to Even list
        
        return head"
odd even linked list,"class Solution:
	def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
		if head is None or head.next is None:
			return head

		e,o = head,head.next
		odd_head = o
		while o!=None and o.next!=None:
			e.next = o.next
			e = e.next
			o.next = e.next
			o = o.next

		e.next = odd_head
		return head"
longest increasing path in a matrix,"class Solution:
    def longestIncreasingPath(self, grid: List[List[int]]) -> int:
        m,n=len(grid),len(grid[0])
        directions = [0, 1, 0, -1, 0] # four directions 
        
        @lru_cache(maxsize=None) # using python cache lib for memoization
        def dfs(r,c):
            ans=1                  
			# iterating through all 4 directions
            for i in range(4): 
                new_row,new_col=r+directions[i], c+directions[i+1] # calculating the new cell
				# check if new cell is within the grid bounds and is an increasing sequence
                if 0<=new_row<m and 0<=new_col<n and grid[new_row][new_col]>grid[r][c]: 
                    ans = max(ans, dfs(new_row, new_col) + 1 )  # finding the max length of valid path from the current cell                                      
            return ans
        
        return max(dfs(r,c) for r in range(m) for c in range(n))"
longest increasing path in a matrix,"class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        row = len(matrix); col = len(matrix[0])
        res = 0
        memo = {}
        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
        
        def helper(i, j):
            if (i,j) in memo: return memo[(i,j)]
            path = 1
            for move in directions:
                r = i + move[0]
                c = j + move[1]
                if (0<=r<row and 0<=c<col and
                    matrix[r][c] != '#' and matrix[r][c] > matrix[i][j]):
                    
                    tmp = matrix[i][j]
                    matrix[i][j] = '#'
                    path = max(path, helper(r, c) + 1)
                    matrix[i][j] = tmp
                    
            memo[(i,j)] = path 
            return memo[(i,j)]
        
        for i in range(row):
            for j in range(col):
                res = max(res, helper(i, j))
    
        return res

# Time: O(N^3)
# Space: O(N^2)"
patching array,"class Solution:
	def minPatches(self, nums: List[int], n: int) -> int:
		ans, total = 0, 0
		num_idx = 0
		while total < n:
			if num_idx < len(nums):
				if total < nums[num_idx] - 1:
					total = total * 2 + 1
					ans += 1
				else:
					total += nums[num_idx]
					num_idx += 1
			else:
				total = total * 2 + 1
				ans += 1
		return ans"
patching array,"class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0 
        while prefix < n: 
            if k < len(nums) and nums[k] <= prefix + 1: 
                prefix += nums[k]
                k += 1
            else: 
                ans += 1
                prefix += prefix + 1
        return ans"
verify preorder serialization of a binary tree,"class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        stack = []
        items = preorder.split("","")
        for i, val in enumerate(items):
            if i>0 and not stack:
                return False
            if stack:
                stack[-1][1] -= 1
                if stack[-1][1] == 0:
                    stack.pop()
            if val != ""#"":
                stack.append([val, 2])
        return not stack"
verify preorder serialization of a binary tree,"class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        outlet = 1
        for x in preorder.split("",""): 
            if outlet == 0: return False #intermediate 
            outlet += 1 if x != ""#"" else -1
        return outlet == 0  #end result"
reconstruct itinerary,"class Solution:
    def __init__(self):
        self.path = []
    
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        flights = {}
        
        # as graph is directed
        # => no bi-directional paths
        for t1, t2 in tickets:
            if t1 not in flights:
                flights[t1] = []
                
            flights[t1].append(t2)

        visited = {}
        for k, v in flights.items():
            v.sort()
            visited[k] = [False for _ in range(len(v))]
        
        base_check = len(tickets) + 1
        routes = ['JFK']
        self.dfs('JFK', routes, base_check, flights, visited)
        
        return self.path
        
        
    def dfs(self, curr, routes, base_check, flights, visited):
        if len(routes) == base_check:
            self.path = routes
            return True
        
        # deadlock
        if curr not in flights:
            return False
        
        for idx in range(len(flights[curr])):
            if not visited[curr][idx]:
                visited[curr][idx] = True
                
                next_airport = flights[curr][idx]
                routes += [next_airport]
                result = self.dfs(next_airport, routes, base_check,
                                    flights, visited)
                
                if result:
                    return True
                routes.pop()
                visited[curr][idx] = False

        return False"
reconstruct itinerary,"class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        digraph = defaultdict(list) #directed graph 
        for fm, to in tickets: heappush(digraph[fm], to)
        
        def dfs(n):
            """"""Hierholzer's algo to traverse every edge exactly once""""""
            while digraph[n]: dfs(heappop(digraph[n]))
            ans.appendleft(n)
        
        ans = deque() 
        dfs(""JFK"")
        return ans"
increasing triplet subsequence,"class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        n = len(nums)
        maxRight = [0] * n  # maxRight[i] is the maximum element among nums[i+1...n-1]
        maxRight[-1] = nums[-1]
        for i in range(n-2, -1, -1):
            maxRight[i] = max(maxRight[i+1], nums[i+1])
            
        minLeft = nums[0]
        for i in range(1, n-1):
            if minLeft < nums[i] < maxRight[i]:
                return True
            minLeft = min(minLeft, nums[i])
        return False"
increasing triplet subsequence,"class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        first = second = math.inf
        for num in nums:
            if num <= first:
                first = num
            elif num <= second:  # Now first < num, if num <= second then try to make `second` as small as possible
                second = num
            else:  # Now first < second < num
                return True
        return False"
self crossing,"class Solution:
    def isSelfCrossing(self, x: List[int]) -> bool:
        def intersect(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real
            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real
        
        def overlap(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real
            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag
                
        uv = complex(0, 1)
        p = complex(0, 0)
        segments = deque()
        for s in x:
            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))
            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):
                    return True
            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):
                    return True
            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):
                    return True
            if len(segments) == 6:
                segments.popleft()
            p = np
            uv *= complex(0, 1)
        return False"
palindrome pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        backward, res = {}, []
        for i, word in enumerate(words):
            backward[word[::-1]] = i

        for i, word in enumerate(words):
            
            if word in backward and backward[word] != i:
                res.append([i, backward[word]])
                
            if word != """" and """" in backward and word == word[::-1]:
                res.append([i, backward[""""]])
                res.append([backward[""""], i])
                
            for j in range(len(word)):
                if word[j:] in backward and word[:j] == word[j-1::-1]:
                    res.append([backward[word[j:]], i])
                if word[:j] in backward and word[j:] == word[:j-1:-1]:
                    res.append([i, backward[word[:j]]])
                    
        return res"
palindrome pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        mp = {x: i for i, x in enumerate(words)} # val-to-pos mapping 
        
        ans = []
        for i, word in enumerate(words): 
            for ii in range(len(word)+1): 
                prefix = word[:ii]
                if prefix == prefix[::-1]: # palindromic prefix 
                    key = word[ii:][::-1]
                    if key in mp and mp[key] != i: ans.append([mp[key], i])
                suffix = word[~ii:]
                if ii < len(word) and suffix == suffix[::-1]: # palindromic suffix 
                    key = word[:~ii][::-1]
                    if key in mp and mp[key] != i: ans.append([i, mp[key]])
        return ans"
house robber iii,"class Solution:
    def rob(self, root: TreeNode) -> int:
        def dfs(node):
            if not node: return 0, 0
            left, right = dfs(node.left), dfs(node.right)
            v_take = node.val + left[1] + right[1]
            v_not_take = max(left) + max(right)
            return v_take, v_not_take
        return max(dfs(root))"
house robber iii,"class Solution:
    def rob(self, root: TreeNode) -> int:
        def dfs(node):
            return (node.val + (left:=dfs(node.left))[1] + (right:=dfs(node.right))[1], max(left) + max(right)) if node else (0, 0)
        return max(dfs(root))"
counting bits,"class Solution:
    def countBits(self, N: int) -> List[int]:
        stem = [0]
        while len(stem) < N+1:
            stem.extend([s + 1 for s in stem])
            
        return stem[:N+1]"
counting bits,"class Solution:
    def countBits(self, n: int) -> List[int]:
        res = [0]
        for i in range(1, n+1):
            res.append(res[i>>1] + i%2)
        return res"
power of four,"class Solution:
    def isPowerOfFour(self, num: int) -> bool:
        return num > 0 and not num &amp; (num - 1)  and len(bin(num)) % 2"
power of four,"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        # Solution 1 using recursion
        while n % 4 == 0 and n > 0:
            return self.isPowerOfFour(n/4)
        return n == 1
        
        # Solution 2 iteration
        if n == 1:
            return True
        if n % 4:
            return False
        while n > 1:
            if n % 4:
                return False
            n //= 4
        return n == 1
        
        # Solution 3 using bit manipulation
        '''
        Once we write numbers in it's binary representation, from there we can observe:=>
        i. 000001 , power of 2 and 4
        ii. 000010, power of only 2
        iii. 000100 , power of 2 and 4
        iv. 001000, power of only 2
        v. 010000 , power of 2 and 4
        vi. 100000, power of only 2
        We can see if the set bit is at an odd position and is a power of 2, it's also power of 4.
        '''
        return n.bit_length() &amp; 1 and not(n &amp; (n-1))"
integer break,"class Solution:
    def integerBreak(self, n: int) -> int:
        if(n<=3):
            return n-1
        n3=n//3
        r3=n%3
        if(r3==0):
            return 3**n3
        if(r3==1):
            r3=4
            n3-=1
        return r3*(3**n3)"
integer break,"class Solution:
    result = {1:1,2:1,3:2,4:4,5:6,6:9,7:12,8:18,9:27,10:36}
    def integerBreak(self, n: int) -> int:
        try:
            return self.result[n]
        except:
            x = float(""-inf"")
            for i in range(1,n):
                j = n-1
                while j>0:
                    if i+j==n:
                        k = self.integerBreak(i)*self.integerBreak(j)
                        x = max(x,k)
                    j-=1
            self.result[n] = x
            return self.result[n]"
reverse string,"class Solution:
    def reverseString(self, s: List[str]) -> None:
        s[:] = s[::-1]"
reverse string,"class Solution:
    def reverseString(self, s: List[str]) -> None:
        s.reverse()"
reverse vowels of a string,"class Solution:
    def reverseVowels(self, s: str) -> str:
        s = list(s)
        left = 0
        right = len(s) - 1
        m = 'aeiouAEIOU'
        while left < right:
            if s[left] in m and s[right] in m:
                
                s[left], s[right] = s[right], s[left]
                
                left += 1; right -= 1
            
            elif s[left] not in m:
                left += 1
            
            elif s[right] not in m:
                right -= 1
            
        return ''.join(s)"
reverse vowels of a string,"class Solution:
    def reverseVowels(self, s: str) -> str:
        it = (ch for ch in s[::-1] if ch.lower() in 'aeiou')
        return ''.join(next(it) if ch.lower() in 'aeiou' else ch for ch in s)"
top k frequent elements,"class Solution:
	def topKFrequent(self, nums: List[int], k: int) -> List[int]:

		frequency = {}

		for num in nums:

			if num not in frequency:

				frequency[num] = 1

			else:

				frequency[num] = frequency[num] + 1

		frequency = dict(sorted(frequency.items(), key=lambda x: x[1], reverse=True))

		result = list(frequency.keys())[:k]

		return result"
top k frequent elements,"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        return [x[0] for x in Counter(nums).most_common(k)]"
intersection of two arrays,"class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        a = []
        for i in nums1:
            if i not in a and i in nums2:
                a.append(i)
        return a"
intersection of two arrays,"class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) &amp; set(nums2))"
intersection of two arrays ii,"class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        
        nums1.sort()
        nums2.sort()
        
        
        one=0
        two=0
        
        ans=[]
        
        while one < len(nums1) and two < len(nums2):
            
            if nums1[one] < nums2[two]:
                one+=1
            elif nums2[two] < nums1[one]:
                two+=1
            else:
                
                ans.append(nums1[one])
                one+=1
                two+=1
        return ans"
intersection of two arrays ii,"class Solution:
	def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:

		result = []

		for i in nums1:
			if i in nums2 and i not in result:
				result = result  + [i]*min(nums1.count(i),nums2.count(i))

		return result"
russian doll envelopes,"class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key=lambda x: (x[0], -x[1]))
        
        res = []		
		# Perform LIS
        for _, h in envelopes:
            l,r=0,len(res)-1
			# find the insertion point in the Sort order
            while l <= r:
                mid=(l+r)>>1
                if res[mid]>=h:
                    r=mid-1
                else:
                    l=mid+1        
            idx = l
            if idx == len(res):
                res.append(h)
            else:
                res[idx]=h
        return len(res)"
russian doll envelopes,"class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key=lambda x: (x[0], -x[1]))        
        res = []
        for _, h in envelopes:
            idx = bisect_left(res, h)
            if idx == len(res):
                res.append(h)
            else:
                res[idx]=h
        return len(res)"
count numbers with unique digits,"class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
        if n == 0: return 1
        if n == 1: return 10

        res = 91
        mult = 8
        comb = 81
        for i in range(n - 2):
            comb *=  mult
            mult -= 1
            res += comb

        return res"
count numbers with unique digits,"class Solution:
    def countNumbersWithUniqueDigits(self, n):
        if n == 0:
            return 1

        if n == 1:
            return 10

        dp = [0]*(n+1)

        dp[0], dp[1] = 1, 10

        for i in range(2,n+1):
            dp[i] = (dp[i-1]-dp[i-2])*(10-(i-1)) + dp[i-1]

        return dp[-1]"
max sum of rectangle no larger than k,"class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        ans = float(""-inf"")
        m, n = len(matrix), len(matrix[0])
        for i in range(n):
            lstSum = [0] * m
            for j in range(i, n):
                currSum = 0
                curlstSum = [0]
                for t in range(m):
                    lstSum[t] += matrix[t][j]
                    currSum += lstSum[t]
                    pos = bisect_left(curlstSum, currSum - k)
                    if pos < len(curlstSum):
                        if curlstSum[pos] == currSum - k:
                            return k
                        else:
                            ans = max(ans, currSum - curlstSum[pos])
                    insort(curlstSum, currSum)
        return ans"
max sum of rectangle no larger than k,"class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        import numpy as np
        
        matrix = np.array(matrix, dtype=np.int32)
        
        M,N = matrix.shape
        
        ret = float(""-inf"")
        
        CUM = np.zeros((M,N), dtype=np.int32)
        for shift_r in range(M):
            CUM[:M-shift_r] += matrix[shift_r:]
            
            _CUM = np.zeros((M-shift_r,N), dtype=np.int32)
            for shift_c in range(N):
                _CUM[:, :N-shift_c] += CUM[:M-shift_r,shift_c:]
                tmp = _CUM[(_CUM<=k) &amp; (_CUM>ret)]
                if tmp.size:
                    ret = tmp.max()
            if ret == k:
                return ret
        
        return ret

'''"
water and jug problem,"class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        return False if x + y < z else True if x + y == 0 else not z % math.gcd(x,y)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
water and jug problem,"class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        return not z or (z <= x + y and z % gcd(x, y) == 0)"
valid perfect square,"class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return int(num**0.5) == num**0.5"
valid perfect square,"class Solution:
	def isPerfectSquare(self, num: int) -> bool:

		low  = 1
		high = num

		while low <= high:

			mid = ( low + high ) //2

			if mid * mid == num:
				return mid

			elif mid * mid < num:
				low = mid + 1

			elif mid * mid > num:
				high = mid - 1

		return False"
largest divisible subset,"class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        if not nums or len(nums) == 0:
            return []

        # since we are doing a ""subset"" question
        # sorting does not make any differences
        nums.sort()
        n = len(nums)

        # initilization
        # f[i] represents the size of LDS ended with nums[i]
        f = [1 for _ in range(n)]
        for i in range(1, n):
            for j in range(i):
                # since we have already sorted,
                # then nums[j] % nums[i] will never equals zero
                # unless nums[i] == nums[j]
                if nums[i] % nums[j] == 0:
                    f[i] = max(f[i], f[j] + 1)

        # extract result from dp array
        max_size = max(f)
        max_idx = f.index(max_size) # since we can return one of the largest
        prev_num, prev_size = nums[max_idx], f[max_idx]
        res = [prev_num]
        for curr_idx in range(max_idx, -1, -1):
            if prev_num % nums[curr_idx] == 0 and f[curr_idx] == prev_size - 1:
                # update
                res.append(nums[curr_idx])
                prev_num = nums[curr_idx]
                prev_size = f[curr_idx]

        return res[::-1]"
largest divisible subset,"class Solution:
    def largestDivisibleSubset(self, nums):
        nums.sort()

        n = len(nums)

        dp = [[nums[i]] for i in range(n)]
        
        for i in range(n):
            for j in range(i):
                if nums[i]%nums[j] == 0 and len(dp[j]) + 1 > len(dp[i]):
                    dp[i] = dp[j] + [nums[i]]

        return max(dp, key = len)"
sum of two integers,"class Solution:
    def getSum(self, a: int, b: int) -> int:
        return int(math.log2(2**a * 2**b))"
sum of two integers,"class Solution:
    def getSum(self, a: int, b: int) -> int:
        return int(log2(2**a * 2**b))"
super pow,"class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        return (a % 1337)**(1140 + int(''.join(map(str, b))) % 1140) % 1337
		
		
- Junaid Mansuri"
super pow,"class Solution(object):
    def superPow(self, a, b):
        @cache    
        def cus_pow(a, b):  # A customized pow(a, b)
            if b == 0 or a == 1: return 1
            if b % 2:
                return a * cus_pow(a, b - 1) % 1337
            return cus_pow((a * a) % 1337, b / 2) % 1337
        res = 1
        for x in b:         # power on array
            res = cus_pow(res, 10) * cus_pow(a, x) % 1337
        return res"
find k pairs with smallest sums,"class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        hq = []
        heapq.heapify(hq)
        
        # add all the pairs that we can form with
        # all the (first k) items in nums1 with the first
        # item in nums2
        for i in range(min(len(nums1), k)):
            heapq.heappush(hq, (nums1[i]+nums2[0], nums1[i], nums2[0], 0))

        # since the smallest pair will
        # be the first element from both nums1 and nums2. We'll
        # start with that and then subsequently, we'll pop it out
        # from the heap and also insert the pair of the current
        # element from nums1 with the next nums2 element
        out = []
        while k > 0 and hq:
            _, n1, n2, idx = heapq.heappop(hq)
            out.append((n1, n2))
            if idx + 1 < len(nums2):
                # the heap will ensure that the smallest element
                # based on the sum will remain on top and the
                # next iteration will give us the pair we require
                heapq.heappush(hq, (n1+nums2[idx+1], n1, nums2[idx+1], idx+1))
            k -= 1
                
        return out"
find k pairs with smallest sums,"class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums2 or not nums1: return []
        heap = []
        heapq.heapify(heap)
        for i, num1 in enumerate(nums1[:k]):
            for num2 in nums2[:k//(i+1)]:
                heapq.heappush(heap, [num1+num2, num1, num2])
        return [x[1:] for x in heapq.nsmallest(k, heap)]"
guess number higher or lower,"class Solution:
    def guessNumber(self, n: int) -> int:
        return __pick__"
guess number higher or lower,"class Solution:
    def guessNumber(self, n: int) -> int:
        low = 1
        high = n
        
        while low<=high:
            mid = (low+high)//2
            gussed = guess(mid)
            
            if gussed == 0:
                return mid
            if gussed<0:
                high = mid-1
            else:
                low = mid+1
        
        return low"
guess number higher or lower ii,"class Solution:
    def getMoneyAmount(self, n: int) -> int:
        if n == 1:
            return 1
        starting_index = 1 if n % 2 == 0 else 2
        selected_nums = [i for i in range(starting_index, n, 2)]
        selected_nums_length = len(selected_nums)
        dp = [[0] * selected_nums_length for _ in range(selected_nums_length)]

        for i in range(selected_nums_length):
            dp[i][i] = selected_nums[i]

        for length in range(2, selected_nums_length + 1):
            for i in range(selected_nums_length - length + 1):
                j = i + length - 1
                dp[i][j] = float(""inf"")
                for k in range(i, j + 1):
                    dp_left = dp[i][k - 1] if k != 0 else 0
                    dp_right = dp[k + 1][j] if k != j else 0
                    dp[i][j] = min(dp[i][j], selected_nums[k] + max(dp_left, dp_right))

        return dp[0][-1]"
guess number higher or lower ii,"class Solution:
    def getMoneyAmount(self, n):
                        # For an interval [l,r], we choose a num, which if incorrect still
                        # allows us to know whether the secret# is in either [l,num-1] or
                        # [num+1,r]. So, the worst-case (w-c) cost is
                        #
                        #      num + max(w-c cost in [l,num-1], w-c cost in [num+1,r])
                        # 
                        # We do this by recursion and binary search, starting with [1,n].

        @lru_cache(None)              # <-- we cache function results to avoid recomputing them
        def dp(l = 1, r = n)-> int:
            if r-l < 1: return 0      # <-- base case for the recursion; one number in [l,r]       
            ans = 1000                # <-- the answer for n = 200 is 952
            
            for choice in range((l+r)//2,r):
                ans = min(ans,choice+max(dp(l,choice-1),dp(choice+1,r)))

            return ans

        return dp()"
wiggle subsequence,"class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        length = 0
        curr = 0
        
        for i in range(len(nums) - 1):
            if curr == 0 and nums[i + 1] - nums[i] != 0:
                length += 1
                curr = nums[i + 1] - nums[i]
                
            if curr < 0 and nums[i + 1] - nums[i] > 0:
                length += 1
                curr = nums[i + 1] - nums[i]
                
            elif curr > 0 and nums[i + 1] - nums[i] < 0:
                length += 1
                curr = nums[i + 1] - nums[i]
                
            else:
                continue
                
        return length + 1"
wiggle subsequence,"class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        memo={}
        def recurse(index,state):
            if index==len(nums):
                return 0
            if index in memo:
                return memo[index]
            ans=1
            for i in range(index+1,len(nums)):
                if state=='positive' and nums[i]-nums[index]<0:
                    ans=max(ans,1+recurse(i,'negative'))
                elif state=='negative'and nums[i]-nums[index]>0:
                    ans=max(ans,1+recurse(i,'positive'))
            memo[index]=ans
            return memo[index]
        res=float('-inf')
        for i in range(1,len(nums)):
            if nums[i]-nums[i-1]>0:
                res=max(res,1+recurse(i,'positive'))
            elif nums[i]-nums[i-1]<0:
                res=max(res,1+recurse(i,'negative'))
        if res==float('-inf'):
            return 1
        return res"
combination sum iv,"class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        waysToAdd = [0 for x in range(target+1)]
        waysToAdd[0] = 1
        
        for i in range(min(nums), target+1):
            waysToAdd[i] = sum(waysToAdd[i-num] for num in nums if i-num >= 0)
        
        return waysToAdd[-1]"
combination sum iv,"class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        
        dp = defaultdict(int)
        
        return self.rec(nums, target, dp)
    
    def rec(self, nums, target, dp):
        
        if target == 0:
            return 1
        
        if target < 0:
            return 0
        
        if target in dp:
            return dp[target]
        
        for num in nums:
            dp[target] += self.rec(nums, target-num, dp)
        
        return dp[target]"
kth smallest element in a sorted matrix,"class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        
        m = len(matrix)
        n = len(matrix[0])
        
        def count(m):
            c = 0                   # count of element less than equals to 'm'
            i = n-1
            j = 0
            
            while i >= 0 and j < n:
                if matrix[i][j] > m:
                    i -= 1
                else:
                    c += i+1
                    j += 1
            return c
           
        
        low = matrix[0][0]
        high = matrix[n-1][n-1]
        
        while low <= high:
            m = (low+high)//2
            cnt = count(m)
            if cnt < k:
                low = m + 1
            else:
                cnt1 = count(m-1)
                if cnt1 < k:
                    return m
                high = m-1
        return 0"
kth smallest element in a sorted matrix,"class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        def merge_two(a, b):
            (m, n) = (len(a), len(b))
            i = j = 0
            d = []
            while i < m and j < n:
                if a[i] <= b[j]:
                    d.append(a[i])
                    i += 1
                else:
                    d.append(b[j])
                    j += 1
            while i < m:
                d.append(a[i])
                i += 1
            while j < n:
                d.append(b[j])
                j += 1

            return d
        
        n=len(matrix)
        if n==1:
            return matrix[0][k-1]
        ans = list(merge(matrix[0],matrix[1]))
        for i in range(2,n):
            ans=list(merge(ans,matrix[i]))
        return ans[k-1]"
linked list random node,"class Solution:

    def __init__(self, head: ListNode):
        """"""
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """"""
        self.head = head # store head of linked list 

    def getRandom(self) -> int:
        """"""
        Returns a random node's value.
        """"""
        cnt = 0
        node = self.head 
        while node: 
            cnt += 1
            if randint(1, cnt) == cnt: ans = node.val # reservoir sampling 
            node = node.next 
        return ans"
linked list random node,"class Solution:
    def __init__(self, head: ListNode):
        self.head = head # store head 
        
    def getRandom(self) -> int:
        node = self.head 
        n = 0
        while node: 
            if randint(0, n) == 0: ans = node.val
            n += 1
            node = node.next 
        return ans"
ransom note,"class Solution:
    def canConstruct(self, ransomNote, magazine):
        for i in set(ransomNote):
            if magazine.count(i) < ransomNote.count(i):
                return False
        return True"
ransom note,"class Solution(object):
    def canConstruct(self, ransomNote, magazine):
        st1, st2 = Counter(ransomNote), Counter(magazine)
        if st1 &amp; st2 == st1:
            return True
        return False"
shuffle an array,"class Solution:
	def __init__(self, nums: List[int]):
		self.arr = nums[:]  # Deep Copy, Can also use Shallow Copy concept!
		# self.arr = nums  # Shallow Copy would be something like this!

	def reset(self) -> List[int]:
		return self.arr

	def shuffle(self) -> List[int]:
		ans = self.arr[:]
		for i in range(len(ans)):
			swp_num = random.randrange(i, len(ans))  # Fisher-Yates Algorithm
			ans[i], ans[swp_num] = ans[swp_num], ans[i]
		return ans"
shuffle an array,"class Solution:
    def partitionDisjoint(self, nums: List[int]) -> int:
        a = list(accumulate(nums, max)) 
        b = list(accumulate(nums[::-1], min))[::-1]
        for i in range(1, len(nums)):
            if a[i-1] <= b[i]: 
                return i"
mini parser,"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        if not s: return NestedInteger()
        if not s.startswith(""[""): return NestedInteger(int(s)) # integer 
        ans = NestedInteger()
        s = s[1:-1] # strip outer ""["" and ""]""
        if s: 
            ii = op = 0 
            for i in range(len(s)): 
                if s[i] == ""["": op += 1
                if s[i] == ""]"": op -= 1
                if s[i] == "","" and op == 0: 
                    ans.add(self.deserialize(s[ii:i]))
                    ii = i+1
            ans.add(self.deserialize(s[ii:i+1]))
        return ans"
mini parser,"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        stack = []
        integerStr = ''
        
        for c in s:
            if c == '[':
                stack.append(NestedInteger())
            elif c == ']':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
                poppedList = stack.pop()
                if len(stack)==0:
                    return poppedList
                stack[-1].add(poppedList)
            elif c == ',':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
            else:
                integerStr += c
                
        return NestedInteger(int(s))"
lexicographical numbers,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        return sorted([x for x in range(1,n+1)],key=lambda x: str(x))"
lexicographical numbers,"class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        return sorted(list(map(str,list(range(1,n+1)))))"
first unique character in a string,"class Solution:
	def firstUniqChar(self, s: str) -> int:

		for i in range(len(s)):

			if s[i] not in s[:i] and s[i] not in s[i+1:]:

				return i

		return -1"
first unique character in a string,"class Solution:
	def firstUniqChar(self, s: str) -> int:

		frequency = {}

		for char in s:

			if char not in frequency:
				frequency[char] = 1
			else:
				frequency[char] = frequency[char] + 1

		for index in range(len(s)):

			if frequency[s[index]] == 1:
				return index

		return -1"
longest absolute file path,"class Solution:
    def lengthLongestPath(self, s: str) -> int:
        paths, stack, ans = s.split('\n'), [], 0
        for path in paths:
            p = path.split('\t')
            depth, name = len(p) - 1, p[-1]
            l = len(name)
            while stack and stack[-1][1] >= depth: stack.pop()
            if not stack: stack.append((l, depth))
            else: stack.append((l+stack[-1][0], depth))
            if '.' in name: ans = max(ans, stack[-1][0] + stack[-1][1])   
        return ans"
longest absolute file path,"class Solution:
    def lengthLongestPath(self, input: str) -> int:
        max_len,ht = 0,{}
        for p in input.split(""\n""):
            key=p.count(""\t"")
            if ""."" not in p:
                value = len(p.replace(""\t"",""""))
                ht[key]=value
            else:
                temp_len = key + len(p.replace(""\t"",""""))
                for ky in ht.keys():
                    if ky < key:
                        temp_len += ht[ky]
                max_len=max(max_len,temp_len)
        return max_len"
find the difference,"class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
    	s, t = sorted(s), sorted(t)
    	for i,j in enumerate(s):
    		if j != t[i]: return t[i]
    	return t[-1]"
find the difference,"class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
    	for i in set(t):
    		if s.count(i) != t.count(i): return i"
elimination game,"class Solution:
    def lastRemaining(self, n: int) -> int:
        if n == 1: return 1
        if n&amp;1: n -= 1
        return n + 2 - 2*self.lastRemaining(n//2)"
elimination game,"class Solution:
    def lastRemaining(self, n: int) -> int:
        
        def fn(n): 
            """"""Return the final number of a list of length n.""""""
            if n == 1: return 1
            if n&amp;1: n -= 1
            return n + 2*(1 - fn(n//2))
        
        return fn(n)"
perfect rectangle,"class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        
        area = 0
        corners = set()
        a = lambda: (Y-y) * (X-x)
        
        for x, y, X, Y in rectangles:
            area += a()
            corners ^= {(x,y), (x,Y), (X,y), (X,Y)}

        if len(corners) != 4: return False
        x, y = min(corners, key=lambda x: x[0] + x[1])
        X, Y = max(corners, key=lambda x: x[0] + x[1])
        return a() == area"
perfect rectangle,"class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        xs=[]
        ys=[]
        
        for sx,sy,ex,ey in rectangles:
            xs.append(sx)
            xs.append(ex)
            
            ys.append(sy)
            ys.append(ey)
            
        xlookup={x:i for i,x in enumerate(sorted(set(xs)))}
        ylookup={y:i for i,y in enumerate(sorted(set(ys)))}
        
        N=len(xlookup)-1
        M=len(ylookup)-1
        grid=[[0]*M for _ in range(N)]
        
        for sx,sy,ex,ey in rectangles:
            for cx in range(xlookup[sx],xlookup[ex]):
                for cy in range(ylookup[sy],ylookup[ey]):
                    grid[cx][cy]+=1
                    
        for row in grid:
            for cell in row:
                if cell!=1:
                    return False
                
        return True"
is subsequence,"class Solution(object):
    def isSubsequence(self, s, t):
        # Base case
        if not s:
            return True
        i = 0
        # Traverse elements of t string
        for j in t:
            # If this index matches to the index of s string, increment i pointer...
            if j == s[i]:
                i += 1
            # If the pointer is equal to the size of s...
            if i == len(s):
                break
        return i == len(s)"
is subsequence,"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i, j, n, m = 0, 0, len(s), len(t)
        while i < n and j < m: # Loop till any of the strings is fully traversed
			if s[i] == t[j]: # If char at i and j are equal then update i
				i += 1 
			# Could also write i += s[i]==t[j]
            j += 1 # Update j always.
        return i == n"
utf 8 validation,"class Solution:
    def validUtf8(self, data: List[int]) -> bool:
        n = len(data)
        l = [2**i for i in range(7, -1, -1)]
        
        def isXByteSeq(pos, X):
            f = data[pos]
            rem = data[pos+1:pos+X]
            ret = (f&amp;l[X]) == 0
            for i in range(X):
                ret &amp;= (f&amp;l[i]) != 0
            for num in rem:
                ret &amp;= (num&amp;l[0]) != 0
                ret &amp;= (num&amp;l[1]) == 0
            return ret
            
        @cache
        def res(pos = 0):
            ret = False
            if pos == n:
                ret = True
            if pos + 3 < n:
                ret |= isXByteSeq(pos, 4) and res(pos + 4)
            if pos + 2 < n:
                ret |= isXByteSeq(pos, 3) and res(pos + 3)
            if pos + 1 < n:
                ret |= isXByteSeq(pos, 2) and res(pos + 2)
            if pos < n:
                ret |= isXByteSeq(pos, 0) and res(pos + 1)
            return ret
        
        return res()"
utf 8 validation,"class Solution:
    def validUtf8(self, data: List[int]) -> bool:
        
        count = 0                                   # Keep a tally of non-first bytes required
        
        for byte in data:                           # Pad out bytes to nine digits and ignore the 1st 1
            byte|= 256                                  # Ex: 35 = 0b100101 --> 35|256 = 0b1_00100101
			
                                                    # Check for bad bytes.
            if (byte >> 3 == 0b1_11111 or               # One of first five digits must be a 1
                (byte >> 6 == 0b1_10)^(count>0)):       # Non-first byte can happen if and only if the current count !=0.
                return False
                                                    # Update counts after new byte. (1-byte -> no change
													# to count required because count == 0.)
            if   byte >> 5 == 0b1_110 : count = 1       # 2-byte first byte
            elif byte >> 4 == 0b1_1110: count = 2       # 3-byte first byte
            elif byte >> 4 == 0b1_1111: count = 3       # 4-byte first byte
            elif byte >> 6 == 0b1_10  : count-= 1       # non-first bytes

        return not count                            # Check for zero-count at EOL"
decode string,"class Solution:
def decodeString(self, s: str) -> str:
    
    res,num = """",0
    st = []
    for c in s:
        if c.isdigit():
            num = num*10+int(c)    
        elif c==""["":
            st.append(res)
            st.append(num)
            res=""""
            num=0
        elif c==""]"":
            pnum = st.pop()
            pstr = st.pop()
            res = pstr + pnum*res
        else:
            res+=c
    
    return res"
decode string,"class Solution:
def decodeString(self, s: str) -> str:       
    def dfs(s,p):
        res = """"
        i,num = p,0
        while i<len(s):
            asc = (ord(s[i])-48)
            if 0<=asc<=9:           # can also be written as if s[i].isdigit()
                num=num*10+asc
            elif s[i]==""["":
                local,pos = dfs(s,i+1)
                res+=local*num
                i=pos
                num=0
            elif s[i]==""]"":
                return res,i
            else:
                res+=s[i]
            i+=1
        return res,i
    
    return dfs(s,0)[0]"
longest substring with at least k repeating characters,"class Solution:
    def rec(self, s, k):
        c = Counter(s)

        if pattern := ""|"".join(filter(lambda x: c[x] < k, c)):
            if arr := list(filter(lambda x: len(x) >= k, re.split(pattern, s))):
            
                return max(map(lambda x: self.rec(x, k), arr))
            
            return 0
        
        return len(s)
    
    def longestSubstring(self, s: str, k: int) -> int:
        return self.rec(s, k)"
longest substring with at least k repeating characters,"class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        #sliding window and hashmap O(n) or Divide and conquer(O(n*n))
        n=len(s)
        ans=0     
        freq= Counter(s)
        max_nums=len(freq)
        for num in range(1,max_nums+1):
            counter=defaultdict(int)
            left=0
            for right in range(n):
                counter[s[right]]+=1 
                
                while len(counter)>num:
                    counter[s[left]]-=1
                    if counter[s[left]]==0:
                        del counter[s[left]]
                    left+=1
                for key in counter:
                    if counter[key]>=k :
                        flag=1
                    else:
                        flag=0
                        break
                if flag==1:
                    ans=max(ans,right-left+1)
        return ans"
rotate function,"class Solution:
    def maxRotateFunction(self, A: List[int]) -> int:
        s, n = sum(A), len(A)
        cur_sum = sum([i*j for i, j in enumerate(A)])
        ans = cur_sum
        for i in range(n): ans = max(ans, cur_sum := cur_sum + s-A[n-1-i]*n)
        return ans"
rotate function,"class Solution:
    def maxRotateFunction(self, nums: List[int]) -> int:
        s, n = sum(nums), len(nums)
        rotate_sum = 0
        
        for i in range(n):
            rotate_sum += nums[i] * i       # ex. [0, 1, 2, 3]  --> 0*0 + 1*1 + 2*2 + 3*3
            
        res = rotate_sum
        
        for i in range(n-1, 0 , -1):
            rotate_sum += s - n * nums[i]   # 0*0 + 1*1 + 2*2 + 3*3 --> 0*1 + 1*2 + 2*3 + 3*4 --> 0*1 + 1*2 + 2*3 + 3*0
            res = max(res, rotate_sum)      # update res
            
        return res"
integer replacement,"class Solution:
    def integerReplacement(self, n: int) -> int:
        cnt = 0
        while n != 1:
            if n%2 == 0:
                n//=2
            elif n%4 == 1 or n == 3:
                n -= 1
            else:
                n += 1
            cnt += 1
        return cnt"
integer replacement,"class Solution:
    def integerReplacement(self, n: int) -> int:
        def helper(n, memo):
            if n in memo:
                return memo[n]
            elif n%2:
                memo[n] = 1 + min(helper(n-1,memo), helper(n+1,memo))
                return memo[n]
            else:
                memo[n] = 1 + helper(n//2, memo)
                return memo[n]
       
        memo = {1:0}
        return helper(n, memo)"
random pick index,"class Solution:

    def __init__(self, nums: List[int]):
        # Reservoir Sampling (which can handle the linked list with unknown size), time complexity O(n) (init: O(1), pick: O(n)), space complextiy O(1)
        self.nums = nums

    def pick(self, target: int) -> int:
        # https://docs.python.org/3/library/random.html
        count = 0
        chosen_index = None
        for i in range(len(self.nums)):
            if self.nums[i] != target:
                continue
            count += 1
            if count == 1:
                chosen_index = i
            elif random.random() < 1 / count:
                chosen_index = i
        return chosen_index"
random pick index,"class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums

    def pick(self, target: int) -> int:
        count = 0        
        for i, n in enumerate(self.nums):
            if n == target:
                count += 1
                if random.randrange(count) == 0:
                    picked = i
                    
        return picked"
evaluate division,"class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        graph = {}
        for (u, v), w in zip(equations, values): 
            graph.setdefault(u, []).append((v, 1/w))
            graph.setdefault(v, []).append((u, w))

        def dfs(n, g, val=1):
            """"""Depth-first traverse the graph.""""""
            if n in vals: return 
            vals[n] = val, g
            for nn, w in graph.get(n, []): dfs(nn, g, w*val)
    
        vals = dict()
        for i, n in enumerate(graph): dfs(n, i)
        
        ans = []
        for u, v in queries: 
            if u in vals and v in vals and vals[u][1] == vals[v][1]: ans.append(vals[u][0]/vals[v][0])
            else: ans.append(-1)
        return ans"
evaluate division,"class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        # directed graph as adjacency list 
        digraph = {} 
        for (u, v), w in zip(equations, values): 
            digraph.setdefault(u, []).append((v, w))
            digraph.setdefault(v, []).append((u, 1/w))
            
        # query 
        def dfs(u, v, w=1): 
            """"""Return division via dfs.""""""
            if u not in digraph: return -1 
            if u == v: return w
            seen.add(u)
            for uu, ww in digraph.get(u, []): 
                if uu not in seen and (ans := dfs(uu, v, w*ww)) != -1: return ans 
            return -1
        
        ans = []
        for u, v in queries: 
            seen = set()
            ans.append(dfs(u, v))
        return ans"
nth digit,"class Solution:
    def findNthDigit(self, n: int) -> int:
        digit = base = 1 # starting from 1 digit
        while n > 9*base*digit: # upper limit of d digits 
            n -= 9*base*digit
            digit += 1
            base *= 10 
        q, r = divmod(n-1, digit)
        return int(str(base + q)[r])"
nth digit,"class Solution:
    def findNthDigit(self, n: int) -> int:
        """"""
        imagine the number you need to find have 4 digit
        so you need to go throught all num have 1 digit, 2 digit, 3 digit
        number have 1 digit:  10 ** 1 - 1 = 9 => 9 * 1 = 9 digit
        number have 2 digit:  10 ** 2 - 1 = 90 => 90 * 2 = 180 digit
        number have 3 digit:  10 ** 3 - 1 = 900 => 900 * 3 = 2700 digit
        ...
        just subtract until you find how many digit of the number you need to find
        when you got the number of digit 
        """"""
        if n < 10:
            return n
        
        number_of_digit = 0 # check how many digit of the number you need to find
        while n > 0:
            number_of_digit += 1
            n -= 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        n += 9 * 10 ** ((number_of_digit - 1)) * number_of_digit
        
        """""" 
        print(n , number_of_digit) if you dont understand 
        after subtract you will find number of digit
        all you need to do now is find exactly number by just a little bit of math
        """""" 
        tmp_num = 0
        
        if n % number_of_digit == 0:
            n //= number_of_digit 
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(tmp_num + n)[-1])
        else:
            n /= number_of_digit
            digit = int((n * number_of_digit) % number_of_digit)
            tmp_num += 10 ** ((number_of_digit - 1)) - 1
            return int(str(int(tmp_num + n) + 1)[digit - 1])"
binary watch,"class Solution:
    def readBinaryWatch(self, n: int) -> List[str]:
    	return [str(h)+':'+'0'*(m<10)+str(m) for h in range(12) for m in range(60) if (bin(m)+bin(h)).count('1') == n]"
binary watch,"class Solution:
    def readBinaryWatch(self, turnedOn):
        return ['{}:{}'.format(i,str(j).zfill(2)) for i in range(12) for j in range(60) if bin(i)[2:].count('1') + bin(j)[2:].count('1') == turnedOn]"
remove k digits,"class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        st = list()
        for n in num:
            while st and k and st[-1] > n:
                st.pop()
                k -= 1
            
            if st or n is not '0': # prevent leading zeros
                st.append(n)
                
        if k: # not fully spent
			st = st[0:-k]
            
        return ''.join(st) or '0'"
remove k digits,"class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        st = []
        for i in num:
            while k and len(st) > 0 and st[-1] > i:
                k -= 1
                st.pop()
            st.append(i)
        while k:
            k -= 1
            st.pop()
        st = """".join(st).lstrip(""0"")
        return st if st else ""0"""
frog jump,"class Solution(object):
    def canCross(self, stones):
        n = len(stones)
        stoneSet = set(stones)
        visited = set()
        def goFurther(value,units):
            if (value+units not in stoneSet) or ((value,units) in visited):
                return False
            if value+units == stones[n-1]:
                return True
            visited.add((value,units))
            return goFurther(value+units,units) or goFurther(value+units,units-1) or goFurther(value+units,units+1)
        return goFurther(stones[0],1)"
frog jump,"class Solution:
    def canCross(self, stones: List[int]) -> bool:
        L = len(stones)
        
        if stones[1] != 1: return False
        
        @cache
        def canCross(stone, k):
            if stone == stones[-1]:
                return True

            jumps = [k, k+1]
            if k > 1: jumps.append(k-1)
            
            for jump in jumps:
                nextStone = stone + jump
                found = bisect_left(stones, nextStone)
                if found < L and stones[found] == nextStone and canCross(nextStone, jump):
                    return True
                
            return False
        
        return canCross(1, 1)"
sum of left leaves,"class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        # does this node have a left child which is a leaf?
        if root.left and not root.left.left and not root.left.right:
			# gotcha
            return root.left.val + self.sumOfLeftLeaves(root.right)

        # no it does not have a left child or it's not a leaf
        else:
			# bummer
            return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"
sum of left leaves,"class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root: return 0
        
        queue = collections.deque([root])
        res = 0
        
        while queue:
            node = queue.popleft()
            if node:
			    # check if the current node has a left child
				# and that left child is a leaf, if yes, consider it
                if node.left and not node.left.left and not node.left.right:
                    res += node.left.val
				
				# irrespectively, add the children
				# of the current node to continue
				# your bfs exploration further
                queue.append(node.left)
                queue.append(node.right)
                
        return res"
convert a number to hexadecimal,"class Solution:
    def toHex(self, num: int) -> str:
        hex=""0123456789abcdef"" #created string for reference
        ot="""" # created a string variable to store and update output string
        if num==0:
            return ""0""
        elif num<0:
            num+=2**32
        while num:
            ot=hex[num%16]+ot # we update the output string with the reminder of num/16 , 16 because we are dealing with hex.
            num//=16 # now we are updating num by dividing it by 16 ***// operator used for floor division , means division will be always integer not float.
        return ot # then we simply return ot"
convert a number to hexadecimal,"class Solution:
    def toHex(self, num: int) -> str:
        Hex='0123456789abcdef' ; ans=''
        if num<0: num+=2**32
        while num>0: ans=Hex[num%16]+ans ; num//=16
        return ans if ans else '0'"
queue reconstruction by height,"class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        output=[] 
        
        # sort the array in decreasing order of height 
        # within the same height group, you would sort it in increasing order of k
        # eg: Input : [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
        # after sorting: [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]
        people.sort(key=lambda x: (-x[0], x[1]))                
        for a in people:
            # Now let's start the greedy here
            # We insert the entry in the output array based on the k value
            # k will act as a position within the array
            output.insert(a[1], a)
        
        return output"
queue reconstruction by height,"class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        from sortedcontainers import SortedList
        n = len(people)
        people.sort()
        ans = [None] * n
        ans[people[0][1]] = people[0]
        sl = SortedList(range(n))
        toRemove = [people[0][1]]
        for i in range(1, n):
            if people[i][0] != people[i - 1][0]:
                for index in toRemove:
                    sl.remove(index)
                toRemove = []
            ans[sl[people[i][1]]] = people[i]
            toRemove.append(sl[people[i][1]])
        return ans"
trapping rain water ii,"class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        if not heightMap or not heightMap[0]:
            return 0
			
			
		# Initial
		# Board cells cannot trap the water
        m, n = len(heightMap), len(heightMap[0])
        if m < 3 or n < 3:
            return 0
			
			
		# Add Board cells first
        heap = []
        for i in range(m):
            for j in range(n):
                if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    heightMap[i][j] = -1
					
					
		# Start from level 0
        level, res = 0, 0
        
		while heap:
            height, x, y = heapq.heappop(heap)
            level = max(height, level)

            for i, j in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= i < m and 0 <= j < n and heightMap[i][j] != -1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
					
					# If cell's height smaller than the level, then it can trap the rain water
                    if heightMap[i][j] < level:
                        res += level - heightMap[i][j]
						
					# Set the height to -1 if the cell is visited
                    heightMap[i][j] = -1

        return res"
trapping rain water ii,"class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        m, n = len(heightMap), len(heightMap[0])
        if m < 3 or n < 3: return 0
        # to simplify the code
        def adjacent(i,j):
            return [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]
        
        # first we sort all heights from the matrix and store their corresponding positions
        # heights will be [(h1,[p1, p2,...]), (h2,[p1, p2, ...]), ...]
        d = defaultdict(list)
        for i in range(m):
            for j in range(n):
                d[heightMap[i][j]].append((i,j))
        heights = sorted(d.items())
        # initialization
        volumn, area, h_lower = 0, 0, heights[0][0]
        level = [[1 for j in range(n)] for i in range(m)]
        for h, positions in heights:
            volumn += area*(h-h_lower)
            h_lower = h
            leak = []
            for i, j in positions:
                # due to height rising, now this position may hold water
                level[i][j] = 0
                area += 1
                if i == 0 or i == m-1 or j == 0 or j == n-1 or any([level[a][b] == -1 for a, b in adjacent(i,j)]):
                    # this position is reachable from outside, therefore cannot hold water
                    leak.append((i,j))
                    level[i][j] = -1
                    area -= 1
            while leak:
                i, j = leak.pop()
                for a, b in adjacent(i,j):
                    if 0 <= a < m and 0 <= b < n and not level[a][b]:
                        # new leaking position found through DFS
                        leak.append((a,b))
                        level[a][b] = -1
                        area -= 1

        return volumn"
longest palindrome,"class Solution:
    def longestPalindrome(self, s: str) -> int:
        oddFlag=0
        
        count=collections.Counter(s)

        ans=0
        for k,v in count.items():
            if v%2==1:
                ans+=v-1
                oddFlag= 1
            else:
                ans+=v
                
        if oddFlag == 1:
            return ans+1
        return ans"
longest palindrome,"class Solution:
    def longestPalindrome(self, s: str) -> int:
        count = {} # Hash Table   
        ans = []   # every word's frequency 
        odd= 0     # store an odd number's frequency 
        for word in s:
            if word not in count:
                count[word] = 1
            else:
                count[word] += 1
        for times in count.values():
            ans.append(times)
            if times % 2 != 0:
                odd += 1      # calculate an odd number's frequency
        if odd != 0:
            return sum(ans) - odd + 1        
        elif odd == 0:
            return sum(ans) - odd"
split array largest sum,"class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:
        def isPossible(maxSum):
            curr = count = 0
            for i in nums:
                count += (i + curr > maxSum)
                curr = curr + i if i + curr <= maxSum else i
            return count + 1 <= m
        
        lo, hi = max(nums), sum(nums)
        while lo <= hi:
            mid = (lo + hi) // 2
            if isPossible(mid): hi = mid - 1
            else: lo = mid + 1
        return lo"
split array largest sum,"class Solution:
    def splitArray(self, nums: [int], m: int) -> int:
        prefixSum = []
        curSum = 0 
        for num in nums: 
            curSum += num
            prefixSum.append(curSum)
        self.prefixSum = prefixSum   
        memo = dict()
        minMax = self.helper(0, m-1, memo)
        return minMax
        
    def getSum(self, start: int, end: int) -> int: 
        res = self.prefixSum[end]
        res -= self.prefixSum[start-1] if start-1 >= 0 else 0 
        return res
    
    def helper(self, index: int, splits: int, memo: dict) -> int: 
        if splits == 0: 
            subarray = self.getSum(index, len(self.prefixSum)-1)
            return subarray
        
        key = (index, splits) 
        if key in memo: 
            return memo[key]
        
        minMax = float('inf')
        maxIndex = len(self.prefixSum)-splits
        for i in range (index, maxIndex): 
            subarray = self.getSum(index, i)
            maxLeftover = self.helper(i+1, splits-1, memo)
            maximum = max(subarray, maxLeftover) 
            minMax = min(minMax, maximum)
        memo[key] = minMax
        return minMax"
fizz buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
    	return ['FizzBuzz' if i%15 == 0 else 'Buzz' if i%5 == 0 else 'Fizz' if i%3 == 0 else str(i) for i in range(1,n+1)]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
fizz buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        r=[]
        while n:
            if n%3==0 and n%5==0:
                r.append(""FizzBuzz"")
            elif n%3==0:
                r.append(""Fizz"")
            elif n%5==0:
                r.append(""Buzz"")
            else:
                r.append(str(n))
            n-=1
        return r[::-1]"
arithmetic slices,"class Solution:
       def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums)-2):
            j = i+1
            while(j<len(nums)-1):
                if nums[j]-nums[j-1] == nums[j+1]-nums[j]:
                    count += 1
                    j += 1
                else:
                    break
        return count"
arithmetic slices,"class Solution:
    def numberOfArithmeticSlices(self, A: List[int]) -> int:
        if len(A) < 3: return 0
        
        res, counter = 0, 2
        last_dif = A[1] - A[0]
        
        for index, num in enumerate(A[2:], 1):
            
            if last_dif == num - A[index]:
                counter += 1  
            else:
                if counter >= 3:
                    res += (counter - 1) * (counter - 2) // 2   
                counter = 2
                last_dif = num - A[index]
                
                
        if counter >= 3:
            res += (counter - 1) * (counter - 2) // 2
        return res"
third maximum number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
    	n, T = list(set(nums)), [float('-inf')]*3
    	for i in n:
    		if i > T[0]:
    			T = [i,T[0],T[1]]
    			continue
    		if i > T[1]:
    			T = [T[0],i,T[1]]
    			continue
    		if i > T[2]:
    			T = [T[0],T[1],i]
    	return T[2] if T[2] != float('-inf') else T[0]
		
		
- Junaid Mansuri"
third maximum number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        
        max1 = nums[0]  #Initialised the max with first index
        secmax = float('-inf') 
        thirmax = float('-inf')
        #assuming second and third to be -infinity
        
        if len(nums)<3:
                return max(nums)
        #this won't run more than 2 times and hence we can consider this in our O(n) solution!
        # It isn't worth writing the Whole Loop logic here
        
        for i in range(len(nums)):
                num = nums[i]
                
				#Read the below if conditions to get the approach of updating First, second and third max respectively
				
                if (num>max1):
                        thirmax = secmax 
                        secmax = max1
                        max1 = nums[i]
                        
                elif(num>secmax and num<max1):
                        thirmax = secmax
                        secmax = num
                        
                elif(num>thirmax and num<secmax):
                        thirmax = num
                        
        return thirmax if thirmax != float('-inf') else max1
		#if condition when the elements get repeated such that thirdmax remains -infinity"
add strings,"class Solution:
	def addStrings(self, num1: str, num2: str) -> str:
		num1 = list(num1)
		num2 = list(num2)
		car = 0
		res = """"
		while num1 or num2 or car:
			if num1:
				car += int(num1.pop())
			if num2:
				car += int(num2.pop())
			res += str((car % 10))
			car //= 10
		return res[::-1]"
add strings,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        def func(n):
            value = {'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9}
            result = 0
            for digit in n:
                result = 10 * result + value[digit]

            return result

        ans = func(num1) + func(num2)
        return str(ans)"
partition equal subset sum,"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
	    if sum(nums)%2:  # or if sum(nums)&amp;1
		    return False
		# main logic here"
partition equal subset sum,"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        s = sum(nums)
        if s&amp;1:
            return False
        """"""
        The dp array stores the total obtained sums we have come across so far.
        Notice that dp[0] = True; if we never select any element, the total sum is 0.
        """"""
        dp = [True]+[False]*s
        # Now, loop through each element
        for num in nums:
            for curr in range(s, num-1, -1):  # avoid going out-of-bounds
                """"""
                Case 1: The current sum (curr) has been seen before.
                        Then, if we don't select the current element, the sum will not change.
						So, this total sum will still exist, and its dp value remains True.
				
				Case 2: The current sum (curr) has not been seen before,
				        but it can be obtained by selecting the current element.
						This means that dp[curr-num] = True, and thus dp[curr] now becomes True.
				
				Case 3: The current sum (curr) has not been seen before,
				        and it cannot be obtained by selecting the current element.
						So, this total sum will still not exist, and its dp value remains False.
                """"""
                dp[curr] = dp[curr] or dp[curr-num]
        # Finally, we want to obtain the target sum
        return dp[s//2]  # or dp[s>>1]"
pacific atlantic water flow,"class Solution:
    def pacificAtlantic(self, ht: List[List[int]]) -> List[List[int]]:
        
        def pac(i,j):
            if rp[i][j]:
                return True
            k=False
            h=ht[i][j]
            ht[i][j]=100001
            if ht[i-1][j]<=h:
                k=k or pac(i-1,j)
                
            if ht[i][j-1]<=h:
                k=k or pac(i,j-1)
                
            if i<m-1 and ht[i+1][j]<=h:
                k=k or pac(i+1,j)
                
            if j<n-1 and ht[i][j+1]<=h:
                k=k or pac(i,j+1)
                
            ht[i][j]=h
            rp[i][j]=k
            return k
        
        def ant(i,j):
            if ra[i][j]:
                return True
            k=False
            h=ht[i][j]
            ht[i][j]=100001
            if i>0 and ht[i-1][j]<=h:
                k=k or ant(i-1,j)
                
            if j>0 and ht[i][j-1]<=h:
                k=k or ant(i,j-1)
                
            if ht[i+1][j]<=h:
                k=k or ant(i+1,j)
                
            if ht[i][j+1]<=h:
                k=k or ant(i,j+1)
                
            ht[i][j]=h
            ra[i][j]=k
            return k
        
        m=len(ht)
        n=len(ht[0])
        rp=[[False for i in range(n)] for j in range(m)]
        ra=[[False for i in range(n)] for j in range(m)]
        
        for i in range(m):
            rp[i][0]=True
            ra[i][-1]=True
        for i in range(n):
            rp[0][i]=True
            ra[-1][i]=True
        
        for i in range(m):
            for j in range(n):
                pac(i,j)
                ant(i,j)
        res=[]
        for i in range(m):
            for j in range(n):
                if rp[i][j] and ra[i][j]:
                    res.append([i,j])
        return res"
pacific atlantic water flow,"class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix: return []
        m, n = len(matrix), len(matrix[0])
        pacific = [(0, i) for i in range(n)] + [(i, 0) for i in range(1, m)]
        atlantic = [(m-1, i) for i in range(n)] + [(i, n-1) for i in range(m-1)]
        def bfs(q):
            visited = set()
            q = collections.deque(q)
            while q:
                i, j = q.popleft()
                visited.add((i, j))
                for ii, jj in map(lambda x: (x[0]+i, x[1]+j), [(-1, 0), (1, 0), (0, -1), (0, 1)]):
                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in visited and matrix[ii][jj] >= matrix[i][j]:
                        q.append((ii, jj))
            return visited     
        return bfs(pacific) &amp; bfs(atlantic)"
battleships in a board,"class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        count = 0
        for r in range(len(board)):
            for c in range(len(board[0])):
                if board[r][c] == 'X':
                    var = 1
                    if (r > 0 and board[r-1][c] == 'X') or (c > 0 and board[r][c-1] == 'X'):
                        var = 0
                    count += var
        return count"
battleships in a board,"class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        count = 0
        
        for i, row in enumerate(board):
            for j, cell in enumerate(row):
                if cell == ""X"":
                    if (i == 0 or board[i - 1][j] == ""."") and\
                       (j == 0 or board[i][j - 1] == "".""):
                            count += 1
                            
        return count"
strong password checker,"class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        #vimla_kushwaha
        s = password
        missing_type = 3
        if any('a' <= c <= 'z' for c in s): missing_type -= 1
        if any('A' <= c <= 'Z' for c in s): missing_type -= 1
        if any(c.isdigit() for c in s): missing_type -= 1

        change = 0
        one = two = 0
        p = 2
        while p < len(s):
            if s[p] == s[p-1] == s[p-2]:
                length = 2
                while p < len(s) and s[p] == s[p-1]:
                    length += 1
                    p += 1
                    
                change += length // 3
                if length % 3 == 0: one += 1
                elif length % 3 == 1: two += 1
            else:
                p += 1
        
        if len(s) < 6:
            return max(missing_type, 6 - len(s))
        elif len(s) <= 20:
            return max(missing_type, change)
        else:
            delete = len(s) - 20
            
            change -= min(delete, one)
            change -= min(max(delete - one, 0), two * 2) // 2
            change -= max(delete - one - 2 * two, 0) // 3
                
            return int(delete + max(missing_type, change))"
strong password checker,"class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        digit = lower = upper = 1
        for ch in password: 
            if ch.isdigit(): digit = 0 
            elif ch.islower(): lower = 0
            elif ch.isupper(): upper = 0 
        missing = digit + lower + upper 
        reps = one = two = 0
        i = 2
        while i < len(password):
            if password[i-2] == password[i-1] == password[i]:
                sz = 3
                while i+1 < len(password) and password[i] == password[i+1]:
                    sz += 1
                    i += 1
                reps += sz // 3
                if sz % 3 == 0: one += 1
                elif sz % 3 == 1: two += 1
            i += 1
        if len(password) < 6: return max(missing, 6 - len(password))
        elif len(password) <= 20: return max(missing, reps)
        else: 
            dels = len(password) - 20
            reps -= min(dels, one)
            reps -= min(max(dels - one, 0), two * 2) // 2
            reps -= max(dels - one - 2 * two, 0) // 3
            return dels + max(missing, reps)"
maximum xor of two numbers in an array,"class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        # need to know the largest binary representation
		# bin prepends '0b', ignore
		L = len(bin(max(nums))) - 2

		# preprocess step - left-pad zeros to ensure each number has L bits
		# (x >> i) &amp; 1 produces the bit at position i for number x
		# x's value is moved right by i bits, we &amp; 1 to produce 0 or 1
		# e.g., if L = 5, then 3 = [0, 0, 0, 1, 1], so the steps to get there are:
		# (3 >> 4) &amp; 1 = 0
		# (3 >> 3) &amp; 1 = 0
		# (3 >> 2) &amp; 1 = 0
		# (3 >> 1) &amp; 1 = 1
		# (3 >> 0) &amp; 1 = 1
		nums_bits = [[(x >> i) &amp; 1 for i in reversed(range(L))] for x in nums]
		root = {}
		# build the trie
		for num, bits in zip(nums, nums_bits):
			node = root
			for bit in bits:
				node = node.setdefault(bit, {})
			node[""#""] = num

		max_xor = 0
		for num, bits in zip(nums, nums_bits):
			node = root
			# we want to find the node that will produce the largest XOR with num
			for bit in bits:
				# our goal is to find the opposite bit, e.g. bit = 0, we want 1
				# this is our goal because we want as many 1's as possible
				toggled_bit = 1 - bit
				if toggled_bit in node:
					node = node[toggled_bit]
				else:
					node = node[bit]
			# we're at a leaf node, now we can do the XOR computation
			max_xor = max(max_xor, node[""#""] ^ num)


        return max_xor"
maximum xor of two numbers in an array,"class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        def helper(group0=[], group1=[], div_bit=0):
            if len(group0) + len(group1) <= 1: return 0
            if len(group0) == 1 and len(group1) == 1: return group0[0] ^ group1[0]
            if div_bit == -1 and group0 and group1: return group0[0] ^ group1[0]
            if div_bit == -1: return 0
            nbit = div_bit - 1
            
            if group0 and group1:
                group00, group01 = divide_by_bit(group0, div_bit)
                group10, group11 = divide_by_bit(group1, div_bit)
                if (group00 and group11) and (group01 and group10):
                    return max(helper(group00, group11, nbit), helper(group10, group01, nbit))
                elif group00 and group11:
                    return helper(group00, group11, nbit)
                elif group01 and group10:
                    return helper(group10, group01, nbit)
                else:
                    return helper(group00 or group01, group10 or group11, nbit)
            else:
                group0, group1 = divide_by_bit(group0 or group1, div_bit)
                return helper(group0, group1, nbit)
                
        max_num = max(nums)
        max_bit = int(math.log(max_num, 2)) if max_num else 0
        return helper(nums, [], max_bit)
        

def divide_by_bit(nums, bit):
    mask = 1 << bit
    g0, g1 = [], []
    for num in nums:
        if num &amp; mask == 0:
            g0.append(num)
        else:
            g1.append(num)
    return g0, g1"
reconstruct original digits from english,"class Solution:
    def originalDigits(self, s: str) -> str:
        c = collections.Counter(s)
        
        digit_count = [0] * 10
        digit_count[0] = c['z']
        digit_count[2] = c['w']
        digit_count[4] = c['u']
        digit_count[6] = c['x']
        digit_count[8] = c['g']
        
        digit_count[3] = c['h'] - digit_count[8]
        digit_count[5] = c['f'] - digit_count[4]
        digit_count[7] = c['s'] - digit_count[6]
        
        digit_count[9] = c['i'] - digit_count[5] - digit_count[6] - digit_count[8]
        digit_count[1] = c['n'] - digit_count[9] * 2 - digit_count[7]
        
        return """".join([str(idx) * cnt for idx, cnt in enumerate(digit_count) if cnt > 0])"
reconstruct original digits from english,"class Solution:
    def originalDigits(self, s: str) -> str:
        # (z)ero, one, t(w)o, three, fo(u)r, five, si(x), seven, ei(g)ht, nine
        from collections import Counter
        sc = Counter(s)
        digits = {0: Counter(""zero""), 1: Counter(""one""), 2:Counter(""two""), 3:Counter(""three""), 4:Counter(""four""), 5:Counter(""five""), 6:Counter(""six""), 7: Counter(""seven""), 8: Counter(""eight""), 9: Counter(""nine"")}
        counts = [0]*10
        
        for i in [0, 2, 4, 6, 8, 3, 1, 7, 5, 9]:
            digit = digits[i]
            while digit <= sc:
                sc -= digit
                counts[i] += 1
                
        return """".join([str(i)*c for i, c in enumerate(counts)])"
longest repeating character replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        
        # Maintain a dictionary that keeps track of last 'window' characters
        # See if 'window' size minus occurrences of the most common char is <= k, if so it's valid
        # Run time is O(length of string * size of alphabet)
		# Space is O(size of alphabet)
        
        d = {}
        window = 0
        
        for i, char in enumerate(s):
            d[char] = d.get(char, 0) + 1
            if window+1 - max(d.values()) <= k:
                window += 1
            else:
                d[s[i-window]] -= 1
        
        return window"
longest repeating character replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        maxf = l = 0
        count = collections.Counter() # counting the occurance of the character in the string. 
		# instead of using ""count = collections.Counter()"", we can do the following:-
		""""""
		for r, n in enumerate(s):
            if n in hashmap:
                hashmap[n] += 1
            else:
                hashmap[n] = 1
		""""""
        for r in range(len(s)):
            count[s[r]] += 1 # increasing the count of the character as per its occurance. 
            maxf = max(maxf, count[s[r]]) # having a max freq of the character that is yet occurred. 
            if r - l + 1 > maxf + k:  # if length of sliding window is greater than max freq of the character and the allowed number of replacement.
                count[s[l]] -= 1 # then we have to decrease the occurrance of the character by 1 are we will be sliding the window. 
                l += 1 # and we have to slide our window
        return len(s) - l  # this will provide the length of the longest substring containing the same letter with the replacement allowed."
construct quad tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        
        def fn(x0, x1, y0, y1): 
            """"""Return QuadTree subtree.""""""
            val = {grid[i][j] for i, j in product(range(x0, x1), range(y0, y1))}
            if len(val) == 1: return Node(val.pop(), True, None, None, None, None)
            tl = fn(x0, (x0+x1)//2, y0, (y0+y1)//2)
            tr = fn(x0, (x0+x1)//2, (y0+y1)//2, y1)
            bl = fn((x0+x1)//2, x1, y0, (y0+y1)//2)
            br = fn((x0+x1)//2, x1, (y0+y1)//2, y1)
            return Node(None, False, tl, tr, bl, br)
        
        n = len(grid)
        return fn(0, n, 0, n)"
construct quad tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        bits = {1:0,0:0}
        for row in grid:
            for i in row:
                bits[i] += 1
        total_bits = len(grid) ** 2
        if bits[1] == total_bits: return Node(1, True, None, None, None, None)
        if bits[0] == total_bits: return Node(0, True, None, None, None, None)
        mid = len(grid)//2
        return Node(1, False, 
        self.construct(list(map(lambda bits: bits[:mid], grid[:mid]))),  
        self.construct(list(map(lambda bits: bits[mid:], grid[:mid]))),
        self.construct(list(map(lambda bits: bits[:mid], grid[mid:]))),
        self.construct(list(map(lambda bits: bits[mid:], grid[mid:]))))"
n ary tree level order traversal,"class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        result = []        
        q = deque([root] if root else [])
        while q:
            result.append([])
            for _ in range(len(q)):
                node = q.popleft()
                result[-1].append(node.val)
                q.extend(node.children)
            
        return result"
n ary tree level order traversal,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(n)
	""""""

	def levelOrder(self, root: Optional['Node']) -> List[List[int]]:
		if root is None:
			return []

		queue = deque([root])
		levels = []

		while queue:
			levels.append([])
			for _ in range(len(queue)):
				node = queue.popleft()
				levels[-1].append(node.val)
				queue.extend(node.children)

		return levels"
flatten a multilevel doubly linked list,"class Solution:
    def flatten(self, head: 'Node') -> 'Node':
        def getTail(node):
            prev = None
            while node:
                _next = node.next
                if node.child:
					# ... <-> node <-> node.child <-> ...
                    node.next = node.child
                    node.child = None
                    node.next.prev = node
					# get the end node of the node.child list
                    prev = getTail(node.next)
                    if _next:
						# ... <-> prev (end node) <-> _next (originally node.next) <-> ...
                        _next.prev = prev
                        prev.next = _next
                else:
                    prev = node
                node = _next  # loop through the list of nodes
            return prev  # return end node
        
        getTail(head)
        return head"
flatten a multilevel doubly linked list,"class Solution:
    def flatten(self, head: 'Node') -> 'Node':
        
        def helper(head) -> 'None':
            
            prev, current_node = None, head
            
            while current_node:
                
                if current_node.child:
                    
                    # flatten child linked list
                    current_child, current_tail = current_node.child, helper(current_node.child)
                    
                    # After next level flattening is completed
                    # Handle for the concatenation between current linked list and child linked list
                    
                    # current node's child points to None after flattening
                    current_node.child = None
                    
                    ## Update the linkage between original next and current tail                    
                    original_next = current_node.next
                    
                    if original_next: 
                        original_next.prev = current_tail                    
                    
                    current_tail.next = original_next
                            
                    ## Update the linkage between current node and current child
                    current_node.next, current_child.prev = current_child, current_node
                    
                    # update prev and cur, move to next position
                    prev, current_node = current_tail, original_next
                    
                    
                else:
                    
                    # update prev and cur, move to next position
                    prev, current_node = current_node, current_node.next
            
            
            # return tail node
            return prev
        
	# ------------------------------------------------------------------------------

        helper(head)
        
        return head"
minimum genetic mutation,"class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        dic=defaultdict(lambda :0)
        lst=[[start,0]]
        dic[start]=1
        while lst:
            x,d=lst.pop(0)
            if x==end:
                return d
            for i in range(len(bank)):
                ct=0
                for j in range(8):
                    if x[j]!=bank[i][j]:
                        ct+=1
                if ct==1:
                    if dic[bank[i]]==0:
                        lst.append([bank[i],d+1])
                        dic[bank[i]]=1
        return -1"
minimum genetic mutation,"class Solution:
    def minMutation(self, start: str, end: str, bank: list[str]) -> int:
        bank = set(bank) | {start}

        def dfs(st0, cnt):
            if st0 == end:
                return cnt

            bank.remove(st0)
            for i, ch0 in enumerate(st0):
                for ch1 in ""ACGT"":
                    if (
                        ch0 != ch1
                        and (st1 := st0[:i] + ch1 + st0[i + 1 :]) in bank
                        and (res := dfs(st1, cnt + 1)) != -1
                    ):
                        return res

            return -1

        return dfs(start, 0)"
number of segments in a string,"class Solution:
    def countSegments(self, s: str) -> int:
        return len([i for i in s.split("" "") if i!=""""])"
number of segments in a string,"class Solution:
    def countSegments(self, s: str) -> int:
        
        #create a list based on a space split
        slist = list(s.split("" ""))
        
        #return the len of list minus empty item
        return(len(slist)-slist.count(""""))"
non overlapping intervals,"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        ans, curr = 1, intervals[0]

        for i in range(n):
            if intervals[i][0] >= curr[1]:
                ans += 1
                curr = intervals[i]

        return n - ans"
non overlapping intervals,"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda k: k[1])
        removed, last_end = 0, float('-inf')
        for start, end in intervals:
            if start < last_end:
                removed += 1
            else:
                last_end = end
        return removed"
find right interval,"class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        start = sorted([[intervals[i][0], i] for i in range(len(intervals))])
        end = sorted([[intervals[i][1], i] for i in range(len(intervals))])
        i = 0
        res = []
        for endVal, endIdx in end:
            while i < len(start) and (endVal > start[i][0]):
                i += 1
            if i < len(start):
                res.append(start[i][1])
            else:
                while len(res) < len(start):
                    res.append(-1)
        ans = []
        for i in range(len(end)):
            ans.append((end[i][1], res[i]))
        ans.sort()
        return [ele[1] for ele in sorted([[a[1], b] for a, b in zip(end, res)])]"
find right interval,"class Solution:
    def findRightInterval(self, intervals: list[list[int]]) -> list[int]:
        tmp, ans = sorted(intervals), []
        indices = {tuple(j): i for i, j in enumerate(intervals)}
        for i in intervals:
            res = Solution().binary_search(tmp, i[1]) or ()
            ans.append(indices.get(tuple(res), -1))
        return ans

    def binary_search(self, arr, target):
        l, r = 0, len(arr) - 1
        while l <= r:
            mid = (l + r) // 2
            element = arr[mid][0]
            if element < target:
                l = mid + 1
            elif element > target:
                r = mid - 1
            else:
                return arr[mid]
        return None if l >= len(arr) else arr[l]"
path sum iii,"class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        
        global result
        result = 0
        
        def dfs(node, target):
            if node is None: return
            find_path_from_node(node, target)
            dfs(node.left, target)
            dfs(node.right, target)
                
        def find_path_from_node(node, target):
            global result
            if node is None: return
            if node.val == target: result += 1
            find_path_from_node(node.left, target-node.val)
            find_path_from_node(node.right, target-node.val)
            
        dfs(root, sum)
        
        return result"
path sum iii,"class Solution(object):
    def pathSum(self, root, targetSum):
        """"""
        :type root: TreeNode
        :type targetSum: int
        :rtype: int
        """"""
        self.targetSum=targetSum
        self.hashmap={0:1}
        self.prefix=0
        self.result=0
        
        self.helper(root)
        
        return self.result
    def helper(self, root):
        
        if root is None:
            return
        
        self.prefix+=root.val
        if self.prefix-self.targetSum in self.hashmap:
            self.result+=self.hashmap[self.prefix-self.targetSum]
        
        if self.prefix in self.hashmap:
            self.hashmap[self.prefix]+=1
        else:
            self.hashmap[self.prefix]=1
            
        self.helper(root.left)
        self.helper(root.right)
        
        self.hashmap[self.prefix]-=1
        self.prefix-=root.val"
find all anagrams in a string,"class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]: 
        # take counter of first n elements in s_dict with n = len(p) - 1
        s_dict = collections.Counter(s[:len(p)-1]) 
        # counter of p, this should not be changed
        p_dict = collections.Counter(p)
        start = 0
        # final result list
        res = []
        # We iterate over the string s, and in each step we check if s_dict and p_dict match
        for i in range(len(p)-1, len(s)):
            # updating the counter &amp; adding the character
            s_dict[s[i]] += 1
            # checking if counters match
            if s_dict == p_dict:
                res.append(start)
            # remove the first element from counter
            s_dict[s[start]] -= 1
            #if element count = 0, pop it from the counter
            if s_dict[s[start]] == 0:
                del s_dict[s[start]]
            start += 1
            
        return res"
find all anagrams in a string,"class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
    	LS, LP, S, P, A = len(s), len(p), 0, 0, []
    	if LP > LS: return []
    	for i in range(LP): S, P = S + hash(s[i]), P + hash(p[i])
    	if S == P: A.append(0)
    	for i in range(LP, LS):
    		S += hash(s[i]) - hash(s[i-LP])
    		if S == P: A.append(i-LP+1)
    	return A
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
k th smallest in lexicographical order,"class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        
        def fn(x): 
            """"""Return node counts in denary trie.""""""
            ans, diff = 0, 1
            while x <= n: 
                ans += min(n - x + 1, diff)
                x *= 10 
                diff *= 10 
            return ans 
        
        x = 1
        while k > 1: 
            cnt = fn(x)
            if k > cnt: k -= cnt; x += 1
            else: k -= 1; x *= 10 
        return x"
arranging coins,"class Solution:
    def arrangeCoins(self, n: int) -> int:

        first = 1
        last = n
        if n==1:
            return 1
        while first <= last:
            mid = (first+last)//2

            if mid*(mid+1) == 2*n:
                return mid
            elif mid*(mid+1) > 2*n:
                last = mid-1
            else:
                first = mid+1
        return last"
arranging coins,"class Solution:
	def arrangeCoins(self, n: int) -> int:

		result = 0

		stairs_number = 1

		while n > 0:
			n = n - stairs_number
			stairs_number = stairs_number + 1
			if n >= 0:
				result = result + 1

		return result"
find all duplicates in an array,"class Solution:
    def findDuplicates(self, N: List[int]) -> List[int]:
        S, A = set(), []
        for n in N:
            if n in S: A.append(n)
            else: S.add(n)
        return A"
find all duplicates in an array,"class Solution:
    def findDuplicates(self, N: List[int]) -> List[int]:
        A = []
        for n in N:
            if N[abs(n)-1] > 0: N[abs(n)-1] = -N[abs(n)-1]
            else: A.append(abs(n))
        return A



- Junaid Mansuri
(LeetCode ID)@hotmail.com"
string compression,"class Solution:
    def compress(self, chars: List[str]) -> int:
        if not chars:
            return 0
        mychar = chars[0]
        count = 0
        length = len(chars)
        chars.append("" "") # Append a space so last char group is not left out in loop
        for i in range(length+1): #+1 for extra space char we added
            char = chars.pop(0)
            if char == mychar: #if same character then just increase the count
                count += 1
            else:
                if count == 1: #if not same then append the char to chars
                    chars.append(mychar) #if count is 1 don't append count
                elif count > 1:
                    chars.append(mychar)
                    chars += (list(str(count))) #if count > 1 append count as a string
                mychar = char #update mychar as the new different char in chars
                count = 1 #reset count to 1 as we have already read the new char
        return len(chars) #since all previous are popped, only the answer remains in chars now"
string compression,"class Solution:
    def compress(self, chars: List[str]) -> int:
        if(len(chars)==1):
            return 1
        ans=[]
        c=None
        ct=0
        i=0
        for a in chars:
            if(a!=c):
                if(ct>1):
                    x=str(ct)
                    for m in x:
                        chars[i]=m
                        i+=1
                chars[i]=a
                i+=1
                ct=1
                c=a
            else:
                ct+=1
        if(ct==1):
            return i
        x=str(ct)
        for m in x:
            chars[i]=m
            i+=1
        return i"
add two numbers ii,"class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
	
        n1 = n2 = 0
        ptr1, ptr2 = l1, l2
        stack = []
        
        while ptr1: n1 += 1; ptr1 = ptr1.next
        while ptr2: n2 += 1; ptr2 = ptr2.next
        max_len = max(n1, n2)
        
        while max_len:
            a = b = 0
            if max_len <= n1: a = l1.val; l1 = l1.next
            if max_len <= n2: b = l2.val; l2 = l2.next
            stack.append(a + b)
            max_len -= 1
        
        sumval, head = 0, None
        while stack or sumval:
            if stack: sumval += stack.pop()
            node = ListNode(sumval % 10)
            node.next = head
            head = node
            sumval //= 10
        return head"
add two numbers ii,"class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:

        def fn(node): 
            """"""Return number represented by linked list.""""""
            ans = 0
            while node:
                ans = 10*ans + node.val
                node = node.next
            return ans 
        
        dummy = node = ListNode()
        for x in str(fn(l1) + fn(l2)): 
            node.next = ListNode(int(x))
            node = node.next
        return dummy.next"
arithmetic slices ii subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        ans = 0 
        freq = [defaultdict(int) for _ in range(len(nums))] # arithmetic sub-seqs
        for i, x in enumerate(nums): 
            for ii in range(i): 
                diff = x - nums[ii]
                ans += freq[ii].get(diff, 0)
                freq[i][diff] += 1 + freq[ii][diff]
        return ans"
arithmetic slices ii subsequence,"class Solution:
    # Intuition - 
    # You travel through nums and reach a num
    # Count the number of weak Arithmetic Sequences you can make from this num
    # What are weak arithmetic sequences - > 2, 4 is a weak arithmetic sequence of diff = 2 ; 3, 4 is a weak arithmetic sequence of diff 1
	# Accomodate all the weak arithmetic sequences you can make with previous nums
    # When you travel further you look back and check the previous nums and their weak arithmetic sequences using their diff dictionary[in python] {maps in general}
    # After the above step check in the diffs of previous nums the weak arithmetic sequences they can make and can they be used to make a proper arithmetic sequence by adding you current num
    # These weak arithmetic sequences can be added to this num to make a proper arithmetic sequence! so count this in the res : res += dp[j][diff]
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 2: return 0
        res = 0
        dp = [defaultdict(int) for _ in range(n)]
        for i in range(1, n):
            for j in range(i):
                diff = nums[i] - nums[j]
                dp[i][diff] += 1
                if diff in dp[j]:
                    res += dp[j][diff]
                    dp[i][diff] += dp[j][diff]
        return res"
number of boomerangs,"class Solution:
    def numberOfBoomerangs(self, p: List[List[int]]) -> int:
        L, t = len(p), 0
        D = [[0]*L for i in range(L)]
        for i in range(L):
        	E = {}
        	for j in range(L):
        		if j > i: D[i][j] = D[j][i] = (p[j][0]-p[i][0])**2 + (p[j][1]-p[i][1])**2
        		E[D[i][j]] = E[D[i][j]] + 1 if D[i][j] in E else 1
        	t += sum(r*(r-1) for r in E.values())
        return t
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
number of boomerangs,"class Solution:
    def dist(self, p1, p2):
        return sqrt(pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2))
    
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        res = 0
        
        for i in range(len(points)):
            ""cache for every point""
            dist_cache = collections.defaultdict(int)
            
            for j in range(len(points)):
                if i == j:
                    continue
                    
                dist_cache[self.dist(points[i], points[j])] += 1
            
            
            for key in dist_cache:
                """"""
                The formula for generating permutations given n object where we are allowed to choose r of them, is: P(n, r) = n! / (n-r)! 
                In our case we have: n = dist_cache[key] (where key is some distance). Also we can choose 2 elements at a time: r = 2. So formula now: P(n, 2) = n! / (n-2)!
                Using some mathematical transformations: n! / (n-2)! = n * (n-1) * (n-2)! / (n-2)! = n * (n-1)
                This logic applies to each point.
                """"""
                res += dist_cache[key] * (dist_cache[key] - 1)
        
        return res"
find all numbers disappeared in an array,"class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for n in nums:
            a = abs(n) - 1
            if nums[a] > 0: nums[a] *= -1
        return [i+1 for i in range(len(nums)) if nums[i] > 0]"
find all numbers disappeared in an array,"class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:                        
        result = [i for i in range(0, len(nums)+1)] # build an array (0, 1, 2, 3, ..., n)
        for i in nums: result[i] = 0 # we index this array, setting ""found"" elements to zero
        return [i for i in result if i != 0] # we return results that aren't zero"
delete node in a bst,"class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        
        if not root:
            return None
            
        if root.val > key:
		    # Target node is smaller than currnet node, search left subtree
			
            root.left = self.deleteNode( root.left, key )

        elif root.val < key:
		    # Target node is larger than currnet node, search right subtree
			
            root.right = self.deleteNode( root.right, key )

        else:
            # Current node is target node
			
            if (not root.left) or (not root.right):
                # At least one child is empty
                # Target node is replaced by either non-empty child or None
                root = root.left if root.left else root.right

            else:
                # Both two childs exist
                # Target node is replaced by smallest element of right subtree
                cur = root.right

                while cur.left:
                    cur = cur.left

                root.val = cur.val
                root.right = self.deleteNode( root.right, cur.val )
                    
        return root"
delete node in a bst,"class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        # search for node
        node = root
        parent = left = None
        while node:
            if node.val < key: parent, node, left = node, node.right, False
            elif node.val > key: parent, node, left = node, node.left, True
            else: break # found 
        
        # delete the node 
        if node: # if found 
            if not node.left or not node.right: 
                if parent: 
                    if left: parent.left = node.left or node.right
                    else: parent.right = node.left or node.right
                else: return node.left or node.right
            else: 
                temp = parent = node
                node = node.left 
                if not node.right: parent.left = node.left
                else: 
                    while node.right: parent, node = node, node.right
                    parent.right = node.left
                temp.val = node.val
        return root"
sort characters by frequency,"class Solution:
    def frequencySort(self, s: str) -> str:
        
        ans_str = ''
        # Find unique characters
        characters = set(s)
        
        counts = []
        # Count their frequency
        for i in characters:
            counts.append([i,s.count(i)])
        
		# Sort characters according to their frequency
        counts = sorted(counts, key= lambda x: x[1], reverse = True)
        
		# Generate answer string by multiplying frequency count with the character
        for i,j in counts:
            ans_str += i*j
        
        return ans_str"
sort characters by frequency,"class Solution:
    def frequencySort(self, s: str) -> str:
        ans = ''
        l = sorted(list(set(s)), key=s.count, reverse=True)
        for i in l:
            ans += i * s.count(i)
        return ans"
minimum number of arrows to burst balloons,"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        pts = sorted(points, key=lambda el: el[1])
        
        res, combo = 0, (float(""-inf""), float(""-inf""))
        for start, end in pts:
            if start <= combo[1]: # overlaps?
                combo = (max(combo[0], start), min(combo[1], end))
            else:
                combo = (start, end)
                res += 1
                
        return res"
minimum number of arrows to burst balloons,"class Solution:
    def findMinArrowShots(self, points):
        n = len(points)
        if n<2:
            return n

        #sort by start and end point
        START, END = 0,1
        points.sort(key=lambda i: (i[START],i[END]) )
        prev, cur = points[0], None
        darts = 0

        for i in range(1, n):
            cur = points[i]

            if cur[START] <= prev[END]:
                #overlap, wait for more overlap to throw dart
                prev = [cur[START], min(cur[END],prev[END])]
            else:
                #no overlap, throw dart at previous
                darts += 1
                prev = cur
		
		#pop the last balloon and return
        return darts+1"
minimum moves to equal array elements,"class Solution:
    def minMoves(self, nums: List[int]) -> int:
        return sum(nums) - (len(nums) * min(nums))"
minimum moves to equal array elements,"class Solution:
    def minMoves(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        return sum((nums[i-1]-nums[i])*i for i in range(1, len(nums)))"
4sum ii,"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        
        # hashmap and final result count
        nums12, res = defaultdict(int), 0
        
        # storing all possible combinations of sum
        for i in nums1:
            for j in nums2:
                nums12[i+j] += 1
        
        # iterating the left out two array to find negation of same value
        for k in nums3:
            for l in nums4:
                res += nums12[-(k+l)]
        
        return res"
4sum ii,"class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        return sum(counts[-(c + d)] for counts in [Counter(a + b for a in nums1 for b in nums2)] for c in nums3 for d in nums4)"
assign cookies,"class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()  # O(nlogn)
        s.sort()  # O(nlogn)
        
        child_point = 0
        cookie_point = 0
        counter = 0
        
        # O(n)
        while child_point < len(g) and cookie_point < len(s):
            if g[child_point] <= s[cookie_point]:
                counter += 1
                child_point += 1
                cookie_point += 1
            else:
                cookie_point += 1
            
        return counter"
assign cookies,"class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int: 
        if len(s)==0:
            return 0
        i=0
        j=0
        c=0
        g.sort()
        s.sort()
        while(i!=len(g) and len(s)!=j):
            if g[i]<=s[j]:
                c+=1
                i+=1
                j+=1
            else:
                j+=1
        return c"
132 pattern,"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        if len(nums)<3:
            return False
      
        second_num = -math.inf
        stck = []
        # Try to find nums[i] < second_num < stck[-1]
        for i in range(len(nums) - 1, -1, -1):
            if nums[i] < second_num:
                return True
            # always ensure stack can be popped in increasing order
            while stck and stck[-1] < nums[i]:
				second_num = stck.pop()  # this will ensure  second_num < stck[-1] for next iteration

            stck.append(nums[i])
        return False"
132 pattern,"class Solution(object):
    def find132pattern(self, nums):
        # Base Condition...
        if len(nums) < 3:
            return False
        m = float('-inf')
        # Initialise a empty stack...
        stack = []
        # Run a Loop from last to first index...
        for i in range(len(nums)-1, -1, -1):
            # If m is greater than nums[i], return true...
            if nums[i] < m:
                return True
            # If stack is not empty &amp;  nums[i] is greater than the top element of stack, then pop the element...
            else:
                while stack and stack[-1] < nums[i]:
                    m = stack.pop()
            # Otherwise, append nums[i] into stack...
            stack.append(nums[i])
        # If the condition is not satisfied, return false.
        return False"
circular array loop,"class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        n, visited = len(nums), set()
        for i in range(n):
            if i not in visited:
                local_s = set()
                while True:
                    if i in local_s: return True
                    if i in visited: break          # credit to @crazyhyz, add this condition to avoid revisited
                    visited.add(i)
                    local_s.add(i)
                    prev, i = i, (i + nums[i]) % n
                    if prev == i or (nums[i] > 0) != (nums[prev] > 0): break
        return False"
circular array loop,"class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        for i in range(len(nums)):
            seen=set()
            while True:
                if i in seen:               # if index already exist in set means, array is circular 
                    return True
                seen.add(i)
                prev=i
                i=(i+nums[i])%len(nums)        # index position for next element
                if prev==i or (nums[i]>0)!=(nums[prev]>0):         # checks whether all the elements in circular subset have same sign
                    break       
        return False"
poor pigs,"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));"
poor pigs,"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        return math.ceil(math.log(buckets, minutesToTest/minutesToDie + 1))"
repeated substring pattern,"class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        return s in s[1:] + s[:-1]"
repeated substring pattern,"class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
	# Here we checking that s is present in a new string double of s which after remvoing fast and last element
        return s in s[1:] + s[:-1]"
hamming distance,"class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        def get_bin(num):
            res = []
            while num > 0:
                res.append(num % 2)
                num //= 2
            return ''.join(str(num) for num in res[::-1])
        
        if x < y:
            x, y = y, x
        
        bin_x, bin_y = get_bin(x), get_bin(y)
        res = 0
        s1, s2 = len(bin_x), len(bin_y)
        bin_y = '0' * (s1 - s2) + bin_y
        
        return sum(bin_x[i] != bin_y[i] for i in range(s1))"
hamming distance,"class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x^y).replace(""0b"","""").count('1')"
minimum moves to equal array elements ii,"class Solution:
    def minMoves2(self, nums: List[int]) -> int:
        nums.sort()
        mid = nums[len(nums)//2]
        result = 0
        for i in nums:
            result+=abs(mid-i)
        return result"
minimum moves to equal array elements ii,"class Solution:
    def minMoves2(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        return sum(abs(nums[i] - nums[n//2]) for i in range(n))"
island perimeter,"class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int: 
    	M, N, p = len(grid), len(grid[0]), 0
    	for m in range(M):
    		for n in range(N):
    			if grid[m][n] == 1:
    				if m == 0   or grid[m-1][n] == 0: p += 1
    				if n == 0   or grid[m][n-1] == 0: p += 1
    				if n == N-1 or grid[m][n+1] == 0: p += 1
    				if m == M-1 or grid[m+1][n] == 0: p += 1
    	return p
		
			
- Junaid Mansuri
- Chicago, IL"
island perimeter,"class Solution:
	def islandPerimeter(self, grid: List[List[int]]) -> int:
		row, col, queue = len(grid), len(grid[0]), deque()
		for x in range(row):
			for y in range(col):
				if grid[x][y] == 1:
					queue.append((x,y))
					return self.bfs(grid, row, col, queue)

	def bfs(self,grid, row, col, queue):
		visited = set()
		perimeter = 0
		while queue:
			x,y = queue.popleft()
			if (x,y) in visited: continue
			visited.add((x,y))
			for nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:
				if 0<=nx<row and 0<=ny<col:
					if grid[nx][ny] == 0:
						perimeter+=1
					if grid[nx][ny] == 1:
						queue.append((nx,ny))
				else: # if out of grid
					perimeter+=1

		return perimeter"
can i win,"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        if desiredTotal == 0: return True # edge case 1
        if maxChoosableInteger * (maxChoosableInteger+1)//2 < desiredTotal: return False # edge case 2
        
        @lru_cache(None)
        def fn(mask, total): 
            """"""Return True if there is a winning strategy given mask &amp; total.""""""
            if total <= 0: return False # already lost 
            for i in range(maxChoosableInteger): 
                if mask &amp; (1 << i): # integer i+1 is not used yet 
                    if not fn(mask ^ (1 << i), total - (i + 1)): return True 
            return False 
        
        return fn(int(""1""*maxChoosableInteger, 2), desiredTotal)"
can i win,"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        return desiredTotal == 0 or desiredTotal % (maxChoosableInteger + 1)"
count the repetitions,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        cnt = idx = 0 
        count = []
        index = []
        for i in range(n1): 
            for ch in s1: 
                if ch == s2[idx]: 
                    idx += 1
                    if idx == len(s2): 
                        cnt += 1
                        idx = 0 
            count.append(cnt)
            index.append(idx)
            for ii in range(i): 
                if index[ii] == idx: 
                    prev = count[ii]
                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))
                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]
                    return (prev + repeat + post) // n2
        return count[-1]//n2"
unique substrings in wraparound string,"class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        consecutive = 1
        
        # stores the maximum length of a substring ending at a character 
        maxSubstr = defaultdict(int)
        maxSubstr[p[0]] = 1
        
        ans = 0
        for x in range(1, len(p)):
            if ord(p[x]) - ord(p[x - 1]) == 1 or p[x] == 'a' and p[x - 1] == 'z':
                consecutive += 1
            else:
                consecutive = 1
            maxSubstr[p[x]] = max(maxSubstr[p[x]], consecutive)
        
        return sum(maxSubstr.values())"
unique substrings in wraparound string,"class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        ans = cnt = 0
        seen = {} # longest string ending at char 
        for i in range(len(p)): 
            if 0 < i and (ord(p[i]) - ord(p[i-1])) % 26 != 1: cnt = 0 # reset counter 
            cnt += 1
            if cnt > seen.get(p[i], 0): # duplicate of seen.get(p[i], 0) 
                ans += cnt - seen.get(p[i], 0) # non-duplicate 
                seen[p[i]] = cnt
        return ans"
validate ip address,"class Solution:
	def validIPAddress(self, query: str) -> str:
		dot = query.count(""."")
		colon = query.count("":"")
		if colon == 0 and dot == 3:
			arr = [i for i in query.split(""."")]
			print(arr)
			flag = True
			for i in arr:
				if i.isdigit() and int(i) <= 255:
					x = int(i)
					if str(x) != i:
						flag = False
						break
				else:
					flag = False
					break
			if flag:
				return ""IPv4""
			else:
				return ""Neither""
		elif colon == 7 and dot == 0:
			flag = True
			arr = [i for i in query.split("":"")]
			for parts in arr:
				l = 0
				for i in parts:
					l += 1
					if i not in ""0123456789abcdefABCDEF"":
						flag = False
						break
				if l > 4 or l < 1:flag = False;break
			if flag:
				return ""IPv6""
			else:
				return ""Neither""

		else:
			return ""Neither"""
validate ip address,"class Solution:
    def validIPAddress(self, queryIP: str) -> str:
        letterHashSet = ('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','A','B','C','D','E','F')
        
        ipv4 = queryIP.split('.')
        ipv6 = queryIP.split(':')
        
        if len(ipv4) == 1:
            if len(ipv6) != 8:
                return ""Neither""
            else:
                for i in ipv6:
                    if len(i) > 4 or len(i) == 0:
                        return ""Neither""
                    for char in i:
                        if char not in letterHashSet:
                            return ""Neither""
                return ""IPv6""
        else:
            if len(ipv4) != 4:
                return ""Neither""
            else:
                for i in ipv4:
                    if (len(i) > 1 and i[0] == '0') or not i.isdigit() or int(i) < 0 or int(i) > 255:
                        return ""Neither""
                return ""IPv4"""
concatenated words,"class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        ddic = lambda: defaultdict(ddic)
        trie = ddic()
        
        for word in words:
            cur = trie
            for char in word:
                cur = cur[char]

            cur['end'] = True
        
        def isConcat(word, start):
            cur = trie
            for i in range(start, len(word)):
                char = word[i]
                if char not in cur:
                    return False
                cur = cur[char]

                if 'end' in cur:
                    if i + 1 == len(word):
                        # tricky part that helps us distinguish simple word from concat word
                        return start != 0
                    
                    if isConcat(word, i + 1):
                        return True

            return False
            
        return [word for word in words if isConcat(word, 0)]"
concatenated words,"class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        s = set(words)
        
        memo = {}
        def isConcatenatedWord(w):
            if w in memo: return memo[w]
            
            for i in range(1, len(w)):
                if w[:i] not in s: continue
                
                r = w[i:]
                if r in s or isConcatenatedWord(r):
                    memo[w] = True
                    return True
                
            memo[w] = False
            return False
        
        return filter(isConcatenatedWord, words)"
matchsticks to square,"class Solution:
    def makesquare(self, arr: List[int]) -> bool:
		# no way to make the square if total length not divisble by 4
        if sum(arr) % 4:
            return False
        
		# target side length
        side = sum(arr) // 4
        
        @lru_cache(None)
        def dp(k, mask, s):
			# finish all four sides
            if k == 4:
                return True
			# move on to next side if current one finished
            if not s:
                return dp(k+1, mask, side)
            
            for i in range(len(arr)):
				# if current matchstick used or longer than remaining side length to fill then skip
                if mask &amp; (1 << i) or s < arr[i]: continue
                if dp(k, mask ^ (1 << i), s - arr[i]):
                    return True
            return False
        
        return dp(0, 0, side)"
matchsticks to square,"class Solution:
    def makesquare(self, matchsticks: List[int]) -> bool:
        # There should be at least 4 matchsticks.
        if len(matchsticks) < 4:
            return False
        
        # Sum of matchstick lengths should be divisble by four.
        side_length, remainder = divmod(sum(matchsticks), 4)
        if remainder != 0:
            return False
        
        # There shouldn't be any single matchstick with length greater than side_length.
        if max(matchsticks) > side_length:
            return False
        
        # Check if partitioning is possible.
        return self.can_partition(matchsticks, 4, side_length)
    
    def can_partition(self, nums, k, target):
        buckets = [0] * k
        nums.sort(reverse=True)  # pruning
        
        def backtrack(idx):
            # If all elements have been used, check if all are equal.
            if idx == len(nums):
                return len(set(buckets)) == 1
            
            # Try placing numbers in each bucket.
            for b in range(k):
                buckets[b] += nums[idx]
                if buckets[b] <= target and backtrack(idx + 1):
                    return True
                buckets[b] -= nums[idx]
                
                # Pruning: Buckets are filled from left to right. If any bucket remains empty,
                # then all buckets to the right of it will also be empty.
                if buckets[b] == 0:
                    break
            
            return False
        
        return backtrack(0)"
ones and zeroes,"class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        counter=[[s.count(""0""), s.count(""1"")] for s in strs]
        
        @cache
        def dp(i,j,idx):
            if i<0 or j<0:
                return -math.inf
            
            if idx==len(strs):
                return 0
            
            return max(dp(i,j,idx+1), 1 + dp(i-counter[idx][0], j-counter[idx][1], idx+1))
        return dp(m,n,0)"
ones and zeroes,"class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:            
        dp = [[0] * (n+1) for _ in range(m+1)]
        counter=[[s.count(""0""), s.count(""1"")] for s in strs]
        
        for zeroes, ones in counter:
            for i in range(m, zeroes-1, -1):
                for j in range(n, ones-1, -1):                   
                    dp[i][j] = max(dp[i][j], 1+dp[i-zeroes][j-ones])
        
        return dp[-1][-1]"
heaters,"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()

        if len(heaters) == 1:
            return max(abs(houses[0] - heaters[0]), abs(houses[-1] - heaters[0]))

        m_value = -1
        f, s, ind_heat = heaters[0], heaters[1], 2
        for i in range(len(houses)):
            while houses[i] > s and ind_heat < len(heaters):
                f, s = s, heaters[ind_heat]
                ind_heat += 1
            m_value = max(m_value, min(abs(houses[i] - f), abs(houses[i] - s)))
        return m_value"
heaters,"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        res = 0
        heater = 0
        
        for h in houses:
            while heater + 1 < len(heaters) and heaters[heater + 1] == heaters[heater]:                  # Avoid duplicates
                heater += 1
            while heater + 1 < len(heaters) and abs(heaters[heater + 1] - h) < abs(heaters[heater] - h): # If using next heater is more efficient
                heater += 1                                                                              # Then use next heater
            
            res = max(res, abs(heaters[heater] - h))        # Update its range to house
        
        return res"
number complement,"class Solution:
    def findComplement(self, num: int) -> int:
        
        bit_mask = 2**num.bit_length() -1 
        
        return ( num ^ bit_mask )"
number complement,"class Solution:
    def findComplement(self, num: int) -> int:
        res, n = 0, 0
        while num:
            if not num &amp; 1:
                res += 2**n
                
            num >>= 1
            n += 1
        
        return res"
total hamming distance,"class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            zero = one = 0
            mask = 1 << i
            for num in nums:
                if mask &amp; num: one += 1
                else: zero += 1    
            ans += one * zero        
        return ans"
total hamming distance,"class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        freq = [0]*32 # count of ""1"" (32-bit ""overkill"")
        for x in nums: 
            x = bin(x)[2:].zfill(32) # 32-bit binary  
            for i in range(32): freq[i] += x[i] == ""1""  # count of 1 
        return sum(freq[i] * (len(nums) - freq[i]) for i in range(32))"
generate random point in a circle,"class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.x = x_center
        self.y = y_center
        self.radius = radius

    def randPoint(self) -> List[float]:
        first = random.uniform(-self.radius, self.radius)
        secondmax = (self.radius ** 2 - first ** 2) ** 0.5
        second = random.uniform(-secondmax, secondmax)
        return [self.x + first, self.y + second]"
generate random point in a circle,"class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.x = x_center
        self.y = y_center
        self.r = radius

    def randPoint(self) -> List[float]:
        r = sqrt(random.random()) * self.r
        angle = random.uniform(0, 2*pi)
        return [self.x + r * math.cos(angle), self.y + r *math.sin(angle)]"
largest palindrome product,"class Solution:
    def largestPalindrome(self, n: int) -> int:
        
        # just to forget about 1-digit case
        if n == 1:
            return 9
        
        # minimal number with n digits (for ex. for n = 4, min_num = 1000)
        min_num = 10 ** (n - 1)
        
        # maximal number with n digits (for ex. 9999)
        max_num = 10 ** n - 1       
        
        max_pal = 0
        
        # step is equal to 2, because we have to get a number, the 1st digit of which is 9, so we have to   
		# iterate only over odd numbers
        for i in range(max_num, min_num - 1, -2): 
            
            # since we are looking for the maximum palindrome number, it makes no sense to iterate over the 
            # product less than the max_pal obtained from the last iteration
            if i * i < max_pal:
                break
                
            for j in range(max_num, i - 1, -2):
                product = i * j
                
                # since a palindrome with an even number of digits must be mod 11 == 0 and we have no reason to 
                # check the product which less or equal than max_pal
                if product % 11 != 0 and product >= max_pal:
                    continue
                    
                # check if product is a palindrome then update the max_pal
                if str(product) == str(product)[::-1]:
                    max_pal = product

        return max_pal % 1337"
largest palindrome product,"class Solution:
    def largestPalindrome(self, n: int) -> int:
        if n == 1:
            return 9
        maxi = 10 ** n   # store the value of 10 
        for z in range(2, maxi): # since both x, y > 0 and z = x + y; which implies that z has a minimum value of 2
            left = maxi - z
            right = int(str(left)[::-1]) # reverese number
            
            discriminant = z ** 2 - 4 * right # b - 4ac
            if discriminant < 0: # no root
                continue
            else: # there exists at least one real solution; so calculate the roots
                root_1 = (z + discriminant ** 0.5) / 2
                root_2 = (z - discriminant ** 0.5) / 2
                if root_1.is_integer() or root_2.is_integer():
                    return (maxi * left + right) % 1337"
sliding window median,"class Solution:
    # TC - O((n - k)*log(k))
    # SC - O(k)
	# 121 ms, faster than 96.23%

    def find_median(self, max_heap, min_heap, heap_size):
        if heap_size % 2 == 1:
            return -max_heap[0]
        else:
            return (-max_heap[0] + min_heap[0]) / 2

    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        max_heap = []
        min_heap = []
        heap_dict = defaultdict(int)
        result = []
        
        for i in range(k):
            heappush(max_heap, -nums[i])
            heappush(min_heap, -heappop(max_heap))
            if len(min_heap) > len(max_heap):
                heappush(max_heap, -heappop(min_heap))
        
        median = self.find_median(max_heap, min_heap, k)
        result.append(median)
        
        for i in range(k, len(nums)):
            prev_num = nums[i - k]
            heap_dict[prev_num] += 1

            balance = -1 if prev_num <= median else 1
            
            if nums[i] <= median:
                balance += 1
                heappush(max_heap, -nums[i])
            else:
                balance -= 1
                heappush(min_heap, nums[i])
            
            if balance < 0:
                heappush(max_heap, -heappop(min_heap))
            elif balance > 0:
                heappush(min_heap, -heappop(max_heap))

            while max_heap and heap_dict[-max_heap[0]] > 0:
                heap_dict[-max_heap[0]] -= 1
                heappop(max_heap)
            
            while min_heap and heap_dict[min_heap[0]] > 0:
                heap_dict[min_heap[0]] -= 1
                heappop(min_heap)

            median = self.find_median(max_heap, min_heap, k)
            result.append(median)
        
        return result"
sliding window median,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        res=[]
        i=0
        j=k
        while j<=len(nums):
            med=self.median(nums[i:j],k)
            res.append(med)
            i+=1;j+=1
        return res
    def median(self,num,k):
        num.sort()
        
        if len(num)%2==1:
            return num[k//2]
        else:
            val=num[k//2]+num[(k//2)-1]
            val/=2
            return val"
magical string,"class Solution:
    def magicalString(self, n: int) -> int:
        arr, i = [1,2,2], 2
   
        while len(arr) < n:
            arr.extend([arr[-1]^3]*arr[i])
            i += 1
    
        return arr[:n].count(1)"
magical string,"class Solution:
    def magicalString(self, n: int) -> int:
        ref = ""122112""
        actual = """"
        start = 0
        one = True
        
        while(len(ref) < n):
            for i in range(start, len(ref)):
                if(one):
                    actual += int(ref[i]) * ""1""
                    one = False
                else:
                    actual += int(ref[i]) * ""2""
                    one = True
                    
            if(len(actual) > len(ref)):
                start = len(ref)
                ref = actual
        
        return ref[:n].count(""1"")"
license key formatting,"class Solution:
    def licenseKeyFormatting(self, S: str, K: int) -> str:
        
        # Eliminate all dashes
        S = S.replace('-', '')
        
        head = len(S) % K
        
        grouping = []
        
        # Special handle for first group
        if head:
            grouping.append( S[:head] )
        
        # General case:
        for index in range(head, len(S), K ):
            grouping.append( S[ index : index+K ] )
        
        
        # Link each group togetger and separated by dash '-'
        return '-'.join( grouping ).upper()"
license key formatting,"class Solution:
    def licenseKeyFormatting(self, s: str, k: int) -> str:
        s = (s.upper()).replace(""-"","""")[::-1]
        ans = str()
        for i in range(0,len(s),k):
            ans += s[i:i+k]+""-""
        return ans[::-1][1:]"
smallest good base,"class Solution:
    def smallestGoodBase(self, n: str) -> str:
        import math
        n = int(n)
        max_m = math.floor(math.log(n, 2))
        ans = 0
        for m in range(max_m, 0, -1):
            k = int(n ** (1 / m))
            if (k ** (m + 1)  - 1) // (k - 1) == n:
                return str(k)
        return str(n - 1)"
smallest good base,"class Solution:
    def smallestGoodBase(self, n: str) -> str:
        n = int(n)
        for p in range(int(log2(n)), 1, -1): 
            k = int(n**(1/p))
            if (k**(p+1)-1)//(k-1) == n: return str(k)
        return str(n-1)"
max consecutive ones,"class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        c1,c2=0,0
        for i in nums:
            if i==1:
                c1+=1
            elif i==0:
                c1=0
            if c1>c2:
                c2=c1
        return c2"
max consecutive ones,"class Solution:
#     O(n) || O(1)
# Runtime: 359ms 91.92% ; Memory: 14.3mb 78.65%
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        count = 0
        maxCount = 0

        for idx, num in enumerate(nums):
            if num == 1:
                count += 1
            if num == 0 or idx == len(nums) - 1:
                maxCount = max(maxCount, count)
                count = 0

        return maxCount"
predict the winner,"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:
        def helper(i, j):
            if i == j:
                return nums[i]
            
            if (i, j) in memo:
                return memo[(i, j)]
            
            score = max(nums[j] - helper(i, j-1), nums[i] - helper(i+1, j))
            memo[(i, j)] = score
            
            return score
            
        memo = {}            
        return helper(0, len(nums)-1) >= 0"
predict the winner,"class Solution:
     def PredictTheWinner(self, nums: List[int]) -> bool:
         dp[i][j] the person's effective score when pick, facing nums[i..j]
         dp = [[0] * len(nums) for _ in range(len(nums))]
         for s in range(len(nums)):
             for i in range(len(nums)-s):
                 j = i + s
                 if i == j:
                     dp[i][i] = nums[i]
                 else:
                     dp[i][j] = max(nums[j] - dp[i][j-1], nums[i] - dp[i+1][j])
         return dp[0][-1] >= 0"
zuma game,"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        
        # start from i and remove continues ball
        def remove_same(s, i):
            if i < 0:
                return s
            
            left = right = i
            while left > 0 and s[left-1] == s[i]:
                left -= 1
            while right+1 < len(s) and s[right+1] == s[i]:
                right += 1
            
            length = right - left + 1
            if length >= 3:
                new_s = s[:left] + s[right+1:]
                return remove_same(new_s, left-1)
            else:
                return s



        hand = """".join(sorted(hand))

        # board, hand and step
        q = collections.deque([(board, hand, 0)])
        visited = set([(board, hand)])

        while q:
            curr_board, curr_hand, step = q.popleft()
            for i in range(len(curr_board)+1):
                for j in range(len(curr_hand)):
                    # skip the continue balls in hand
                    if j > 0 and curr_hand[j] == curr_hand[j-1]:
                        continue
                    
                    # only insert at the begin of continue balls in board
                    if i > 0 and curr_board[i-1] == curr_hand[j]: # left side same color
                        continue
                    
                    pick = False
                    # 1. same color with right
                    # 2. left and right are same but pick is different
                    if i < len(curr_board) and curr_board[i] == curr_hand[j]:
                        pick = True
                    if 0<i<len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:
                        pick = True
                    
                    if pick:
                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)
                        new_hand = curr_hand[:j] + curr_hand[j+1:]
                        if not new_board:
                            return step + 1
                        if (new_board, new_hand) not in visited:
                            q.append((new_board, new_hand, step+1))
                            visited.add((new_board, new_hand))

        return -1"
zuma game,"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        hand = ''.join(sorted(hand))
        
        @cache
        def fn(board, hand):
            """"""Return min number of balls to insert.""""""
            if not board: return 0
            if not hand: return inf 
            ans = inf 
            for i, ch in enumerate(hand): 
                if i == 0 or hand[i-1] != ch: # pruning 1
                    hh = hand[:i] + hand[i+1:]
                    for j in range(0, len(board)): 
                        if ch == board[j] or j and board[j-1] == board[j]: # pruning 2
                            bb, nn = """", board[:j] + ch + board[j:]
                            while bb != nn:
                                bb, nn = nn, """"
                                for k, grp in groupby(bb): 
                                    x = len(list(grp))
                                    if x < 3: nn += k*x
                            ans = min(ans, 1 + fn(bb, hh))
            return ans 
        
        return (lambda x: x if x < inf else -1)(fn(board, hand))"
increasing subsequences,"class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        def dfs(i, num, curr):
            if len(curr)>=2:
                ans.add(curr[:])
            if i>=len(nums):
                return
            for j in range(i, len(nums)):
                if nums[j]>=num:
                    dfs(j+1, nums[j], curr+(nums[j],))
                        
        ans = set()
        dfs(0, -float(""inf""), ())
        return ans"
increasing subsequences,"class Solution:
	def findSubsequences(self, nums: List[int]) -> List[List[int]]:

		def combinations(idx, curArr, nums, res):
			if len(curArr) >= 2:
				res.add(curArr)

			for i in range(idx, len(nums)):
				if not curArr or nums[i] >= curArr[-1]:
					combinations(i+1, curArr+(nums[i],), nums, res)

		res = set()
		combinations(0, (), nums, res)
		return res"
construct the rectangle,"class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        
        for i in range(int(area**0.5),0,-1):
            if area % i == 0: return [area//i,i]"
construct the rectangle,"class Solution:
    def constructRectangle(self, area: int) -> List[int]:        
        for i in range(int(area**0.5), 0, -1):
            if area%i == 0: return [area//i,i]"
reverse pairs,"class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        ans = 0
        seen = []
        for x in nums: 
            k = bisect_right(seen, 2*x)
            ans += len(seen) - k
            insort(seen, x)
        return ans"
reverse pairs,"class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        
        def fn(nums, aux, lo, hi): 
            """"""Return number of reverse pairs in nums[lo:hi].""""""
            if lo + 1 == hi: return 0 
            mid = lo + hi >> 1
            left = fn(aux, nums, lo, mid)
            right = fn(aux, nums, mid, hi)
            split = 0 
            i, j = lo, mid
            for _ in range(lo, hi): 
                if i == mid or j < hi and aux[i] > 2*aux[j]: 
                    split += mid - i 
                    j += 1
                else: i += 1
            i, j = lo, mid
            for k in range(lo, hi): 
                if j == hi or i < mid and aux[i] < aux[j]: 
                    nums[k] = aux[i]
                    i += 1
                else: 
                    nums[k] = aux[j]
                    j += 1
            return left + split + right 
                
        return fn(nums, nums.copy(), 0, len(nums))"
target sum,"class Solution:    
    def findTargetSumWays(self, nums: List[int], target: int) -> int:     
        dic = defaultdict(int)
        
        def dfs(index=0, total=0):          
            key = (index, total)
            
            if key not in dic:
                if index == len(nums):                    
                    return 1 if total == target else 0
                else:
                    dic[key] = dfs(index+1, total + nums[index]) + dfs(index+1, total - nums[index])                    
                        
            return dic[key]                                                             
                
        return dfs()"
target sum,"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        sumOfNums = sum(nums)
        n = len(nums)
        
        if target > sumOfNums:
            return 0

        if (target + sumOfNums) % 2 != 0:
            return 0
        
        s1 = (sumOfNums + target) // 2
        
        # DP Table
        t = [[0] * (s1 + 1) for i in range(n + 1)]
		
        t[0][0] = 1
        
        for i in range(1, n + 1):
            for j in range(s1 + 1):
                
                if nums[i - 1] <= j:
                    t[i][j] = t[i - 1][j] + t[i - 1][j - nums[i - 1]]
                
                else:
                    t[i][j] = t[i-1][j]
            
        return t[n][s1]"
teemo attacking,"class Solution(object):
    def findPoisonedDuration(self, timeSeries, duration):
        repeat = 0
        for i in range(len(timeSeries)-1):
            diff = timeSeries[i+1] - timeSeries[i]
            if diff < duration:
                repeat += duration - diff
        return len(timeSeries)*duration - repeat"
teemo attacking,"class Solution:
def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:
    
    res = 0
    for i in range(len(timeSeries)-1):
        s = timeSeries[i]+duration-1
        if s<timeSeries[i+1]:
            res+=s-timeSeries[i]+1
        else:
            res+=timeSeries[i+1]-timeSeries[i]
            
    res+=duration
    return res"
next greater element i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        
        
        # a stack with monotonic decreasing
        monotonic_stack = []
        
        # dictionary:
        # key: number
        # value: next greater number of key
        dict_of_greater_number = {}

        # ----------------------------------------------
        
        # launch linear scan to build dict_of_greater_number
        for cur_number in nums2:
            
            # maintain a monotonic decreasing stack
            while monotonic_stack and cur_number > monotonic_stack[-1]:
                
                pop_out_number = monotonic_stack.pop()
                
                # next greater number of pop_out_number is cur_number
                dict_of_greater_number[pop_out_number] = cur_number
            
            monotonic_stack.append(cur_number)
        # ----------------------------------------------
        
        # solution output
        next_greater_element = []
        
        # get next greater element by dictionary
        for x in nums1:
            
            if x in dict_of_greater_number:
                next_greater_element.append( dict_of_greater_number[x] )
                
            else:
                next_greater_element.append(-1)
                
        return next_greater_element"
next greater element i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack = []
        nextGreaterDic = {ch:-1 for ch in nums2}
        
        for i in range(len(nums2)):
            while stack and nums2[stack[-1]] < nums2[i]:
                nextGreaterDic[nums2[stack.pop()]] = nums2[i]
            stack.append(i)
        
        for i, ch in enumerate(nums1):
            nums1[i] = nextGreaterDic[ch]
        
        return nums1"
random point in non overlapping rectangles,"class Solution:
    def __init__(self, rects: List[List[int]]):
        self.rects = rects
        self.search_space = []

        for i, rect in enumerate(rects):
            a, b, c, d = rect
            self.search_space.append((d - b + 1) * (c - a + 1))
            if i != 0:
                self.search_space[i] += self.search_space[i - 1]
      

    def pick(self) -> List[int]:
        randval = random.randint(0, self.search_space[-1] - 1)

        low = 0
        high = len(self.search_space) - 1

        while low < high:
            midpt = low + (high - low) // 2

            if self.search_space[midpt] <= randval:
                low = midpt + 1
            else:
                high = midpt


        rect = self.rects[low]
        rect_range = randval

        if low > 0:
            rect_range -= self.search_space[low - 1] 


        a, b, c, d = rect

        return [(rect_range % (c - a + 1)) + a, (rect_range // (c - a + 1)) + b]"
random point in non overlapping rectangles,"class Solution:

    def __init__(self, rects: List[List[int]]):
        self.rects = rects  
        self.weights = []                                   # self.weights record the ""points"" one rectangle have respectively
        
        for i in range(len(rects)):
            num_points = (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1)
            self.weights.append(num_points)

    def pick(self) -> List[int]:
        rect = random.choices(self.rects, self.weights)[0]  # Random choose rectangle weighted by its points.
        x = random.randint(rect[0], rect[2])                # rect[0], rect[2] are left and right bound respectively
        y = random.randint(rect[1], rect[3])                # rect[1], rect[3] are bottom and top bound respectively
        
        return [x, y]"
diagonal traverse,"class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        if not matrix:
            return res

        # group values in matrix by the sum of their indices in a map
        map = {}
        for i in range(len(matrix) + len(matrix[0]) - 1):
            map[i] = []

        # populate the map
        for i, row in enumerate(matrix):
            for j, val in enumerate(row):
                map[i + j].append(val)

        # iterate through map and reverse values where key is divisible by two
        for k, v in map.items():
            if k % 2 == 0:
                map[k] = v[::-1]
        
        # populate output
        for v in map.values():
            for val in v:
                res.append(val)
                
        return res"
diagonal traverse,"class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        # Making a dictionary of keys = (row + col) as in a Diagonal treversal line (index of row + index of col) = constant. And values of Dictionary are elements of mat
        myDict = {}
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                if (i+j) not in myDict:
                    myDict[i+j] = [mat[i][j]]
                else:
                    myDict[i+j].append(mat[i][j])
                    
        #print(myDict)
        
        ans = []
        # adding values of myDict Diagonally in zigzag manner
        zigzag = False
        for i in myDict:
            if zigzag == True:
                ans += myDict[i]
                zigzag = False
            else:
                ans += myDict[i][::-1]
                zigzag = True
    
        return ans"
keyboard row,"class Solution:
    def findWords(self, wds: List[str]) -> List[str]:
        st = {'q': 1, 'w': 1, 'e': 1, 'r': 1, 't': 1, 'y': 1, 'u': 1, 'i': 1, 'o': 1, 'p': 1, 'a': 2, 's': 2, 'd': 2, 'f': 2, 'g': 2, 'h': 2, 'j': 2, 'k': 2, 'l': 2, 'z': 3, 'x': 3, 'c': 3, 'v': 3, 'b': 3, 'n': 3, 'm': 3}

        ret = []

        for wd in wds:
            val = 0
            for i in range(len(wd)):
                if i == 0:
                    val = st.get(wd[i].lower())
                else:
                    if val != st.get(wd[i].lower()):
                        val = -1
                        break
            if val != -1:
                ret.append(wd)
        return ret"
keyboard row,"class Solution:
    def findWords(self, words):
        letters_a, letters_b, letters_c = set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')
        row_words = []
        for word in words:
            unique_word = set(word.lower())
            if unique_word <= letters_a or unique_word <= letters_b or unique_word <= letters_c:
                row_words.append(word)
        return row_words"
find mode in binary search tree,"class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        
        def traverse(root: TreeNode) -> None:
            
            if not root:
                return
            
            nonlocal maxcount, count, prevval, modes
            
            traverse(root.left)
            
            if root.val == prevval:
                count += 1
            else:                
                count = 1
                
            if count > maxcount:
                maxcount = count
                modes = [root.val]
            elif count == maxcount:
                modes.append(root.val)
                
            prevval = root.val
            traverse(root.right)
                
                
        modes = []
        maxcount = 0
        count = 0
        prevval = root.val
        traverse(root)
        
        return modes"
find mode in binary search tree,"class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if root.val == 0: return [0]
        nums, stack = {}, []
        
        while True:
            while root:
                if root.val in nums.keys(): nums[root.val] += 1
                else: nums[root.val] = 1
                    
                stack.append(root)
                root = root.left
            
            if not stack: break 
            root = stack.pop().right
        
        maxValue = max(nums.values())
        
        return [k for k, v in nums.items() if maxValue == v]"
ipo,"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        capital, profits = zip(*sorted(zip(capital, profits)))
        i = 0 
        pq = []
        for _ in range(k): 
            while i < len(capital) and capital[i] <= w: 
                heappush(pq, -profits[i])
                i += 1
            if pq: w -= heappop(pq)
        return w"
ipo,"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        max_profit = []
        min_capital = []
        
        for a, b in zip(capital, profits):
            if a <= w:
                heappush(max_profit, -b)
            else:
                heappush(min_capital, (a, b))

        for i in range(k):
            if max_profit:
                w += -heappop(max_profit)

                while min_capital and min_capital[0][0] <= w:
                    dontcare, value = heappop(min_capital)
                    heappush(max_profit, -value)
            else:
                break
        return w"
next greater element ii,"class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack, res = [], [-1] * len(nums) # taking an empty stack for storing index, a list with the lenght same as of nums so that we wont add unnecessary elements.
        # [-1] * len(nums) = this will produce a list with len of nums and all elems will be -1.
        for i in list(range(len(nums))) * 2: # see explanation below.
            while stack and (nums[stack[-1]] < nums[i]): # stack is not empty and nums previous elem is less then current, i.e 1<2. 
                res[stack.pop()] = nums[i] # then we`ll pop the index in stack and in the res on the same index will add the current num. 
            stack.append(i) # if stack is empty then we`ll add the index of num in it for comparision to the next element in the provided list. 
        return res # returing the next greater number for every element in nums."
next greater element ii,"class Solution:
#     O(n) || O(n)
# Runtime: 323ms 48.44% Memory: 15.7mb 65.00%
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        result = [-1] * len(nums)

        stack = list()

        for i in range(2*len(nums)):

            circularIdx = i % len(nums)

            while len(stack) > 0 and nums[stack[len(stack)-1]] < nums[circularIdx]:
                top = stack.pop()
                result[top] = nums[circularIdx]

            stack.append(circularIdx)

        return result"
base 7,"class Solution:
    def convertToBase7(self, num: int) -> str:
        if not num:
            return ""0""
        l=[]
        x=num
        if num<0:
            num=-num
        while num>0:
            r=num%7
            l.append(str(r))
            num//=7
        return """".join(l[::-1]) if x>=0 else ""-""+ """".join(l[::-1])"
base 7,"class Solution:
    def convertToBase7(self, num: int) -> str:
        answer = []
        sign = num

        if not num:
            return ""0""
        elif num < 0:
            num *= -1

        while num:
            a = str(num % 7)
            answer.insert(0, a)
            num = num // 7

        if sign < 0:
            return ""-"" + """".join(answer)
        else:
            return """".join(answer)"
relative ranks,"class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        rankings = []
        for i, val in enumerate(score):
            heappush(rankings, (-val, i))
        ans = [''] * len(score)
        r = 1
        rank = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""]
        while len(rankings) != 0:
            _, i = heappop(rankings)
            if r <= 3:
                ans[i] = rank[r-1]
            else:
                ans[i] = f'{r}'
            r += 1
        return ans"
relative ranks,"class Solution:
    def findRelativeRanks(self, nums: List[int]) -> List[str]:
        if len(nums)==1:
            return [""Gold Medal""]
        elif len(nums)==2:
            if nums[0]>nums[1]:
                nums[0],nums[1]=""Gold Medal"",""Silver Medal""
            else:
                nums[1],nums[0]=""Gold Medal"",""Silver Medal""
            return nums
        l=sorted(nums)
        fmax,smax,tmax=l[-1],l[-2],l[-3]
        d={}
        for i,j in enumerate(l):
            d[j]=i
        for i in range(len(nums)):
            if nums[i]==fmax:
                nums[i]=""Gold Medal""
            elif nums[i]==smax:
                nums[i]=""Silver Medal""
            elif nums[i]==tmax:
                nums[i]=""Bronze Medal""
            else:
                nums[i]=str(len(nums)-d[nums[i]])
        return nums"
perfect number,"class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num == 1:
            return False
        res = 1
        for i in range(2,int(num**0.5)+1):
            if num%i == 0:
                res += i + num//i
        return res == num"
perfect number,"class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        l=[]
        for i in range(1,int(num**0.5)+1):
            if num%i==0:
                l.extend([i,num//i])
        return sum(set(l))-num==num"
most frequent subtree sum,"class Solution:
    def findFrequentTreeSum(self, root: TreeNode) -> List[int]:
        
        counts = collections.Counter()
        
        def dfs(node):
            if not node: return 0            
            result = node.val + dfs(node.left) + dfs(node.right)
            counts[result] += 1        
            return result
        
        dfs(root)       
        
        # Try to return the most frequent elements
        # Return [] if we run into index errors
        try:
            freq = counts.most_common(1)[0][1]
            return [x[0] for x in counts.items() if x[1] == freq]
        except:
            return []"
most frequent subtree sum,"class Solution:
    def findFrequentTreeSum(self, root: TreeNode) -> List[int]:
        
        def fn(node):
            """"""Populate frequency table.""""""
            if not node: return 0 
            ans = node.val + fn(node.left) + fn(node.right)
            freq[ans] = 1 + freq.get(ans, 0)
            return ans 
        
        freq = {}
        fn(root)
        most = max(freq.values(), default=0)
        return [k for k, v in freq.items() if v == most]"
fibonacci number,"class Solution:
    def fib(self, N: int) -> int:
    	a, b = 0, 1
    	for i in range(N): a, b = b, a + b
    	return a
		
		
- Python 3
- Junaid Mansuri"
fibonacci number,"class Solution:
	def fib(self, n: int) -> int:

		dp = [0,1]

		for i in range(2,n+1):

			dp.append(dp[i-1] + dp[i-2])

		return dp[n]"
find bottom left tree value,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        q=[[root]]
        nodes=[]
        while q:
            nodes = q.pop(0)
            t=[]
            for n in nodes:
                if n.left:
                    t.append(n.left)
                if n.right:
                    t.append(n.right)
            if t:
                q.append(t)
        return nodes[0].val
# Please upvote if you understand the solution"
find bottom left tree value,"class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        queue = [root]
        last = 0
        
        while len(queue):
            node = queue.pop(0)
            last = node.val
            
            if node.right:
                queue.append(node.right)
            if node.left:
                queue.append(node.left)
                
                
        return last"
freedom trail,"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        locs = {}
        for i, ch in enumerate(ring): locs.setdefault(ch, []).append(i)
            
        @cache 
        def fn(i, j): 
            """"""Return turns to finish key[j:] startin from ith position on ring.""""""
            if j == len(key): return 0 
            loc = locs[key[j]]
            k = bisect_left(loc, i) % len(loc)
            ans = min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1)
            k = (k-1) % len(loc)
            ans = min(ans, min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1))
            return ans 
        
        return fn(0, 0) + len(key)"
freedom trail,"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        char_pos = defaultdict(set)
        for i, c in enumerate(ring):
            char_pos[c].add(i)
        
        def minStep(fromm, to):
            if fromm == to:
                return 0
            minSteps = abs(fromm - to)
            minSteps = min(minSteps, abs(len(ring) - minSteps))
            return minSteps
        
        n = len(key)
        dp = [0] * len(ring)
        for p in char_pos[key[0]]:
            dp[p] = minStep(0, p)
        prev_char = key[0]
        for c in key[1:]:
            if prev_char == c:
                continue
            for next_pos in char_pos[c]:
                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])
            prev_char = c
        return min(dp[p] for p in char_pos[prev_char]) + len(key)"
find largest value in each tree row,"class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def helper(root, depth):
            if root is None:
                return
            
            if depth == len(res):
                res.append(root.val)
            else:
                res[depth] = max(res[depth], root.val)
            
            helper(root.left, depth + 1)
            helper(root.right, depth + 1)
        
        helper(root, 0)
        return res"
find largest value in each tree row,"class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        q=[]
        if root:
            q.append(root)
        Max=[]
        while len(q)>0:
            arr=[]
            length=len(q)
            for i in range(len(q)):
                current=q.pop(0)
                arr.append(current.val)
                if current.left:
                    q.append(current.left)
                if current.right:
                    q.append(current.right)
            Max.append(max(arr))
        return Max;"
longest palindromic subsequence,"class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        return self.get_longest_subseq(0, len(s)-1, s)
    
    def get_longest_subseq(self, start, end, s):
        """"""
            method used to find the longest palindrome subsequence in a string
            start: start index of the string
            end: end index of the string
            s: string
            return: length of the longest palindrome subsequence
        """"""
        if start == end:
            return 1
			
        if start > end:
            return 0

        if s[start] == s[end]:
            return 2 + self.get_longest_subseq(start + 1, end - 1, s)
        
        return max(self.get_longest_subseq(start + 1, end, s), self.get_longest_subseq(start, end - 1, s))"
longest palindromic subsequence,"class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        # add 2d list memo to avoid redundant calculation
        self.memo = [[0 for _ in range(len(s))] for _ in range(len(s))]
        return self.get_longest_subseq(0, len(s)-1, s)
    
    def get_longest_subseq(self, start, end, s):
        """"""
            method used to find the longest palindrome subsequence in a string
            start: start index of the string
            end: end index of the string
            s: string
            return: length of the longest palindrome subsequence
        """"""
        if start == end:
            return 1
        
        if start > end:
            return 0

        # if the value is in the memo, return the value
        if self.memo[start][end] != 0:
            return self.memo[start][end]

        # if the value is not in the memo, calculate the value
        # then add the value to the memo
        if s[start] == s[end]:
            self.memo[start][end] = 2 + self.get_longest_subseq(start + 1, end - 1, s)
        else:
            self.memo[start][end] = max(self.get_longest_subseq(start + 1, end, s), self.get_longest_subseq(start, end - 1, s))
            
        return self.memo[start][end]"
super washing machines,"class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        total = sum(machines)
        if total % len(machines): return -1 # impossible 
        avg = total // len(machines)
        
        ans = prefix = 0
        for i, x in enumerate(machines): 
            ans = max(ans, abs(prefix), x - avg)
            prefix += x - avg
        return ans"
coin change ii,"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [[1]+[0]*amount for _ in range(len(coins)+1)]
        for i in range(1, len(coins)+1):
            for j in range(1, amount+1):
                if coins[i-1] <= j:
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[len(coins)][amount]  # or dp[-1][-1]"
coin change ii,"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [1] + [0]*amount
        for coin in coins: 
            for x in range(coin, amount+1): 
                dp[x] += dp[x-coin]
        return dp[-1]"
random flip matrix,"class Solution:

    def __init__(self, m: int, n: int):
        self.nums = m * n - 1
        self.cols = n
        self.flipped = set()
        

    def flip(self) -> List[int]:
        rc = random.randint(0, self.nums)
        while rc in self.flipped:
            rc = random.randint(0, self.nums)
            
        self.flipped.add(rc)
        return [rc // self.cols, rc % self.cols]
    

    def reset(self) -> None:
        self.flipped = set()"
random flip matrix,"class Solution:

    def __init__(self, m: int, n: int):
        self.cols = n
        self.nums = m * n
        self.tail = m * n - 1
        self.indexes = [i for i in range(m * n)]
        
    def flip(self) -> List[int]:
        ind = random.randint(0, self.tail)
		
		# swap the selected index with the index at self.indexes[self.tail]
        rc = self.indexes[ind]
        self.indexes[ind] = self.indexes[self.tail]
		# decrease self.tail by one means we drop the candidates flipped.
        self.tail -= 1
        
        return [rc // self.cols, rc % self.cols]
        
    def reset(self) -> None:
        self.indexes = [i for i in range(self.nums)]
        self.tail = self.nums - 1"
detect capital,"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
    	return word in [word.upper(), word.lower(), word.title()]
		

- Python 3
- Junaid Mansuri"
detect capital,"class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if word.isupper(): return True
        if word.islower(): return True
        if word[0].isupper() and word[1:].islower(): return True
        return False"
longest uncommon subsequence i,"class Solution:
    def findLUSlength(self, a: str, b: str) -> int:
        if a==b:return -1
        else:return max(len(a),len(b))"
longest uncommon subsequence i,"class Solution:
    def findLUSlength(self, a: str, b: str) -> int:
        return -1 if a == b else max(len(a), len(b))"
longest uncommon subsequence ii,"class Solution:
    def findLUSlength(self, S: List[str]) -> int:
    	C = collections.Counter(S)
    	S = sorted(C.keys(), key = len, reverse = True)
    	for i,s in enumerate(S):
    		if C[s] != 1: continue
    		b = True
    		for j in range(i):
    			I, c = -1, True
    			for i in s:
    				I = S[j].find(i,I+1)
    				if I == -1:
    					c = False
    					break
    			if c:
    				b = False
    				break
    		if b: return len(s)
    	return -1
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
longest uncommon subsequence ii,"class Solution:
    def findLUSlength(self, strs: List[str]) -> int:
        def isSubseq(a, b):
            j = 0
            for i in range(len(b)):
                if a[j] == b[i]:
                    j += 1
                    if j == len(a):
                        return True
            return False
        c = Counter(strs)
        s = sorted(c.keys(), key=len, reverse=True)
        for i in range(len(s)):
            if c[s[i]] > 1:
                continue
            if i == 0 or not any(isSubseq(s[i], s[j]) for j in range(i)):    
                return len(s[i])
        return -1"
continuous subarray sum,"class Solution:
	def checkSubarraySum(self, nums: List[int], k: int) -> bool:
		# Brute Force: O(^2) - TLE
		count = 0
		for i in range(len(nums)):
			sum = 0
			for j in range(i, len(nums)):
				sum += nums[j]
				if sum % k == 0:
				   return True
		return False

class Solution:
	def checkSubarraySum(self, nums: List[int], k: int) -> bool:
		# Optimal Approach - Time and Space: O(n), O(n)
		res = {0: -1}
		prefSum = 0
		for i in range(len(nums)):
			prefSum += nums[i]
			rem = prefSum % k
			if rem in res:
				if i-res[rem] > 1:
					return True
			else:
				res[rem] = i
		return False"
continuous subarray sum,"class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        prefix_sums = defaultdict(lambda:float(inf))        
        #Key is prefix_sum%k, value is earliest occurence of the same prefix_sum   
        
        running_sum = 0
        for i, n in enumerate(nums):
            running_sum += n
            mod_sum = running_sum%k
            #If running_sum%k = 0 + other_sum%k for a value other_sum in prefix_sum 
            #then we can subtract the other_sum and we'll have a multiple of k
            
            #Subarray must have at least 2 elements so we will not return True in cases of having just one element
            #or subtracting the prefix_sum right before the current one
            if i >= 1 and (mod_sum == 0 or prefix_sums[mod_sum] < i - 1):
                return True
            
            #We wouldn't need to keep track of minimum position if we could have subarray of size 1
            prefix_sums[mod_sum] = min(prefix_sums[mod_sum], i)
                
        return False"
longest word in dictionary through deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        def is_subseq(main: str, sub: str) -> bool:
            i, j, m, n = 0, 0, len(main), len(sub)
            while i < m and j < n and n - j >= m - i:
                if main[i] == sub[j]:
                    i += 1
                j += 1
            return i == m
        
        res = ''
        helper = sorted(d, key = lambda x: len(x), reverse = True)
        for word in helper:
            if len(word) < len(res): return res
            if ( not res or word < res )  and is_subseq(word, s):
                res = word
        return res"
longest word in dictionary through deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        
        def fn(word): 
            """"""Return True if word matches a subsequence of s.""""""
            ss = iter(s)
            return all(c in ss for c in word)
        
        return next((w for w in sorted(d, key=lambda x: (-len(x), x)) if fn(w)), """")"
contiguous array,"class Solution:
    def findMaxLength(self, nums: List[int]) -> int:

        partial_sum = 0
        
		# table is a dictionary
		# key : partial sum value
		# value : the left-most index who has the partial sum value
		
        table = { 0: -1}
        
        max_length = 0
        
        for idx, number in enumerate( nums ):
            
            # partial_sum add 1 for 1
            # partial_sum minus 1 for 0
            
            if number:
                partial_sum += 1
            else:
                partial_sum -= 1
                
            
            if partial_sum in table:
                
                # we have a subarray with equal number of 0 and 1
                # update max length
                
                max_length = max( max_length, ( idx - table[partial_sum] ) )
                
            else:
                # update the left-most index for specified partial sum value
                table[ partial_sum ] = idx
                
        return max_length"
contiguous array,"class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        m,c=0,0
        d={0:-1}
        for i in range(len(nums)):
            if nums[i]==0:
                c-=1
            else:
                c+=1
            if c in d:
                m=max(m,i-d[c])
            else:
                d[c]=i
        return m"
beautiful arrangement,"class Solution:
    def countArrangement(self, n: int) -> int:
        self.count = 0
        self.backtrack(n, 1, [])
        return self.count
        
    def backtrack(self, N, idx, temp):
        if len(temp) == N:
            self.count += 1
            return
        
        for i in range(1, N+1):
            if i not in temp and (i % idx == 0 or idx % i == 0):
                temp.append(i)
                self.backtrack(N, idx+1, temp)
                temp.pop()"
beautiful arrangement,"class Solution:
    def countArrangement(self, n: int) -> int:
        ans=[]
        def permute(l,p,index):
            if l==[]:
                ans.append(p)
            for i,v in enumerate(l):
                if v%(index+1)==0 or (index+1)%v==0:
                    permute(l[:i]+l[i+1:],p+[v],index+1)
        
        permute(list(range(1,n+1)),[],0)
        return len(ans)"
random pick with weight,"class Solution:

    def __init__(self, w: List[int]):
        self.li = []
        ma = sum(w)
        
        for i, weight in enumerate(w):
            ratio = ceil(weight / ma * 100)
            self.li += ([i] * ratio)
        

    def pickIndex(self) -> int:
        return random.choice(self.li)"
random pick with weight,"class Solution:

    def __init__(self, w: List[int]):
        self.w = w
        self.c = [0] * len(w)
        s = sum(w)
        self.c[0] = w[0]/s
        for i in range(1, len(w)):
            self.c[i] = self.c[i-1] + w[i]/s

    def pickIndex(self) -> int:
        pr = random.random()
        return bisect.bisect_left(self.c, pr)"
minesweeper,"class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        m, n = len(board), len(board[0])
        def dfs(x, y):
            if board[x][y] == 'M': board[x][y] = 'X'
            elif board[x][y] == 'E':
                cnt, nei = 0, []
                for i, j in map(lambda v: (v[0]+x, v[1]+y), [(-1, 0), (1, 0), (-1, -1), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 1)]):
                    if 0 <= i < m and 0 <= j < n:
                        nei.append((i, j))
                        if board[i][j] == 'M': cnt += 1
                if not cnt:
                    board[x][y] = 'B'
                    for i, j in nei: dfs(i, j)
                else: board[x][y] = str(cnt)
        dfs(*click)            
        return board"
minesweeper,"class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        x,y = click[0],click[1]
        options = []
        if board[x][y] == ""M"":
            board[x][y] = ""X""
        else:
            options = [(0,1),(0,-1),(1,0),(1,-1),(1,1),(-1,-1),(-1,0),(-1,1)]

            count = 0
            for i,j in options:
                if x+i > -1 and x+i < len(board) and y+j > -1 and y+j < len(board[0]):
                    if board[x+i][y+j] == ""M"":
                        count += 1
            if count == 0:
                board[x][y] = ""B""
                for i,j in options:
                    if x+i > -1 and x+i < len(board) and y+j > -1 and y+j < len(board[0]):
                        if board[x+i][y+j] == ""M"" or board[x+i][y+j] == ""E"":
                            self.updateBoard(board,[x+i,y+j])
            else:
                board[x][y] = str(count)

        return board"
minimum absolute difference in bst,"class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        d = float('inf')
        s = []
        if root == None:
            return 
        d = self.traverse(root,d,s)
        return d
    def traverse(self,root,d,s):
        if root.left != None:
            d = self.traverse(root.left,d,s)
        s.append(root.val)
        if len(s)>1:
            diff = s[-1]-s[-2]
            if diff < d:
                d = diff
        if root.right != None:
            d = self.traverse(root.right,d,s) 
        return d"
minimum absolute difference in bst,"class Solution:
	def getMinimumDifference(self, root: TreeNode) -> int:
		queue, result, diff = deque([root]), [], float(""inf"")

		while queue:
			curNode = queue.popleft()

			result.append(curNode.val)

			if curNode.left:
				queue.append(curNode.left)

			if curNode.right:
				queue.append(curNode.right)

		result.sort()
		for i in range(len(result)-1):
			if abs(result[i+1] - result[i]) < diff: diff = abs(result[i+1] - result[i])

		return diff"
k diff pairs in an array,"class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        cnt=0
        c=Counter(nums)
        
        if k==0:
            for key,v in c.items():
                if v>1:
                    cnt+=1
        else:
            for key,v in c.items():
                if key+k in c:
                    cnt+=1
        return cnt"
k diff pairs in an array,"class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        count = Counter(nums)
        if k > 0:
            return sum([i + k in count for i in count])
        else:
            return sum([count[i] > 1 for i in count])"
complex number multiplication,"class Solution:
    def complexNumberMultiply(self, num1: str, num2: str) -> str:
        a1,b1 = num1.split('+')
        a1 = int(a1)
        b1 = int(b1[:-1])
        a2,b2 = num2.split('+')
        a2 = int(a2)
        b2 = int(b2[:-1])
        return str(a1*a2 + b1*b2*(-1)) + '+' + str(a1*b2 + a2*b1) + 'i'"
complex number multiplication,"class Solution:
    def complexNumberMultiply(self, a: str, b: str) -> str:
        [A1,B1,A2,B2] = map(int,(a+'+'+b).replace('i','').split('+'))
        return str(A1*A2-B1*B2)+'+'+str(A1*B2+A2*B1)+'i'
		
		
- Junaid Mansuri
- Chicago, IL"
convert bst to greater tree,"class Solution:
	def convertBST(self, root: TreeNode) -> TreeNode:
		sum = 0
		
		def sol(root: TreeNode) -> TreeNode:
			nonlocal sum
			if root:
				sol(root.right)
				root.val += sum
				sum = root.val
				sol(root.left)
			return root
		
		return sol(root)"
convert bst to greater tree,"class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def dfs(node, init):
            if not node: return 0
            
            r_sum = dfs(node.right, init)
            orig, node.val = node.val, node.val + init + r_sum
            l_sum = dfs(node.left, node.val)
            
            return r_sum + orig + l_sum
                       
        dfs(root, 0)
        return root"
minimum time difference,"class Solution:
    def findMinDifference(self, timePoints: List[str]) -> int:
        M = 1440
        times = [False] * M
        for time in timePoints:
            minute = self.minute(time)
            if times[minute]:
                return 0
            times[minute] = True
        
        minutes = [i for i in range(M) if times[i]]
        return min((minutes[i] - minutes[i-1]) % M for i in range(len(minutes)))
        
    def minute(self, time: str) -> int:
        h, m = map(int, time.split(':'))
        return 60*h + m"
minimum time difference,"class Solution:
    def findMinDifference(self, timePoints: List[str]) -> int:
        def toMinFromZero(t):
            return 60*int(t[:2]) + int(t[3:])
        
        maxMins = 60*24 # number of mins in a day
        if len(timePoints) > maxMins:
            return 0
    
        # we sort the timestamps. Idea: The smallest difference will always be a 
        # difference between two neighboring times in the array.
        ts = [toMinFromZero(t) for t in timePoints]
        ts.sort()
        
        diffMin = maxMins
        # calculate the pairwise difference ...
        for i in range(1,len(ts)):
            t_high = ts[i]
            t_low = ts[i-1]
            diffMin = min(diffMin, t_high - t_low)
        # ... and due to the 24 hour clock, don't forget the last and first entry with modulo arithmetic
        diffMin = min(diffMin, (ts[0] - ts[-1]) % maxMins)
        
        return diffMin"
single element in a sorted array,"class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        counts = defaultdict(int)
        for num in nums:
            counts[num] += 1
        for num, count in counts.items():
            if count == 1:
                return num
        return -1  # this will never be reached
		# return Counter(nums).most_common()[-1][0]  # one-liner, but TC O(nlogn)"
single element in a sorted array,"class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        val, seen = -1, True
        for num in nums:
            if val == num:
                seen = True
            elif seen:
                val = num
                seen = False
            else:
                return val
        return -1  # this will never be reached"
reverse string ii,"class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        if len(s)<(k):return s[::-1]
        if len(s)<(2*k):return (s[:k][::-1]+s[k:])
        return s[:k][::-1]+s[k:2*k]+self.reverseStr(s[2*k:],k)"
reverse string ii,"class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        s=list(s)
        for i in range(0,len(s),2*k):
            if len(s[i:i+k])<k:
                s[i:i+k]=s[i:i+k][::-1]
            elif 2*k>len(s[i:i+k])>=k:
                s[i:i+k]=s[i:i+k][::-1]
        return """".join(s)"
01 matrix,"class Solution:
	def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
		row, col = len(mat), len(mat[0])
		queue = deque([])

		for x in range(row):
			for y in range(col):
				if mat[x][y] == 0:
					queue.append((x, y, 1))


		return self.bfs(row, col, queue, mat)

	def bfs(self, row, col, queue, grid):
		visited = set()
		while queue:
			x, y, steps = queue.popleft()

			for nx, ny in [[x+1,y], [x-1,y], [x,y+1], [x,y-1]]:
				if 0<=nx<row and 0<=ny<col and (nx,ny) not in visited:
					if grid[nx][ny] == 1:
						visited.add((nx,ny))
						grid[nx][ny] = steps
						queue.append((nx, ny, steps+1))

		return grid"
01 matrix,"class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        r=len(mat)
        c=len(mat[0])
        for i in range(r):
            for j in range(c):
                if mat[i][j]!=0:
                    top=mat[i-1][j] if i>0 else float('inf')
                    left=mat[i][j-1] if j>0 else float('inf')
                    mat[i][j]=min(top,left)+1
        for i in range(r-1,-1,-1):
            for j in range(c-1,-1,-1):
                if mat[i][j]!=0:
                    down=mat[i+1][j] if i<r-1 else float('inf')
                    right=mat[i][j+1] if j<c-1 else float('inf')
                    mat[i][j]=min(mat[i][j],min(down,right)+1)
        return mat"
diameter of binary tree,"class Solution:
    def __init__(self):
	    self.diameter = 0  # stores the maximum diameter calculated
	
    def depth(self, node: Optional[TreeNode]) -> int:
        """"""
        This function needs to do the following:
            1. Calculate the maximum depth of the left and right sides of the given node
            2. Determine the diameter at the given node and check if its the maximum
        """"""
        # Calculate maximum depth
        left = self.depth(node.left) if node.left else 0
        right = self.depth(node.right) if node.right else 0
        # Calculate diameter
        if left + right > self.diameter:
            self.diameter = left + right
        # Make sure the parent node(s) get the correct depth from this node
        return 1 + (left if left > right else right)
    
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # if not root:
        #     return 0
        self.depth(root)  # root is guaranteed to be a TreeNode object
        return self.diameter"
diameter of binary tree,"class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        def height(root):
            nonlocal diameter
            if not root:
                return 0
            
            left = height(root.left)
            right = height(root.right)
            diameter = max(diameter, left + right)
            return max(left, right) + 1
        
        diameter = 0
        height(root)
        return diameter"
remove boxes,"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:
        
        @cache
        def fn(lo, hi, k): 
            """"""Return max score of removing boxes from lo to hi with k to the left.""""""
            if lo == hi: return 0 
            while lo+1 < hi and boxes[lo] == boxes[lo+1]: lo, k = lo+1, k+1
            ans = (k+1)*(k+1) + fn(lo+1, hi, 0)
            for mid in range(lo+2, hi): 
                if boxes[lo] == boxes[mid]: 
                    ans = max(ans, fn(lo+1, mid, 0) + fn(mid, hi, k+1))
            return ans 
                
        return fn(0, len(boxes), 0)"
remove boxes,"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def dp(l, r, count = 0):
            if l > r: return 0
            // Initial count for the letter at boxes[l]
            count += 1
            ptr = l + 1
            while ptr <= r and boxes[l] == boxes[ptr]:
                ptr += 1
                count += 1
            points = (count ** 2) + dp(ptr, r)
            for i in range(ptr + 1, r + 1):
                if boxes[l] == boxes[i]:
                    points = max(points, dp(i, r, count) + dp(ptr, i - 1))
            return points

        return dp(0, len(boxes) - 1)"
number of provinces,"class Solution(object):
    def findCircleNum(self, M):
        """"""
        :type M: List[List[int]]
        :rtype: int
        """"""
        n = len(M)  #1
        visited = [False]*n  #2
        count = 0  #3
        
        if not M:  #4
            return 0  #5
        
        def dfs(u):  #6
            for v in range(n):  #7
                if M[u][v] == 1 and visited[v] == False:  #8
                    visited[v] = True  #9
                    dfs(v)  #10
        
        
        for idx in range(n): #11
            if visited[idx] == False: #12
                count += 1 #13
                visited[idx] == True #14
                dfs(idx) #15
        
        return count #16"
number of provinces,"class Solution:
    def findCircleNum(self, M: List[List[int]]) -> int:
        dsu = DSU(len(M))
        for i, r in enumerate(M):
            for j, v in enumerate(r):
                if j > i - 1: break
                if v == 1:
                    dsu.union(i, j)
        return dsu.numFrdCir
    
class DSU:
    def __init__(self, num):
        self.numFrdCir = num
        self.par = list(range(num))
        self.rnk = [0] * num
        
    def find(self, x):
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]
    
    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr == yr:
			return
        elif self.rnk[xr] < self.rnk[yr]:
            self.par[xr] = yr
        elif self.rnk[xr] > self.rnk[yr]:
            self.par[yr] = xr
        else:
            self.par[yr] = xr
            self.rnk[xr] += 1
        self.numFrdCir -= 1"
student attendance record i,"class Solution:
    def checkRecord(self, s: str) -> bool:
    	return (s.count('A') < 2) and ('LLL' not in s)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
student attendance record i,"class Solution:
    def checkRecord(self, s: str) -> bool:
        d=0
        for i in range(len(s)):
            if s[i]=='A':
                d+=1
            if d==2:
                return False
            if i>=2 and s[i]==s[i-1]==s[i-2]=='L':
                return False
        return True"
student attendance record ii,"class Solution:
    def checkRecord(self, n: int) -> int:
    	C, m = [1,1,0,1,0,0], 10**9 + 7
    	for i in range(n-1):
    		a, b = sum(C[:3]) % m, sum(C[3:]) % m
    		C = [a, C[0], C[1], a + b, C[3], C[4]]
    	return (sum(C) % m)"
student attendance record ii,"class Solution:
    def checkRecord(self, n: int) -> int:
        """"""
        Suppose dp[i] is the number of all the rewarded sequences without 'A'
        having their length equals to i, then we have:
            1. Number of sequence ends with 'P': dp[i - 1]
            2. Number of sequence ends with 'L':
                2.1 Number of sequence ends with 'PL': dp[i - 2]
                2.2 Number of sequence ends with 'LL':
                    2.2.1 Number of sequence ends with 'PLL': dp[i - 3]
                    2.2.2 Number of sequence ends with 'LLL': 0 (not allowed)

            So dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3], 3 <= i <= n

        Then all the rewarding sequences with length n are divided into
        two cases as follows:
            1. Number of sequences without 'A': dp[n]
            2. Number of sequence with A in the middle, since we could only 
                have at most one A in the sequence to get it rewarded, 
                suppose A is at the ith position, then we have:
                    A[i] = dp[i] * dp[n - 1 - i]

                Then the number of such sequences is:
                    sum(A[i] for i in range(n))

        Then our final result will be dp[n] + sum(A[i] for i in range(n)).

        Corner cases:
            1. dp[0] = 1: which means the only case when the sequence is an
                empty string.
            2. dp[1] = 2: 'L', 'P'
            3. dp[2] = 4: 'LL', 'LP', 'PL', 'PP'
        """"""
        if not n:
            return 0

        if n == 1:
            return 3

        MOD = 10 ** 9 + 7
        dp = [1, 2, 4] + [0] * (n - 2)

        # Calculate sequences without 'A'.
        for i in range(3, n + 1):
            dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD

        # Calculate final result.
        rslt = dp[n] % MOD
        for i in range(n):
            rslt += (dp[i] * dp[n - 1 - i]) % MOD

        return rslt % MOD"
optimal division,"class Solution:
    def optimalDivision(self, nums: List[int]) -> str:
        if len(nums) <= 2: return ""/"".join(map(str, nums))
        return f'{nums[0]}/({""/"".join(map(str, nums[1:]))})'"
optimal division,"class Solution:
    def optimalDivision(self, nums: List[int]) -> str:
        return ""/"".join(map(str, nums)) if len(nums) <= 2 else f'{nums[0]}/({""/"".join(map(str, nums[1:]))})'"
brick wall,"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        count = defaultdict(int)
        tot = len(wall)
        if tot == 1 and len(wall[0]) > 1:
            return 0
        elif tot == 1 and len(wall[0]) == 1:
            return 1
        
        for w in wall:
            s = 0 
            for i in range(len(w)):
                s += w[i]
                count[s] += 1
            count[s] -= 1

        return tot - max(count.values())"
brick wall,"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        table = dict()
        for row in wall:
            tmp_sum = 0
            for item in row:
                tmp_sum += item
                if tmp_sum not in table:
                    table[tmp_sum] = 1
                else:
                    table[tmp_sum] += 1
        output = len(wall)
        for key in table:
            if len(wall) - table[key] < output and key != sum(wall[0]):
                output = len(wall) - table[key]
        return output"
next greater element iii,"class Solution:
    def nextGreaterElement(self, n: int) -> int:
        m=list(str(n))                       ## n = 257761
        l = len(m)                           ## l = 6
        d = {}
        res = str(n)
        
        ## reading character backwards: 1->6->7->7->5 break
        for i,c in enumerate(m[::-1]): 
            if not d:
                d[c]=1                       ## d = {'1':1}
            else:
                if all(c >= x for x in d):
                    d[c]=d.get(c,0)+1        ## d = {'1':1,'6':1,'7':2} 
                else:
                    d[c]=d.get(c,0)+1        ## d = {'1':1,'5':1,'6':1,'7':2}
                    res = ''.join(m[:l-1-i])        ## res = '2'
                    stock = sorted(list(d.keys()))  ## stock = ['1','5','6','7']
                    cplus = stock[stock.index(c)+1] ## cplus = '6' just > '5'
                    res += cplus                    ## res = '26'
                    d[cplus] -= 1                   ## d = {'1':1,'5':1,'6':0,'7':2}
                    res += ''.join([x * d[x] for x in stock]) 
					                                ## res = '26' + '1577'
                    break
        
        return int(res) if n < int(res) < (2**31-1) else -1"
next greater element iii,"class Solution:
    def nextGreaterElement(self, n: int) -> int:
        digits = list(str(n))
        j = i = len(digits)-1
        while i and digits[i] <= digits[i-1]: i-=1
        if i == 0: return -1
        while digits[j] <= digits[i-1]: j-=1
        digits[j],digits[i-1] = digits[i-1],digits[j]
        digits[i:] = digits[i:][::-1]
        res = ''.join(digits)
        return res if int(res) < 2**31 else -1"
reverse words in a string iii,"class Solution:
    def reverseWords(self, s: str) -> str:
    	s = s.split()
    	for i in range(len(s)): s[i] = s[i][::-1]
    	return "" "".join(s)
	

- Junaid Mansuri
(LeetCode ID)@hotmail.com"
reverse words in a string iii,"class Solution:
    def reverseWords(self, s: str) -> str:
        s = s.strip().split()                   #Converting s into a list to get rid of spaces
        out = []
        for word in s:                          #Reversing each word of the list using two-pointers
            i = 0
            j = (len(word) - 1)
            while (i < j):
                word = list(word)
                word[i], word[j] = word[j], word[i]
                i += 1
                j -= 1
            a = (''.join(word))
            out.append(a)
        return(' '.join(out))                     #joining the words back to form a string"
logical or of two binary grids represented as quad trees,"class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2 # boundary condition 
        if quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1 # boundary condition 
        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)
        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val: 
            return Node(tl.val, True, None, None, None, None)
        return Node(None, False, tl, tr, bl, br)"
logical or of two binary grids represented as quad trees,"class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if quadTree1.isLeaf and quadTree2.isLeaf:                                    # case 1: both are leaf nodes
            node = Node(quadTree1.val | quadTree2.val, 1, None, None, None, None)
            return node
        elif quadTree1.isLeaf and not quadTree2.isLeaf:                              # case 2: node 1 is leaf node, node 2 is not
            node = Node(0, 0, 
                        self.intersect(quadTree1, quadTree2.topLeft), 
                        self.intersect(quadTree1, quadTree2.topRight), 
                        self.intersect(quadTree1, quadTree2.bottomLeft), 
                        self.intersect(quadTree1, quadTree2.bottomRight))
        elif not quadTree1.isLeaf and quadTree2.isLeaf:                              # case 3: node 2 is leaf node, node 1 is not
            node = Node(0, 0, 
                        self.intersect(quadTree1.topLeft, quadTree2), 
                        self.intersect(quadTree1.topRight, quadTree2), 
                        self.intersect(quadTree1.bottomLeft, quadTree2), 
                        self.intersect(quadTree1.bottomRight, quadTree2))
        else:                                                                        # case 4: neither nodes are leaf 
            node = Node(0, 0, 
                        self.intersect(quadTree1.topLeft, quadTree2.topLeft), 
                        self.intersect(quadTree1.topRight, quadTree2.topRight), 
                        self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft), 
                        self.intersect(quadTree1.bottomRight, quadTree2.bottomRight))
            
        if node.topLeft.isLeaf and node.topRight.isLeaf and node.bottomLeft.isLeaf \
            and node.bottomRight.isLeaf and node.topLeft.val == node.topRight.val \
            == node.bottomLeft.val == node.bottomRight.val:                          # shrink quad nodes to one leaf node is values in 4 areas are the same
            return Node(node.topLeft.val, 1, None, None, None, None)
        return node"
maximum depth of n ary tree,"class Solution:
    def maxDepth(self, root: 'Node') -> int:
        
        if root is None:
            # empty node or empty tree
            return 0
    
        else:
            # DFS to choose the longest path
            
            if root.children:
                # current node has subtrees
                return max( self.maxDepth(child) for child in root.children ) + 1
            
            else:
                # current node is leaf node
                return 1"
maximum depth of n ary tree,"class Solution:
    def maxDepth(self, root: 'Node') -> int:
        
        if not root : return 0
        
        if root.children :
            return 1 + max([self.maxDepth(x) for x in root.children])
        else :
            return 1"
subarray sum equals k,"class Solution:
	def subarraySum(self, nums: List[int], k: int) -> int:

		ans=0
		prefsum=0
		d={0:1}

		for num in nums:
			prefsum = prefsum + num

			if prefsum-k in d:
				ans = ans + d[prefsum-k]

			if prefsum not in d:
				d[prefsum] = 1
			else:
				d[prefsum] = d[prefsum]+1

		return ans"
subarray sum equals k,"class Solution(object):
    def subarraySum(self, nums, k):
        
        currSum = 0
        ansCount = 0
        prevSums = {0:1}        
        
        for num in nums:
            
            currSum += num
            
            if currSum - k in prevSums:
                ansCount += prevSums[currSum - k]
                
            if currSum in prevSums:
                prevSums[currSum] += 1
            else:
                prevSums[currSum] = 1

        return ansCount"
array partition,"class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        sum_ = 0
        for i in range(0,len(nums),2):
            sum_ += nums[i]
        return sum_

# Time : 356 ms
# Memory : 16.7 M"
array partition,"class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        return sum(sorted(nums)[::2])
        
# Time : 332 ms
# Memory : 16.5 M"
binary tree tilt,"class Solution:
    def findTilt(self, root: Optional[TreeNode]) -> int:
        def rec(node):
            nonlocal res
            if not node:
                return 0
            left_sum = rec(node.left)
            right_sum = rec(node.right)
            res += abs(left_sum - right_sum)
            
            return left_sum + node.val + right_sum
        
        res = 0
        rec(root)
        return res"
binary tree tilt,"class Solution:
	def findTilt(self, root: TreeNode) -> int:
		return self.traverse(root)[1]

	def traverse(self,root):
		if not root:
			return 0,0
		'''
		lvsum &amp; rvsum --> Sum of **values** all left and right children nodes respectively
		ltsum &amp; rtsum --> Sum of **tilt** of all left and right children nodes respectively  
		'''
		lvsum,ltsum = self.traverse(root.left)
		rvsum,rtsum = self.traverse(root.right)
		val_sum = root.val+lvsum+rvsum
		tilt_sum = ltsum + rtsum + abs(lvsum - rvsum)
		return val_sum,tilt_sum"
find the closest palindrome,"class Solution:
    def find_next_palindrome(self, n, additive):
        l = len(n)
        if l == 0:
            return 0
        first_half = str(int(n[:l // 2 + l % 2]) + additive)
        return int(first_half + first_half[(-1 - l%2)::-1])
            
    def nearestPalindromic(self, n: str) -> str:
        m = int(n)
        candidates = [self.find_next_palindrome(n, additive) for additive in range(-1, 2)] # Cases 1, 2, and 3
        candidates.append(self.find_next_palindrome(""9""*(len(n)-1), 0)) # Case 4
        candidates.append(self.find_next_palindrome(""1"" + ""0""*len(n), 0)) # Case 5

        ans = None
        for t in candidates:
            if t == m:
                continue
            if ans is None or abs(ans - m) > abs(t - m) or (abs(ans - m) == abs(t - m) and t < m):
                ans = t
        return str(ans)"
find the closest palindrome,"class Solution:
    def nearestPalindromic(self, n: str) -> str:
        """"""
        1. The nearest palindrome falls into the boundary of
            [10 ** (maxLen - 1) - 1, 10 ** maxLen + 1].
        2. We should only consider the change on the first half part of n and
            reverse it to the second half of n as this will give us smaller
            results.
        3. Then we we take the first half part of n and add 1, add 0 or add -1
            to it, then reverse it to the second half to create the palindrome
            candidates.
        4. Then we compare all the candidates distance against n. Notice that
            if n is already a palindrome, it should be excluded from the above
            comparison.
        """"""
        maxLen, N = len(n), int(n)

        # Calculate bounds first.
        low, high = 10 ** (maxLen - 1) - 1, 10 ** maxLen + 1

        # Calculate remaining candidates.
        isOddLen = maxLen &amp; 1
        firstHalf = int(n[:(maxLen >> 1) + isOddLen])
        smaller = int(str(firstHalf - 1) + str(firstHalf - 1)[-1-isOddLen::-1])
        same = int(str(firstHalf) + str(firstHalf)[-1-isOddLen::-1])
        larger = int(str(firstHalf + 1) + str(firstHalf + 1)[-1-isOddLen::-1])

        # Compare all the above results.
        if same == N:  # n is already a palindrome.
            return str(min(
                [low, high, smaller, larger],
                key=lambda x: (abs(x - N), x)))
        else:
            return str(min(
                [low, high, smaller, same, larger],
                key=lambda x: (abs(x - N), x)))"
array nesting,"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        res, l = 0, len(nums)
        globalSet = set()
        for k in range(l):
            if k not in globalSet:
                currLength, currSet, val = 0, set(), k
                while True:
                    if nums[val] in currSet: break
                    currSet.add(nums[val])
                    globalSet.add(nums[val])
                    currLength, val = currLength + 1, nums[val]
                res = max(res, currLength)        
        return res"
array nesting,"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        ans = cnt = 0
        for i, idx in enumerate(nums):
            if idx < 0: continue                           # avoid revisit
            while nums[idx] >= 0:
                cnt, nums[idx], idx = cnt+1, -1, nums[idx] # increment length; mark as visited; visit next value
            else:    
                ans, cnt = max(ans, cnt), 0                # record length and reset `cnt`
        return ans"
reshape the matrix,"class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        flatten = []
        new_mat = []
        for row in mat:
            for num in row:
                flatten.append(num)
                
        if r * c != len(flatten):   # when given parameters is NOT possible and legal
            return mat
        else:
            for row_index in range(r):
                new_mat.append(flatten[row_index * c : row_index * c + c])
            return new_mat"
reshape the matrix,"class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        queue = [cell for row in mat for cell in row] if r*c==len(mat)*len(mat[0]) else []
        return [[queue.pop(0) for _ in range(c)] for _ in range(r)] if queue else mat"
permutation in string,"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        window = len(s1)
        s1_c = Counter(s1)
        
        for i in range(len(s2)-window+1):
            s2_c = Counter(s2[i:i+window])
            if s2_c == s1_c:
                return True
            
        return False"
permutation in string,"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        h1=Counter(s1)
        n=len(s1)
        
        for i in range(len(s2)-len(s1)+1):
            h2 = Counter(s2[i:i+n])
            if h1==h2:
                return True
        return False"
subtree of another tree,"class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        if not s: 
            return False
        if self.isSameTree(s, t): 
            return True
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)

    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if p and q:
            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        return p is q"
subtree of another tree,"class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        def f(root):
            if not root:
                return ""L""
            left_end = ""$"" if not root.left else """"
            right_end = ""#"" if not root.right else """"
            return left_end + ""|"" + f(root.left) + ""-"" + str(root.val) + ""-"" + f(root.right) + ""|"" + right_end

        x = f(subRoot)
        y = f(root)

        return y.find(x) != -1"
distribute candies,"class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType) //2, len(set(candyType)))"
distribute candies,"class Solution:
    def distributeCandies(self, C: List[int]) -> int:
    	return min(len(C)//2,len(set(C)))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
out of boundary paths,"class Solution:         # The plan is to accrete the number of paths from the starting cell, which
                        # is the sum of (a) the number of adjacent positions that are off the grid
                        # and (b) the number of paths from the adjacent cells in the grid within 
                        # maxMove steps. We determine (b) recursively.

    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:

        @lru_cache(None)                                # <-- Many cells are revisited so we cache the previous calls
        def dp (x,y,steps = maxMove):
            if x not in range(m) or y not in range(n):  # <-- Moved off the grid so increment the tally
                return 1
            if not steps:                               # <-- Ran out of the maxMove steps
                return 0

            ans, dx, dy = 0, 1, 0
            for _ in range(4):
                ans+= dp(x+dx, y+dy, steps-1)           # <-- visit the adjacent cells
                dx, dy = dy,-dx                         # <-- iterates thru the directions:
				                                        #         south => east => north => west 

            return ans  

        return dp (startRow, startColumn)%1000000007
		
		# Thanks to XixiangLiu for fixing a number of my errors in the original post."
out of boundary paths,"class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        modulo = 10 ** 9 + 7

        @lru_cache(None)
        def recursion(move, row, col):
            if row == m or row < 0 or col == n or col < 0:
                return 1
            if move == 0:
                return 0
            move -= 1
            return (
                recursion(move, row, col + 1)
                + recursion(move, row, col - 1)
                + recursion(move, row - 1, col)
                + recursion(move, row + 1, col)
            ) % modulo
        return recursion(maxMove, startRow, startColumn)"
shortest unsorted continuous subarray,"class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        sorted_nums = sorted(nums)
        
        l, u = len(nums) - 1,0
        for i in range(len(nums)):
            if nums[i]!=sorted_nums[i]:
                l=min(l, i)
                u=max(u, i)
        
        
        return 0 if l>=u else u-l+1"
shortest unsorted continuous subarray,"class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        
        l,u = len(nums)-1, 0
        stck=[]
        for i in range(len(nums)):
            while stck and nums[stck[-1]]>nums[i]:
                l = min(l, stck.pop())
            stck.append(i)
        
        stck=[]        
        for i in range(len(nums)-1,-1, -1):
            while stck and nums[stck[-1]]<nums[i]:
                u = max(u, stck.pop())
            stck.append(i)
        
        return 0 if l>=u else u-l+1"
delete operation for two strings,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m,n=len(word1),len(word2)
        @cache
        def lcs(i, j): # find longest common subsequence
            if i==m or j==n:
                return 0            
            return 1 + lcs(i+1, j+1) if word1[i]==word2[j] else  max(lcs(i+1, j), lcs(i,j+1))                               
        # subtract the lcs length from both the strings 
        # the difference is the number of characters that has to deleted
        return m + n - 2*lcs(0,0)"
delete operation for two strings,"class Solution:       
    def minDistance(self, word1: str, word2: str) -> int:
        if len(word1)>len(word2):
            word2,word1=word1,word2        
        
        m,n=len(word1),len(word2)
        prev=[0] * (m+1)
        
        for i in range(n-1, -1, -1):
            curr=[0] * (m+1)
            for j in range(m-1, -1, -1):
                if word1[j] == word2[i]:
                    curr[j]=1 + prev[j+1]
                else:
                    curr[j]=max(curr[j+1], prev[j])
            prev=curr
        return m + n - 2*prev[0]"
erect the fence,"class Solution:
    def outerTrees(self, points: List[List[int]]) -> List[List[int]]:
        """"""
        Use Monotone Chain algorithm.
        """"""
        def is_clockwise(
                p0: List[int], p1: List[int], p2: List[int]) -> bool:
            """"""
            Determine the orientation the slope p0p2 is on the clockwise
            orientation of the slope p0p1.
            """"""
            return (p1[1] - p0[1]) * (p2[0] - p0[0]) > \
                (p2[1] - p0[1]) * (p1[0] - p0[0])

        sortedPoints = sorted(points)

        # Scan from left to right to generate the lower part of the hull.
        hull = []
        for p in sortedPoints:
            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):
                hull.pop()

            hull.append(p)

        if len(hull) == len(points):  # All the points are on the perimeter now.
            return hull

        # Scan from right to left to generate the higher part of the hull.
        # Remove the last point first as it will be scanned again.
        hull.pop()
        for p in reversed(sortedPoints):
            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):
                hull.pop()

            hull.append(p)

        # Pop the first point as it is already added to hull when processing
        # the lower part.
        hull.pop()

        return hull"
erect the fence,"class Solution:
    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:
        

        def check_clockwise(p1,p2,p3):
            
            x1,y1 = p1
            x2,y2 = p2
            x3,y3 = p3
            """"""
            slope of p1 and p2 will be y2-y1/x2-x1
            
            slope of p2 and p3 will be y3-y2/x3-x2
            
            combining them both gives
            
            y3-y2/x3-x2   -   y2-y1/x2-x1 
            
            this eqn represents the resultant formed by those two
            if this is greater than 0 then direction will be counter clockwise else clockwise
            """"""
            return (y3-y2)*(x2-x1)-(y2-y1)*(x3-x2) #return <0 if clockwise
        
        
        trees.sort()
        upper = []
        lower = []
        
        for t in trees:
            
            while len(upper)>1 and check_clockwise(upper[-1],upper[-2],t)>0:
                upper.pop()
            
            while len(lower)>1 and check_clockwise(lower[-1],lower[-2],t)<0:
                lower.pop()
            
            upper.append(tuple(t))
            lower.append(tuple(t))
        
        return list(set(upper+lower))"
n ary tree preorder traversal,"class Solution(object):
    def preorder(self, root):
        # To store the output result...
        output = []
        self.traverse(root, output)
        return output
    def traverse(self, root, output):
        # Base case: If root is none...
        if root is None: return
        # Append the value of the root node to the output...
        output.append(root.val)
        # Recursively traverse each node in the children array...
        for child in root.children:
            self.traverse(child, output)"
n ary tree preorder traversal,"class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        
        def dfs(root, output):
            if not root:
                return None
            output.append(root.val)
            for child in root.children:
                dfs(child, output)
            return output
        
        return dfs(root, [])"
n ary tree postorder traversal,"class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        
        def dfs(node):
            """"""Populate ans via post-order traversal.""""""
            if not node: return 
            for child in node.children: dfs(child)
            ans.append(node.val)
            
        ans = []
        dfs(root)
        return ans"
n ary tree postorder traversal,"class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        ans = []
        stack = [root]
        while stack:
            node = stack.pop()
            if node: 
                ans.append(node.val)
                stack.extend(node.children)
        return ans[::-1]"
tag validator,"class Solution:
    def isValid(self, code: str) -> bool:
        if code[0] != '<' or code[-1] != '>': return False
        i, n = 0, len(code)
        stk = []
        while i < n:
            if code[i] == '<':
                if i != 0 and code[i: i + 9] == '<![CDATA[':
                    if not stk: return False
                    j = i + 9
                    while j + 3 <= n and code[j: j + 3] != ']]>': j += 1
                    if code[j: j + 3] == ']]>': i = j + 3
                    else: return False
                else:
                    start = i
                    isend = False
                    i += 1
                    if i >= n: return False
                    if code[i] == r'/':
                        isend = True
                        i += 1
                    if i >= n: return False
                    tag = ''
                    while i < n and code[i] != '>':
                        if not code[i].isupper(): return False
                        tag += code[i]
                        i += 1
                    if i >= n or len(tag) == 0 or len(tag) > 9: return False
                    if isend:
                        if not stk or stk[-1] != tag: return False
                        stk.pop(-1)
                    else:
                        if start != 0 and not stk: return False
                        stk.append(tag)
                    i += 1
            else:
                if not stk: return False
                while i < n and code[i] != '<': i += 1
        return not stk"
tag validator,"class Solution:
    def isValid(self, code: str) -> bool:
        prefix = suffix = False 
        stack = []
        i = 0 
        while i < len(code): 
            if code[i:i+2] == '</': 
                ii = i = i+2
                for i in range(i, len(code)): 
                    if code[i] == '>': break 
                else: return False 
                if i == len(code)-1: suffix = True 
                tag = code[ii:i]
                if not stack or stack[-1] != tag: return False 
                stack.pop()
                if not stack and not suffix: return False 
            elif code[i:i+3] == '<![': 
                ii = i = i+3
                buffer = 1
                for i in range(i, len(code)): 
                    if code[i] == '[': 
                        if buffer: 
                            buffer = 0 
                            if code[ii:i] != ""CDATA"": return False 
                    elif code[i:i+3] == ']]>': 
                        if buffer: return False 
                        break 
                else: return False 
            elif code[i] == '<': 
                ii = i = i+1
                for i in range(i, len(code)): 
                    if code[i] == '>': break 
                else: return False 
                if ii == 1: prefix = True 
                tag = code[ii:i]
                if not (all(map(str.isupper, tag)) and 1 <= len(tag) <= 9): return False 
                stack.append(tag)
            i += 1
        return prefix and suffix and not stack"
fraction addition and subtraction,"class Solution:
    def fractionAddition(self, exp: str) -> str:
        
        if not exp:
            return ""0/1""
        
        if exp[0] != '-':
            exp = '+' + exp
        
        # Parse the expression to get the numerator and denominator of each fraction
        num = []
        den = []
        pos = True
        i = 0
        while i < len(exp):
            # Check sign
            pos = True if exp[i] == '+' else False
            
            # Get numerator
            i += 1
            n = 0
            while exp[i].isdigit():
                n = n*10 + int(exp[i])
                i += 1
            num.append(n if pos else -n)
            
            # Get denominator
            i += 1
            d = 0
            while i < len(exp) and exp[i].isdigit():
                d = d*10 + int(exp[i])
                i += 1
            den.append(d)
        
        # Multiply the numerator of all fractions so that they have the same denominator
        denominator = functools.reduce(lambda x, y: x*y, den)
        for i,(n,d) in enumerate(zip(num, den)):
            num[i] = n * denominator // d
        
        # Sum up all of the numerator values
        numerator = sum(num)
        
        # Divide numerator and denominator by the greatest common divisor (gcd)
        g = math.gcd(numerator, denominator)
        numerator = numerator // g
        denominator = denominator // g
        
        return f""{numerator}/{denominator}"""
fraction addition and subtraction,"class Solution:
    def fractionAddition(self, expression: str) -> str:
        pairs, cur, sign, multiple = [], '', 0, 1
        for c in expression+'+':
            if not sign:
                if c == '-': sign = -1
                else: sign, cur = 1, cur + c
            elif c in '-+':
                left, right = cur.split('/')
                pairs.append((abs(int(left)) * sign, abs(int(right))))
                multiple *= pairs[-1][1]
                sign, cur = -1 if c == '-' else 1, ''
            else: cur += c
        s = sum([n * multiple // d for n, d in pairs])
        def gcd(a, b):
            while b: a, b = b, a % b
            return abs(a)                
        divisor = gcd(s, multiple)
        return f'{s//divisor}/{multiple//divisor}'"
valid square,"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
        def dist(point1,point2):
            return (point1[0]-point2[0])**2+(point1[1]-point2[1])**2
            
        D=[
        dist(p1,p2),
        dist(p1,p3),
        dist(p1,p4),
        dist(p2,p3),
        dist(p2,p4),
        dist(p3,p4)
        ]
        D.sort()
        return 0<D[0]==D[1]==D[2]==D[3] and D[4]==D[5]"
valid square,"class Solution:
    def validSquare(self, p1, p2, p3, p4) :
        def f(p1, p2, p3) :
            l = sorted([(p1[0]-p2[0])**2+(p1[1]-p2[1])**2, (p1[0]-p3[0])**2+(p1[1]-p3[1])**2, (p3[0]-p2[0])**2+(p3[1]-p2[1])**2])
            return l[0]+l[1]==l[2] and l[0]==l[1]!=0
        return f(p1,p2,p3) and f(p2,p3,p4) and f(p3,p4,p1)"
longest harmonious subsequence,"class Solution:
	def findLHS(self, nums: List[int]) -> int:
		tmp = Counter(nums)
		keys = tmp.keys()
		max = 0
		for num in keys:
			if num - 1 in keys:
				if tmp[num - 1] + tmp[num] > max:
					max = tmp[num - 1] + tmp[num]
		return max"
longest harmonious subsequence,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        s = Counter(nums)
        l = 0
        for i in s:
            if i+1 in s:
                l = max(s[i]+s[i+1],l)
        return l"
range addition ii,"class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        min_row = m
        min_col = n
        for i in range(len(ops)):
            min_row=min(min_row, ops[i][0])
            min_col=min(min_col, ops[i][1])
        return min_row*min_col"
range addition ii,"class Solution:
    def maxCount(self, m: int, n: int, p: List[List[int]]) -> int:
    	return min([i[0] for i in p])*min(i[1] for i in p) if p else m*n
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
minimum index sum of two lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        d = {}
        d2 = {}
        min_ = 5000
        ret = []

        for i in range(len(list1)):
            d[list1[i]] = i+1

        for i in range(len(list2)):
            a = d.get(list2[i], 0)
            if a:
                b = a+i-1
                if b <= min_:
                    min_ = b
                    d2[list2[i]] = b

        for k,v in d2.items():
            if v <= min_:
                ret.append(k)

        return ret"
minimum index sum of two lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        list3 = set(list1) &amp; set(list2)
        m, v = 3000, []
        for i in list3:
            s = list1.index(i) + list2.index(i)
            if m > s:
                v = [i]
                m = s
            elif m == s:
                v.append(i)
        return v"
non negative integers without consecutive ones,"class Solution:
    def findIntegers(self, n: int) -> int:
        # f stores the fibonacci numbers
        f = [1, 2]
        for i in range(2, 30):
            f.append(f[-1]+f[-2])
        
        # last_seen tells us if there was a one right before. 
        # If that is the case, we are done then and there!
        # ans is the answer
        ans, last_seen = 0, 0
        for i in reversed(range(30)):
            if (1 << i) &amp; n: # is the ith bit set?
                ans += f[i]
                if last_seen: 
                    ans -= 1
                    break
                last_seen = 1
            else:
                last_seen = 0
        return ans+1"
non negative integers without consecutive ones,"class Solution:
    def findIntegers(self, n: int) -> int:
        fib = [1, 2]
        for _ in range(30): fib.append(fib[-2] + fib[-1])
        
        ans = prev = 0
        for i in range(31, -1, -1): 
            if n &amp; (1<<i): 
                ans += fib[i]
                if prev: return ans
                else: prev = 1
            else: prev = 0
        return ans + 1"
can place flowers,"class Solution:
    def canPlaceFlowers(self, f: List[int], n: int) -> bool:
        L, i, c, f = len(f)-2, -2, 0, f + [0]
        while i < L:
        	i += 2
        	if f[i] == 1: continue
        	if f[i+1] == 0: c += 1
        	else: i += 1
        return n <= c
		
		
		
		
class Solution:
    def canPlaceFlowers(self, f: List[int], n: int) -> bool:
    	L, f, i, c = len(f), [0] + f + [0], 1, 0
    	while i <= L:
    		if f[i-1:i+2] == [0,0,0]: c, i = c + 1, i + 1
    		i += 1
    	return n <= c
		
		
		
		
class Solution:
    def canPlaceFlowers(self, f: List[int], n: int) -> bool:
    	L, f, s, c = len(f), f + [0,1], 0, 1
    	for i in range(L+2):
    		if f[i] == 1: s, c = s + max(0,c-1)//2, 0
    		else: c += 1
    	return n <= s
		
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
can place flowers,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        l=[0]+flowerbed+[0]
        for i in range(1,len(l)-1):
            if sum(l[i-1:i+2])==0:
                l[i]=1
                n-=1 
        return n<=0"
construct string from binary tree,"class Solution:
    def tree2str(self, t: TreeNode) -> str:
        sb = [] # init string builder
        
        # helper function to create result
        def helper(node: TreeNode) -> None: 
            if not node:
                return
            
            sb.append(str(node.val))
            
            if not node.left and not node.right:
                # leaf node, stop processing
                return
            
            sb.append('(')          # always wrap left node with parenthesis when right node exist
            helper(node.left)       # process left node recursively 
            sb.append(')')                         

            if node.right:          # adding parenthesis for the right node only if it is not empty
                sb.append('(')
                helper(node.right)
                sb.append(')') 
        
        helper(t)

        return ''.join(sb)"
construct string from binary tree,"class Solution:
    def tree2str(self, t: TreeNode) -> str:
        sb = [] # init string builder
        
        # helper function to create result
        def helper(node: TreeNode) -> None:
            if not node:
                return
            
            sb.append('(')                      # add 1st wrapping parenthesis
            sb.append(str(node.val))
            
            helper(node.left)                   # process left recursively
            
            if not node.left and node.right:    # add parenthesis if left is empty but right exists
                sb.append('()')
                
            helper(node.right)                  # process right recursively
            
            sb.append(')')                      # add 2nd wrapping parenthesis
        
        helper(t)

        # trim 1st and last parenthesis build result string
        return ''.join(sb[1:-1])"
find duplicate file in system,"class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        m = defaultdict(list)
        for p in paths:
            # 1. split the string by ' '
            path = p.split()
            # the first string is the directory path
            # the rest of them are just file names with content
            directoryPath, rest = path[0], path[1:]
            # for each file names with content
            for f in rest:
                # we retrieve the file name and the file content
                fileName, fileContent = f.split('(')[0], f.split('(')[1][:-1]
                # then group {directoryPath}/{fileName} by file content
                m[fileContent].append(""{}/{}"".format(directoryPath, fileName))
        # return the file list only when the size is greater than 1, meaning they are duplicate files
        return [m[k] for k in m.keys() if len(m[k]) > 1]"
find duplicate file in system,"class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        dic = {}
        duplicateFiles=[]
        for filePath in paths:
            fileNames = filePath.split() #Split the path to filenames
            directoryPath = fileNames[0] #To take only the directory from the given filePath
            for file in fileNames[1:]: #traverse through each file
                fileName,fileContent = file[:file.index('(')],file[file.index('('):-1]#To get fileName and fileContent
                if fileContent not in dic:# if the content not in dic make an empty list for that particular key
                    dic[fileContent] = []
                dic[fileContent].append(directoryPath+'/'+fileName)#Just append the value of the key in the dictionary every key has a list of fileNames
        for value in dic.values():
            if len(value)>1: #Append only if the len the values in the Dictionary is > 1
                duplicateFiles.append(value)
        return duplicateFiles[::-1] #To generate the output as it is in the expected I have used [::-1]"
valid triangle number,"class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        ans = 0
        for i in range(len(nums)): 
            lo, hi = 0, i-1
            while lo < hi: 
                if nums[lo] + nums[hi] > nums[i]:
                    ans += hi - lo 
                    hi -= 1
                else: lo += 1
        return ans"
valid triangle number,"class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        ans = 0
        for i in range(len(nums)):
            k = i+2
            for j in range(i+1, len(nums)):
                while k < len(nums) and nums[i] + nums[j] > nums[k]: k += 1
                if j < k: ans += k-1-j
        return ans"
merge two binary trees,"class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1: return root2
        if not root2: return root1
        queue = deque([(root1, root2)])
        while queue:
            current_root1, current_root2 = queue.pop()
            if current_root1.left and current_root2.left: queue.append((current_root1.left, current_root2.left))
            elif not current_root1.left: current_root1.left = current_root2.left
            if current_root1.right and current_root2.right: queue.append((current_root1.right, current_root2.right))
            elif not current_root1.right: current_root1.right = current_root2.right
            current_root1.val += current_root2.val
        return root1"
merge two binary trees,"class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1: return root2
        if not root2: return root1
        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        return root1"
task scheduler,"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        cnt = [0] * 26
        for i in tasks: cnt[ord(i) - ord('A')] += 1
        mx, mxcnt = max(cnt), 0
        for i in cnt: 
            if i == mx: mxcnt += 1
        return max((mx - 1) * (n + 1) + mxcnt, len(tasks))"
task scheduler,"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        counter = dict()
        for task in tasks:
            counter[task] = counter.get(task, 0) + 1
        
        # create a max heap of the frequency
        # of the task occuring using the map
        hq = list()
        for task, count in counter.items():
            heappush(hq, (-count, task))
        
        time = 0
        while hq:
            tmp = []
            for _ in range(n+1): # units are inclusive hence n+1
                # add all tasks to the temp list
                # if there are tasks to be processed
                # in the queue, note that for this n
                # cycles, we're not pushing processed
                # items back in the queue but rather in the
                # tmp list so that they don't appear before n
                # cycles have been passed.
                if hq: tmp.append((heappop(hq)))
                
            # but once we've done n cycles from the
            # queue, we can safely add the processed
            # tasks back to the queue to be processed
            # again if they have repititions left (count)
            for count, task in tmp:
                if count+1 < 0: heappush(hq, (count+1, task))
            
            # for every cycle, we will add n+1 cycles to the total
            # time because that's the max number of cycles you can
            # perform at a time without repeating characters
            # BUT for the last few tasks, there can be <n tasks
            # in the queue and we would've put them inside tmp
            # so only in that case, we'll check if queue is empty
            # and if so, we'll add len(tmp) to the overall time
            time += len(tmp) if not hq else n+1
                
        return time"
add one row to tree,"class Solution:
    def addOneRow(self, root: TreeNode, v: int, d: int, side = ""left"") -> TreeNode:
        if d == 1:
            res = TreeNode(v)
            setattr(res, side, root)
            return res
        if root:
            root.left = self.addOneRow(root.left, v, d - 1)
            root.right = self.addOneRow(root.right, v, d - 1, 'right')
        return root"
add one row to tree,"class Solution:
    def addOneRow(self, root: TreeNode, v: int, d: int) -> TreeNode:
        if d == 1: return TreeNode(v, left=root) # edge case 
        
        def fn(node, d): 
            if d == 1: 
                node.left = TreeNode(v, left=node.left)
                node.right = TreeNode(v, right=node.right)
            if node.left: node.left = fn(node.left, d-1)
            if node.right: node.right = fn(node.right, d-1)
            return node 
        
        return fn(root, d-1)"
maximum product of three numbers,"class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        max1 = max2 = max3 = float(""-inf"")
        min1 = min2 = float(""inf"")
        
        for num in nums: 
            if num > max1:
                max1, max2, max3 = num, max1, max2
            elif num > max2:
                max2, max3 = num, max2
            elif num > max3:
                max3 = num
                
            if num < min1:
                min1, min2 = num, min1
            elif num < min2:
                min2 = num
        
        return max(max2*max3, min1*min2) * max1"
maximum product of three numbers,"class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        nums.sort()
        return max(nums[0]*nums[1]*nums[-1], nums[-3]*nums[-2]*nums[-1])"
k inverse pairs array,"class Solution:
                        # A very good description of the dp solution is at
                        # https://leetcode.com/problems/k-inverse-pairs-array/solution/ 
                        # The code below uses two 1D arrays--dp and tmp--instead if a 
                        # 2D array. tmp replaces dp after each i-iteration.
    def kInversePairs(self, n: int, k: int) -> int:
        dp, mod = [1]+[0] * k, 1000000007
        
        for i in range(n):
            tmp, sm = [], 0
            for j in range(k + 1):
                sm+= dp[j]
                if j-i >= 1: sm-= dp[j-i-1]
                sm%= mod
                tmp.append(sm)
            dp = tmp
            #print(dp)       # <-- uncomment this line to get a sense of dp from the print output
			                 #     try n = 6, k = 4; your answer should be 49.
        return dp[k]"
k inverse pairs array,"class Solution:
		def kInversePairs(self, n: int, k: int) -> int:
			m = 10 ** 9 + 7

			dp0 = [0] * (k + 1)
			dp0[0] = 1

			for i in range(n):
				dp1 = []
				s = 0
				for j in range(k + 1):
					s += dp0[j]
					if j >= i + 1:
						s -= dp0[j - i - 1]
					s %= m
					dp1.append(s)
				dp0 = dp1

			return dp0[-1]"
course schedule iii,"class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        courses.sort(key=lambda c: c[1])
        A, curr = [], 0
        for dur, ld in courses:
            heapq.heappush(A,-dur)
            curr += dur
            if curr > ld: curr += heapq.heappop(A)
        return len(A)"
course schedule iii,"class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
		#sorts the course according to the 2nd index of all elements in the list
        courses.sort(key = lambda x:x[1])
        #print(courses) #to visualize the code after sorting it
        maxHeap = [] # to store the negative values of the courses of index to understand more watch the image attached you will get more clarification
		# to count the courses and to add the total Sum
        cnt,totSum = 0,0 
		#traverse the loop upto length of the courses
		for i in range(len(courses)): 
			#push the negative value of the courses[i][0] into maxHeap
            heappush(maxHeap,-1*courses[i][0])
			#calculate the total number of courses to total Sum and increment the count by 1
            totSum += courses[i][0]
            cnt += 1
            #print(maxHeap) #Just to see the elements present in max heap
			#if total sum exceeds before the loop ends then heap comes into action to find the exact count
            if totSum > courses[i][1]:
				#Now negative value in the heap gets poped out and added to the total Sum and the count is decremented by 1.
                totSum += heappop(maxHeap)
                cnt -= 1
        return cnt"
smallest range covering elements from k lists,"class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        k=len(nums)
        maxx=-float('inf')
        ans=[0,float('inf')]
        heap=[]
        for i in range(k):
            heap.append((nums[i][0],i,0))
            if nums[i][0]>maxx:maxx=nums[i][0]
        heapq.heapify(heap)
        while True:
            val,row,col= heapq.heappop(heap)
            tmp=maxx-val
            if tmp<ans[1]-ans[0]:ans=[val,maxx]
            elif tmp==ans[1]-ans[0] and val<ans[0]:ans=[val,maxx]
            if col+1==len(nums[row]):break        
            if nums[row][col+1]>maxx:maxx=nums[row][col+1]
            heapq.heappush(heap,(nums[row][col+1],row,col+1))
        return ans"
smallest range covering elements from k lists,"class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        h = [] # min heap, keeps track of current range that fits 1+ numbers from all lists
        lower, upper = float('inf'), float('-inf') # min and max of the current range

        # initialize current range
        for i, l in enumerate(nums):
            heapq.heappush(h, (l[0], i, 0)) # num, list index, element index
            lower, upper = min(lower, l[0]), max(upper, l[0])
        res = [lower, upper]

        while True:

            # pop smallest element in current range
            num, i, j = heapq.heappop(h)

            # exhausted all elements from the list of the popped element
            if j+1 == len(nums[i]):
                break

            # add the next element from the list of the popped element
            heapq.heappush(h, (nums[i][j+1], i, j+1))

            # get min and max of the new current range
            lower, upper = h[0][0], max(upper, nums[i][j+1])

            # update range if the current range is smaller
            if upper - lower < res[1] - res[0]:
                res = [lower, upper]

        return res"
sum of square numbers,"class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        low = 0
        high = int(sqrt(c))
        
        if high**2 == c:
            return True
        
        while low<=high:
            x = low **2 + high **2
            if x == c:
                return True
            if x > c:
                high-=1
            else:
                low+=1
        return False"
sum of square numbers,"class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        first=0
        last=int(sqrt(c))
        if c<=2:
            return True
        
        while first<=last:
            k=(first*first) + (last*last) 
            if k==c:
                return True
            elif k<c:
                first=first+1
            else:
                last=last-1
        return False
		
		# we can know that those two nums will be in the         
	    # range of 0,sqrt(num) inclusive"
exclusive time of functions,"class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        helper = lambda log: (int(log[0]), log[1], int(log[2])) # to covert id and time to integer
        logs = [helper(log.split(':')) for log in logs]         # convert [string] to [(,,)]
        ans, s = [0] * n, []                                    # initialize answer and stack
        for (i, status, timestamp) in logs:                     # for each record
            if status == 'start':                               # if it's start
                if s: ans[s[-1][0]] += timestamp - s[-1][1]     # if s is not empty, update time spent on previous id (s[-1][0])
                s.append([i, timestamp])                        # then add to top of stack
            else:                                               # if it's end
                ans[i] += timestamp - s.pop()[1] + 1            # update time spend on `i`
                if s: s[-1][1] = timestamp+1                    # if s is not empty, udpate start time of previous id; 
        return ans"
exclusive time of functions,"class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        
        
        f = [0]*(n)
        
        
        stack=[]
        
        
        for i in logs:
            
            ID,pos,time = i.split(':')
            
            ID= int(ID)
            time= int(time)
            if pos == 'start':
                
                stack.append([ID,time])
            else:
                
                prID, prtime = stack.pop()
                
                timespent = time-prtime+1
                f[ID]+= timespent
                
                #remove the overlapping time 
                
                if stack:
                    f[stack[-1][0]]-= timespent
                    
        return f"
average of levels in binary tree,"class Solution:
    def averageOfLevels(self, root: TreeNode) -> List[float]:
        
        if not root:
            
            # Quick response for empty tree
            return []
        
        traversal_q = [root]
        
        average = []
        
        while traversal_q:
            
            # compute current level average
            cur_avg = sum( (node.val for node in traversal_q if node) ) / len(traversal_q)
            
            # add to result
            average.append( cur_avg )
            
            # update next level queue
            next_level_q = [ child for node in traversal_q for child in (node.left, node.right) if child ]
            
            # update traversal queue as next level's
            traversal_q = next_level_q
            
        return average"
average of levels in binary tree,"class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        
		#starting here, the next ~8 lines are how I do bfs recursively.
        levels = []
        def bfs(node, level):
            if node:
                if len(levels) == level: levels.append([])
                levels[level] += [node.val]
                bfs(node.left, level+1)
                bfs(node.right, level+1)
        
        bfs(root, 0)
	# after that, just return the averages in a list.
        return [sum(i)/len(i) for i in levels]"
shopping offers,"class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        n = len(price)
        @lru_cache(maxsize=None)
        def dfs(needs):
            ans = sum([i*j for i, j in zip(price, needs)]) 
            cur = sys.maxsize
            for s in special:
                new_needs, ok = [], True
                for i in range(n):
                    need, give = needs[i], s[i]
                    if need < give:  # if over purchase, ignore this combination
                        ok = False
                        break
                    new_needs.append(need-give)    
                if ok: cur = min(cur, dfs(tuple(new_needs)) + s[-1])
            return min(ans, cur)
        return dfs(tuple(needs))"
shopping offers,"class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        
        @lru_cache(None)
        def fn(*args): 
            """"""Return the lowest price one has to pay to get items in args.""""""
            ans = sum(x*y for x, y in zip(args, price))
            for offer in special: 
                if all(x >= y for x, y in zip(args, offer)):
                    ans = min(ans, fn(*(x-y for x, y in zip(args, offer))) + offer[-1])
            return ans 
            
        return fn(*needs)"
decode ways ii,"class Solution:
    def numDecodings(self, s: str) -> int:
        non_zero = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        first_incl, second_incl = 1, 0
        first_excl, second_excl = 0, 0
        
        if s[0] in non_zero:
            second_incl = 1
        if s[0] == '*':
            second_incl = 9
            
        for i in range(1, len(s)):
            new_incl, new_excl = 0, 0
            if s[i] == '*':
                new_incl = 9 * (second_incl + second_excl)
                
                if s[i-1] == '1':
                    # number is of type (1, *)
                    new_excl = 9 * (first_incl + first_excl)
                    
                elif s[i-1] == '2':
                    # number is of type (2, *)
                    new_excl = 6 * (first_incl + first_excl)
                    
                elif s[i-1] == '*':
                    # number is of type (*, *)
                    new_excl = 15 * (first_incl + first_excl)
            else:
                if s[i] in non_zero:
                    new_incl = second_incl + second_excl
                        
                if s[i-1] == '*':
                    # number is of type (*,digit)
                    if int(s[i]) <= 6:
                        new_excl = 2 * (first_excl + first_incl)
                    else:
                        new_excl = first_incl + first_excl
                        
                else:
                    # number is of type (digit,digit)
                    val = int(s[i-1:i+1])
                    if 10 <= val <= 26:
                        new_excl = first_incl + first_excl
                    else:
                        new_excl = 0
            first_incl, first_excl = second_incl, second_excl
            second_incl, second_excl = new_incl, new_excl
        return (second_incl + second_excl) % (10**9 + 7)"
decode ways ii,"class Solution:
    def numDecodings(self, s: str) -> int:
        
        @cache 
        def fn(i): 
            """"""Return decode ways.""""""
            if i == len(s): return 1 
            if s[i] == ""0"": return 0 
            if i == len(s)-1: return 9 if s[i] == '*' else 1
            if s[i] == ""*"": 
                ans = 9*fn(i+1)
                if s[i+1] == ""*"": ans += 15*fn(i+2)
                else: 
                    ans += fn(i+2)
                    if s[i+1] <= ""6"": ans += fn(i+2)
            else: 
                ans = fn(i+1)
                if s[i+1] == ""*"": 
                    if s[i] == ""1"": ans += 9*fn(i+2)
                    elif s[i] == ""2"": ans += 6*fn(i+2)
                elif int(s[i:i+2]) <= 26: ans += fn(i+2)
            return ans % 1_000_000_007
        
        return fn(0)"
solve the equation,"class Solution:
    def solveEquation(self, equation: str) -> str:
        def helper(l,r): # left inclusive and right exclusive
            constant = unknown = 0
            sign,val = 1,''
            while l < r:
                if equation[l].isnumeric():
                    val += equation[l]
                elif equation[l] == 'x':
                    unknown += sign*int(val or '1') # in case the coefficient is 1
                    val = ''
                else: # meet a +/-
                    if val:
                        constant += sign*int(val)
                    sign = 1 if equation[l]=='+' else -1
                    val = ''
                l += 1
            if val: # if the last digit is a number
                constant += sign*i
            return constant,unknown
    
        mid = equation.find('=')
        constant1,unknown1 = helper(0,mid)
        constant2,unknown2 = helper(mid+1,len(equation))
        const,var = constant2-constant1,unknown1-unknown2
        # print(a,b)
        if var == 0:
            if const == 0: return ""Infinite solutions""
            else: return ""No solution""
        else: return 'x={}'.format(const//var)"
solve the equation,"class Solution:
    def solveEquation(self, equation: str) -> str:
        left, right = equation.split('=')
        def simplify(s):
            x_cnt, c_cnt, cur, sign = 0, 0, '', 1
            for c in s + '+':             # adding `+` to process the last term of `s`, since sign is a trigger 
                if c in '-+':             # use sign as a trigger
                    if not cur:           # handle edge case: leading `-` (e.g. ""-x=-1"")
                        sign = -1 if s[0] == '-' else 1
                    elif cur[-1] == 'x':  # if `cur` is a term of `x`
                        x_cnt += sign * (int(cur[:-1]) if cur[:-1] else 1)
                    else:                 # if `cur` is a constant term
                        c_cnt += sign * int(cur)
                    sign, cur = 1 if c == '+' else -1, '' # get new `sign` &amp; reset `cur`
                else: cur += c            # other situation, append char to `cur`
            return x_cnt, c_cnt           # return #_of_x and #_of_constant 
        (x1, c1), (x2, c2) = simplify(left), simplify(right)
        if c2-c1 == x1-x2 == 0: return 'Infinite solutions'
        elif x1-x2 == 0: return 'No solution'
        else: return f'x={(c2-c1)//(x1-x2)}'"
maximum average subarray i,"class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
    	M = d = 0
    	for i in range(len(nums)-k):
    		d += nums[i+k] - nums[i]
    		if d > M: M = d
    	return (sum(nums[:k])+M)/k
		
		
- Python 3
- Junaid Mansuri"
maximum average subarray i,"class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        g=sum(nums[:k])
        m=g
        for i in range(len(nums)-k):
            g=g-nums[i]+nums[i+k]
            m=max(m,g)
        return m/k"
set mismatch,"class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        c=Counter(nums)
        l=[0,0]
        for i in range(1,len(nums)+1):
            if c[i]==2:
                l[0]=i
            if c[i]==0:
                l[1]=i
        return l"
set mismatch,"class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        n = len(nums)
        true_sum = n*(n+1)//2
        actual_sum = sum(nums)
        set_sum = sum(set(nums))
        return [actual_sum - set_sum, true_sum - set_sum]"
maximum length of pair chain,"class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort()
        rt = 1
        l = pairs[0]
        for r in range(1,len(pairs)):
            if l[1] < pairs[r][0]:
                rt += 1 
                l = pairs[r]
            elif pairs[r][1]<l[1]:
                l = pairs[r]
        return rt"
maximum length of pair chain,"class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort()
        dp=[1 for i in range(len(pairs))]
        dp[0]=1
        for i in range(1,len(pairs)):
            for j in range(i-1,-1,-1):
                if pairs[i][0]>pairs[j][1]:
                    dp[i]=max(dp[i],dp[j]+1)
        return dp[len(pairs)-1]"
palindromic substrings,"class Solution:
    def countSubstrings(self, s: str) -> int:
	    L, r = len(s), 0
	    for i in range(L):
	    	for a,b in [(i,i),(i,i+1)]:
	    		while a >= 0 and b < L and s[a] == s[b]: a -= 1; b += 1
	    		r += (b-a)//2
	    return r
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
palindromic substrings,"class Solution:    
    def expandAndCountPallindromes(self, i, j, s):
        '''Counts the number of pallindrome substrings from a given center i,j        
        1. when i=j, it's an odd-lengthed pallindrome string. 
            eg: for string ""aba"", i=j=1.
        2. when i+1=j, it's an even-lengthed pallindrome string. 
            eg: for string ""abba"", i=1, j=2.
        
        Parameters:
            i,j - centers from which the code will expand to find number of pallindrome substrings.
            s - the string in which the code needs to find the pallindrome substrings. 
        
        Returns:
            cnt - The number of pallindrome substrings from the given center i,j       
        '''
        
        length=len(s)
        cnt=0
        
        while 0<=i and j<length and s[i]==s[j]:
            i-=1
            j+=1
            cnt+=1
        
        return cnt
        
    def countSubstrings(self, s: str) -> int:
        
        return sum(self.expandAndCountPallindromes(i,i,s) + self.expandAndCountPallindromes(i,i+1,s) for i in range(len(s)))"
replace words,"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        d = {w:len(w) for w in dictionary}
        mini, maxi = min(d.values()), max(d.values())
        wd = sentence.split()
        rt = []
        for s in wd:
            c = s 
            for k in range(mini,min(maxi,len(s))+1):
                ss = s[:k]
                if ss in d:
                    c = ss 
                    break 
            rt.append(c)
        return "" "".join(rt)"
replace words,"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        
        sentence = sentence.split()
        
        operated = []
        
        for word in dictionary :
            k = len(word)
            for i in range(len(sentence)):
                if sentence[i][:k] == word :
                    if i not in operated :
                        sentence[i] = word
                        operated.append(i)
                    else:
                        if len(word) < len(sentence[i]) :
                            sentence[i] = word 
        return "" "".join(sentence)"
dota2 senate,"class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        n = len(senate)
        s, banned = set(), [False] * n
        ban_d = ban_r = 0
        while len(s) != 1:
            s = set()
            for i, p in enumerate(senate):
                if banned[i]: continue
                if p == 'R':
                    if ban_r > 0:           # current R being banned
                        ban_r -= 1
                        banned[i] = True
                    else:                   # if current R is valid, it will ban D
                        ban_d += 1
                        s.add('R')
                else:        
                    if ban_d > 0:           # current D being banned
                        ban_d -= 1
                        banned[i] = True
                    else:                   # if current D is valid, it will ban R
                        ban_r += 1
                        s.add('D')
        return 'Radiant' if s.pop() == 'R' else 'Dire'"
dota2 senate,"class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiant, dire = deque(), deque()
        for i, x in enumerate(senate): 
            if x == ""R"": radiant.append(i)
            else: dire.append(i)
        while radiant and dire: 
            if radiant[0] < dire[0]: 
                radiant.append(radiant.popleft()+len(senate))
                dire.popleft()
            else: 
                radiant.popleft()
                dire.append(dire.popleft()+len(senate))
        return ""Radiant"" if radiant else ""Dire"""
2 keys keyboard,"class Solution:
    def minSteps(self, n: int) -> int:
        
        dp = [float('inf')] * (n+1)	
		## Intialize a dp array to store the solutions of sub problems i.e. number of steps needed
	
        dp[1] = 0
		## Intially first element of dp array with 0 as 'A' is already present and we haven't consumed any steps yet. 
		## As the value of n is from [1,3000] and initally 'A' is already present so we don't need to bother about the dp[0]
        
        divisors = []
		## This is to store the divisors of N
		
        for i in range(1, n//2 + 1):
            if n % i == 0:
                divisors.append(i)
		## We have stored all the divisors. For n = 10, divisors = [1,2,5]
        
        for j in divisors:
            dp[j] += 1
			##To copy the current number of A's, we add one step
			
            for i in range(j+1, n+1):
                if i % j == 0:
				## We can only form the string length which is divisible by j 
                    dp[i] = min(dp[i], dp[i-j] + 1)
					## Compare with previous number of steps and update with the minimum
        return dp[-1]
		#Return last value of dp i.e. N"
2 keys keyboard,"class Solution:
    def minSteps(self, n: int) -> int:
        cache = {}
        def helper(screen, clipboard):
            if (screen, clipboard) in cache: return cache[(screen, clipboard)]
            if screen == n: return 0
            if screen > n: return float(""Inf"")
            
            copy_paste = helper(screen+screen, screen) + 2
            paste = float(""Inf"")
            if clipboard:
                paste = helper(screen + clipboard, clipboard) + 1

            cache[(screen, clipboard)] = min(copy_paste, paste)    
            return cache[(screen, clipboard)]
        
        return helper(1, 0)"
find duplicate subtrees,"class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        
        seen = collections.defaultdict(int)
        res = []
        
        def helper(node):
            if not node:
                return
            sub = tuple([helper(node.left), node.val, helper(node.right)])
            if sub in seen and seen[sub] == 1:
                res.append(node)
            seen[sub] += 1
            return sub
        
        helper(root)
        return res"
find duplicate subtrees,"class Solution:
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        mapped = {}
        ans = set()
        def duplicated(node):
            if not node:
                return '#'
            s = ''
            if not node.left and not node.right:
                s += str(node.val)
                mapped[s] = mapped.get(s,0)+1
                if mapped[s]==2:
                    ans.add(node)
                return s
            s  = s + str(node.val)
            s = s + "","" + duplicated(node.left)
            s = s+ "","" + duplicated(node.right)
            mapped[s]  = mapped.get(s,0)+1
            if mapped[s]==2:
                ans.add(node)
            return s
        
        duplicated(root)
        return ans"
two sum iv input is a bst,"class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        queue = [root]
        unique_set = set()
        
        while len(queue) > 0:
            current = queue.pop()
            if k - current.val in unique_set: return True
            unique_set.add(current.val)
            if current.left: queue.append(current.left)
            if current.right: queue.append(current.right)
        
        return False"
two sum iv input is a bst,"class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        def inorder(node: TreeNode):
            if node:
                yield from inorder(node.left)
                yield node.val
                yield from inorder(node.right)
        
        arr = [x for x in inorder(root)]
        i = 0
        j = len(arr) - 1
        
        while i < j:
            if arr[i] + arr[j] == k: return True
            if arr[i] + arr[j] < k: i += 1
            if arr[i] + arr[j] > k: j -= 1
            
        return False"
maximum binary tree,"class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        
        # base case
        if not nums:
            return None
        
        max_val = max(nums)
        max_idx = nums.index(max_val)
        root = TreeNode(max_val)
        
        root.left = self.constructMaximumBinaryTree(nums[:max_idx])
        root.right = self.constructMaximumBinaryTree(nums[max_idx+1:])
        
        return root"
maximum binary tree,"class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if not nums: return # boundary condition 
        i = nums.index(max(nums))
        return TreeNode(nums[i], left=self.constructMaximumBinaryTree(nums[:i]), right=self.constructMaximumBinaryTree(nums[i+1:]))"
print binary tree,"class Solution:
    def printTree(self, root: TreeNode) -> List[List[str]]:
        height = 0
        def dfs(node, h):                               # Find height
            nonlocal height
            height = max(height, h)
            if node.left:
                dfs(node.left, h+1)
            if node.right:    
                dfs(node.right, h+1)
        dfs(root, 0)
        n = 2 ** (height + 1) - 1                       # Get `n`
        offset = (n - 1) // 2                           # Column for root node
        ans = [[''] * n for _ in range(height + 1)]
        q = [(root, 0, offset)]
        for i in range(height+1):                       # BFS
            tmp_q = []
            while q:
                cur, r, c = q.pop()
                ans[r][c] = str(cur.val)
                if cur.left:
                    tmp_q.append((cur.left, r+1, c-2 ** (height - r - 1)))
                if cur.right:    
                    tmp_q.append((cur.right, r+1, c+2 ** (height - r - 1)))
            q = tmp_q
        return ans"
print binary tree,"class Solution:
    def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:
        height = self.height(root) - 1
        m, n = height + 1, 2 ** (height + 1) - 1
        res = [[''] * n for _ in range(m)]
        
        def helper(root, r, c):
            if root is None:
                return
            
            res[r][c] = str(root.val)
            x = 2 ** (height - r - 1)
            helper(root.left, r + 1, c - x)
            helper(root.right, r + 1, c + x)
        
        helper(root, 0, (n - 1) // 2)
        return res
    
    def height(self, root):
        if root is None:
            return 0
        
        return 1 + max(self.height(root.left), self.height(root.right))"
robot return to origin,"class Solution:
    def judgeCircle(self, moves: str) -> bool:
        return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')


- Python 3
- Junaid Mansuri"
robot return to origin,"class Solution:
    def judgeCircle(self, m: str) -> bool:
        return m.count(""D"") == m.count(""U"") and m.count(""R"") == m.count(""L"")"
find k closest elements,"class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
		# first binary search where the value 'x' should be in the sorted array
        n = len(arr)
        low, high = 0, n - 1
        while low <= high:
            mid = low + (high - low) // 2
            if arr[mid] == x:
                start, end = mid - 1, mid + 1
                k -= 1
                break
            elif arr[mid] < x:
                low = mid + 1
            else:
                high = mid - 1
                
        if low > high:
            start = high
            end = low
        #  after we found where 'x' should be in the sorted array we expand to the left and to the right to find the next values until k (using two pointers start, end)
        while k > 0:
            if start == -1:
                end += 1
            elif end == n:
                start -= 1
            else:
                if abs(arr[start] - x) <= abs(arr[end] - x):
                    start -= 1
                else:
                    end += 1
            k -= 1
        return arr[start + 1:end]"
find k closest elements,"class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        left=0
        right=len(arr) - 1
        while right-left+1 > k:
            if  abs(x-arr[left]) > abs(x-arr[right]):
                left+=1
            else:
                right-=1
        return arr[left:right+1]

# time and space complexity 
# time: O(n)
# space: O(1)"
split array into consecutive subsequences,"class Solution:
		def isPossible(self, nums: List[int]) -> bool:
			len1 = len2 = absorber = 0
			prev_num = nums[0] - 1
			for streak_len, streak_num in Solution.get_streaks(nums):
				if streak_num == prev_num + 1:
					spillage = streak_len - len1 - len2
					if spillage < 0:
						return False
					absorber = min(absorber, spillage)
					len1, len2, absorber = spillage - absorber, len1, absorber + len2
				else:
					if len1 or len2:
						return False
					absorber = 0
				prev_num = streak_num
			return len1 == len2 == 0

		@staticmethod
		def get_streaks(nums: List[int]):
			streak_num = nums[0]
			streak_len = 0
			for num in nums:
				if num == streak_num:
					streak_len += 1
				else:
					yield streak_len, streak_num
					streak_num = num
					streak_len = 1
			yield streak_len, streak_num"
split array into consecutive subsequences,"class Solution:
			def isPossible(self, nums: List[int]) -> bool:
				counter = collections.Counter(nums)
				for i in sorted(counter.keys()):
					while counter[i] > 0:
						last = 0
						j = i
						k = 0
						while counter[j] >= last:
							last = counter[j]
							counter[j] -= 1
							j += 1
							k += 1
						if k < 3:
							return False
				return True"
image smoother,"class Solution:
    def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:
        row, col = len(M), len(M[0])
        res = [[0]*col for i in range(row)]
        dirs = [[0,0],[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[-1,1],[1,-1]]
        for i in range(row):
            for j in range(col):
                temp = [M[i+m][j+n] for m,n in dirs if 0<=i+m<row and 0<=j+n<col]
                res[i][j] = sum(temp)//len(temp)
        return res"
image smoother,"class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        m, n = len(img), len(img[0])
        
        def avg(i, j):
            s = squares = 0
            top, bottom = max(0, i - 1), min(m, i + 2)
            left, right = max(0, j - 1), min(n, j + 2)

            for x in range(top, bottom):
                for y in range(left, right):
                    s += img[x][y]
                    squares += 1
            
            return s // squares
                       
        return [[avg(i, j) for j in range(n)] for i in range(m)]"
maximum width of binary tree,"class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        Q = collections.deque()
        Q.append((root,0))
        ans = 0
        while Q:
            length = len(Q)
            _, start = Q[0]
            for i in range(length):
                node, index = Q.popleft()
                if node.left:
                    Q.append((node.left, 2*index))
                if node.right:
                    Q.append((node.right, 2*index+1))
            ans = max(ans, index-start+1)
        return ans"
maximum width of binary tree,"class Solution:
    
    def widthOfBinaryTree(self, root: TreeNode) -> int:        
 
        queue = collections.deque([(root, 0, 0)])
    
        left, right = {}, {}
    
        result = 0
    
        while queue:
            node, x, y = queue.popleft()
            if not node: continue
            left[y] = min(left.get(y, x), x)
            right[y] = max(right.get(y, x), x)
            result = max(result, right[y]-left[y]+1)
            queue.extend([
                (node.left, 2*x, y+1),
                (node.right, (2*x)+1, y+1)
            ])
            
        return result"
strange printer,"class Solution:
    def strangePrinter(self, s: str) -> int:
        s = """".join(ch for i, ch in enumerate(s) if i == 0 or s[i-1] != ch)
        
        @cache
        def fn(lo, hi): 
            """"""Return min ops to print s[lo:hi].""""""
            if lo == hi: return 0
            ans = 1 + fn(lo+1, hi)
            for mid in range(lo+1, hi): 
                if s[lo] == s[mid]: 
                    ans = min(ans, fn(lo, mid) + fn(mid+1, hi))
            return ans 
        
        return fn(0, len(s))"
non decreasing array,"class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        cnt_violations=0        
        for i in range(1, len(nums)):                       
            if nums[i]<nums[i-1]:
                if cnt_violations==1:
                    return False
                cnt_violations+=1
                if i>=2 and nums[i-2]>nums[i]:
                    nums[i]=nums[i-1]                       
        return True"
non decreasing array,"class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        flag = False
        nums = [-float('inf')] + nums + [float('inf')]
        for i in range(1, len(nums) - 2):
            if nums[i + 1] < nums[i]:
                if flag: return False
                else: 
                    if nums[i + 2] >= nums[i] or nums[i + 1] >= nums[i - 1]: 
                        flag = True
                    else: return False
        return True"
beautiful arrangement ii,"class Solution:
    def constructArray(self, n: int, k: int) -> List[int]:
        lo, hi = 1, n 
        ans = []
        while lo <= hi: 
            if k&amp;1: 
                ans.append(lo)
                lo += 1
            else: 
                ans.append(hi)
                hi -= 1
            if k > 1: k -= 1
        return ans"
beautiful arrangement ii,"class Solution:
    def constructArray(self, n: int, k: int) -> List[int]:
        number_tail = k // 2
        start, end = [i for i in range(1, n - number_tail + 1)], [i for i in range(n, n - number_tail, -1)]
        i, j = 0, 0
        if k % 2 == 0:
            start, end = end, start
        answer = []
        for i, j in zip(start, end):
            answer.append(i)
            answer.append(j)
        if len(start) > len(end):
            for i in range(len(end), len(start)):
                answer.append(start[i])
        if len(start) < len(end):
            for i in range(len(start), len(end)):
                answer.append(end[i])
        return answer"
kth smallest number in multiplication table,"class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
		# special cases: k == 1,  k == m * n
        if k == 1: 
            return 1
        if k == m * n: 
            return m * n
		# make the matrix a tall one - height >= width 
		# because later I will loop along the width. This will reduce the time
        if n >= m: 
            m, n = n, m
        
		# set the left, right boundaries and the ranks (the largest ranks for the values)
		# e.g. in a 3 * 3 table, number 2 shows up twice, taking up ranks from 2 to 3
		# so the largest rank here is 3 for number 2. 
        left = 1
        # left_rank = 1
        right = m * n
        # right_rank = m * n
        
		# binary search loop
        while right - left > 1: 
            mid = (left + right) // 2
			# mid_rank is the largest rank of the number
            mid_rank = 0
			
			# find the number of columns whose maximum < mid
			# (mid - 1) is to prevent counting the column with maximum == mid.
            num_cols = (mid - 1) // m
            residual = mid - num_cols * m
            mid_rank += num_cols * m
            
			# flag to track if mid is a valid value in the table
            flag = 0
            for i in range(num_cols + 1, n + 1): 
                if i == mid: 
                    mid_rank += 1
                    break
                else: 
                    mid_rank += mid // i
                    if mid % i == 0: 
                        flag = 1
            if flag == 1: 
				# mid is a valid number in the table
				# if mid_rank == k: mid's largest rank is k and mid is the kth number
				# if mid_rank < k: kth number > mid, so left = mid
				# if mid_rank > k: mid's largest rank > k but mid still can be the kth number but kth number can be no larger than mid, so right = mid
                if mid_rank == k: 
                    return mid
                elif mid_rank > k: 
                    right = mid
                else: 
                    left = mid
            else: 
				# mid is not a valid number in the table
				# if mid_rank == k, it means there are k values in the table smaller than mid
				# so there is a number smaller than mid ranking the kth. 
				# mid_rank > k or mid_rank < k:  similar operation as above
                if mid_rank >= k: 
                    right = mid
                else: 
                    left = mid
        
		# In case the while loop breaks out without returning
		# let's assume when right - left == 2 and mid == left + 1. The solution must be among the three. 
		# right with its largest rank > k
		# left with its largest rank < k
		# Scenario 1. if mid is a valid number in the table
		## 1a. if mid_rank < k: right has its rank from mid_rank + 1 (<= k) till right_rank (> k)
		## 1b. if mid_rank > k: right = mid. Now right (== mid) has its rank from left_rank + 1 (<= k) till mid_rank (> k)
		## in both cases, right is the solution
		# Scenario 2. if mid is not a valid number in the table then we can just ignore mid and imply the solution is right. 
		## But step by step, as mid is not in the table, mid_rank == left_rank, so left = mid. 
		## So right has its rank from mid_rank + 1 (i.e. left_rank + 1) (<= k) till right_rank (> k). right is the solution. 
        return right"
kth smallest number in multiplication table,"class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
        lo, hi = 1, m*n
        while lo < hi: 
            mid = lo + hi >> 1
            cnt = sum(min(n, mid//(i+1)) for i in range(m))
            if cnt < k: lo = mid + 1
            else: hi = mid 
        return lo"
trim a binary search tree,"class Solution:
	def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
		if not root: return root
		if root.val < low: return self.trimBST(root.right, low, high)
		if root.val > high: return self.trimBST(root.left, low, high)
		root.left = self.trimBST(root.left, low, high)
		root.right = self.trimBST(root.right, low, high)
		return root"
trim a binary search tree,"class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if not root: return None
        if root.val > high:
            return self.trimBST(root.left, low, high)
        if root.val < low:
            return self.trimBST(root.right, low, high)
        root.left = self.trimBST(root.left, low, root.val)
        root.right = self.trimBST(root.right, root.val, high)
        return root"
maximum swap,"class Solution:
    def maximumSwap(self, num: int) -> int:
        s = list(str(num))
        n = len(s)
        for i in range(n-1):                                # find index where s[i] < s[i+1], meaning a chance to flip
            if s[i] < s[i+1]: break
        else: return num                                    # if nothing find, return num
        max_idx, max_val = i+1, s[i+1]                      # keep going right, find the maximum value index
        for j in range(i+1, n):
            if max_val <= s[j]: max_idx, max_val = j, s[j]
        left_idx = i                                        # going right from i, find most left value that is less than max_val
        for j in range(i, -1, -1):    
            if s[j] < max_val: left_idx = j
        s[max_idx], s[left_idx] = s[left_idx], s[max_idx]   # swap maximum after i and most left less than max
        return int(''.join(s))                              # re-create the integer"
maximum swap,"class Solution:
    def maximumSwap(self, num: int) -> int:
        # larger digit to swap, digit position of this digit
        high_digit = high_pos = 0
        
        # smaller digit to swap, digit position of this digit
        low_digit = low_pos = 0
        
        # greatest digit seen so far, digit postion of this digit
        cur_high_digit, cur_high_pos = -1, 0
        
        # current digit position
        pos = 1
        
        res = num
        while num: # iterate through digits from right to left
            digit = num % 10
            
            # if digit is greatest digit yet
            if digit > cur_high_digit:
                cur_high_digit, cur_high_pos = digit, pos
            
            # if digit is less than greatest digit yet
            elif digit < cur_high_digit:
                # set the digits to swap as the greatest digit yet, and this digit
                high_digit, high_pos = cur_high_digit, cur_high_pos
                low_digit, low_pos = digit, pos
            
            pos *= 10
            num //= 10
        
        # swap the digits
        res += high_digit*(low_pos - high_pos) + low_digit*(high_pos - low_pos)
        return res"
second minimum node in a binary tree,"class Solution:
	def findSecondMinimumValue(self, root: TreeNode) -> int:
		def inorderTraversal(root):
			if not root:
				return []
			else:
				return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)
		r = set(inorderTraversal(root))
		if len(r)>=2:
			return sorted(list(r))[1]
		else:
			return -1"
second minimum node in a binary tree,"class Solution:
    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:
        if not root:
            return None
        
        r, l = [root], []
        
        while r:
            n = r.pop(0)
            l.append(n.val)
            if n.right: r.append(n.right)
            if n.left:  r.append(n.left)
                
        l = sorted(list(set(l)))
        
        if len(l) == 1:
            return -1
        return l[1]"
bulb switcher ii,"class Solution:
    def flipLights(self, n: int, m: int) -> int:
        
        def fn(n, m): 
            """"""Return number of different status.""""""
            if m * n == 0: return 1
            return fn(n-1, m-1) + fn(n-1, m)
        
        return fn(min(n, 3), min(m, 3))"
bulb switcher ii,"class Solution:
    def flipLights(self, n: int, presses: int) -> int:
        if not presses: 
            return 1
        elif n < 3:
            if n == 1: 
                return 2
            elif presses >= 2:
                return 4
            else:
                return 3
        else:
            if presses >= 3: 
                return 8
            elif presses == 2:
                return 7
            else:
                return 4"
number of longest increasing subsequence,"class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        ct = [1] * len(nums)
        maxLen, maxCt = 0, 0
        
        # same as the LIS code, iterate
        # over all the elements once and then
        # from 0 -> i again to compute LISs
        for i in range(len(nums)):
            for j in range(i):
                # If it's a valid LIS
                if nums[i] > nums[j]:
                    # and if the length
                    # of LIS at i wrt j
                    # is going to be increased
                    # update the length dp
                    # and since this is just one
                    # continous LIS, count of i
                    # will become same as that of j
                    if dp[j]+1 > dp[i]:
                        dp[i] = dp[j] + 1
                        ct[i] = ct[j]
                    # if on the other hand, the
                    # length of the LIS at i becomes
                    # the same as it was, it means
                    # there's another LIS of this same
                    # length, in this case, add the LIS
                    # count of j to i, because the current
                    # LIS count at i consists of ways to get
                    # to this LIS from another path, and now
                    # we're at a new path, so sum thse up
                    # there's no point
                    # in updating the length LIS here.
                    elif dp[i] == dp[j] + 1:
                        ct[i] += ct[j]
            
            # at any point, keep track
            # of the maxLen and maxCt
            # we'll use it to compute our result
            if dp[i] > maxLen:
                maxLen = dp[i]
                
        # now, we have the maxLength
        # of the given nums, we can iterate
        # over all 3 arrays (hypothetically)
        # and just add up the count of all those
        # LIS which are the longest (maxLen)
        # and that's the result
        for i in range(len(nums)):
            if maxLen == dp[i]:
                maxCt += ct[i]
    
 
        return maxCt"
number of longest increasing subsequence,"class Solution:
    def findNumberOfLIS(self, nums):
        n = len(nums)

        dp, cnt, max_val = [1]*n, [1]*n, 1

        for i in range(1,n):
            for j in range(i):
                if nums[i] > nums[j]:
                    if dp[j] + 1 > dp[i]:
                        dp[i], cnt[i] = 1 + dp[j], cnt[j]
                    elif dp[j] + 1 == dp[i]:
                        cnt[i] += cnt[j]

            max_val = max(max_val,dp[i])

        return sum([j for i,j in zip(dp,cnt) if i == max_val])"
longest continuous increasing subsequence,"class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        counter=1
        temp=1
        for i in range(0,len(nums)-1):
            if nums[i]<nums[i+1]:
                temp+=1
                if temp>counter:
                    counter=temp
            else:
                temp=1
        return counter"
longest continuous increasing subsequence,"class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        maxLen = count = 1
        for i in range(len(nums) - 1):
            if nums[i] < nums[i + 1]:
                count += 1
            else:
                count = 1
                
            maxLen = max(count, maxLen)
                
        return maxLen"
cut off trees for golf event,"class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        forest.append([0] * len(forest[0]))
        for row in forest: row.append(0)
        def bfs(end, start):
            if end == start: return 0
            visited, queue = set(), {start}
            visited.add(start)
            step = 0
            while queue:
                s = set()
                step += 1
                for p in queue:                    
                    for dr, dc in ((-1, 0), (1, 0), (0, 1), (0, -1)):
                        r, c = p[0] + dr, p[1] + dc
                        if not forest[r][c] or (r, c) in visited: continue
                        if (r, c) == end: return step
                        visited.add((r, c))
                        s.add((r, c))
                queue = s

        trees = [(height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if forest[r][c] > 1]
        # check
        queue = [(0, 0)]
        reached = set()
        reached.add((0, 0))
        while queue:
            r, c = queue.pop()
            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                row, col = r + dr, c + dc
                if forest[row][col] and (row, col) not in reached:
                    queue.append((row, col))
                    reached.add((row,col))
        if not all([(i, j) in reached for (height, i, j) in trees]): return -1
        trees.sort()
        return sum([bfs((I,J),(i,j)) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees)])"
cut off trees for golf event,"class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        forest.append([0] * len(forest[0]))
        for row in forest: row.append(0)
        # distance
        def distance(i, j, I, J):
            manhattan = abs(i - I) + abs(j - J)
            detour = 0
            good, bad = [(i, j)], []
            visited = set()
            while True:
                if not good:
                    good, bad = bad, []
                    detour += 1
                i, j = good.pop()
                if i == I and j == J: return manhattan + detour * 2
                if (i, j) in visited: continue
                visited.add((i, j))
                for i, j, closer in ((i-1, j, i > I), (i+1, j, i < I), (i, j+1, j < J), (i, j-1, j > J)):
                    if forest[i][j]:
                        (good if closer else bad).append((i, j))
                    
        trees = [(height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if forest[r][c] > 1]
        # check
        queue = [(0, 0)]
        reached = set()
        reached.add((0, 0))
        while queue:
            r, c = queue.pop()
            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                row, col = r + dr, c + dc
                if forest[row][col] and (row, col) not in reached:
                    queue.append((row, col))
                    reached.add((row,col))
        if not all([(i, j) in reached for (height, i, j) in trees]): return -1
        trees.sort()
        return sum([distance(i, j, I, J) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees)])"
valid parenthesis string,"class Solution:
    def checkValidString(self, s: str) -> bool:
        
        # store the indices of '('
        stk = []
        
        # store the indices of '*'
        star = []
        
        
        for idx, char in enumerate(s):
            
            if char == '(':
                stk.append( idx )
                
            elif char == ')':
                
                if stk:
                    stk.pop()
                elif star:
                    star.pop()
                else:
                    return False
            
            else:
                star.append( idx )
        
        
        # cancel ( and * with valid positions, i.e., '(' must be on the left hand side of '*'
        while stk and star:
            if stk[-1] > star[-1]:
                return False
        
            stk.pop()
            star.pop()
        
        
        # Accept when stack is empty, which means all braces are paired
        # Reject, otherwise.
        return len(stk) == 0"
valid parenthesis string,"class Solution:
    def checkValidString(self, s: str) -> bool:
        leftmin = leftmax = 0
        for c in s:
            if c == ""("":
                leftmax += 1
                leftmin += 1
            if c == "")"":
                leftmax -= 1
                leftmin = max(0, leftmin-1)
            if c == ""*"":
                leftmax +=1
                leftmin = max(0, leftmin-1)
            if leftmax < 0:
                return False
        if leftmin == 0:
            return True"
valid palindrome ii,"class Solution:
    def validPalindrome(self, s: str) -> bool:
            p1=0
            p2=len(s)-1
            while p1<=p2:
                if s[p1]!=s[p2]:
                    string1=s[:p1]+s[p1+1:]
                    string2=s[:p2]+s[p2+1:]
                    return string1==string1[::-1] or string2==string2[::-1]
                p1+=1
                p2-=1
            return True"
valid palindrome ii,"class Solution:
    def validPalindrome(self, s: str) -> bool:
        
        def isPalindrome(left, right, changed):            
            while left < right:
                if s[left] != s[right]:
                    if not changed:
                        return isPalindrome(left + 1, right, True) or isPalindrome(left, right - 1, True)
                    else:
                        return False
                else:
                    left += 1
                    right -= 1
            return True

        return isPalindrome(0, len(s) - 1, False)"
baseball game,"class Solution:
    def calPoints(self, s: List[str]) -> int:
    	p = []
    	for i in s:
    		if i == 'C': p.pop()
    		elif i == 'D': p.append(2*p[-1])
    		elif i == '+': p.append(p[-1]+p[-2])
    		else: p.append(int(i))
    	return sum(p)"
baseball game,"class Solution:
    def calPoints(self, s: List[str]) -> int:
    	s, i = [int(s[i]) if s[i] not in 'CD+' else s[i] for i in range(len(s))]+[''], 1
    	while s[i] != '':
    		if s[i] == 'C':
    			del s[i-1], s[i-1]
    			i -= 1
    			continue
    		i += 1
    	for i in range(len(s)-1):
    		if s[i] == 'D': s[i] = 2*s[i-1]
    		if s[i] == '+': s[i] = s[i-2] + s[i-1]
    	return sum(s[:len(s)-1])
		


- Junaid Mansuri
(LeetCode ID)@hotmail.com"
redundant connection,"class Solution(object):
    def findRedundantConnection(self, edges):
        self.parent = dict()
        
        for e in edges:
            
            f0 = self.find(e[0])
            f1 = self.find(e[1])
            if f0 == f1:
                return e
            
            self.parent[f0] = f1
            
    def find(self, x):
        if x not in self.parent:
            return x
    
        return self.find(self.parent[x])"
redundant connection,"class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        d=defaultdict(lambda:[])
        for i in range(len(edges)):
            d[edges[i][0]].append(edges[i][1])
            d[edges[i][1]].append(edges[i][0])

        while any([len(v)<2 for v in d.values()]):
            for k,v in [(k,v) for k, v in d.items() if len(v)<2]:
                for m in v:
                    d[m].remove(k)
                del d[k]
                
        for e in reversed(edges):
            if e[0] in d and e[1] in d:
                return e"
repeated string match,"class Solution:
    def repeatedStringMatch(self, A: str, B: str) -> int:
    	if set(B).issubset(set(A)) == False: return -1
    	for i in range(1,int(len(B)/len(A))+3):
    		if B in A*i: return i
    	return -1
		
	- Python3
	- Junaid Mansuri"
repeated string match,"class Solution:
    def repeatedStringMatch(self, A: str, B: str) -> int:
        if len(A) >= len(B):
            if B in A: return 1
            elif B in A*2: return 2
            else: return -1
        prefix = max(0, B.find(A)) #prefix -- length of A1
        repeat, postfix = divmod(len(B)-prefix, len(A)) #postfix -- length of A2
        repeat += bool(prefix) + bool(postfix)
        if B in A * repeat: return repeat
        else: return -1"
longest univalue path,"class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        
        def dfs(node): 
            """"""Return longest univalue branch and longest univalue path (post-order traversal).""""""
            if not node: return 0, 0
            (lx, llup), (rx, rlup) = dfs(node.left), dfs(node.right) 
            if not node.left or node.left.val != node.val: lx = 0
            if not node.right or node.right.val != node.val: rx = 0 
            return 1 + max(lx, rx), max(llup, rlup, 1 + lx + rx)
        
        return max(0, dfs(root)[-1]-1)"
longest univalue path,"class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        
        def dfs(node): 
            """"""Return longest univalue branch and longest univalue path (post-order traversal).""""""
            nonlocal ans 
            if not node: return 0
            lx, rx = dfs(node.left), dfs(node.right) 
            if not node.left or node.left.val != node.val: lx = 0
            if not node.right or node.right.val != node.val: rx = 0 
            ans = max(ans, 1 + lx + rx)
            return 1 + max(lx, rx)
        
        ans = 0
        dfs(root)
        return max(0, ans-1)"
knight probability in chessboard,"class Solution:
    def knightProbability(self, n: int, k: int, row0: int, col0: int) -> float:
	
		# precalculate possible moves
        adj_list = defaultdict(list)
        d = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2))
        for row in range(n):
            for col in range(n):
                for dx, dy in d:
                    pos = (row + dx, col + dy)
                    if 0 <= pos[0] < n and 0 <= pos[1] < n:
                        adj_list[(row, col)].append(pos)

        @cache
        def get_leafs_num(pos, h):
            if h == k:
                return 1
            
            res = 0
            for next_pos in adj_list[pos]:
                res += get_leafs_num(next_pos, h + 1)
                
            return res            
            
        leafs_num = get_leafs_num((row0, col0), 0)

        return leafs_num / 8**k"
knight probability in chessboard,"class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        # Define two states, current and next
        current = [[0 for _ in range(n)] for _ in range(n)]
        next1 = [[0 for _ in range(n)] for _ in range(n)]
        current[row][column] = 1
        
        # Mark all possible moves of a knight in chessboard
        all_pos = [(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2),(2,-1),(1,-2)]
        
        for _ in range(k): # K moves
            for i in range(n): # board of size n * n
                for j in range(n): # start from cell [0,0] and check if current value is non-zero
                    if current[i][j] != 0:
                        for pos in all_pos: # For each valid moves from all_pos, add values to next steps
                            temp_x = i + pos[0]
                            temp_y = j + pos[1]
                            if 0 <= temp_x < n and 0 <= temp_y < n: # If the knight is inside the board, then add current value divide by 8. 
                                next1[temp_x][temp_y] += (current[i][j] / 8) # We divided it by 8 as there are total 8 possibilities
            current, next1 = next1, [[0 for _ in range(n)] for _ in range(n)] # Assign next as current and redefine next as empty array. Now, we'll again fill this next array with values of current
        
		# Find total probability of the last state. That'll be current as we just swapped current &amp; next!!
        total_sum = 0
        for item in current:
            total_sum += sum(item)
        return total_sum"
maximum sum of 3 non overlapping subarrays,"class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        @cache
        def fn(i, n): 
            """"""Return max sum of 3 non-overlapping subarrays.""""""
            if n == 0: return []
            if i+k >= len(prefix): return []
            return max([i] + fn(i+k, n-1), fn(i+1, n), key=lambda x: sum(prefix[xx+k] - prefix[xx] for xx in x))
        
        return fn(0, 3)"
maximum sum of 3 non overlapping subarrays,"class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        rs0, rs1, rs2 = sum(nums[:k]), sum(nums[k:2*k]), sum(nums[2*k:3*k])
        m0, m1, m2 = rs0, rs0 + rs1, rs0 + rs1 + rs2
        i0, i1, i2 = [0], [0, k], [0, k, 2*k]
        for i in range(len(nums)-3*k): 
            rs0 += nums[i+k] - nums[i]
            rs1 += nums[i+2*k] - nums[i+k]
            rs2 += nums[i+3*k] - nums[i+2*k]
            if rs0 > m0: m0, i0 = rs0, [i+1]
            if m0 + rs1 > m1: m1, i1 = m0 + rs1, i0 + [i+k+1]
            if m1 + rs2 > m2: m2, i2 = m1 + rs2, i1 + [i+2*k+1]
        return i2"
employee importance,"class Solution:
    def getImportance(self, employees, id):
        """"""
        :type employees: Employee
        :type id: int
        :rtype: int
        """"""
        id_to_emp = {employee.id: employee for employee in employees}
        importance = 0
        stack = [id_to_emp[id]]
        while stack:
            cur_emp = stack.pop()
            importance += cur_emp.importance
            stack.extend([id_to_emp[new_emp] for new_emp in cur_emp.subordinates])
        return importance"
employee importance,"class Solution:
    def getImportance(self, employees: List['Employee'], id: int) -> int:
        emap = {e.id: e for e in employees}

        q=deque([id])
        ans=0
        
        while q:
            emp_id=q.popleft()
            ans+=emap[emp_id].importance
            
            for sub in emap[emp_id].subordinates:
                q.append(sub)
        return ans"
stickers to spell word,"class Solution:
    def minStickers(self, stickers: List[str], target: str) -> int:
        freqs = [Counter(x) for x in stickers]
        
        @cache
        def fn(x):
            """"""Return min sticks to give x.""""""
            if not x: return 0 
            ans = inf
            freq = Counter(x)
            for cnt in freqs: 
                if x[0] in cnt: 
                    xx = """".join(k*v for k, v in (freq - cnt).items())
                    ans = min(ans, 1 + fn(xx))
            return ans 
        
        ans = fn(target)
        return ans if ans < inf else -1"
stickers to spell word,"class Solution:
    def minStickers(self, stickers: List[str], target: str) -> int:
        tcount = Counter(target)
        def getScore(s):
            temp = dict(tcount)
            sdict = defaultdict(int)
            res = 0
            for c in s:
                if c in temp and temp[c] > 0:
                    temp[c] -= 1
                    res += 1
                    sdict[c] += 1
            return (res, sdict)
        stickers = [getScore(s) for s in stickers]
        stickers.sort(key = lambda x: x[0], reverse = True)
        stickers = [x[1] for x in stickers if x[0] > 0]
        opt = [stickers[0]]
        for i in range(1, len(stickers)):
            if opt[-1].keys() == stickers[i].keys() :
                continue
            opt.append(stickers[i])
        stickers = opt[:]
            
        seen = set()
        q = deque([target])
        step = 0
        while q:
            n = len(q)
            step += 1
            for i in range(n):
                cur = q.popleft()
                if cur in seen:
                    continue
                seen.add(cur)
                for stick in stickers:
                    if cur[0] not in stick:
                        continue
                    new = str(cur)
                    for s in stick:
                        new = new.replace(s,'', stick[s])
                    if new == """":
                        return step
                    if new not in seen:
                        q.append(new)
        return -1"
top k frequent words,"class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        #Have a dict of word and its freq
        counts = collections.Counter(words)
        
        #get a array wchich will have a tuple of word and count
        heap = [(-count, word) for word, count in counts.items()]
        
        #as default heap structure in python min heap and we want max heap
        # to get top frequent word, we will do a make the counter negative
        #so that the topmost element will come up (i.e -8 < -2 so in min heap -8 will come up wich is actually 8)
        
        heapq.heapify(heap) #creating heap in place
        #by deualt it will sort by fre then word
        
        return [heapq.heappop(heap)[1] for _ in range(k)]"
top k frequent words,"class Solution:
    def topKFrequent(self, words, k):
        dicktionary = defaultdict(int)
        for i in words: dicktionary[i] += 1
        
        sorted_dick = sorted(dicktionary.items(), key=lambda x: (-x[1], x[0]))
        
        return [i[0] for i in sorted_dick][:k]"
binary number with alternating bits,"class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        s = bin(n).replace('0b','')
        for i in range(len(s)-1):
            if s[i] == s[i+1]:
                return False
        return True"
binary number with alternating bits,"class Solution:
	def hasAlternatingBits(self, n: int) -> bool:
		while n > 1:
			bit1 = n &amp; 1
			n >>= 1
			bit2 = n &amp; 1
			if bit1 == bit2:
				return False
		return True"
max area of island,"class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        
        maxArea = 0
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1: # run dfs only when we find a land
                    maxArea = max(maxArea, self.dfs(grid, i, j))
                    
        return maxArea
    
                    
    def dfs(self, grid, i, j):
		# conditions for out of bound and when we encounter water
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:
            return 0
        
        maxArea = 1
        grid[i][j] = '#'  # this will act as visited set
        maxArea += self.dfs(grid, i+1, j)
        maxArea += self.dfs(grid, i-1, j)
        maxArea += self.dfs(grid, i, j+1)
        maxArea += self.dfs(grid, i, j-1)
        
        return maxArea"
max area of island,"# Set + Recursion Solution
# Time:     O(n * m),     Iterates through grid once.
# Space:    O(n * m),     Uses set to keep track of visited indices.
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        M, N = len(grid), len(grid[0])                                          # Gets size of grid.        
        visited = set()                                                         # Set containing a tuple if indices visited in grid.
        
        def isValidIndice(row: int, column: int) -> bool:                       # Chekcs if a row and column are in the grid.
            if row < 0 or M <= row: return False                                # Checks for out of bounds row.
            if column < 0 or N <= column: return False                          # Checks for out of bounds column.
            
            return True                                                         # Returns True if all checks are passed.
        
        def islandArea(row, column) -> int:                                     # Gets the area of a 4-connected island on the grid. 
            if (row, column) in visited: return 0                               # Checks if indices have been visited already.
            if not isValidIndice(row, column): return 0                         # Checks if the indice is in bounds.
            if grid[row][column] == 0: return 0                                 # Checks if cell is water.
            
            visited.add((row, column))                                          # Adds cell to visited set.
            up, down = islandArea(row-1, column), islandArea(row+1, column)     # Recursive call to cells above and below to get area.
            left, right = islandArea(row, column-1), islandArea(row, column+1)  # Recursive call to cells left and right to get area.
            
            return 1 + up + down + left + right                                 # returns the area of the island.
            
            
        area, maxArea = 0, 0
        for row in range(M):                                                    # Iterates through grid rows.
            for column in range(N):                                             # Iterates through grid columns.
                area = islandArea(row, column)                                  # Gets area of island if cell is 1.
                maxArea = max(maxArea, area)                                    # Sets max island area found.
                
                
        return maxArea                                                          # Returns max island area found."
count binary substrings,"class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        stack = [[], []]
        latest = int(s[0])
        stack[latest].append(latest)
        result = 0
        for i in range(1,len(s)):
            v = int(s[i])
            if v != latest:
                stack[v].clear()
                latest = v
            stack[v].append(v)
            if len(stack[1-v]) > 0:
                stack[1-v].pop()
                result += 1
        return result"
count binary substrings,"class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        prev, cur = 0, 1
        res = 0
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                cur += 1
            else:
                prev, cur = cur, 1

            if cur <= prev:
                res += 1
        
        return res"
degree of an array,"class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
    	C = {}
    	for i, n in enumerate(nums):
    		if n in C: C[n].append(i)
    		else: C[n] = [i]
    	M = max([len(i) for i in C.values()])
    	return min([i[-1]-i[0] for i in C.values() if len(i) == M]) + 1
		
		
- Junaid Mansuri"
degree of an array,"class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        '''
        step 1: find the degree
            - create a hashmap of a number and value as list of occurance indices
            - the largest indices array in the hashmap gives us the degree
        step 2: find the minimum length subarray with same degree
            - initialize result as length of array
            - for each indices array, if it's length equals degree, means it's most frequent element
                - this length will be equal to the difference of first occurance and last occurance of most frequent element
                - compare this length with current result and keep the smallest length as result
            - return result + 1 because difference of indices will give us length - 1
                
            
        '''
        c = defaultdict(list)
        for i, n in enumerate(nums):
            c[n].append(i)        
        degree = max([len(x) for x in c.values()])
        
        result = len(nums)
        for indices in c.values():
            if len(indices) == degree:
                result = min(result, indices[-1] - indices[0])
        return result + 1"
partition to k equal sum subsets,"class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        if k==1:
            return True
        total = sum(nums)
        n = len(nums)
        if total%k!=0:
            return False
        nums.sort(reverse=True)
        average = total//k
        if nums[0]>average:
            return False
        
        visited = [False]*n
        def dfs(cur, begin, k):
            if k==0:
                return True
            if cur>average:
                return False
            elif cur==average:
                return dfs(0, 0, k-1)
            for i in range(begin, n):
                if not visited[i]:
                    visited[i] = True
                    if dfs(cur + nums[i], i+1, k):
                        return True
                    visited[i] = False
            return False
        
        return dfs(0, 0, k)"
partition to k equal sum subsets,"class Solution(object):
    def canPartitionKSubsets(self, nums, k):
        target = sum(nums)
        if target % k != 0: return False
        target //= k
        cur = [0] * k; nums.sort( reverse = True)
        def foo( index):
            if index == len( nums): return True
            for i in range( k):
                if nums[index] + cur[i] <= target:
                    cur[i] += nums[index]
                    if foo( index + 1) == True: return True
                    cur[i] -= nums[index]
                if cur[i] == 0: break
            return False
        return foo( 0)"
falling squares,"class Solution:
    def fallingSquares(self, positions):
            height, pos, max_h,res = [0],[0],0,[]
            for left, side in positions:
                i = bisect.bisect_right(pos, left)
                j = bisect.bisect_left(pos, left + side)
                high = max(height[i - 1:j] or [0]) + side 
                pos[i:j] = [left, left + side]
                height[i:j] = [high, height[j - 1]]
                max_h = max(max_h, high)
                res.append(max_h)
            return res"
falling squares,"class Solution:
    def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        ans = []
        for i, (x, l) in enumerate(positions): 
            val = 0
            for ii in range(i): 
                xx, ll = positions[ii]
                if xx < x+l and x < xx+ll: val = max(val, ans[ii])
            ans.append(val + l)
        for i in range(1, len(ans)): ans[i] = max(ans[i-1], ans[i])
        return ans"
search in a binary search tree,"class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return
        if root.val==val:
            return root
        if root.val<val:
            return self.searchBST(root.right,val)
        else:
            return self.searchBST(root.left,val)"
search in a binary search tree,"class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root is None or root.val == val: # If end is reached or a node with a value of target is found found.
            return root # Return that node.
		# If target > current nodes value search in left side of node else search rightwards.
        return self.searchBST(root.left,val) if root.val > val else self.searchBST(root.right,val)"
insert into a binary search tree,"class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root: return TreeNode(val)
            
        cur, next = None, root
        while next:
            cur = next
            next = cur.left if val < cur.val else cur.right
        
        if val < cur.val: 
            cur.left = TreeNode(val)
        else: 
            cur.right = TreeNode(val)
            
        return root"
insert into a binary search tree,"class Solution:
    def insertIntoBST(self, root, val):
        if not root:
            return TreeNode(val)
      
        if val<root.val:
            root.left = self.insertIntoBST(root.left, val)
        else:
            root.right = self.insertIntoBST(root.right, val)
  
        return root"
binary search,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)-1
        
        while left<=right:
            mid = (left+right)//2
            if nums[mid]==target:
                return mid
            elif nums[mid]>target:
                right = mid-1
            else:
                left = mid+1
        
        return -1"
binary search,"class Solution:
	def search(self, nums: List[int], target: int) -> int:

		low=0
		high=len(nums)-1

		while low <=high:
			mid= (low+high)//2

			if nums[mid]==target:
				return mid
				
			elif nums[mid]<target:
				low=mid+1
				
			elif nums[mid]>target:
				high=mid-1

		return -1"
design hashset,"# Linked List Solution
class MyHashSet(object):
    
    def __init__(self):
        self.keyRange = 769
        self.bucketArray = [LinkedList() for i in range(self.keyRange)]
        
    def _hash(self, key):
        return key % self.keyRange
    
    def add(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].append(key)
        
    def remove(self, key):
        bucketIndex = self._hash(key)
        self.bucketArray[bucketIndex].deleteNodeKeyAll(key)
        # while self.bucketArray[bucketIndex].search(key):
        #     self.bucketArray[bucketIndex].deleteNodeKeyOne(key)
        
    def contains(self, key):
        bucketIndex = self._hash(key)
        return self.bucketArray[bucketIndex].search(key)
    
# ---------------------------------------------------------
## Define a linked list

class Node:
    
    def __init__(self, val, next = None):
        self.val = val
        self.next = next
        
class LinkedList:
    
    def __init__(self):
        self.head = None

# ---------------------------------------------------------
## Insert a new node

### Insert the new node at the front of the linked list
    def push(self, new_val):
        new_node = Node(new_val)
        new_node.next = self.head
        self.head = new_node
        
### Insert the new node at the end of the linked list
    def append(self, new_val):
        new_node = Node(new_val)
        if self.head is None:
            self.head = new_node
            return
        # Traverse till the end of the linked list
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

### Insert the new node after a given node
    def insertAfter(self, new_val, prev_node):
        if prev_node is None:
            print(""Please enter the node which is the previous node of the inserted node."")
            return
        new_node = Node(new_val)
        new_node.next = prev_node.next
        prev_node.next = new_node
        
# ---------------------------------------------------------
## Delete a node

### Delete a node by value
# Iterative Method
    def deleteNodeKeyOne(self, key): # delete a single node
        temp = self.head
        if temp is None:
            return
        if temp.val == key:
            self.head = temp.next
            temp = None
            return
        while temp is not None:
            if temp.val == key:
                break
            prev = temp
            temp = temp.next
        if temp is None:
            return
        prev.next = temp.next
        temp = None
        
    def deleteNodeKeyAll(self, key): # delete all the nodes with value key
        temp = self.head
        if temp is None:
            return
        while temp.val == key:
            deletedNode = temp
            self.head = temp.next
            temp = self.head
            deletedNode = None
            if temp is None:
                return
        nxt = temp.next
        while nxt is not None:
            if nxt.val == key:
                deletedNode = nxt
                temp.next = nxt.next
                deletedNode = None
            temp = nxt
            nxt = nxt.next

### Delete a node by position and return the value of the deleted node
    def deleteNodePosition(self, position):
        if self.head is None:
            return
        if position == 0:
            temp = self.head
            self.head = self.head.next
            temp = None
            return
        idx = 0
        current = self.head
        prev = self.head
        nxt = self.head
        while current is not None:
            if idx == position:
                nxt = current.next
                break
            prev = current
            current = current.next
            idx += 1
        prev.next = nxt
        current = None
        
# ---------------------------------------------------------
# Print a linked list
    def printList(self):
        temp = self.head
        while temp:
            print ("" %d"" %(temp.val))
            temp = temp.next

# ---------------------------------------------------------
## Search an element in a linked list
    def search(self, x):
        current = self.head
        while current is not None:
            if current.val == x:
                return True
            current = current.next
        return False"
design hashset,"# Array List Solution

class MyHashSet:

    def __init__(self):
        self.buckets = []

    def add(self, key: int) -> None:
        count = 0
        for x in self.buckets:
            if key in x:
                x += [key]
                count += 1
        if count == 0:
            self.buckets += [[key]]

    def remove(self, key: int) -> None:
        for x in self.buckets:
            while key in x:
                x.remove(key)

    def contains(self, key: int) -> bool:
        for x in self.buckets:
            if key in x:
                return True
        return False"
to lower case,"class Solution:
    def toLowerCase(self, s: str) -> str:
        # Instead of using .lower(), let's implement with ASCII
        # ord() returns the ascii value of a passed character
        
        # Uncomment the line below to see the ASCII value of some important characters
        # print(ord('a'), ord('z'), ord('A'), ord('Z'))
        
        # Notice 'a'=97, and 'A'=65
        # This can be used to tell whether a character is upper/lower case, and can help us convert between them
        
        # First, make the string a list so we can change each char individually
        s = list(s)
        
        # Then, loop through the characters, and if their ascii value is <= 90 and >= 65, they must be upper case
        # Use the difference (97 - 65 = 32) to convert it from upper to lower, then use chr() to convert from ascii to char
        #   - ord('A') + 32 = 97 = ord('a')
        for i in range(len(s)):
            if ord(s[i]) <= 90 and ord(s[i]) >= 65:
                s[i] = chr(ord(s[i])+32)
        return ''.join(s)"
to lower case,"class Solution:
    def toLowerCase(self, s: str) -> str:
        res = """"
        for i in s:
            if ord(i) >= 65 and ord(i) <=90:
                res+=chr(ord(i)+32)
            else:
                res+=i
        return res"
random pick with blacklist,"class Solution:

    def __init__(self, n: int, blacklist: List[int]):
        self.hashmap={}
        for b in blacklist:
            self.hashmap[b]=-1
        self.length=n-len(blacklist)
        flag=n-1
        for b in blacklist:
            if b<self.length: 
                while flag in self.hashmap:
                    flag-=1
                self.hashmap[b]=flag
                flag-=1
            
    def pick(self) -> int:
        seed=random.randrange(self.length)
        return self.hashmap.get(seed,seed)
        


# Your Solution object will be instantiated and called as such:
# obj = Solution(n, blacklist)
# param_1 = obj.pick()"
random pick with blacklist,"class Solution:
	def __init__(self, n, blacklist):
		self.whiteSize = n - len(blacklist)
		self.hmap = {ele: 1 for ele in blacklist}
		
		idx = n - 1
		for ele in self.hmap:
			if ele >= self.whiteSize:
				continue
			
			while idx in self.hmap:
				idx -= 1
			self.hmap[ele] = idx
			idx -= 1
			
	def pick(self):
		index = randint(0, self.whiteSize - 1)
		if index in self.hmap:
			return self.hmap[index]
		return index"
minimum ascii delete sum for two strings,"class Solution:
def minimumDeleteSum(self, s1: str, s2: str) -> int:
    
    def lcs(s,p):
        m,n = len(s),len(p)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        for i in range(m):
            for j in range(n):
                if s[i]==p[j]:
                    dp[i+1][j+1] = dp[i][j]+ord(s[i])
                else:
                    dp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1])
                    
        return dp[-1][-1]
    
    common = lcs(s1,s2)
    total,res = 0,0
    for c in s1:
        total+=ord(c)
    for c in s2:
        total+=ord(c)
    
    res = total - common*2
    return res"
minimum ascii delete sum for two strings,"class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        
        @lru_cache(None)
        def fn(i, j): 
            """"""Return minimum ASCII delete sum for s1[i:] and s2[j:].""""""
            if i == len(s1): return sum(ord(s2[jj]) for jj in range(j, len(s2)))
            if j == len(s2): return sum(ord(s1[ii]) for ii in range(i, len(s1)))
            if s1[i] == s2[j]: return fn(i+1, j+1)
            return min(ord(s1[i]) + fn(i+1, j), ord(s2[j]) + fn(i, j+1))
        
        return fn(0, 0)"
subarray product less than k,"class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        
        if k <= 1:
            # Quick response for invalid k on product of positive numbers
            return 0
        
        else:
            left_sentry = 0

            num_of_subarray = 0
            product_of_subarry = 1

            # update right bound of sliding window
            for right_sentry in range( len(nums) ):

                product_of_subarry *= nums[right_sentry]

                # update left bound of sliding window
                while product_of_subarry >= k:
                    product_of_subarry //= nums[left_sentry]
                    left_sentry += 1

                # Note:
                # window size = right_sentry - left_sentry + 1

                # update number of subarrary with product < k
                num_of_subarray += right_sentry - left_sentry + 1

            return num_of_subarray"
subarray product less than k,"class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        
        res = 0
        product = 1
        left = 0
        
        for right, num in enumerate(nums):
            product *= num
            while product >= k:
                product //= nums[left]
                left += 1
            
            res += right - left + 1
        
        return res"
best time to buy and sell stock with transaction fee,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = inf, 0
        for x in prices:
            buy = min(buy, x)
            sell = max(sell, x - buy)
        return sell"
best time to buy and sell stock with transaction fee,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = inf, 0
        for x in prices: 
            buy = min(buy, x - sell)
            sell = max(sell, x - buy)
        return sell"
1 bit and 2 bit characters,"class Solution:
    def isOneBitCharacter(self, bits):
        i, n, numBits = 0, len(bits), 0
        while i < n:
            bit = bits[i]
            if bit == 1:
                i += 2
                numBits = 2
            else:
                i += 1
                numBits = 1
        return numBits == 1"
1 bit and 2 bit characters,"class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i=0
        count=0
        while i<len(bits):
            if bits[i]==1:
                count=2
                i+=2
            else:
                count=1
                i+=1
        return count%2"
maximum length of repeated subarray,"class Solution:
    # DP Approach - Similar to 1143. Longest Common Subsequence
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n, m = len(nums1), len(nums2)
        # dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        ans = 0
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                # if both character is same
                if nums1[i - 1] == nums2[j - 1]:
                    # then we add 1 to the previous state, which is dp[i - 1][j - 1]
                    # in other word, we extend the repeated subarray by 1
                    # e.g. a = [1], b = [1], length of repeated array is 1
                    #      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    # record the max ans here
                    ans = max(ans, dp[i][j])
                # else:
                    # if you are looking for longest common sequence,
                    # then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here
                    # however, this problem is looking for subarray,
                    # since both character is not equal, which means we need to break it here
                    # hence, set dp[i][j] to 0
        return ans"
maximum length of repeated subarray,"class Solution:
    # Binary Search Approach
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        N, M = len(nums1), len(nums2)
        
        def ok(k):
            # the idea is to use binary search to find the length `k`
            # then we check if there is any nums1[i : i + k] == nums2[i : i + k]
            s = set(tuple(nums1[i : i + k]) for i in range(N - k + 1))
            return any(tuple(nums2[i : i + k]) in s for i in range(M - k + 1))
        
        # init possible boundary
        l, r = 0, min(N, M)
        while l < r:
            # get the middle one
            # for even number of elements, take the upper one
            m = (l + r + 1) // 2
            if ok(m): 
                # include m
                l = m
            else:
                # exclude m
                r = m - 1
        return l"
find k th smallest pair distance,"class Solution:
	def smallestDistancePair(self, nums: List[int], k: int) -> int:

		def getPairs(diff):
			l = 0
			count = 0

			for r in range(len(nums)):
				while nums[r] - nums[l] > diff:
					l += 1
				count += r - l

			return count


		nums.sort()
		l, r = 0, nums[-1] - nums[0]

		while l < r:
			mid = (l + r) // 2
			res = getPairs(mid)

			if res >= k:
				r = mid
			else:
				l = mid + 1

		return l"
find k th smallest pair distance,"class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        nums.sort()
        
        def fn(val): 
            """"""Return count of pairs whose diff <= val.""""""
            ans = ii = 0
            for i, x in enumerate(nums):
                while ii < i and x - nums[ii] > val: ii += 1
                ans += i - ii
            return ans 
        
        lo, hi = 0, nums[-1] - nums[0]
        while lo < hi: 
            mid = lo + hi >> 1
            if fn(mid) < k: lo = mid + 1
            else: hi = mid
        return lo"
longest word in dictionary,"class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()                  # for smallest lexicographical order
        visited = {""""}                # hashset to keep a track of visited words
        res = ''
        
        for word in words:
            if word[:-1] in visited:     # check previous word ie. word[:len(word)-1] visited or not
                visited.add(word)        # add this word to the set
                if len(word) > len(res): # current word have greater lenght and lexicographically smaller
                    res = word           # update res
        
        return res
    
    
    
# Time: O(n log(n))   # for sorting the words
# Space: O(n)         # for making the set visited"
longest word in dictionary,"class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort()
        max_len = 1
        symbol = ']'
        ans = None
        for i in range(len(words)):
            if len(words[i]) == 1:
                words[i] = words[i] + symbol
                if max_len < len(words[i]):
                    max_len = len(words[i])
                    ans = words[i]
            else:
                word = words[i][:-1] + symbol
                index = bisect.bisect_left(words, word)
                if index < len(words) and words[index] == word:
                    words[i] = words[i] + symbol
                    if max_len < len(words[i]):
                        max_len = len(words[i])
                        ans = words[i]
        if not ans:
            return """"
        return ans[:-1]"
accounts merge,"class Solution:
    def dfs(self, graph, node, visit):
        visit.add(node)
        for nei in graph[node]:
            if nei not in visit:
                self.dfs(graph, nei, visit)
        self.res.append(node)
    
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        graph = collections.defaultdict(set)
        for account in accounts:
            for email in account[1:]:
                graph[account[1]].add(email)
                graph[email].add(account[1])
        #print(graph.items())
        
        visit = set()
        ans = []
        for account in accounts:
            name = account[0]
            for email in account[1:]:
                if email not in visit:
                    self.res = []
                    self.dfs(graph, email, visit)
                    ans.append([name]+sorted(self.res))
        return ans"
accounts merge,"class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x, y):
            rootx = find(x)
            rooty = find(y)
            if rootx == rooty:
                return
            if rank[rootx] > rank[rooty]:
                parent[rooty] = rootx
            elif rank[rooty] > rank[rootx]:
                parent[rootx] = rooty
            else:
                parent[rootx] = rooty
                rank[rooty] += 1
        parent = list(range(len(accounts)))
        rank = [0] * len(accounts)
        email_parent = {}
        for idx, account in enumerate(accounts):
            for email in account[1:]:
                if email in email_parent:
                    union(idx, email_parent[email])
                email_parent[email] = idx
        ans = {}
        for email in email_parent:
            root = find(email_parent[email])
            if root in ans:
                ans[root].append(email)
            else:
                ans[root] = [accounts[root][0], email]
        ans = list(ans.values())
        for account in ans:
            account[1:] = sorted(account[1:])
        return ans"
remove comments,"class Solution:
    def removeComments(self, source: List[str]) -> List[str]:
        ans, inComment = [], False
        new_str = """"
        for c in source:
            if not inComment: new_str = """"
            i, n = 0, len(c)
            # inComment, we find */
            while i < n:
                if inComment:
                    if c[i:i + 2] == '*/' and i + 1 < n:
                        i += 2
                        inComment = False
                        continue
                    i += 1
                # not in Comment, we find /* // and common character
                else:
                    if c[i:i + 2] == '/*' and i + 1 < n:
                        i += 2
                        inComment = True
                        continue
                    if c[i:i + 2] == '//' and i + 1 < n:
                        break
                    new_str += c[i]
                    i += 1
            if new_str and not inComment:
                ans.append(new_str)
                    

        return ans"
remove comments,"class Solution:
    def removeComments(self, source: List[str]) -> List[str]:
        ans = []
        comment = False # True for block comment 
        
        for line in source: 
            if not comment: ans.append([]) # if not started as comment
            i = 0
            while i < len(line): 
                if comment: 
                    if line[i:i+2] == ""*/"": 
                        comment = False 
                        i += 1
                else:  
                    if line[i:i+2] == ""//"": break 
                    elif line[i:i+2] == ""/*"": 
                        comment = True 
                        i += 1
                    else: ans[-1].append(line[i])
                i += 1
        return filter(None, map("""".join, ans))"
find pivot index,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        left = 0 # nums[0] + nums[1] + ... + nums[middleIndex-1]
        right = sum(nums) # nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]

        for i, num in enumerate(nums): # we can use normal for loop as well.
            right -= num # as we are trying to find out pivot index so iteratively we`ll reduce the value of right to find the pivot index
            if left == right: # comparing the values for finding out the pivot index.
                return i # if there is any return the index whixh will be our required index.
            left += num # we have to add the num iteratively. 

        return -1"
find pivot index,"class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        s1,s2=0,sum(nums)
        for i in range(len(nums)):
            s2-=nums[i]
            if s1==s2:
                return i
            s1+=nums[i]
        return -1"
split linked list in parts,"class Solution:
    def splitListToParts(self, head: ListNode, k: int) -> List[ListNode]:
        size = self.get_size(head)
        min_len, one_more = divmod(size, k)
        res = []
        current = ListNode()
        current.next = head
        for i in range(k):
            ans = current
            for _ in range(min_len + int(i < one_more)):
                current = current.next
            res.append(ans.next)
            ans.next = None
        return res

    def get_size(self, head: ListNode) -> int:
        size = 0
        while head is not None:
            size += 1
            head = head.next
        return size"
split linked list in parts,"class Solution:
    def splitListToParts(self, H: ListNode, k: int) -> List[ListNode]:
        A, B, i = [], [], 0
        while H != None: H, _ = H.next, A.append(H.val)
        LA = len(A)
        (n, r) = divmod(LA,k) if k < LA else (1,0)
        A.extend([0]*(k-LA))
        for s in range(k):
            L = LH = ListNode(A[i])
            for j in range(i+1,i+n+(r>0)): L.next = ListNode(A[j]); L = L.next
            i, r, _ = i + n + (r>0), r - 1, B.append(LH if s<LA else None)
        return B
            

- Junaid Mansuri
- Chicago, IL"
number of atoms,"class Solution:
    def countOfAtoms(self, formula: str) -> str:
        # constant declarations
        upper=""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
        lower=upper.lower()
        digits = ""0123456789""
        
        # variables
        count=defaultdict(int)
        element_name = None
        element_name_parse_start=False
        element_count =""""
        bracket_stacks = [[]]
        buffer = []
        
        # function to parse out the complete number if a digit is seen, 
        # the function takes the character, that was seen as a digit and 
        # the generator object to get the remaining (yet to be read) part of formula
        def parseout_number(ch,gen):
            nonlocal buffer
            num=""""
            try:
                while ch in digits:
                    num += ch
                    ch = next(gen)
                # after number is parsed out and a non-number character is seen, 
                # add that non-number character to the buffer to be read next, dont miss parsing it
                buffer.append(ch)
            except StopIteration:
                # while iterating to find the end digit of the number, we have reached the end of the formula, 
                # meaning the digit ch and subsequent characters were numbers and were the last thing in the formula
				# the code, outside of try-catch handles all the possible scenerios of parsing the number out, 
				# so do nothing here. move along
                pass
            # if we saw a number, return it as integer, else return empty string
            if num != """":
                return int(num)
            else:
                return """"
        
        #generator expression
        formula_chars = (ch for ch in formula)
        
        # iterate over all characters
        for char in formula_chars:
            
            # add the character emitted by generator into buffer for processing
            buffer.append(char)
            
            # process what ever is in the buffer queue
            while buffer:
                ch = buffer.pop(0)
                
                # if the character is an upper case character
                # set the a flag to indicate start of a new element name
                # check if the previous elementname was added to the processing_stack (bracket_stacks)
                # if not then add it, noting one atom for that element
                # set the character to element_name variable
                if ch in upper:
                    element_name_parse_start=True
                    if element_name is not None and element_count == """":
                        bracket_stacks[-1].append([element_name,1])
                    element_name = ch
                # if character is lowercase, just concat it to the element_name
                elif ch in lower:
                    element_name += ch
                # if character is a numerical digit, then parse that number out completely as integer
                # set the flag to indicate the reading the element name is done
                # store the element name and it's corresponding count into the processing_stack
                # reset the variables element_name and element_count, ready for next element
                elif ch in digits:
                    element_name_parse_start=False
                    element_count = parseout_number(ch,formula_chars)
                    bracket_stacks[-1].append([element_name,element_count])
                    element_count = """"
                    element_name = None
                # if open bracket is seen, check if reading the element_name flag is still True
                # if it is then that element has one atom only
                # add it to the processing stack
                # set the flag to indicate that reading the 'element_name' is done and 
                # add another processing stack top the top of the 'bracket_stacks'
                # this new processing stack will have the atom details within the bracket
                # finally, reset all other variables to ensure 
				# clean slate for the new child 'processing-stack' before exiting the code-block
                elif ch == ""("":
                    if element_name_parse_start:
                        bracket_stacks[-1].append([element_name,1])
                    element_name_parse_start=False
                    element_count = """"
                    bracket_stacks.append([]) # new processing stack
                    element_name = None
                
                # if a bracket is closed
                # make sure we account for one atom of element, if a number was not seen before closing the bracket
                # set the flag to indicate we are done reading element_name
                # check what is the next character after the bracket close char. 
				# if it's a digit, then parse that number out 
                # that number is the multiplier for the current processing stack
                # which means we will need to multiply every atom/element count by the multiplier
                # at this point the current processing stack 
				# which was created as part of opening the bracket is processed
                # so, merge what we found into the parent processing stack by 
                # extending the parent processing stack with the results of the child stack
                elif ch == "")"":
                    if element_name_parse_start:
                        bracket_stacks[-1].append([element_name,1])
                    element_name = None
                    element_name_parse_start=False
                    braket_multiplier = """"
                    try:
                        next_ch= next(formula_chars)
                        braket_multiplier = parseout_number(next_ch,formula_chars)
                    except StopIteration:
                        pass
                    
                    if braket_multiplier == """":
                        braket_multiplier = 1
					# pop the child processing - stack to be processed
                    process_this = bracket_stacks.pop()
                    
					#processing
                    for idx,_ in enumerate(process_this):
                        process_this[idx][1] = process_this[idx][1]*braket_multiplier
					
					#merging processed child stack with the parent stack
                    bracket_stacks[-1].extend(process_this)
        
        # if the new element name seen flag is set then process that 
        # atom by adding it's element-name and atom count to the current processing stack
        if element_name_parse_start:
            if element_name is not None:
                if element_count != """":
                    bracket_stacks[-1].append([element_name,int(element_count)])
                else:
                    bracket_stacks[-1].append([element_name,1])
        
        # pop the top-level processing-stack, this should contain a 'flattened' version of the atoms and their counts
        # note that the counts of elements are not aggregated yet, 
        # eg:If Oxygen was seen within a bracket and also seen outside that bracket, 
        # then we'll have two entries for Oxygen. We'll aggregate them next...
        count_pairs = bracket_stacks.pop()
        
        # aggregate all the 'flattened' data in 'count_pairs' variable, using a dictionary
        for element_name,element_count in count_pairs:
            count[element_name]+= element_count
        
        # preparing the output string...
        # create a list meant to hold the 'words' of the output string, based on the description
        output=[]
        
        # fetch the keylist
        elements_list = list(count.keys())
        
        #sort it
        elements_list.sort()
        
        # for each element in the sorted keylist, if the element has more 
        # than 1 atom, append the atom and it's count
        # if element has only 1 atom only append the atom name, 
        # but don't append the atom's count (which is 1)
        for element in elements_list:
            if count[element] > 1:
                output.append(element)
                output.append(str(count[element]))
            else:
                output.append(element)
        
        # output will now have an list of words representation of what we need. turn the list into a string and return it
        return """".join(output)"
number of atoms,"class Solution:
    def countOfAtoms(self, formula: str) -> str:
        mp = {}
        stack = []
        for i, x in enumerate(formula): 
            if x == ""("": stack.append(i)
            elif x == "")"": mp[stack.pop()] = i
        
        def fn(lo, hi): 
            """"""Return count of atom in a freq table.""""""
            k = lo 
            ans = defaultdict(int)
            while k < hi: 
                cnt = 0 
                if formula[k] == ""("": 
                    freq = fn(k+1, mp[k])
                    k = mp[k] + 1
                    while k < hi and formula[k].isdigit(): 
                        cnt = 10*cnt + int(formula[k])
                        k += 1
                    for key, val in freq.items(): ans[key] += val * max(1, cnt)
                else: 
                    atom = formula[k]
                    k += 1
                    while k < hi and formula[k] != ""("" and not formula[k].isupper(): 
                        if formula[k].isalpha(): atom += formula[k]
                        else: cnt = 10*cnt + int(formula[k])
                        k += 1
                    ans[atom] += max(1, cnt)
            return ans 
        
        
        ans = []
        for k, v in sorted(fn(0, len(formula)).items()): 
            ans.append(k)
            if v > 1: ans.append(str(v))
        return """".join(ans)"
self dividing numbers,"class Solution:
	def selfDividingNumbers(self, left: int, right: int) -> List[int]:
		result = []

		for i in range(left, right+ 1):
			if ""0"" in str(i): continue
			val = i
			while val > 0:
				n = val % 10
				if i % n != 0:
					val = -1
				val = val // 10

			if val != -1: result.append(i)

		return result"
self dividing numbers,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        v = []
        for x in range(left, right+1):
            # iterate thru every number left-right

            a = [*str(x)]
            # basically splits the str version of the number
            # ex: 22 -> ['2','2']

            d = True
            # bool variable to validate every number is self dividing

            for r in a:
                if int(r) != 0:
                # making sure r is not something like '0' in something like 10 for example
                    if x%int(r)!=0:
                        # if there is a number thats remainder is not 0
                        d = False
                else:
                    d = False
                    # falsing when there is a number such as 10, 20
            if d:
                v.append(x)
                # if d ends up being true, it appends x to v
        return v"
my calendar i,"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)"
count different palindromic subsequences,"class Solution:
    def countPalindromicSubsequences(self, s:str) -> int:
        
        @cache
        def fn(ch, i, j):
            if i > j:
                return 0
            
            if i == j and s[i] == ch:
                return 1
            
            if s[i] == s[j] == ch:
                return 2 + fn('a', i+1, j-1) + fn('b', i+1, j-1) + fn('c', i+1, j-1) + fn('d', i+1, j-1)
            elif s[i] != ch:
                return fn(ch, i+1, j)
            elif s[j] != ch:
                return fn(ch, i, j-1)
        
        
        n = len(s)
        return (fn('a', 0, n-1) + fn('b', 0, n-1) + fn('c', 0, n-1) + fn('d', 0, n-1)) % (10**9+7)"
count different palindromic subsequences,"class Solution:
    def countPalindromicSubsequences(self, S: str) -> int:
        n = len(S)
        pos = dict()
        nexts = [n]*n
        prev = [-1]*n
        for i, c in enumerate(S):
            if c in pos: prev[i] = pos[c]
            pos[c] = i
        pos = dict()
        for j in range(n-1, -1, -1):
            if S[j] in pos: nexts[j] = pos[S[j]]
            pos[S[j]] = j
        dp = [[0]*n for _ in range(n)]
        for i in range(n):
            dp[i][i] = 1
        for D in range(1, n):
            for i in range(n-D):
                j = i + D
                if S[i] != S[j]:
                    dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]
                else:
                    if nexts[i] > prev[j]: # a...a
                        dp[i][j] = dp[i+1][j-1] * 2 + 2
                    elif nexts[i] == prev[j]: # a..a...a
                        dp[i][j] = dp[i+1][j-1] * 2 + 1
                    else: # a...a....a....a
                        dp[i][j] = dp[i+1][j-1] * 2 - dp[nexts[i]+1][prev[j]-1]
        return dp[0][n-1] % (10**9+7)"
flood fill,"class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        
        h, w = len(image), len(image[0])
        
		
        def dfs( r, c, src_color):
            
            if r < 0 or c < 0 or r >= h or c >= w or image[r][c] == newColor or image[r][c] != src_color:
                # Reject for invalid coordination, repeated traversal, or different color
                return
            
            # update color
            image[r][c] = newColor
            
            
            # DFS to 4-connected neighbors
            dfs( r-1, c, src_color )
            dfs( r+1, c, src_color )
            dfs( r, c-1, src_color )
            dfs( r, c+1, src_color )
            
        # ---------------------------------------------------------------------------
        
        dfs(sr, sc, src_color = image[sr][sc] )
        
        return image"
flood fill,"class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        
        start_color = image[sr][sc]
        
        def flood_fill(x, y):
            if x < 0 or x >= len(image): return
            if y < 0 or y >= len(image[0]): return
            
            if image[x][y] == color: return
            if image[x][y] != start_color: return
            
            image[x][y] = color
            
            flood_fill(x-1, y)
            flood_fill(x+1, y)
            flood_fill(x, y+1)
            flood_fill(x, y-1)
        
        flood_fill(sr, sc)
        return image"
asteroid collision,"class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for a in asteroids:
            if a > 0:
                stack.append(a)
            else:
                while stack and stack[-1] > 0 and stack[-1] + a < 0:
                    stack.pop()
                if not stack or stack[-1] < 0:
                    stack.append(a)
                elif stack[-1] + a == 0:
                    stack.pop()
        return stack"
asteroid collision,"class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for asteroid in asteroids:
			# if there's things on the stack, we need to consider if we've got case 4
            while stack and stack[-1] > 0 and asteroid < 0:
				# determine which asteroids are exploding
                if abs(stack[-1]) < abs(asteroid):
                    stack.pop()
					# considered asteroid might still destroy others so continue checking
                    continue
                elif abs(stack[-1]) == abs(asteroid):
                    stack.pop()
                break
			# if nothing on the stack, or cases 1-3, just append
            else:
                stack.append(asteroid)
        return stack"
parse lisp expression,"class Solution:
    def evaluate(self, expression: str) -> int:
        stack = []
        parenEnd = {}
        
        # Get the end parenthesis location 
        for idx, ch in enumerate(expression):
            if ch == '(':
                stack.append(idx)
            if ch == ')':
                parenEnd[stack.pop()] = idx

        # Parses the expression into a list, each new sublist is a set of parenthesis
        # Example: 
        # Input: ""(let x 2 (mult x (let x 3 y 4 (add x y))))""
        # Output: ['let', 'x', '2', ['mult', 'x', ['let', 'x', '3', 'y', '4', ['add', 'x', 'y']]]]
        def parse(lo, hi):
            arr = []
            word = []

            i = lo
            while i < hi:
                if expression[i] == '(':
                    arr.append(parse(i + 1, parenEnd[i]))
                    i = parenEnd[i]
                elif expression[i] == ' ' or expression[i] == ')' and word != []:
                    if ''.join(word) != '':
                        arr.append(''.join(word))
                    word = []
                    i += 1
                elif expression[i] != ')':
                    word.append(expression[i])
                    i += 1
                else:
                    i += 1


            if word != []:
                arr.append(''.join(word))

            return arr

        # Change string expression into the list expression
        expressionList = parse(1, len(expression) - 1)

        # Eval expression with starting scope (variables)
        return self.genEval(expressionList, {})
    
    def genEval(self, expression, scope):
        if type(expression) != list:
            # If expression is just a variable or int
            try:
                return int(expression)
            except:
                return scope[expression]
        else:
            if expression[0] == 'let':
                # Remove ""let"" from expression list
                expression = expression[1:]
                
                # This loop updates the scope (variables)
                while len(expression) > 2:
                    scope = self.letEval(expression, scope.copy())
                    expression = expression[2:]
                    
                # Return the last value
                return self.genEval(expression[0], scope.copy())
                
            if expression[0] == 'add':
                return self.addEval(expression, scope.copy())
                
            if expression[0] == 'mult':
                return self.multEval(expression, scope.copy())


    
    def letEval(self, expression, scope):
        scope[expression[0]] = self.genEval(expression[1], scope)
        return scope
    
    def addEval(self, expression, scope):
        return self.genEval(expression[1], scope) + self.genEval(expression[2], scope)
    
    def multEval(self, expression, scope):
        return self.genEval(expression[1], scope) * self.genEval(expression[2], scope)"
parse lisp expression,"class Solution:
    def evaluate(self, expression: str) -> int:
        loc = {}
        stack = []
        for i, x in enumerate(expression): 
            if x == ""("": stack.append(i)
            elif x == "")"": loc[stack.pop()] = i
        
        def fn(lo, hi, mp): 
            """"""Return value of given expression.""""""
            if expression[lo] == ""("": return fn(lo+1, hi-1, mp)
            i = lo
            vals = []
            while i < hi: 
                if expression[i:i+3] in (""let"", ""add""): 
                    op = expression[i:i+3]
                    i += 3
                elif expression[i:i+4] == ""mult"": 
                    op = ""mult""
                    i += 4
                elif expression[i].isalpha(): 
                    x = """"
                    while i < hi and expression[i].isalnum(): 
                        x += expression[i]
                        i += 1
                    if op in (""add"", ""mult""): vals.append(mp[x])
                elif expression[i].isdigit() or expression[i] == ""-"": 
                    v = """"
                    while i < hi and (expression[i].isdigit() or expression[i] == ""-""): 
                        v += expression[i]
                        i += 1
                    if op == ""let"": mp[x] = int(v)
                    else: vals.append(int(v))
                elif expression[i] == ""("": 
                    v = fn(i+1, loc[i], mp.copy())
                    i = loc[i] + 1
                    if op == ""let"": mp[x] = v
                    else: vals.append(v)
                else: i += 1
            if op == ""let"": return int(v)
            elif op == ""add"": return sum(vals)
            else: return reduce(mul, vals)
            
        return fn(0, len(expression), {})"
monotone increasing digits,"class Solution:
    def monotoneIncreasingDigits(self, N: int) -> int:
        nums = [int(x) for x in str(N)] # digits 
        stack = []
        for i, x in enumerate(nums): 
            while stack and stack[-1] > x: x = stack.pop() - 1
            stack.append(x) 
            if len(stack) <= i: break 
        return int("""".join(map(str, stack)).ljust(len(nums), ""9"")) # right padding with ""9"""
monotone increasing digits,"class Solution:
    def monotoneIncreasingDigits(self, n: int) -> int:
    	N = [int(i) for i in str(n)]
    	L = len(N)
    	for I in range(L-1):
    		if N[I] > N[I+1]: break
    	if N[I] <= N[I+1]: return n
    	N[I+1:], N[I] = [9]*(L-I-1), N[I] - 1
    	for i in range(I,0,-1):
    		if N[i] >= N[i-1]: break
    		N[i], N[i-1] = 9, N[i-1] - 1
    	return sum([N[i]*10**(L-i-1) for i in range(L)])
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
daily temperatures,"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        result = [0] * len(temperatures) # having list with 0`s elements of same lenght as temperature array.
        stack = [] # taking empty stack. 
        for index, temp in enumerate(temperatures): # Traversing through provided list. 
            while stack and temperatures[stack[-1]] < temp: # stack should not be empty and checking previous temp with current temp. 
                # the above while loop and taking stack for saving index is very common practice in monotonic stack questions. Suggestion: understand it properly. 
                prev_temp = stack.pop() # stack.pop() will provide index of prev temp, taking in separate var as we are using it more then on place. 
                result[prev_temp] = index - prev_temp #at the index of prev_temp and i - prev_temp by this we`ll get how many step we moved to have greater temp. 
            stack.append(index) # in case stack is empty we`ll push index in it. 

        return result # returing the list of number of days to wait."
daily temperatures,"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        l = len(temperatures)
        result = [0] * l
        for i in range(l-1):
            for j in range(i+1, l):
                if temperatures[j] > temperatures[i]:
                    result[i] = j-i
                    break
        return result"
delete and earn,"class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        mp = {}
        for x in nums: mp[x] = x + mp.get(x, 0)
        
        @lru_cache(None)
        def fn(i): 
            """"""Return maximum points one can earn from nums[i:].""""""
            if i >= len(nums): return 0 
            if nums[i] + 1 not in mp: return mp[nums[i]] + fn(i+1)
            return max(mp[nums[i]] + fn(i+2), fn(i+1))
        
        nums = sorted(set(nums))
        return fn(0)"
delete and earn,"class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        freq = Counter(nums)
        prev = -inf 
        f0 = f1 = 0
        for x in sorted(freq): 
            if prev + 1 == x: f0, f1 = max(f0, f1), f0 + x*freq[x]
            else: f0, f1 = max(f0, f1), max(f0, f1) + x*freq[x]
            prev = x
        return max(f0, f1)"
cherry pickup,"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        
        @lru_cache(None)
        def fn(t, i, ii): 
            """"""Return maximum cherries collected at kth step when two robots are at ith and iith row""""""
            j, jj = t - i, t - ii #columns
            if not (0 <=  i < n and 0 <=  j < n) or t <  i or grid[ i][ j] == -1: return -inf #robot 1 not at proper location
            if not (0 <= ii < n and 0 <= jj < n) or t < ii or grid[ii][jj] == -1: return -inf #robot 2 not at proper location
            if t == 0: return grid[0][0] #starting from 0,0
            return grid[i][j] + (i != ii)*grid[ii][jj] + max(fn(t-1, x, y) for x in (i-1, i) for y in (ii-1, ii))
            
        return max(0, fn(2*n-2, n-1, n-1))"
cherry pickup,"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:

        @cache
        def dp(x1, y1, x2):
            y2 = x1+y1-x2

            if not(0 <= x1 < len(grid) and 0 <= y1 < len(grid[0]) and 0 <= x2 < len(grid) and 0 <= y2 < len(grid[0])):
                return -float('inf')

            if grid[x1][y1] == -1 or grid [x2][y2] == -1 :
                return -float('inf')

            if x1 == len(grid)-1 and x2 == len(grid)-1 and y1 == len(grid[0])-1 and y1 == len(grid[0])-1 :
                if grid[x1][y1] == 1 :
                    return 1 
                else :
                    return 0 

            if x1 == x2 and y1 == y2 :
                if grid[x1][y1] == 1 :
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
            else :
                if grid[x1][y1] == 1 and grid[x2][y2] == 1:
                    return 2+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x1][y1] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                elif grid[x2][y2] == 1:
                    return 1+max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
                else:
                    return max(dp(x1+1, y1, x2+1), dp(x1+1, y1, x2), dp(x1, y1+1, x2+1), dp(x1, y1+1, x2))
        
        if dp(0,0,0) == -float('inf'):
            return 0
        else :
            return dp(0,0,0)"
network delay time,"class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:        
        adj_list = defaultdict(list)
        
        for x,y,w in times:
            adj_list[x].append((w, y))
        
        visited=set()
        heap = [(0, k)]
        while heap:
            travel_time, node = heapq.heappop(heap)
            visited.add(node)
            
            if len(visited)==n:
                return travel_time
            
            for time, adjacent_node in adj_list[node]:
                if adjacent_node not in visited:
                    heapq.heappush(heap, (travel_time+time, adjacent_node))
                
        return -1"
network delay time,"class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        dp = [sys.maxsize] * n
        dp[k-1] = 0
        graph = collections.defaultdict(list)
        for s, e, w in times:
            graph[s].append((e, w))
        visited = set()    
        heap = [(0, k)]            
        while heap:
            cur, node = heapq.heappop(heap)
            dp[node-1] = cur
            if node not in visited:
                visited.add(node)
                n -= 1
            for nei, w in graph[node]:
                if dp[nei-1] > cur + w:
                    dp[nei-1] = cur + w
                    if nei not in visited:
                        heapq.heappush(heap, (cur + w, nei))
            if not n: return cur
        return -1"
find smallest letter greater than target,"class Solution(object):
    def nextGreatestLetter(self, letters, target):
        """"""
        :type letters: List[str]
        :type target: str
        :rtype: str
        """"""
        
        # if the number is out of bound
        if target >= letters[-1] or target < letters[0]:
            return letters[0]
        
        low = 0
        high = len(letters)-1
        while low <= high:
            mid = (high+low)//2
            
            if  target >= letters[mid]: # in binary search this would be only greater than
                low = mid+1
            
            if target < letters[mid]:
                high = mid-1
                
        return letters[low]"
find smallest letter greater than target,"class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:

        t_ord = ord(target) - ord('a')
        for i in letters:
            l_ord = ord(i) - ord('a')
            if l_ord > t_ord:
                return i
        return letters[0] # if no chrater is gte that target then return 0 index element"
min cost climbing stairs,"class Solution:
	def minCostClimbingStairs(self, cost: List[int]) -> int:
		cur = 0 
		dp0 = cost[0]
		if len(cost) >= 2:
			dp1 = cost[1]

		for i in range(2, len(cost)):
			cur = cost[i] + min(dp0, dp1)
			dp0 = dp1
			dp1 = cur

		return min(dp0, dp1)"
min cost climbing stairs,"class Solution:
			def minCostClimbingStairs(self, cost: List[int]) -> int:
				if not cost:
					return 0

				cur=0
				dp0=cost[0]

				if len(cost) >= 2:
					dp1=cost[1]

				for i in range(2, len(cost)):
					cur=cost[i] + min(dp0,dp1)
					dp0=dp1
					dp1=cur

				return min(dp0,dp1)"
largest number at least twice of others,"class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        if len(nums) is 1:
            return 0
        dom = max(nums)
        i = nums.index(dom)
        nums.remove(dom)
        if max(nums) * 2 <= dom:
            return i
        return -1"
largest number at least twice of others,"class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        largest = max(nums)
        for idx, val in enumerate(nums):
            if val==largest:
                new_idx = idx
                continue
            if val*2>largest: return -1
        return new_idx"
shortest completing word,"class Solution:
    def shortestCompletingWord(self, P: str, words: List[str]) -> str:
        alphs=""""
        res=""""        
        for p in P:
                if p.isalpha():
                        alphs+=p.lower()
        for word in words:                
                if all(alphs.count(alphs[i]) <= word.count(alphs[i]) for i in range(len(alphs))):
                        if res=="""" or len(res)>len(word):
                                res=word
        
        return res"
shortest completing word,"class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        req = Counter(filter(str.isalpha, licensePlate.lower()))
        words.sort(key=len)
        for count, word in zip(map(Counter, words), words):
            if count >= req:
                return word"
contain virus,"class Solution:
    def containVirus(self, mat: List[List[int]]) -> int:
        m,n = len(mat),len(mat[0])

        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area
            if 0<=i<m and 0<=j<n and (i,j) not in visited:
                if mat[i][j]==2: # Already quarantined cell
                    return 0
                if mat[i][j]==0:
                    nextInfected.add((i,j)) # add cell which will be infected next day
                    return 1   # require one wall to quarantined cell from one side
                    
                else:
                    visited.add((i,j))
                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction
            else:
                return 0
				
        ans = 0 
        while True:   # this loop running ""how many days we should installing the walls"" times
            # For every day check which area infect more cells
            visited = set()  # Using in dfs
            All_nextinfect  = set()
            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day
            
            for i in range(m):
                for j in range(n):
                    if mat[i][j]==1 and (i,j) not in visited:
                        nextInfected = set()
                        a = dfs(i,j,visited,nextInfected)
                        
                        if len(stop)<len(nextInfected):
                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus
                            stop = nextInfected  # pick new area which we want to save
                            walls = a  # require walls
                            p,q = i,j  # starting position(indices) of this area
                        else:
                            All_nextinfect  = All_nextinfect | nextInfected   
                            
            if not stop : # if our job is done i.e. No cell will be infect Later
                break
            ans += walls  # add new walls installed this day
            
            # change each cell value to 2 which will be covered by quarantined area
            def fun(p,q):
                if 0<=p<m and 0<=q<n and mat[p][q]==1:
                    mat[p][q]=2
                    fun(p+1,q)
                    fun(p-1,q)
                    fun(p,q-1)
                    fun(p,q+1)
            fun(p,q) # start dfs from start point of quarantined area
            
            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day
                mat[a][b] = 1

        return ans   # Final answer"
contain virus,"class Solution:
    def containVirus(self, isInfected: List[List[int]]) -> int:
        m, n = len(isInfected), len(isInfected[0])
        ans = 0 
        while True: 
            regions = []
            fronts = []
            walls = []
            seen = set()
            for i in range(m): 
                for j in range(n): 
                    if isInfected[i][j] == 1 and (i, j) not in seen: 
                        seen.add((i, j))
                        stack = [(i, j)]
                        regions.append([(i, j)])
                        fronts.append(set())
                        walls.append(0)
                        while stack: 
                            r, c = stack.pop()
                            for rr, cc in (r-1, c), (r, c-1), (r, c+1), (r+1, c): 
                                if 0 <= rr < m and 0 <= cc < n: 
                                    if isInfected[rr][cc] == 1 and (rr, cc) not in seen: 
                                        seen.add((rr, cc))
                                        stack.append((rr, cc))
                                        regions[-1].append((rr, cc))
                                    elif isInfected[rr][cc] == 0: 
                                        fronts[-1].add((rr, cc))
                                        walls[-1] += 1
            if not regions: break
            idx = fronts.index(max(fronts, key = len))
            ans += walls[idx]
            for i, region in enumerate(regions): 
                if i == idx: 
                    for r, c in region: isInfected[r][c] = -1 # mark as quaranteened 
                else: 
                    for r, c in fronts[i]: isInfected[r][c] = 1 # mark as infected 
        return ans"
open the lock,"class Solution:
    def openLock(self, deadends: List[str], end: str) -> int:
        if end in deadends or ""0000"" in deadends:
            return -1
        if end == ""0000"":
            return 0
        start, end, deadends = 0, int(end), {int(deadend) for deadend in deadends}

        def distance(cur: int, target: int) -> int:
            diff = 0
            for _ in range(4):
                a, b = cur % 10, target % 10
                d = abs(a - b)
                diff += min(d, 10 - d)
                cur, target = cur // 10, target // 10
            return diff

		def turn_knob(cur: int, idx: int) -> Tuple[int, int]:
			index = 10 ** idx
			digit = cur // index % 10
			up = cur - 9 * index if digit == 9 else cur + index
			down = cur - index if digit else cur + 9 * index
			return up, down

        def process(
            this_q: List[int], this_v: Dict[int, int], other_v: Dict[int, int], target: int
        ) -> int:
            _, cur = heappop(this_q)
            step = this_v[cur]
            for i in range(4):
                up, down = turn_knob(cur, i)
                if up in other_v:
                    return step + other_v[up] + 1
                if down in other_v:
                    return step + other_v[down] + 1
                if up not in deadends and up not in this_v:
                    this_v[up] = step + 1
                    this_q.append((distance(up, target), up))
                if down not in deadends and down not in this_v:
                    this_v[down] = step + 1
                    this_q.append((distance(down, target), down))
            heapify(this_q)
            return None

        s_q, s_v = [(distance(start, end), start)], {start: 0}
        e_q, e_v = [(distance(end, start), end)], {end: 0}
        while s_q and e_q:
            s = process(s_q, s_v, e_v, end)
            if s: return s
            e = process(e_q, e_v, s_v, start)
            if e: return e
        return -1"
open the lock,"class Solution:
    def openLock(self, deadends: list[str], target: str) -> int:
        target, turns = int(target), [0] * 10000
        for el in deadends:
            turns[int(el)] = -1
        dq = deque([0] * (turns[0] + 1))

        while dq:
            cur = dq.popleft()
            if cur == target:
                return turns[cur]

            for x in (10, 100, 1000, 10000):
                for k in (1, 9):
                    nxt = cur // x * x + (cur + k * x // 10) % x
                    if not turns[nxt]:
                        dq.append(nxt)
                        turns[nxt] = turns[cur] + 1

        return -1"
cracking the safe,"class Solution:
    def crackSafe(self, n: int, k: int) -> str:
        def dfs(path, visitedCombinations, targetNumVisited, combos):
            # Base Case. We've visited all possible combinations
            if len(visitedCombinations) == targetNumVisited:
                combos.append(''.join([str(x) for x in path]))
                return True
            # This if/else is necessary to prevent Python from picking up the first element if n = 1
            if n > 1:
                lastDigits = ''.join([str(x) for x in path[-(n-1):]])
            else:
                lastDigits = ''
            for i in range(k):
                path.append(i)
                newPwd = f'{lastDigits}{i}'
                # We have not reached the minimum pwd length. Continue recursion
                if len(newPwd) != n: 
                    if dfs(path, visitedCombinations, targetNumVisited, combos):
                        return True
                if len(newPwd) == n and newPwd not in visitedCombinations:
                    visitedCombinations[newPwd] = 1
                    if dfs(path, visitedCombinations, targetNumVisited, combos):
                        return True
                    del visitedCombinations[newPwd]
                path.pop()
            return False
                          
        
        # Empty visited Combinations hash set
        visitedCombinations = {}
        combos = []
        dfs([], visitedCombinations, k**n, combos)
        return combos[0]"
cracking the safe,"class Solution:
    def crackSafe(self, n: int, k: int) -> str:

        total = k**n-1
        start = '0' * n
        visited = set()
        visited.add('0' * n)
        self.ans = '0' * n

        def dfs(total,start):
            if total == 0: 
                return True
            for i in range(k):
                last = start[1:n]
                #print(last+str(i))
                end = last+str(i)
                if end not in visited:
                    visited.add(end)
                    total = total-1
                    self.ans = self.ans+str(i)
                    if dfs(total, end):
                        return True
                    else:
                        visited.remove(end)
                        total = total+1
                        self.ans = self.ans[:-1]
                        #print(""l"")
            return False

        dfs(total,start)
        return self.ans"
reach a number,"class Solution:
    def reachNumber(self, target: int) -> int:
        target = abs(target)
        step = 0
        far = 0
        while far < target or far%2 != target%2:
            step += 1
            far +=step
        
        return step"
reach a number,"class Solution:
    def reachNumber(self, target: int) -> int:
        def gaussSum(n):
            return n*(n+1)//2
        
        def binaryFind(lower, upper):
            t = abs(target)
            sums, n = -1, -1
            while lower <= upper:
                mid = (lower+upper)//2
                if gaussSum(mid) >= t:
                    sums, n = gaussSum(mid), mid
                    upper = mid-1
                else:
                    lower = mid+1
            return sums, n
        
                    
        lower, upper = 0, 10**5
        # find min n s.t. 1+2+...+n>=abs(target)
        sums, n = binaryFind(lower, upper)
        while sums%2 != abs(target)%2:
            sums += n+1
            n += 1
        return n"
pyramid transition matrix,"class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mp = {}
        for x, y, z in allowed: mp.setdefault((x, y), set()).add(z)
            
        def fn(row): 
            """"""Return list of rows built from given row.""""""
            ans = [""""]
            for x, y in zip(row, row[1:]):
                if (x, y) not in mp: return []
                ans = [xx + zz for xx in ans for zz in mp[x, y]]
            return ans 
        
        # dfs 
        stack = [bottom]
        while stack: 
            row = stack.pop()
            if len(row) == 1: return True 
            stack.extend(fn(row))
        return False"
pyramid transition matrix,"class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mp = {}
        for x, y, z in allowed: mp.setdefault((x, y), set()).add(z)
            
        def fn(row):
            """"""Return True if row could be built.""""""
            if len(row) == 1: return True 
            for xx in product(*(mp.get((x, y), []) for x, y in zip(row, row[1:]))): 
                if fn(xx): return True 
            return False 
        
        return fn(bottom)"
set intersection size at least two,"class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda x:x[1])
        size = 0
        prev_start = -1
        prev_end = -1

        for curr_start, curr_end in intervals:
            if prev_start == -1 or prev_end < curr_start: #if intervals do not overlap
                size += 2
                prev_start = curr_end-1
                prev_end = curr_end

            elif prev_start < curr_start: #if intervals overlap
                if prev_end != curr_end:
                    prev_start = prev_end
                    prev_end = curr_end
                    
                else:
                    prev_start = curr_end-1
                    prev_end = curr_end

                size += 1

        return size"
set intersection size at least two,"class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        ans = []
        for x, y in sorted(intervals, key=lambda x: (x[1], -x[0])): 
            if not ans or ans[-2] < x: 
                if ans and x <= ans[-1]: ans.append(y)
                else: ans.extend([y-1, y])
        return len(ans)"
special binary string,"class Solution:
def makeLargestSpecial(self, s: str) -> str:
    
    l = 0
    balance = 0
    sublist = []
    for r in range(len(s)):
        balance += 1 if s[r]=='1' else -1
        if balance==0:
            sublist.append(""1"" + self.makeLargestSpecial(s[l+1:r])+ ""0"")
            l = r+1
    
    sublist.sort(reverse=True)
    return ''.join(sublist)"
special binary string,"class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        
        def fn(lo, hi): 
            if lo == hi: return """"
            vals = []
            ii, prefix = lo, 0
            for i in range(lo, hi):
                prefix += 1 if s[i] == ""1"" else -1 
                if prefix == 0: 
                    vals.append(""1"" + fn(ii+1, i) + ""0"")
                    ii = i+1
            return """".join(sorted(vals, reverse=True))
        
        return fn(0, len(s))"
prime number of set bits in binary representation,"class Solution:
    def isPrime(self,x):
        flag=0
        if x==1:
            return False
        for i in range(2,x):
            if x%i==0:
                flag=1
                break
        if flag==1:
            return False
        return True
        
    def countPrimeSetBits(self, left: int, right: int) -> int:
        arr_dict={}
        lst=list(range(left,right+1))
        for i in lst:
            if i not in arr_dict:
                arr_dict[i]=bin(i).replace(""0b"","""")
        arr=list(arr_dict.values())
        count=0
        for i in arr:
            if self.isPrime(i.count('1')):
                # print(i)
                count+=1
        return count"
prime number of set bits in binary representation,"class Solution:
    def countPrimeSetBits(self, L: int, R: int) -> int:
    	return sum(1 for i in range(L,R+1) if bin(i).count('1') in {2,3,5,7,11,13,17,19})
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
partition labels,"class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        L = len(s)
        last = {s[i]: i for i in range(L)} # last appearance of the letter
        i, ans = 0, []
        while i < L:
            end, j = last[s[i]], i + 1
            while j < end: # validation of the part [i, end]
                if last[s[j]] > end:
                    end = last[s[j]] # extend the part
                j += 1
           
            ans.append(end - i + 1)
            i = end + 1
            
        return ans"
partition labels,"class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        d = collections.defaultdict(int)
        for i, c in enumerate(S): d[c] = i
        ans, left, right = [], -1, -1
        for i, c in enumerate(S):
            right = max(right, d[c])
            if i == right:
                ans.append(right-left)
                left = i
        return ans"
largest plus sign,"class Solution:
    def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:
        mat = [[1]*N for _ in range(N)]
        for x, y in mines: mat[x][y] = 0                   # create matrix with mine
            
        up = [[0]*N for _ in range(N)]                     # count 1s above mat[i][j] if mat[i][j] is 1
        for i in range(N):
            for j in range(N):
                if mat[i][j]: 
                    up[i][j] = 1
                    if i > 0: up[i][j] += up[i-1][j] 
                
        down = [[0]*N for _ in range(N)]                   # count 1s below mat[i][j] if mat[i][j] is 1
        for i in range(N-1, -1, -1):
            for j in range(N):
                if mat[i][j]: 
                    down[i][j] = 1
                    if i < N-1: down[i][j] += down[i+1][j] 
                    
        left = [[0]*N for _ in range(N)]                   # count 1s on the left side of mat[i][j] if mat[i][j] is 1
        for i in range(N):
            for j in range(N):
                if mat[i][j]:
                    left[i][j] = 1
                    if j > 0: left[i][j] += left[i][j-1]
                    
        right = [[0]*N for _ in range(N)]                  # count 1s on the right side of mat[i][j] if mat[i][j] is 1
        for i in range(N):
            for j in range(N-1, -1, -1):
                if mat[i][j]:
                    right[i][j] = 1
                    if j < N-1: right[i][j] += right[i][j+1]
         
		# find the largest + sign by using cached directions information
        return max(min([up[i][j], down[i][j], left[i][j], right[i][j]]) for i in range(N) for j in range(N))"
largest plus sign,"class Solution:
    def orderOfLargestPlusSign(self, N: int, M: List[List[int]]) -> int:
    	DP, M, R, T, m = [[math.inf]*N for i in range(N)], {tuple(m) for m in M}, list(range(N)), (0,1), 0
    	for k,i in itertools.product(T,R):
    		for _ in T:
    			c, I, _ = 0, i, R.reverse()
    			for j in R:
    				if k: i,j = j,i
    				c = 0 if (i,j) in M else c + 1
    				DP[i][j], i = min(DP[i][j],c), I
    	return max(max(i) for i in DP)"
couples holding hands,"class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        loc = {x: i for i, x in enumerate(row)}
        ans = 0
        for i in range(0, len(row), 2): 
            p = row[i] - 1 if row[i]&amp;1 else row[i]+1
            if row[i+1] != p: 
                ans += 1
                ii = loc[p]
                loc[row[i+1]], loc[row[ii]] = loc[row[ii]], loc[row[i+1]] # swap mappings
                row[i+1], row[ii] = row[ii], row[i+1] # swap values 
        return ans"
couples holding hands,"class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        n = len(row)
        def swap(idx, tgt):
            for i in range(idx, n):
                if row[i] == tgt:
                    row[idx], row[i] = row[i], row[idx]
                    return 1
            return 0

        output = 0
        for i in range(0, n, 2):
            num = row[i]
            if num % 2 == 0: target = num + 1
            else: target = num - 1
            if row[i + 1] != target: output += swap(i + 1, target)
        return output"
toeplitz matrix,"class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]])->bool:
        r_len, c_len = len(matrix),len(matrix[0])
        
        for r in range (1, r_len):
            for c in range (1, c_len):
                if matrix[r][c]!=matrix[r-1][c-1]:
                    return False
        
        return True"
toeplitz matrix,"class Solution(object):
    def isToeplitzMatrix(self, matrix):
        return all(i == 0 or j == 0 or matrix[i-1][j-1] == val
                   for i, row in enumerate(matrix)
                   for j, val in enumerate(row))"
reorganize string,"class Solution:
    def reorganizeString(self, S: str) -> str:
        counter = collections.Counter(S)
        i, res, n = 0, [None] * len(S), len(S)
        for k in sorted(counter, key = counter.get, reverse = True):
            if counter[k] > n // 2 + (n % 2): return """"
            for j in range(counter[k]):
                if i >= n: i = 1
                res[i] = k; i += 2
        return """".join(res)"
reorganize string,"class Solution:
    def reorganizeString(self, S: str) -> str:
        if not S: return ''
        heap, last, ans = [], None, ''
        counts = collections.Counter(S)
        for ch in counts:
            heapq.heappush(heap, (-counts[ch], ch))
            
        while heap:
            count, ch = heapq.heappop(heap)
            ans += ch
            if last:
                heapq.heappush(heap, last)
            last = (count+1, ch) if count != -1 else None
        return ans if not last else ''"
max chunks to make sorted ii,"class Solution:
def maxChunksToSorted(self, nums: List[int]) -> int:
    
    st = []
    for n in nums:
        if len(st)==0 or st[-1]<=n:
            st.append(n)
        else:
            ma = st[-1]
            while st and st[-1]>n:
                ma = max(ma,st.pop())
            st.append(ma)
    
    return len(st)"
max chunks to make sorted ii,"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        S = []
        for a in arr:
            min_i, max_i = a, a
            while S and a < S[-1][1]:
                start, end = S.pop()
                min_i, max_i = min(start, min_i), max(end, max_i)
            S.append([min_i, max_i])
        return len(S)"
max chunks to make sorted,"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        stack = []
        
        for num in arr:
            lagest = num
            while stack and num < stack[-1]:
                lagest = max(lagest, stack.pop())

            stack.append(lagest)
        
        return len(stack)"
max chunks to make sorted,"class Solution:
	def maxChunksToSorted(self, arr: List[int]) -> int:
		temp_sum, block = 0, 0
		for i in range(len(arr)):
			temp_sum += arr[i] - i
			if temp_sum == 0:
				block += 1
		return block"
jewels and stones,"class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
    	return sum(i in J for i in S)



class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
    	return sum(S.count(i) for i in J)



from collections import Counter

class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
    	return sum(Counter(S)[i] for i in J)
		
		

- Junaid Mansuri
(LeetCode ID)@hotmail.com"
jewels and stones,"class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        occ=dict()
        for i in stones:
            if i in occ.keys():
                occ[i]+=1
            else:
                occ.update({i:1})
        res=0
        for i in jewels:
            if i in occ.keys():
                res+=occ[i]
            
        return res"
sliding puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        def isSolved(board):
            if board[-1] != 0: return False
            for i in range(5):
                if board[i] != i + 1: return False
            return True
        
        swap = {
            0: [1, 3],
            1: [0, 2, 4],
            2: [1, 5],
            3: [0, 4],
            4: [1, 3, 5],
            5: [2, 4],
        }

        q = [board[0] + board[1]]
        steps = 0
        seen = set()
        while (len(q)):
            new_q = []
            for board in q:
                if tuple(board) in seen: continue
                seen.add(tuple(board))
                if isSolved(board): return steps

                zeroIdx = board.index(0)
                for swapIdx in swap[zeroIdx]:
                    copy = board.copy()
                    copy[zeroIdx], copy[swapIdx] = copy[swapIdx], copy[zeroIdx]
                    new_q.append(copy)
            steps += 1
            q = new_q

        return -1"
sliding puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        neighbours = ((1, 3), (0, 2, 4), (1, 5), (0, 4), (1, 3, 5), (2, 4))
        board = tuple(tile for row in board for tile in row)
        solved = (1, 2, 3, 4, 5, 0)
        
        if board == solved:
            return 0
        
        q = collections.deque([(board, 0)])
        visited = {board}
        
        while q:
            board, moves = q.popleft()
            zero = board.index(0)
            
            for neighbour in neighbours[zero]:
                newBoard = list(board)
                newBoard[zero], newBoard[neighbour] = newBoard[neighbour], newBoard[zero]
                newBoard = tuple(newBoard)
                
                if newBoard == solved:
                    return moves + 1
                if newBoard not in visited:
                    visited.add(newBoard)
                    q.append((newBoard, moves + 1))
        
        return -1"
global and local inversions,"class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        for i, a in enumerate(A):
            if (abs(a - i) > 1):
                return False
        
        return True"
global and local inversions,"class Solution:
    def isIdealPermutation(self, nums: List[int]) -> bool:
        currMax = float('-inf')
        willBeNextMax = float('-inf')
        for num in nums:
            if num < currMax:
                return False
            else:
                currMax = willBeNextMax
                willBeNextMax = max(willBeNextMax, num)
        return True"
swap adjacent in lr string,"class Solution:
    def canTransform(self, S, E):
        L, R, X = 0, 0, 0
        for i, j in zip(S, E):
            L += (j == 'L')
            R += (i == 'R')
            if i == 'R' and L: return False
            if j == 'L' and R: return False
            L -= (i == 'L')
            R -= (j == 'R')
            if L < 0 or R < 0: return False
            X += (i == 'X') - (j == 'X')
        return X == 0"
swap adjacent in lr string,"class Solution:
	def canTransform(self, start: str, end: str) -> bool:
		i=j=0
		n=len(start)
		while i<n or j<n:
			while i<n and start[i]=='X':
				i+=1
			while j<n and end[j]=='X':
				j+=1
			if i==n or j==n:
				return i==j
			if start[i]!=end[j]:
				return False
			if (start[i]=='L' and j>i) or (start[i]=='R' and i>j):
				return False
			i+=1
			j+=1
		return True"
swim in rising water,"class Solution:
    # O(max(n^2, m)) time, h --> the highest elevation in the grid
    # O(n^2) space,
    # Approach: BFS, Priority queue
    # I wld advise to do task scheduler question, it's pretty similar
    # except that u apply bfs to traverse the grid 4 directionally
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        if n == 1:
            return 0
        
        def getNeighbours(coord: Tuple) -> List[Tuple]:
            i, j = coord
            n = len(grid)
            neighbours = []
            
            if i < n-1:
                neighbours.append((i+1, j))
            if i > 0:
                neighbours.append((i-1, j))
            if j < n-1:
                neighbours.append((i, j+1))
            if j > 0:
                neighbours.append((i, j-1))
                
            return neighbours
        
        qu = deque()
        waiting_qu = []
        vstd = set()
        waiting_qu.append([grid[0][0], (0, 0)])
        vstd.add((0, 0))
        time = 0
        
        while waiting_qu:
            time +=1
            while waiting_qu and waiting_qu[0][0] <= time:
                qu.append(heapq.heappop(waiting_qu)[1])
            
            while qu:
                cell = qu.popleft()
                if cell == (n-1, n-1):
                    return time
                nbrs = getNeighbours(cell)
                for nb in nbrs:
                    if nb in vstd:  continue
                    x, y = nb
                    elevation = grid[x][y]
                    vstd.add(nb)
                    if elevation > time:
                        heapq.heappush(waiting_qu, [elevation, nb])
                    else:
                        qu.append(nb)
        
        return -1"
swim in rising water,"class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        minheap = [(grid[0][0], 0, 0)]
        visited = [[False for _ in range(n)] for _ in range(n)]
        visited[0][0] = True

        while minheap:
            maxht, x, y = heapq.heappop(minheap)
            #print(maxht, x, y)
            if x == n-1 and y == n-1:
                return maxht
            if x > 0 and visited[x-1][y] == False:
                visited[x-1][y] = True
                heapq.heappush(minheap, (max(maxht, grid[x-1][y]), x-1, y))
            if y > 0 and visited[x][y-1] == False:
                visited[x][y-1] = True
                heapq.heappush(minheap, (max(maxht, grid[x][y-1]), x, y-1))
            if x < n-1 and visited[x+1][y] == False:
                visited[x+1][y] = True
                heapq.heappush(minheap, (max(maxht, grid[x+1][y]), x+1, y))
            if y < n-1 and visited[x][y+1] == False:
                visited[x][y+1] = True
                heapq.heappush(minheap, (max(maxht, grid[x][y+1]), x, y+1))"
k th symbol in grammar,"class Solution:
    
    def kthGrammar(self, N: int, K: int) -> int:
        if N == 1: 
            return 0
        half = 2**(N - 2) 
        
        if K > half:
            return 1 if self.kthGrammar(N - 1, K - half) == 0 else 0
        else:
            return self.kthGrammar(N - 1, K)"
k th symbol in grammar,"class Solution:
    def kthGrammar(self, N, K):
        if K == 1: return 0
        if K &amp; 1: return self.kthGrammar(N - 1, K // 2 + 1)
        return self.kthGrammar(N - 1, K // 2) ^ 1"
reaching points,"class Solution:
    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        if sx > tx or sy > ty: return False
        if sx == tx: return (ty-sy)%sx == 0 # only change y
        if sy == ty: return (tx-sx)%sy == 0
        if tx > ty: 
            return self.reachingPoints(sx, sy, tx%ty, ty) # make sure tx%ty < ty
        elif tx < ty: 
            return self.reachingPoints(sx, sy, tx, ty%tx)
        else:
            return False"
reaching points,"class Solution:
    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        while sx < tx or sy < ty: 
            if tx > ty: 
                k = (tx - sx)//ty 
                if k == 0: break 
                tx -= k * ty 
            else: 
                k = (ty - sy)//tx 
                if k == 0: break 
                ty -= k * tx 
        return sx == tx and sy == ty"
rabbits in forest,"class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        return sum((key+1) * math.ceil(freq / (key+1)) if key+1 < freq else key+1 for key, freq in collections.Counter(answers).items())"
rabbits in forest,"class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        ans, cnt = 0, collections.Counter(answers)
        for key, freq in cnt.items():
            if key + 1 < freq: ans += (key+1) * math.ceil(freq / (key+1))
            else: ans += key+1
        return ans"
transform to chessboard,"class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        n = len(board)
        
        def fn(vals): 
            """"""Return min moves to transform to chessboard.""""""
            total = odd = 0 
            for i, x in enumerate(vals): 
                if vals[0] == x: 
                    total += 1
                    if i&amp;1: odd += 1
                elif vals[0] ^ x != (1 << n) - 1: return inf
            ans = inf 
            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)
            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)
            return ans 
        
        rows, cols = [0]*n, [0]*n
        for i in range(n): 
            for j in range(n): 
                if board[i][j]: 
                    rows[i] ^= 1 << j 
                    cols[j] ^= 1 << i
        ans = fn(rows) + fn(cols)
        return ans if ans < inf else -1"
minimum distance between bst nodes,"class Solution:
    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        
        # list with two element
        # the first for the previous element
        # the second for the min value
        pre_mn = [-float(""inf""), float(""inf"")]
        
        def dfs(tree):
            
            if not tree:
                return
            
            # Keep going to the left
            dfs(tree.left)
            
            # if we can't go further, update min and pre
            pre_mn[1] = min(pre_mn[1], abs(tree.val) - pre_mn[0])
            pre_mn[0] = tree.val
            
            # keep traversing in-order
            dfs(tree.right)
        
        dfs(root)
        
        # return min (the second element in the list)
        return pre_mn[1]"
minimum distance between bst nodes,"class Solution:
    def traverse(self,root,vals):
        if root is None:
            return
        
        self.traverse(root.left,vals)
        vals.append(root.val)
        self.traverse(root.right,vals)
        
    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        vals =[]
        self.traverse(root,vals)
        
        ans = [abs(vals[i+1]-vals[i]) for i in range(len(vals)-1)]
        return min(ans)"
letter case permutation,"class Solution(object):
    def letterCasePermutation(self, S):
        """"""
        :type S: str
        :rtype: List[str]
        """"""
        def backtrack(sub="""", i=0):
            if len(sub) == len(S):
                res.append(sub)
            else:
                if S[i].isalpha():
                    backtrack(sub + S[i].swapcase(), i + 1)
                backtrack(sub + S[i], i + 1)
                
        res = []
        backtrack()
        return res"
letter case permutation,"class Solution:
    def letterCasePermutation(self, S: str) -> List[str]:
        output = [""""]
        for ch in S:
            for i in range(len(output)):
                if ch.isalpha():
                    output.append(output[i]+ch.lower())
                    output[i] = output[i]+ch.upper()
                else:
                    output[i] = output[i]+ch
        return output"
is graph bipartite,"class Solution:

    def isBipartite(self, graph: list[list[int]]) -> bool:
	
        vis = [False for n in range(0, len(graph))]
        
        while sum(vis) != len(graph): # Since graph isn't required to be connected this process needs to be repeated

            ind = vis.index(False) # Find the first entry in the visited list that is false
            vis[ind] = True
            grp = {ind:True} # initialize first node as part of group 1
            q = [ind] # Add current index to queue
            
            while q: # Go to each node in the graph
                u = q.pop(0)

                for v in graph[u]: # Go to each vertice connected to the current node

                    if vis[v] == True: #  If visited check that it is in the opposite group of the current node
                        if grp[u] == grp[v]:
                            return False # If a single edge does not lead to a group change return false

                    else: # If not visited put v in opposite group of u, set to visited, and append to q
                        vis[v] = True
                        grp[v] = not grp[u]
                        q.append(v)
        
        return True"
is graph bipartite,"class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        graph = [set(g) for g in graph]
        colors = [-1] * n
        def bfs(i):
            q = collections.deque([[i, 0]])
            while q:
                idx, color = q.popleft()
                colors[idx] = color
                for nei in graph[idx]:
                    if colors[nei] >= 0:
                        if 1-color != colors[nei]: 
                            return False
                        continue
                    q.append((nei, 1-color))
            return True
        for i in range(n):
            if colors[i] < 0 and not bfs(i):
                return False
        return True"
k th smallest prime fraction,"class Solution:

	def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
		if len(arr) > 2:
			res = []  # list for storing the list: [prime fraction of arr[i]/arr[j], arr[i], arr[j]]

			for i in range(len(arr)):
				for j in range(i + 1, len(arr)):
					# creating and adding the sublist to res
					tmp = [arr[i] / arr[j], arr[i], arr[j]]
					res.append(tmp)

			# sorting res on the basis of value of arr[i] 
			res.sort(key=lambda x: x[0])

			# creating and returning the required list
			return [res[k - 1][1], res[k - 1][2]]
		else:
			return arr"
k th smallest prime fraction,"class Solution:
    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        N = len(arr)
        def count_less(v):
            """"""1. the number of fractions < v
            2. the largest fraction l/r that is < v""""""
            li = 0
            cnt, l, r = 0, arr[0], arr[-1]
            for ri in range(1, N):
                while li < ri and arr[li]/arr[ri] < v:
                    if arr[li]/arr[ri] > l/r:
                        l, r = arr[li], arr[ri]
                    li += 1
                cnt += li
            return cnt, l, r

        lo, hi = arr[0]/arr[-1], 1
        while lo <= hi:
            v = (lo+hi)/2
            cnt, l, r = count_less(v)
            if cnt == k:
                return [l, r]
            if cnt < k:
                lo = v
            else:
                hi = v"
cheapest flights within k stops,"class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        #Make graph
        adj_list = {i:[] for i in range(n)}
        for frm, to, price in flights:
            adj_list[frm].append((to, price))
        
        best_visited = [2**31]*n # Initialized to maximum
        
        prior_queue = [ (0, -1, src) ]  # weight, steps, node

        while prior_queue:
            cost, steps, node = heapq.heappop(prior_queue)
            
            if best_visited[node] <= steps:  # Have seen the node already, and the current steps are more than last time
                continue

            if steps > k:  # More than k stops, invalid
                continue

            if node==dst:  # reach the destination # as priority_queue is a minHeap so this cost is the most minimum cost.
                return cost
            
            best_visited[node] = steps # Update steps

            for neighb, weight in adj_list[node]:
                heapq.heappush(prior_queue, (cost + weight, steps + 1, neighb))

        return -1
		
# Time: O(n * len(flights) * log(n))
# Space: O(n)"
cheapest flights within k stops,"class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        graph = {}

        for u in range(n):
            graph[u] = []

        for u,v,w in flights:
            graph[u].append((v,w))

        heap = [(0,-K,src)]

        while heap:
            (cost,i,u) = heapq.heappop(heap)

            if u == dst:
                return cost

            for v,w in graph[u]:
                nc = cost + w

                if i <= 0:
                    heapq.heappush(heap, (nc,i+1,v))

        return -1"
rotated digits,"class Solution:
    def rotatedDigits(self, N: int) -> int:
        count = 0
        for x in range(1, N+1):
            x = str(x)
            if '3' in x or '4' in x or '7' in x:
                continue
            if '2' in x or '5' in x or '6' in x or '9' in x:
                count+=1
        return count"
rotated digits,"class Solution:
    def rotatedDigits(self, N: int) -> int:
        d = {'0':'0','1':'1','2':'5','5':'2','6':'9','8':'8','9':'6'}
        count = 0
        for i in range(1,N+1):
            x = ''
            flag = True
            for j in str(i):
                if j not in d.keys():
                    flag = False
                    break
                else:
                    x += d[j]
            if flag and x != str(i):
                count += 1
        return count"
escape the ghosts,"class Solution:
    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
        t_x, t_y = target
        m_x, m_y = abs(t_x), abs(t_y)
        for x, y in ghosts:
            manhattan = abs(t_x - x) + abs(t_y - y)
            if manhattan <= m_x + m_y:
                return False
        return True"
escape the ghosts,"class Solution:
    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
        xx, yy = target 
        return all(abs(x-xx) + abs(y-yy) > abs(xx) + abs(yy) for x, y in ghosts)"
domino and tromino tiling,"class Solution(object):
    def numTilings(self, n):
        dp = [1, 2, 5] + [0] * n
        for i in range(3, n):
            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007
        return dp[n - 1]"
domino and tromino tiling,"class Solution(object):
    def numTilings(self, n):
        dp, dpa = [1, 2] + [0] * n, [1] * n
        for i in range(2, n):
            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007
            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007
        return dp[n - 1]"
custom sort string,"class Solution:
    def customSortString(self, order: str, s: str) -> str:

        rank = [26]*26
        
        for i in range(len(order)):
            rank[ord(order[i]) - ord('a')] = i

        return """".join(sorted(list(s), key= lambda x: rank[ord(x) - ord('a')]))"
custom sort string,"class Solution:
    def customSortString(self, order: str, s: str) -> str:
        
        def serialOrder(x):
            return rank[ord(x) - ord('a')]
        
        rank = [26]*26
        
        for i in range(len(order)):
            rank[ord(order[i]) - ord('a')] = i
        
        
        print(rank)
        arr = [i for i in s]
        
        arr.sort(key= serialOrder)
        
        s = """".join(arr)
        
        return s"
number of matching subsequences,"class Solution:
def numMatchingSubseq(self, s: str, words: List[str]) -> int:
    
    def is_sub(word):
        index=-1
        for ch in word:
            index=s.find(ch,index+1)
            if index==-1:
                return False
        return True
    
    c=0
    for word in words:
        if is_sub(word):
            c+=1
    
    return c"
number of matching subsequences,"class Solution:  # The plan is to iterate through the words and, for each word w, move 
                     # letter by letter of w though the string s if possible to determine 
                     # whether w is a subsequence of s. If so, we  add to ans.
                     #
                     # We use a function and a cache because many of the words share letter
                     # sequences.

    def numMatchingSubseq(self, s: str, words: list[str]) -> int:
                                    
        @lru_cache(None)            
        def checkWord(word):
            start = 0 

            for ch in word:         
                start = s.find(ch, start) + 1          # <-- find gives us the index of the
                if not start: return False             #     the next occurence of ch after
                                                       #     the index ""start""
            return True
        
        return sum(checkWord(w) for w in words)        # <-- we count all the words that
                                                       #     returned True."
preimage size of factorial zeroes function,"class Solution:
    def preimageSizeFZF(self, k: int) -> int:
        lo, hi = 0, 1 << 32
        while lo <= hi: 
            mid = lo + hi >> 1
            x, y = mid, 0 
            while x: 
                x //= 5
                y += x
            if y < k: lo = mid + 1
            elif y > k: hi = mid - 1
            else: return 5
        return 0"
preimage size of factorial zeroes function,"class Solution:
    def findzeroes(self,num):
        # This part takes log(n) time
        tmp=0
        val=5
        while val<=num:
            tmp+=num//val
            val*=5
        return tmp
    def preimageSizeFZF(self, k: int) -> int:

        if k==0:return 5
        high=5
        while True:
            tmp=self.findzeroes(high)
            if tmp==k:return 5
            if tmp>k:break
            high*=5
        low=high//5
        while low<=high:
            mid=(low+high)//2
            tmp=self.findzeroes(mid)
            if tmp==k:return 5
            if tmp<k:low=mid+1
            else:high=mid-1
        return 0"
valid tic tac toe state,"class Solution:
    def validTicTacToe(self, board: List[str]) -> bool:
                                            # The two criteria for a valid board are:
                                            #   1) num of Xs - num of Os is 0 or 1
                                            #   2) X is not a winner if the # of moves is even, and
                                            #      O is not a winner if the # of moves is odd.

        d = {'X': 1, 'O': -1, ' ': 0}               # transform the 1x3 str array to a 1x9 int array
        s = [d[ch] for ch in ''.join(board)]        # Ex: [""XOX"","" X "",""   ""] --> [1,-1,1,0,1,0,0,0,0]
        sm = sum(s)

        if sm>>1: return False                                      # <-- criterion 1
        
        n = -3 if sm == 1 else 3                                    # <-- criterion 2.
        if n in {s[0]+s[1]+s[2], s[3]+s[4]+s[5], s[6]+s[7]+s[8], 
                 s[0]+s[3]+s[6], s[1]+s[4]+s[7], s[2]+s[5]+s[8],         # the elements of the set are 
                 s[0]+s[4]+s[8], s[2]+s[4]+s[6]}: return False           # the rows, cols, and diags
        
        return True                                                 # <-- both criteria are true"
valid tic tac toe state,"class Solution:
    def validTicTacToe(self, board: List[str]) -> bool:
        n = 3
        rows = [0] * n
        cols = [0] * n
        diag = antidiag = balance = 0
        
        def win(v):
            if v in rows or v in cols or v in [diag, antidiag]: return True
            return False
        
        for i in range(n):
            for j in range(n):
                if board[i][j] != "" "":
                    balance += 1 if board[i][j] == ""X"" else -1
                    rows[i] += 1 if board[i][j] == ""X"" else -1
                    cols[j] += 1 if board[i][j] == ""X"" else -1
                    if i == j: diag += 1 if board[i][j] == ""X"" else -1
                    if i + j == n - 1: antidiag += 1 if board[i][j] == ""X"" else -1
        
        if not 0 <= balance <= 1: return False
            
        if balance == 0 and win(n): return False
        if balance == 1 and win(-n): return False
        
        return True"
number of subarrays with bounded maximum,"class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        start,end = -1, -1
        res = 0
        for i in range(len(nums)):
            if nums[i] > right:
                start = end = i
                continue
                
            if nums[i] >= left:
                end = i
                
            res += end - start
        return res"
number of subarrays with bounded maximum,"class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        ans = inc = cnt = 0 
        for x in nums: 
            if x < left: cnt += 1
            elif left <= x <= right: inc = cnt = cnt + 1
            else: inc = cnt = 0 
            ans += inc 
        return ans"
rotate string,"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        return len(s) == len(goal) and s in goal+goal"
rotate string,"class Solution:
    def rotateString(self, A: str, B: str) -> bool:
    	return (A in B*2) and (len(A) == len(B))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
all paths from source to target,"class Solution:
     def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
            q = [[0]]
            result = []
            target = len(graph) - 1
            
            while q:
                temp = q.pop(0)
                
                if temp[-1] == target:
                    result.append(temp)
                else:
                    for neighbor in graph[temp[-1]]:
                        q.append(temp + [neighbor])
            
            return result"
all paths from source to target,"class Solution(object):
    def __init__(self):
        self.memo = {}
    def allPathsSourceTarget(self, graph):
        """"""
        :type graph: List[List[int]]
        :rtype: List[List[int]]
        """"""
        self.memo = {len(graph)-1:[[len(graph)-1]]}
        def calc(N):
            if N in self.memo:
                return self.memo[N]
            a = []
            for n in graph[N]:
                for path in calc(n):
                    a.append([N]+path)
            self.memo[N] = a
            return a
        return calc(0)"
smallest rotation with highest score,"class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        diff = [0]*(len(nums) + 1)
        for i, x in enumerate(nums): 
            diff[i+1] += 1
            if x <= i: diff[0] += 1
            diff[(i-x)%len(nums) + 1] -= 1
        
        ans = prefix = 0 
        mx = -inf 
        for i, x in enumerate(diff): 
            prefix += x
            if prefix > mx: mx, ans = prefix, i
        return ans"
smallest rotation with highest score,"class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        diff = [1] * len(nums)
        for i, x in enumerate(nums): 
            diff[(i-x+1) % len(nums)] -= 1
        prefix = list(accumulate(diff))
        return prefix.index(max(prefix))"
champagne tower,"class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        dp = [[0 for _ in range(x)] for x in range(1, query_row + 2)]
        dp[0][0] = poured
        
        for i in range(query_row):
            for j in range(len(dp[i])):
                temp = (dp[i][j] - 1) / 2.0
                if temp>0:
                    dp[i+1][j] += temp
                    dp[i+1][j+1] += temp
        
        return dp[query_row][query_glass] if dp[query_row][query_glass] <= 1 else 1"
champagne tower,"class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        pyramid = {k-1:[0] * k for k in range(1, 101)}
        pyramid[0][0] = poured
        for row in range(1, query_row+1):
            T = True
            for c in range(row):
                val = (pyramid[row-1][c] - 1.0) / 2.0
                if val>0:
                    T = False
                    pyramid[row][c] += val
                    pyramid[row][c+1] += val
            if T:
                return min(1, pyramid[query_row][query_glass])
        return min(1, pyramid[query_row][query_glass])"
minimum swaps to make sequences increasing,"class Solution:
    def minSwap(self, A: List[int], B: List[int]) -> int:
        ans = sm = lg = mx = 0
        for x, y in zip(A, B): 
            if mx < min(x, y): # prev max < current min
                ans += min(sm, lg) # update answer &amp; reset 
                sm = lg = 0 
            mx = max(x, y)
            if x < y: sm += 1 # count ""x < y""
            elif x > y: lg += 1 # count ""x > y""
        return ans + min(sm, lg)"
minimum swaps to make sequences increasing,"class Solution:
    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:
        dp = [[-1]*2 for i in range(len(nums1))]
        
        def solve(prev1, prev2, i, swaped):
            if i >= len(nums1): return 0
            if dp[i][swaped] != -1: return dp[i][swaped]
                        
            ans = 2**31
            
            # No Swap
            if nums1[i] > prev1 and nums2[i] > prev2:
                ans = solve(nums1[i], nums2[i], i+1, 0) 
            
            # Swap
            if nums1[i] > prev2 and nums2[i] > prev1:
                ans = min(ans, 1 + solve(nums2[i], nums1[i], i+1, 1)) 
            
            dp[i][swaped] = ans
            return ans
        
        return solve(-1, -1, 0, 0)"
find eventual safe states,"class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n=len(graph)
        status=[0]*(n)
        res=[]
        
        def dfs(i):# this function will check is there any loop, cycle and i is a part of that loop,cycle 
            if status[i]==""visited"": #if this node is already visited, loop detected return true
                return True
            if status[i]==""safe"": #if this node is previously visited and marked safe no need to repeat it ,return False no loop possible from it
                return False
            status[i]=""visited"" # so we have visited this node
            for j in graph[i]:
                if  dfs(j):# if loop detected return True
                    return True
            status[i]=""safe"" # if we reached till here means no loop detected from node i so this node is safe
            return False # no loop possible return false
       
    
        for i in range(n):
            if not dfs(i): #if no loop detected this node is safe 
                res.append(i)
        return res"
find eventual safe states,"class Solution:
	""""""
	Time:   O(V + E)
	Memory: O(V)
	""""""

	WHITE = 0
	GRAY = 1
	BLACK = 2

	def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
		def dfs(u: int) -> bool:
			if color[u] == self.GRAY:
				return True

			if color[u] == self.BLACK:
				return False

			color[u] = self.GRAY
			for v in graph[u]:
				if dfs(v):
					return True

			color[u] = self.BLACK
			return False

		color = [self.WHITE] * len(graph)
		return [node for node in range(len(graph)) if not dfs(node)]"
unique morse code words,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(n)
	""""""

	MORSE = {
		'a': '.-',   'b': '-...', 'c': '-.-.', 'd': '-..',  'e': '.',    'f': '..-.', 'g': '--.',
		'h': '....', 'i': '..',   'j': '.---', 'k': '-.-',  'l': '.-..', 'm': '--',   'n': '-.',
		'o': '---',  'p': '.--.', 'q': '--.-', 'r': '.-.',  's': '...',  't': '-',    'u': '..-',
		'v': '...-', 'w': '.--',  'x': '-..-', 'y': '-.--', 'z': '--..',
	}

	def uniqueMorseRepresentations(self, words: List[str]) -> int:
		return len(set(map(self.encode, words)))

	@classmethod
	def encode(cls, word: str) -> str:
		return ''.join(map(cls.MORSE.get, word))"
unique morse code words,"class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
    	M = ['.-','-...','-.-.','-..','.','..-.','--.','....','..','.---','-.-','.-..','--','-.','---','.--.','--.-','.-.','...','-','..-','...-','.--','-..-','-.--','--..']
    	return len(set([''.join(map(lambda x: M[ord(x)-97], w)) for w in words]))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
split array with same average,"class Solution(object):
    def splitArraySameAverage(self, A):
        if len(A)==1: return False
        global_avg = sum(A)/float(len(A))
        for lenB in range(1, len(A)/2+1):
            if int(lenB*global_avg) == lenB*global_avg:
                if self.exist(lenB*global_avg, lenB, A):
                    return True
        return False
            
    def exist(self, tosum, item_count, arr):
        if item_count==0:
            return False if tosum else True
        if item_count > len(arr) or not arr: 
            return False
        if any([self.exist(tosum-arr[0], item_count-1, arr[1:]),
               self.exist(tosum, item_count, arr[1:])]):
            return True
        return False"
split array with same average,"class Solution:
	def splitArraySameAverage(self, A: List[int]) -> bool:

		# A subfunction that see if total k elements sums to target
		# target is the goal, k is the number of elements in set B, i is the index we have traversed through so far
		mem = {}

		def find(target, k, i):
			# if we are down searching for k elements in the array, see if the target is 0 or not. This is a basecase
			if k == 0: return target == 0

			# if the to-be selected elements in B (k) + elements we have traversed so far is larger than total length of A
			# even if we choose all elements, we don't have enough elements left, there should be no valid answer.
			if k + i > len(A): return False

			if (target, k, i) in mem: return mem[(target, k, i)]

			# if we choose the ith element, the target becomes target - A[i] for total sum
			# if we don't choose the ith element, the target doesn't change
			mem[(target - A[i], k - 1, i + 1)] = find(target - A[i], k - 1, i + 1) or find(target, k, i + 1)

			return mem[(target - A[i], k - 1, i + 1)]

		n, s = len(A), sum(A)
		# Note that the smaller set has length j ranging from 1 to n//2+1
		# we iterate for each possible length j of array B from length 1 to length n//2+1
		# if s*j%n, which is the sum of the subset, it should be an integer, so we only proceed to check if s * j % n == 0
		# we check if we can find target sum s*j//n (total sum of j elements that sums to s*j//n)
		return any(find(s * j // n, j, 0) for j in range(1, n // 2 + 1) if s * j % n == 0)"
number of lines to write string,"class Solution:
    def numberOfLines(self, widths: List[int], s: str) -> List[int]:
        count = ans =  wi = 0
        s = list(s)
        while s:
            val = ord(s[0]) - 97
            
            if(widths[val] + wi > 100):
                wi = 0
                count += 1
            
            wi += widths[val]
            
            s.pop(0)
        return([count + 1 , wi])"
number of lines to write string,"class Solution:
#     Runtime: 42ms 67.78% Memory: 13.9mb 19.81%
# O(n) || O(1)
    def numberOfLines(self, widths, s):
        newLine = 1
        
        width = 0
        
        for char in s:
            charWidth = widths[ord(char) - ord('a')]
            
            if charWidth + width > 100:
                newLine += 1
                width = 0
                
            width += charWidth
                
        return [newLine, width]"
max increase to keep city skyline,"class Solution:
    def maxIncreaseKeepingSkyline(self, G: List[List[int]]) -> int:
        M, N, R, C = len(G), len(G[0]), [max(r) for r in G], [max(c) for c in zip(*G)]
        return sum(min(R[i],C[j]) - G[i][j] for i,j in itertools.product(range(M),range(N)))
		
		
- Junaid Mansuri
- Chicago, IL"
max increase to keep city skyline,"class Solution:
    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        rows_max = [0] * len(grid)
        cols_max = [0] * len(grid[0])

        for i in range(len(grid)):
            for j in range(len(grid[0])):
                rows_max[i] = max(rows_max[i], grid[i][j])
                cols_max[j] = max(cols_max[j], grid[i][j])

        res = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                res += min(rows_max[i], cols_max[j]) - grid[i][j]

        return res"
soup servings,"class Solution:
    def soupServings(self, n: int) -> float:
        @cache                                 # cache the result for input (a, b)
        def dfs(a, b):
            if a <= 0 and b > 0: return 1      # set criteria probability
            elif a <= 0 and b <= 0: return 0.5
            elif a > 0 and b <= 0: return 0
            return (dfs(a-4, b) + dfs(a-3, b-1) + dfs(a-2, b-2) + dfs(a-1, b-3)) * 0.25 # dfs
        if n > 4275: return 1                  # observe the distribution you will find `a` tends to be easier to get used up than `b`
        n /= 25                                # reduce the input scale
        return dfs(n, n)                       # both soup have `n` ml"
soup servings,"class Solution:
    def soupServings(self, n: int) -> float:
        if n > 4275: return 1                                        # handle special case
        n = n // 25 + (n%25 > 0)                                     # count size of tabulation
        dp = [[0] * (n+1) for _ in range(n+1)]
        dp[n][n] = 1
        for i in range(n, 0, -1):                                    # starting from (n, n) for each soup
            for j in range(n, 0, -1):
                for a, b in [[4, 0], [3, 1], [2, 2], [1, 3]]:
                    dp[max(0, i-a)][max(0, j-b)] += dp[i][j] * 0.25  # traverse backwards from (n,n) to (0,0)
        ans = dp[0][0] / 2                                           # half the probability when `a` &amp; `b` both use up at the same time
        for j in range(1, n+1):                                      # plus when `a` use up first
            ans += dp[0][j]
        return ans"
expressive words,"class Solution:
    def expressiveWords(self, s: str, words: List[str]) -> int:
        
        def summarize(word):
            res = []
            
            n = len(word)
            i, j = 0, 0
            while i<=j and j <= n-1:
                while j <= n-1 and word[j] == word[i]:
                    j += 1
                res.append(word[i])
                res.append(j-i)
                i = j
            return res
        
        t = 0 
        start = summarize(s)
        n = len(start)//2
        def compare(w):
            r = summarize(w)
        
            if len(r) != len(start):
                return False 
            for i in range(0, 2*n, 2):
                if start[i] != r[i]:
                    return False
                elif start[i] == r[i]:
                    if start[i+1] < r[i+1]:
                        return False
                    elif start[i+1] == r[i+1]:
                        pass 
                    elif start[i+1] < 3:
                        return False
            return True

        for w in words:
            if compare(w):
                t += 1
        return t"
expressive words,"class Solution:
   def expressiveWords(self, s: str, words) -> int:

       def condenseWord (s):
           wordTable = []
           repeatCounter = 1
           condenseWord = """"
           for i in range(len(s)):
               if i == 0:
                   continue
               if s[i] == s[i-1]:
                   repeatCounter += 1
               else:
                   condenseWord += s[i-1]
                   wordTable.append(repeatCounter)
                   repeatCounter = 1
                   
           else:
               condenseWord += s[len(s)-1]
               wordTable.append(repeatCounter)
               
           return condenseWord, wordTable
   
       
       matchCounter = 0
       sampleCondenseWord, sampleWordTable = condenseWord(s)
       for word in words:
           testCondenseWord, testWordTable = condenseWord(word)
           if sampleCondenseWord == testCondenseWord:
               for i in range(len(sampleCondenseWord)):
                   if sampleWordTable[i] >= 3 and sampleWordTable[i] < testWordTable[i]:
                       break
                   if sampleWordTable[i] < 3 and sampleWordTable[i] != testWordTable[i]:
                       break
               else:
                   matchCounter += 1
       
       return matchCounter"
chalkboard xor game,"class Solution:
    def xorGame(self, nums):
        #create a variable 0 
        x = 0 
        #iterate over the elements in the nums
        for i in nums:
            #do xor of all the elements
            x ^= i 
        #Alice wins in two situations :
        #1.if the xor is already 0 (x == 0 )
        #2.if the length of nums is even because if alice got chance with even length and xor != 0 he will select a number so that he will leave the odd number of same integer 
        #if nums == [a,a,a,b] then alice erase b so bob must erase from [a,a,a] so he will lose if he erase any number 
        return x == 0 or len(nums)%2 == 0 
        #in other situations bob will win"
chalkboard xor game,"class Solution:
    def xorGame(self, nums: List[int]) -> bool:
        return reduce(xor, nums) == 0 or not len(nums)&amp;1"
subdomain visit count,"class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d = defaultdict(int)
        for s in cpdomains:
            cnt, s = s.split()
            cnt = int(cnt)
            d[s] += cnt
            pos = s.find('.') + 1
            while pos > 0:
                d[s[pos:]] += cnt
                pos = s.find('.', pos) + 1
        for x, i in d.items():
            yield f'{i} {x}'"
subdomain visit count,"class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        hashmap = {}
        for cpdom in cpdomains:
            (num, domain) = (int(x) if i==0 else x for i, x in enumerate(cpdom.split("" "")))
            domains = domain.split('.')  # split the domain by '.'
            for idx in reversed(range(len(domains))):
                subdomain = '.'.join(domains[idx:])
                val = hashmap.get(subdomain, 0)  # 0 if not found in hashmap
                val += num
                hashmap[subdomain] = val
        
        # print(hashmap)
        ans = []
        for subdomain, count in hashmap.items():
            ans.append("" "".join([str(count), subdomain]))  # join count and subdomain using empty space ("" "")
            
        return ans
        
        # Run / Memory: O(N)  N - number of elements in the cpdomains"
largest triangle area,"class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:        
       
        area = 0
        n = len(points)
        for i in range(n):
            x1,y1 = points[i]
            for j in range(i+1,n):
                x2,y2 = points[j]
                for k in range(j+1,n):
                    x3,y3 = points[k]
                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))
                    if curr>area:
                        area = curr
        return area"
largest triangle area,"class Solution:
    def largestTriangleArea(self, p: List[List[int]]) -> float:
        L, A = len(p), 0
        for i in range(L-2):
        	for j in range(i+1,L-1):
        		for k in range(j+1,L):
        			R = Area_Shoelace(p[i],p[j],p[k])
        			A = max(A,R)
        return A

def Area_Shoelace(a,b,c):
	return abs(a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-(a[0]*c[1]+c[0]*b[1]+b[0]*a[1]))/2"
largest sum of averages,"class Solution:
    def largestSumOfAverages(self, nums: List[int], k: int) -> float:
        
        @lru_cache(maxsize=None)
        def maxAvgSum(index: int, partitions_left: int) -> int:
            if partitions_left == 1:
                return sum(nums[index:]) / (len(nums) - index)

            max_sum: float = 0.0
            for i in range(index, len(nums) - (partitions_left - 1)):
                cur_sum: float = sum(nums[index:i + 1])/(i + 1 - index)
                cur_sum += maxAvgSum(i + 1, partitions_left - 1)
                max_sum = max(cur_sum, max_sum)
            return max_sum
    
        return maxAvgSum(0, k)"
largest sum of averages,"class Solution:
    def largestSumOfAverages(self, nums: List[int], k: int) -> float:
        
        def helper(ind, k, currSum, count):
            if ind>=n:
                return 0
            if k==0:
                return -int(1e9)
            if dp[ind][count][k]!=-1:
                return dp[ind][count][k]
            currSum+=nums[ind]
            notTake=currSum/count + helper(ind+1, k-1, 0, 1)
            take=helper(ind+1, k, currSum, count+1)
            dp[ind][count][k]=max(take, notTake)
            return dp[ind][count][k]
        
        n=len(nums)
        dp=[[[-1]*(k+1) for i in range(n+1)] for i in range(n+1)]
        return helper(0, k, 0, 1)"
binary tree pruning,"class Solution(object):
    def pruneTree(self, root):
        """"""
        :type root: TreeNode
        :rtype: TreeNode
        """"""
        if root==None:
            return None
        _l = self.pruneTree(root.left)
        _r = self.pruneTree(root.right)
        if root.val == 0 and _l == None and _r == None:
            return None
        else:
            root.left = _l
            root.right = _r
        return root"
binary tree pruning,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(n)
	""""""

	def pruneTree(self, root: TreeNode) -> TreeNode:
		return self._prune(root)

	@classmethod
	def _prune(cls, root: Optional[TreeNode]) -> Optional[TreeNode]:
		if not root:
			return None

		root.left = cls._prune(root.left)
		root.right = cls._prune(root.right)

		return root if (root.val or root.left or root.right) else None"
bus routes,"class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        m = defaultdict(set)
        for i, route in enumerate(routes):
            for node in route:
                m[node].add(i)
        ans = -1
        vis = set()
        queue = deque()
        queue.append(source)
        while queue:
            l = len(queue)
            ans += 1
            for _ in range(l):
                cur = queue.popleft()
                if cur == target:
                    return ans
                for bus in m[cur]:
                    if bus not in vis:
                        vis.add(bus)
                        queue.extend(routes[bus])
        return -1"
bus routes,"class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        if source==target:
            return 0
        busstop=defaultdict(list)#List of Buses departing from every bus stops
        for busnum,stops in enumerate(routes):
            for stop in stops:
                busstop[stop].append(busnum)#'busnum' is departing from the bustop 'stop'
        q=[]
        visit=set()
        for bus in busstop[source]:#Grab all the buses departing from the source busstop
            q.append((bus,1))
            visit.add(bus)
        while q:
            busnum,numofbus=q.pop(0)
            if target in routes[busnum]:#If my target is in current bus route return the numofbus I have taken
                return numofbus
            for stops in routes[busnum]:#Get me all the stops for my current bus
                for buses in busstop[stops]:#Get me all the buses which departs from the stop of my current bus
                    if buses not in visit:#If I have not taken the bus add it to my queue
                        visit.add(buses)
                        q.append((buses,numofbus+1))
        return -1"
ambiguous coordinates,"class Solution:
    def ambiguousCoordinates(self, s: str) -> List[str]:
        s = s.strip(""("").strip("")"")
        
        def fn(s): 
            """"""Return valid numbers from s.""""""
            if len(s) == 1: return [s]
            if s.startswith(""0"") and s.endswith(""0""): return []
            if s.startswith(""0""): return [s[:1] + ""."" + s[1:]]
            if s.endswith(""0""): return [s]
            return [s[:i] + ""."" + s[i:] for i in range(1, len(s))] + [s]
        
        ans = []
        for i in range(1, len(s)): 
            for x in fn(s[:i]):
                for y in fn(s[i:]): 
                    ans.append(f""({x}, {y})"")
        return ans"
ambiguous coordinates,"class Solution:
    def ambiguousCoordinates(self, s: str) -> List[str]:
        
        def possibleSplit(inputStr):
            # integer (no leading zeros or '0' itself)
            output = [inputStr] if inputStr[0] != '0' or inputStr == '0' else []
            # float
            for i in range(1, len(inputStr)):
                digit, decimal = inputStr[:i], inputStr[i:]
                # checking digit (left extra zeros)
                if len(digit) >= 2 and digit[0] == '0':
                    break
                # checking decimal (right extra zeros)
                if decimal[-1] == '0':
                    break
                output.append(f'{digit}.{decimal}')
            return output
        
        numStr = s[1:-1]
        output = []
        for i in range(1, len(numStr)):
            for x in possibleSplit(numStr[:i]):
                for y in possibleSplit(numStr[i:]):
                    output.append(f'({x}, {y})')

        return output"
linked list components,"class Solution:
    def numComponents(self, head: ListNode, G: List[int]) -> int:
        Gs = set(G)
        ans = 0
        while head: 
            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1
            head = head.next 
        return ans"
linked list components,"class Solution:
    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:
        nums = set(nums)
        cur = head
        res = 0
        connected = False
        
        while cur:
            if cur.val in nums:
                if not connected:
                    res += 1
                    connected = True
            else:
                connected = False
            cur = cur.next
            
        return(res)"
race car,"class Solution:
def racecar(self, target: int) -> int:
    
    q = deque()
    q.append((0,0,1))
    while q:
        m,p,s = q.popleft()
        if p==target:
            return m
        rev = -1 if s>0 else 1
		
        q.append((m+1,p+s,s*2))
        
        if (p+s<target and s<0) or (p+s>target and s>0):        # If you are back to the target and speed is reverse or if you are ahead of target and speed is positive then reverse the speed
            q.append((m+1,p,rev))
    
    return -1"
race car,"class Solution:
    def racecar(self, target: int) -> int:
        q = [(0, 1)]
        steps = 0
        
        while q:
            num = len(q)
            for i in range(num):
                pos, speed = q.pop(0)
                if pos == target:
                    return steps
                q.append((pos+speed, speed*2))
                rev_speed = -1 if speed > 0 else 1
                if (pos+speed) < target and speed < 0 or (pos+speed) > target and speed > 0:
                    q.append((pos, rev_speed))
            steps += 1"
most common word,"class Solution:
    def getSplit(self, s):
        result = []
        strS = ''
        for i in s.lower():
            if i not in ""!?',;. "": strS += i
            else:
                if len(strS) > 0: result.append(strS)
                strS = ''
        if len(strS) > 0: result.append(strS)
        return result

    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        paragraph = self.getSplit(paragraph)
        freq = {}
        for s in paragraph:
            if s not in banned:
                if s in freq: freq[s] += 1
                else: freq[s] = 1
                
        m = max(freq.values())
        for k in freq:
            if freq[k] == m: return k"
most common word,"class Solution:
    def mostCommonWord(self, para: str, banned: List[str]) -> str:
        
        p = []
        s = ''
		banned = set(banned)
        rem = {""!"",""?"",""'"","","","";"",""."","" ""}
        freq = {}
        
        for c in para:
            if c in rem:
                if s: p.append(s)
                s = ''
                continue
            
            if c.isupper(): s += c.lower()
            else: s += c
        
        if s: p.append(s)
        maxfreq, maxword = 0, ''
        
        for w in p:
            
            if w in banned: continue
            if w not in freq: freq[w] = 0
                
            freq[w] += 1
            if freq[w] > maxfreq:
                maxfreq = freq[w]
                maxword = w
                
        return maxword"
short encoding of words,"class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        words.sort(key=len, reverse=True)
        res = []
        for suffix in words:
            if not any(word.endswith(suffix) for word in res):  # check that this word is not actually a suffix
                res.append(suffix)
        return sum(len(word)+1 for word in res)  # append hash '#' symbol to each word that is not a suffix"
short encoding of words,"class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        words = set(words)  # important - e.g. [""time"",""time""] -> ""time#""
        counter = Counter(word[i:] for word in words for i in range(len(word)))
        return sum(len(word)+1 for word in words if counter[word] == 1)"
shortest distance to a character,"class Solution:
    def shortestToChar(self, s: str, c: str) -> List[int]:
        L = []
        for idx, value in enumerate(s):
            if value == c:
                L.append(idx)
        
        distance = []
        i = 0
        for idx, value in enumerate(s):
            if value == c:
                distance.append(0)
                i += 1
            elif idx < L[0]:
                distance.append(L[0] - idx)
            elif idx > L[-1]:
                distance.append(idx - L[-1])
            else:
                distance.append(min((L[i] - idx), (idx - L[i-1])))                    
        return distance"
shortest distance to a character,"class Solution:
    def shortestToChar(self, s: str, c: str) -> List[int]:
        ids = [i for i in range(len(s)) if s[i] == c]
        return [min([abs(i-id_) for id_ in ids]) for i in range(len(s))]"
card flipping game,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        """"""
        O(n) time complexity: n is length of fronts
        O(n) space complexity
        """"""
        same = {x for i, x in enumerate(fronts) if x == backs[i]}
        res = 9999
        for i in range(len(fronts)):
            if fronts[i] not in same: res = min(res, fronts[i])
            if backs[i] not in same: res = min(res, backs[i])
        return res % 9999"
card flipping game,"class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        same = {ff for ff, bb in zip(fronts, backs) if ff == bb}
        return min((x for x in fronts+backs if x not in same), default=0)"
binary trees with factors,"class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        total_nums = len(arr)
        moduler = 1000000007
        count_product_dict = {num: 1 for num in arr}
        arr.sort()

        for i in range(1, total_nums):
            for j in range(i):
                quotient = arr[i] // arr[j]
                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:
                    break
                if arr[i] % arr[j] == 0:
                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)
                    count_product_dict[arr[i]] %= moduler
                    
        return sum(count_product_dict.values()) % moduler"
binary trees with factors,"class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        ans = 0
        dp = {}
        for n in arr:
            temp = 1
            for k in dp.keys():
                if n%k==0 and n//k in dp:
                    temp+=dp[k]*dp[n//k]
            ans+= temp
            dp[n] = temp
        return ans%(10**9+7)"
goat latin,"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        new = sentence.split() # Breaks up the input into individual sentences
        count = 1 # Starting at 1 since we only have one ""a"" to begin with.
        
        for x in range(len(new)):
            if new[x][0].casefold() in 'aeiou': # Checks if the first value of x is a vowel. The casefold, can be replaced with lower, lowers the case. Can also just be removed and have ""in 'aeiouAEIOU'
                new[x] = new[x] + 'ma' + 'a'*count # Brings it together with the count multiplying number of ""a""'s as needed.
                count += 1
            elif new[x].casefold() not in 'aeiou': # Same comment as above.
                new[x] = new[x][1:] + new[x][0] + 'ma' + 'a'*count # Just moves the first value to the end then does the a.
                count += 1
        
        return "" "".join(x for x in new) # Converts the list back into a string."
goat latin,"class Solution:
    def toGoatLatin(self, S: str) -> str:
        out=''
        l=S.split()
        for i in range(len(l)):
            if l[i][0] in 'aeiouAEIOU':
                out+=l[i]+'m'+'a'*(i+2)+' '
            else:
                out+=l[i][1:]+l[i][0]+'m'+'a'*(i+2)+' '
        return out[:-1]"
friends of appropriate ages,"class Solution:
    def numFriendRequests(self, ages: List[int]) -> int:
        ages.sort()                                   # sort the `ages`
        ans = 0
        n = len(ages)
        for idx, age in enumerate(ages):              # for each age
            lb = age                                  # lower bound
            ub = (age - 7) * 2                        # upper bound
            i = bisect.bisect_left(ages, lb)          # binary search lower bound
            j = bisect.bisect_left(ages, ub)          # binary search upper bound
            if j - i <= 0: continue
            ans += j - i                              # count number of potential friends
            if lb <= age < ub:                        # ignore itself
                ans -= 1
        return ans"
friends of appropriate ages,"class Solution(object):
    def numFriendRequests(self, ages):
        count = [0] * 121                           # counter: count frequency of each age
        for age in ages:
            count[age] += 1
        ans = 0
        for ageA, countA in enumerate(count):       # nested loop, pretty straightforward
            for ageB, countB in enumerate(count):
                if ageA * 0.5 + 7 >= ageB: continue
                if ageA < ageB: continue
                if ageA < 100 < ageB: continue
                ans += countA * countB
                if ageA == ageB: ans -= countA
        return ans"
most profit assigning work,"class Solution:
    #Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)
    #Space-Complexity: O(n)
    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        #Approach: First of all, linearly traverse each and every corresponding index
        #position of first two input arrays: difficulty and profit to group each
        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array
        #by increasing difficulty of the job! Then, for each worker, perform binary
        #search and consistently update the max profit the current worker can work and
        #earn! Add this value to answer variable, which is cumulative for all workers!
        #this will be the result returned at the end!
        arr = []
        for i in range(len(difficulty)):
            arr.append([difficulty[i], profit[i]])
        #sort by difficulty!
        arr.sort(key = lambda x: x[0])
        #then, I need to update the maximum profit up to each and every item!
        maximum = float(-inf)
        for j in range(len(arr)):
            maximum = max(maximum, arr[j][1])
            arr[j][1] = maximum
        ans = 0
        #iterate through each and every worker!
        for w in worker:
            bestProfit = 0
            #define search space to perform binary search!
            L, R = 0, len(arr) - 1
            #as long as search space has at least one element to consider or one job,
            #continue iterations of binary search!
            while L <= R:
                mid = (L + R) // 2
                mid_e = arr[mid]
                #check if current job has difficulty that is manageable!
                if(mid_e[0] <= w):
                    bestProfit = max(bestProfit, mid_e[1])
                    #we still need to search right and try higher difficulty
                    #jobs that might yield higher profit!
                    L = mid + 1
                    continue
                else:
                    R = mid - 1
                    continue
            #once we break from while loop and end binary search, we should have
            #found bestProfit for current worker performing task that is manageable!
            ans += bestProfit
        return ans"
most profit assigning work,"class Solution:
    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        # sort difficulty and profit together as a tuple
        difficulty, profit = zip(*sorted(zip(difficulty, profit)))
        ret = max_profit = idx = 0
        for ability in sorted(worker):
            # if ability is smaller than the smallest difficulty
            # it's smaller than all difficulties
            if ability < difficulty[0]: continue
            # try to find a larger profit than the current one
            # this while loop will be run for at most len(difficulty) times
            # as idx is not reset at the end
            while idx < len(difficulty) and ability >= difficulty[idx]:
                max_profit = max(max_profit, profit[idx])
                idx += 1
            # increment total profit
            ret += max_profit
        return ret"
making a large island,"class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        N = len(grid)
        DIRECTIONS = [(-1, 0), (0, -1), (0, 1), (1, 0)]
        
		address = {}
        def dfs(row, column, island_id):
            queue = deque([(row, column, island_id)])
            visited.add((row, column))
            area = 1
            while queue: 
                row, column, island_id = queue.pop()
                address[(row, column)] = island_id
                for direction in DIRECTIONS:
                    r, c = row + direction[0], column + direction[1]
                    if r in range(N) and c in range(N) and grid[r][c] == 1 and (r, c) not in visited:
                        queue.append((r, c, island_id))
                        visited.add((r, c))
                        area += 1
            return area
        
        visited = set()
        area = {}
        island_id = 0
        for row in range(N):
            for column in range(N):
                if grid[row][column] == 1 and (row, column) not in visited:
                    area[island_id] = dfs(row, column, island_id)
                    island_id += 1
                    
        if len(address.keys()) == N**2: return N**2   
        
        largest_area = 1
        for row in range(N):
            for column in range(N):
                if grid[row][column] == 1: continue
                neighbours = set()
                large_area = 1
                for direction in DIRECTIONS:
                    r, c = row + direction[0], column + direction[1]
                    if r in range(N) and c in range(N) and grid[r][c] == 1 and address[(r, c)] not in neighbours:
                        neighbours.add(address[(r, c)])
                        large_area += area[address[(r, c)]]
                largest_area = max(largest_area, large_area)
                
        return largest_area"
making a large island,"class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        n = len(grid) 
        v = 2 
        freq = defaultdict(int)
        for r in range(n): 
            for c in range(n): 
                if grid[r][c] == 1: 
                    stack = [(r, c)]
                    grid[r][c] = v
                    while stack: 
                        i, j = stack.pop()
                        freq[v] += 1
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 1: 
                                stack.append((ii, jj))
                                grid[ii][jj] = v
                    v += 1
                    
        ans = max(freq.values(), default=0)
        for i in range(n): 
            for j in range(n): 
                if grid[i][j] == 0: 
                    cand = 1
                    seen = set()
                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                        if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] and grid[ii][jj] not in seen: 
                            seen.add(grid[ii][jj])
                            cand += freq[grid[ii][jj]]
                    ans = max(ans, cand)
        return ans"
count unique characters of all substrings of a given string,"class Solution:
    def uniqueLetterString(self, s: str) -> int:
        r=0
        for i in range(len(s)):
            for j in range(i, len(s)):
                ss=s[i:j+1]
                unique=sum([ 1 for (i,v) in Counter(ss).items() if v == 1 ])
                r+=unique
        return r"
count unique characters of all substrings of a given string,"class Solution:
    def uniqueLetterString(self, s: str) -> int:
        def does_char_appear_once(sub, t):
            num=0
            for c in sub:
                if c==t:
                    num+=1
            return num==1
            
        r=0
        for c in string.ascii_uppercase:
            for i in range(len(s)):
                for j in range(i, len(s)):
                    if does_char_appear_once(s[i:j+1], c):
                        r+=1
        return r"
consecutive numbers sum,"class Solution:
    def consecutiveNumbersSum(self, n: int) -> int:
        csum=0
        result=0
        for i in range(1,n+1):
            csum+=i-1
            if csum>=n:
                break
            if (n-csum)%i==0:
                result+=1
        return result"
consecutive numbers sum,"class Solution:
    def consecutiveNumbersSum(self, n: int) -> int:
        i=1
        res=0
        k=int((n*2)**0.5)
        while i<=k:
            if i%2:
                if n%i==0:
                    res+=1
            elif (n-(i//2))%i==0:
                res+=1
            i+=1
        return res"
positions of large groups,"class Solution(object):
    def largeGroupPositions(self, s):
        s += "" ""
        
        streak, char, out = 0, s[0], []
        
        for i,c in enumerate(s):
            if c != char:
                if streak >= 3:
                    out.append([i-streak, i-1])
                
                streak, char = 0, s[i]
                
            streak += 1
        
        return out"
positions of large groups,"class Solution(object):
    def largeGroupPositions(self, s):
        s += "" ""
        
        start, char, out = 0, s[0], []
        
        for i,c in enumerate(s):
            if c != char:
                if i-start >= 3:
                    out.append([start, i-1])
                
                start, char = i, s[i]
        
        return out"
masking personal information,"class Solution:
    def maskPII(self, s: str) -> str:
        if '@' in s: return f'{s[0].lower()}*****{s[s.index(""@"")-1].lower()+"""".join([x.lower() for x in s[s.index(""@""):]])}'
        s=''.join([x for x in s if x not in '()- +'])
        return ('' if len(s)<=10 else '+'+'*'*(len(s)-10)+'-')+f'***-***-{s[-4:]}'"
masking personal information,"class Solution:
    def maskPII(self, s: str) -> str:
        if '@' in s:
            user,domain=s.split('@')
            return f'{user[0].lower()}{""*""*5}{user[-1].lower()}@{domain.lower()}'
        s=''.join([x for x in s if x.isdigit()])  ; n=0
        return f'+{""*""*(n-10)}-***-***-{s[-4:]}' if n>10 else f'***-***-{s[-4:]}'"
flipping an image,"class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        """"""
        Simple &amp; striaghtforward without using inbuilt functions.
     
        In actual the run time is very less as we are iterating only n/2 time
        for each image list.
        Time complexity : O(n * n/2) == O(n^2) 
        Space complexity : O(1)
        """"""
        
        for im in image: #Iterate through each im list in the image list.
            i, j = 0, len(im)-1    #Maintain two pointers one at start and one at end.
            while i <= j:          #Iterate while first pointer is less than or equal to second pointer.
                im[i], im[j] = im[j]^1, im[i]^1   #swap element at both pointer &amp; complement them at the same time.
                i +=1              #increment first pointer to move forward
                j -=1              #decrement second pointer to move backward
            
        return image         # return same list
    
    
        """"""
        Using inbuilt functions
        """"""
        # for im in range(len(image)):
        #     image[im] = list(map(lambda a : abs(a-1), reversed(image[im])))
        # return image
    
        """"""
        One liner
        """"""
        return [[i^1 for i in im[::-1]] for im in image]"
flipping an image,"class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        for i in range(len(image)):
            image[i] = image[i][::-1]
            for j in range(len(image[i])):
                if image[i][j] == 0:
                    image[i][j] = 1
                else:
                    image[i][j] = 0
        return image"
find and replace in string,"class Solution:
    def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:
        # iterate from the greater index to the smallest
        for i, src, tg in sorted(list(zip(indices, sources, targets)), reverse=True):    
            # if found the pattern matches with the source, replace with the target accordingly
            if s[i:i+len(src)] == src: s = s[:i] + tg + s[i+len(src):]            
        return s"
find and replace in string,"class Solution:
    def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:
        
        res=[]
        i=0
        replace_map={i:(s,t) for i,s,t in zip( indices, sources, targets ) }
        
        while i<len(s):    
            
            if i in replace_map: #check all chars
               
                done,p,sw_ind=0,i,0   #done: to check if all word was seen in s, p:pointer of s, sw_ind:pointer for char is source word 
                source_word=replace_map[i][0]
                target=replace_map[i][1]
                while p<len(s) and sw_ind<len(source_word) and s[p]==source_word[sw_ind]: 
                    done+=1
                    p+=1
                    sw_ind+=1
                if done==len(source_word):  #so all source word was found, append target to res and advance i
                    res.append(target)
                    i=i+len(source_word)
                else:                      #so not all sourcce-word was found so append (i) to res and continue normally
                    res.append(s[i])
                    i+=1
            else:   #index not to be replaced append to res
                res.append(s[i])
                i+=1
                
                    
        return """".join(res)"
sum of distances in tree,"class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = {}
        for u, v in edges: 
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
        
        size = [0]*n
        
        def fn(x, par): 
            """"""Return size and sum of distances in sub-tree.""""""
            c = s = 0
            for xx in graph.get(x, []): 
                if xx != par: 
                    cc, ss = fn(xx, x)
                    c, s = c + cc, s + ss + cc
            size[x] = c + 1
            return c + 1, s
        
        ans = [0]*n
        ans[0] = fn(0, -1)[1]
        
        stack = [0]
        while stack: 
            x = stack.pop()
            for xx in graph.get(x, []): 
                if not ans[xx]: 
                    ans[xx] = ans[x] + n - 2*size[xx]
                    stack.append(xx)
        return ans"
sum of distances in tree,"class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        g = collections.defaultdict(list)
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)
        
        res = [0]*n
        for i in range(n):
            q = [i]
            visit = set()
            visit.add(i)
            step, cnt = 1, 0
            while q:
                num = len(q)
                for j in range(num):
                    node = q.pop(0)
                    for nei in g[node]:
                        if nei not in visit:
                            cnt += step
                            visit.add(nei)
                            q.append(nei)
                if q:step+=1
            res[i] = cnt
        
        return res"
image overlap,"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        n = len(img1)
        bestOverlap = 0

        def helper(dr, dc):
            overlap = 0
            for r in range(n):
                for c in range(n):
                    nr, nc = r + dr, c + dc
                    if nr in range(n) and nc in range(n) and img1[nr][nc] == 1 and img2[r][c] == 1:
                        overlap += 1

            return overlap

        for r in range(-n, n):
            for c in range(-n, n):
                bestOverlap = max(helper(r, c), bestOverlap)

        return bestOverlap"
image overlap,"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        n = len(img1)
        bestOverlap = 0
        i1, i2 = [], []
        for r in range(n):
            for c in range(n):
                if img1[r][c] == 1:
                    i1.append((r, c))

                if img2[r][c] == 1:
                    i2.append((r, c))

        overlap = {}
        for i1_r, i1_c in i1:
            for i2_r, i2_c in i2:
                shift = (i2_r - i1_r, i2_c - i1_c)
                overlap[shift] = overlap.get(shift, 0) + 1
                bestOverlap = max(bestOverlap, overlap[shift])
        
        return bestOverlap"
rectangle overlap,"class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
        [A,B,C,D], [E,F,G,H] = rec1, rec2
        return F<D and E<C and B<H and A<G
		
		
- Python 3
- Junaid Mansuri"
rectangle overlap,"class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        # TIME and SPACE Complexity: O(1)
		
        #Funtion checking if coordinate of Rec2 overlapped Rec1;
        def checkOverlapping(rec1_left, rec1_right, rec2_left, rec2_right):
            
            rec2_StartingCoordinate = max(rec1_left, rec2_left)
            rec1_EndingCoordinate = min(rec1_right, rec2_right)
            isOverlapped = rec2_StartingCoordinate < rec1_EndingCoordinate
            
            return isOverlapped
        
        
        #All Horizontal coordinates of Rec1 and Rec2;
        rec1HozlLeft = rec1[0]
        rec1HozlRight = rec1[2]
        rec2HozlLeft = rec2[0]
        rec2HozlRight = rec2[2]
        
        #All Vertical coordinates of Rec1 and Rec2;
        rec1VerBottom = rec1[1]
        rec1VerTop = rec1[3]
        rec2VerBottom = rec2[1]
        rec2VerTop = rec2[3]
        
        # 1st Check the Horizontal coordinates if Rec2 is overlapped Rec1;
        ## 2nd Check the Vertical coordinates if Rec2 is Overlapped Rec1; 
        ### return True if both Horizontal and Vertical are Overlapped
        return checkOverlapping(rec1HozlLeft, rec1HozlRight, rec2HozlLeft, rec2HozlRight) and \
                checkOverlapping(rec1VerBottom, rec1VerTop, rec2VerBottom, rec2VerTop)"
new 21 game,"class Solution:
    def new21Game(self, N: int, K: int, W: int) -> float:
        
        @lru_cache(None)
        def fn(n): 
            """"""Return prob of of points between K and N given current point n.""""""
            if N < n: return 0
            if K <= n: return 1
            if n+1 < K: return (1+W)/W*fn(n+1) - 1/W*fn(n+W+1)
            return 1/W*sum(fn(n+i) for i in range(1, W+1))
        
        return fn(0)"
new 21 game,"class Solution:
    def new21Game(self, N: int, K: int, W: int) -> float:
        ans = [0]*K + [1]*(N-K+1) + [0]*W
        val = sum(ans[K:K+W])
        for i in reversed(range(K)): 
            ans[i] = val/W
            val += ans[i] - ans[i+W]
        return ans[0]"
push dominoes,"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        dominoes = 'L' + dominoes + 'R'
        res = []
        left = 0
        
        for right in range(1, len(dominoes)):
            if dominoes[right] == '.': 
                continue
                
            middle = right - left - 1
            if left: 
                res.append(dominoes[left])
            if dominoes[left] == dominoes[right]: 
                res.append(dominoes[left] * middle)
            elif dominoes[left] == 'L' and dominoes[right] == 'R':
                res.append('.' * middle)
            else: 
                res.append('R' * (middle // 2) + '.' * (middle % 2) + 'L' * (middle // 2))
            left = right
            
        return ''.join(res)"
push dominoes,"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        ans = ['.' for _ in range(len(dominoes))]

        queue = deque()
        for i, d in enumerate(dominoes):
            if d == 'L' or d == 'R':
                queue.append((i, d))
            ans[i] = d
        
        while queue:
            size = len(queue)
            collision = defaultdict(list)
            for _ in range(size):
                i, d = queue.popleft()
                if d == 'L' and i - 1 >= 0 and ans[i - 1] == '.':
                    collision[i - 1].append('L')
                elif d == 'R' and i + 1 < len(ans) and ans[i + 1] == '.':
                    collision[i + 1].append('R')
            for pos in collision:
                if len(collision[pos]) == 2:
                    ans[pos] = '.'
                else:
                    ans[pos] = collision[pos][0]
                    queue.append((pos, collision[pos][0]))
                
        return ''.join(ans)"
similar string groups,"class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        N = len(strs)
        parent = [i for i in range(N)]
        depth = [1 for _ in range(N)]

        def find(idx):
            if idx != parent[idx]:
                return find(parent[idx])
            return idx
        
        def union(idx1, idx2):
            p1 = find(idx1)
            p2 = find(idx2)
            if p1 == p2: return
            if depth[p1] < depth[p2]:
                parent[p1] = p2
            elif depth[p2] < depth[p1]:
                parent[p2] = p1
            else:
                parent[p2] = p1
                depth[p1] += 1

        def similar(w1, w2):
            dif_idx = -1
            for idx in range(len(w1)):
                if w1[idx] != w2[idx]:
                    if dif_idx < 0:
                        dif_idx = idx
                    else:
                        if w1[dif_idx] != w2[idx]: return False
                        if w2[dif_idx] != w1[idx]: return False
                        if w1[idx+1:] != w2[idx+1:]: return False
                        return True
            return True
                    
        for idx in range(1, N):
            for pid in range(0, idx):
                if similar(strs[pid], strs[idx]):
                    union(pid, idx)

        return len([i for i, p in enumerate(parent) if i==p])"
similar string groups,"class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        def isSimilar(x, y):
            if x == y:
                return True
            x = [i for i in x]
            y = [i for i in y]
            # Save the index where x[i] != y[i]
            idx = []
            for i in range(len(x)):
                if x[i] != y[i]:
                    idx.append(i)
            if len(idx) == 2:
                x[idx[0]], x[idx[1]] = x[idx[1]], x[idx[0]]

                if x == y:
                    return True
                else:
                    return False
            else:
                return False
            
        def addEdge(x, y, graph):
            graph[x].append(y)
            graph[y].append(x)
            
        # Create a graph and find the number of components, that's the answer
        graph = {i: [] for i in strs}
        visited = {i: False for i in strs}
		# Construction of graph
        for i in range(len(strs)):
            for j in range(i+1, len(strs)):
			# Check if two nodes are similar
                if isSimilar(strs[i], strs[j]):
                    addEdge(strs[i], strs[j], graph)  
		# Number of components to be stored in ""ans"" variable
        ans = 0
		# BFS over all the words in strs
        for node in graph.keys():
            if visited[node] == False:
                ans += 1
                queue = [node]
                while queue:
                    u = queue.pop(0)
                    visited[u] = True
                    for child in graph[u]:
                        if visited[child] == False:
                            visited[child] = True
                            queue.append(child)
        return ans"
magic squares in grid,"class Solution:
    def numMagicSquaresInside(self, G: List[List[int]]) -> int:
    	M, N, S, t = len(G)-2, len(G[0])-2, {(8,1,6,3,5,7,4,9,2),(6,1,8,7,5,3,2,9,4),(2,7,6,9,5,1,4,3,8),(6,7,2,1,5,9,8,3,4)}, range(3)
    	return sum((lambda x: x in S or x[::-1] in S)(tuple(sum([G[i+k][j:j+3] for k in t],[]))) for i,j in itertools.product(range(M),range(N)))"
magic squares in grid,"class Solution:
    def numMagicSquaresInside(self, G: List[List[int]]) -> int:
    	M, N, S, t, s = len(G), len(G[0]), set(range(1,10)), range(3), 0
    	for i in range(M-2):
    		for j in range(N-2):
    			g = [G[i+k][j:j+3] for k in t]
    			if set(sum(g,[])) != S or g[1][1] != 5: continue
    			if any(sum(g[k]) != 15 for k in t) or any(sum([g[k][l] for k in t]) != 15 for l in t): continue
    			if sum([g[k][k] for k in t]) != 15 or sum([g[k][2-k] for k in t]) != 15: continue
    			s += 1
    	return s
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
keys and rooms,"class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited_rooms = set()
        stack = [0] # for rooms that we need to visit and we start from room [0]
        
        while stack: 
            room = stack.pop() 
            visited_rooms.add(room)
            for key in rooms[room]:
                if key not in visited_rooms:
                    stack.append(key)
        return len(visited_rooms) == len(rooms)"
keys and rooms,"class Solution:
    
    def visitAll(self,rooms,index,visited):
        if index not in visited:
            visited.add(index)
            for i in rooms[index]:
                self.visitAll(rooms,i,visited)
    
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = set()
        self.visitAll(rooms,0,visited)
        return len(visited)==len(rooms)"
split array into fibonacci sequence,"class Solution:
    def splitIntoFibonacci(self, num: str) -> List[int]:
        def dfs(i):
            if i>=len(num):
                return len(ans)>2           
            n = 0
            for j in range(i, len(num)):
                n = n*10 + int(num[j]) 
                if n>2**31: # if number exceeds the range mentioned
                    return False
                # if len < 2 we know more elements need to be appended
                # as size>=3 if size is already greater we check for fibonacci
                # as last + secondLast == curr
                if len(ans)<2 or (ans[-1]+ans[-2]==n):
                    ans.append(n)
                    if dfs(j+1):
                        return True
                    ans.pop()
                if i==j and num[j]=='0': # if trailing 0 is present
                    return False
        
        if len(num)<=2: return []
        ans = []
        if dfs(0): return ans
        return []"
split array into fibonacci sequence,"class Solution:
    def isAdditiveNumber(self, num: str) -> List[int]:
        def dfs(i, ans):
            if i>=len(num):
                return len(ans)>2           
            n = 0
            for j in range(i, len(num)):
                n = n*10 + int(num[j]) 
                if len(ans)<2 or (ans[-1]+ans[-2]==n):
                    ans.append(n)
                    if dfs(j+1, ans):
                        return True
                    ans.pop()
                if i==j and num[j]=='0': 
                    return False
        
        return dfs(0, [])"
guess the word,"class Solution:
    def findSecretWord(self, words: List[str], master: 'Master') -> None:        
        k = 1 # for tracing the number of loops
        matches = 0
        blacklists = [[] for i in range(6)]
        
        while matches != 6:
            n = len(words)
            r = random.randint(0, n - 1)
            matches = master.guess(words[r])
            key = words[r]
            # print(k, n, r, matches, key)
            
            words.pop(r)
            
            if matches == 0:
                for i in range(6):
                    blacklists[i].append(key[i])
                # print(blacklists)
            
            elif matches > 0 and matches < 6:
                candidates = []
                for i in range(n - 1):
                    count = 0
                    for j in range(6):
                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:
                            count += 1
                    if count >= matches:
                        candidates.append(words[i])
                            
                words = candidates.copy()
                # print(words)
            
            k += 1"
guess the word,"class Solution:
    def findSecretWord(self, wordlist: List[str], master: 'Master') -> None:
        def hamming_distance(w1: str, w2: str) -> int:
            return sum(1 for k in range(6) if w1[k] != w2[k])

        current_guess = wordlist[0]
        curr_distance = 6 - Master.guess(master, current_guess)
        while curr_distance != 0:
		    # Secret word have <current_distance> form our <current_guess>. 
			# Therefore secret word is one of the words with Hamming distance <current_distance> from our <current_guess>.
			# So lets delete all other words.
            wordlist = [w for w in wordlist if hamming_distance(current_guess, w) == curr_distance]
            # current_guess = wordlist.pop(random.randint(0, len(wordlist) - 1))
			# You sould not use any random. In some random cases 
			# number of guesses may be ecxeed 10, but in next attempt it's not, etc.
            current_guess = wordlist.pop()
            curr_distance = 6 - Master.guess(master, current_guess)"
backspace string compare,"class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
    	a, A = [collections.deque(), collections.deque()], [S,T]
    	for i in range(2):
	    	for j in A[i]:
   		 		if j != '#': a[i].append(j)
   		 		elif a[i]: a[i].pop()
    	return a[0] == a[1]"
backspace string compare,"class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
    	s, t = [], []
    	for i in S: s = s + [i] if i != '#' else s[:-1]
    	for i in T: t = t + [i] if i != '#' else t[:-1]
    	return s == t"
longest mountain in array,"class Solution:
    def longestMountain(self, arr: List[int]) -> int:
        increasing = False
        increased = False
        mx = -math.inf
        curr = -math.inf
        for i in range(1, len(arr)):
            if arr[i] > arr[i-1]:
                if increasing:
                    curr += 1
                    increased = True
                else:
                    mx = max(curr, mx)
                    curr = 2
                    increased = True
                    increasing = True
            elif arr[i] < arr[i-1]:
                if increasing:
                    increasing = False
                curr += 1
            else:
                if increased and not increasing:
                    mx = max(mx, curr)
                curr = -math.inf
                increased = False
                increasing = False
        if not increasing and increased:
            mx = max(mx, curr)
        return 0 if mx == -math.inf else mx"
longest mountain in array,"class Solution:
    def longestMountain(self, arr: List[int]) -> int:
        len_mountain = slope = 0
        start = -1
        arr.append(arr[-1])    # to trigger len_mountain check in the loop
        for i, (a, b) in enumerate(zip(arr, arr[1:])):
            if b > a:
                if slope < 1:
                    if slope == -1 and start > -1:
                        len_mountain = max(len_mountain, i + 1 - start)
                    start = i
                    slope = 1
            elif b < a:
                if slope == 1:
                    slope = -1
            else:
                if slope == -1:
                    if start > -1:
                        len_mountain = max(len_mountain, i + 1 - start)
                slope = 0
                start = -1
        return len_mountain"
hand of straights,"class Solution:
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        counter = Counter(hand)
        while counter:
            n = groupSize
            start = min(counter.keys())
            while n:
                if start not in counter:
                    return False
                counter[start] -= 1
                if not counter[start]:
                    del counter[start]
                start += 1
                n -= 1
        return True"
hand of straights,"class Solution:
    def isNStraightHand(self, nums: List[int], k: int) -> bool:
        nums.sort()
        n = len(nums)
        count = defaultdict(int)
        for num in nums:
            count[num] += 1
            
        for i in range(n):
            if count[nums[i]] != 0:
                count[nums[i]] -= 1
                for j in range(nums[i]+1, nums[i]+k):
                    if count[j] == 0:
                        return False
                    count[j] -= 1
        return True"
shortest path visiting all nodes,"class Solution:
	def shortestPathLength(self, graph: List[List[int]]) -> int:

		length = len(graph)

		result = 0

		visited_node = []

		queue = []  

		for i in range(length):
			visited_node.append(set([1<<i]))
			queue.append([i,1<<i])

		while queue:

			result = result + 1

			new_queue = []

			for node, value in queue:

				for neigbour_node in graph[node]:

					mid_node = (1<<neigbour_node)|value

					if mid_node not in visited_node[neigbour_node]:

						if mid_node+1 == 1<<length:

							return result

						visited_node[neigbour_node].add(mid_node)

						new_queue.append([neigbour_node, mid_node])

			queue = new_queue

		return 0"
shortest path visiting all nodes,"class Solution:
    def shortestPathLength(self, graph: List[List[int]]) -> int:
        n = len(graph)
        dist = [[inf]*n for _ in range(n)]
        
        for i, x in enumerate(graph): 
            dist[i][i] = 0
            for ii in x: dist[i][ii] = 1
        
        # floyd-warshall 
        for k in range(n): 
            for i in range(n): 
                for j in range(n): 
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
        
        @cache 
        def fn(x, mask): 
            if mask == 0: return 0 
            ans = inf 
            for i in range(n): 
                if mask &amp; (1 << i): 
                    ans = min(ans, dist[x][i] + fn(i, mask ^ (1<<i)))
            return ans 
        
        return min(fn(x, (1 << n)-1) for x in range(n))"
shifting letters,"class Solution:
    def shiftingLetters(self, S: str, shifts: List[int]) -> str:
        
        final_shift = list(accumulate(shifts[::-1]))[::-1]
        
        s_list = list(S)
        
        for x in range(len(s_list)):
            midval = ord(s_list[x]) + final_shift[x]%26
            if midval > 122:
                midval = midval - 26
            
            s_list[x] = chr(midval)
        
        return ''.join(s_list)"
shifting letters,"class Solution:
    def shiftingLetters(self, S: str, shifts: List[int]) -> str:
        return ''.join(chr((ord(letter) + shifting%26) - 26)  if (ord(letter) + shifting%26)>122 else chr((ord(letter) + shifting%26)) for letter,shifting in zip(S, list(accumulate(shifts[::-1]))[::-1]))"
maximize distance to closest person,"class Solution:
    def maxDistToClosest(self, seats: List[int]) -> int:
        #initialization, starting index is 0, result is res
        left,res,index = -1,0,0
        while index != len(seats):
            # only right is 1
            if left == -1 and seats[index] == 1:
                res = max(res,index)
                left = index
                index+=1
                continue
            # only left is 1
            if index == len(seats)-1 and seats[index] == 0:
                res = max(res,index-left)
                index+=1
                continue
            # left and right both 1, sitting in the middle
            if seats[index] == 1:
                res = max(res,(index-left)//2)
                left = index
            index+=1
        return res"
maximize distance to closest person,"class Solution:
    def maxDistToClosest(self, seats: List[int]) -> int:
        distance = -1 
        Maximum_Distance = 0
        for i in range(len(seats)):
            if seats[i] == 1: # if seat is 0 that means it is empty we won't perform any action
                if distance == -1: # if we are encounting the first seated person
                    Maximum_Distance = i 

                else:
                    Maximum_Distance = max(Maximum_Distance,((i - distance) // 2)) 
                    # if we have encounted any seated person before then we will compare for the maximum distance till now to the current distance possible
                
                distance = i 

        if seats[-1] == 0: # if end seat is empty
            Maximum_Distance = max(Maximum_Distance, (len(seats) - 1 - distance))
        return Maximum_Distance"
rectangle area ii,"class Solution:
    def rectangleArea(self, rectangles: List[List[int]]) -> int:
        line = []
        for x1, y1, x2, y2 in rectangles: 
            line.append((y1, x1, x2, 1))
            line.append((y2, x1, x2, 0))
        
        ans = yy = val = 0
        seg = []
        for y, x1, x2, tf in sorted(line): 
            ans += val * (y - yy)
            yy = y 
            if tf: insort(seg, (x1, x2))
            else: seg.remove((x1, x2))
            val = 0 
            prev = -inf 
            for x1, x2 in seg: 
                val += max(0, x2 - max(x1, prev))
                prev = max(prev, x2)
        return ans % 1_000_000_007"
loud and rich,"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        richer_count = [0 for _ in range(len(quiet))]
        graph = defaultdict(list)
        answer = [idx for idx in range(len(quiet))]
        
        ## create the graph so that we go from the richer to the poorer
        for rich, poor in richer:
            graph[rich].append(poor)
            richer_count[poor] += 1
            
        ## we include the richest ones.
        queue = collections.deque([])
        for person, rich_count in enumerate(richer_count):
            if not rich_count:
                queue.append(person)
                
        while queue:
            person = queue.popleft()
            ## pointer to the quietest person
            quieter_person = answer[person]
            
            for poorer in graph[person]:
                ## pointer to the quietest person richer than me
                quieter_richer = answer[poorer]
                ## on the answer we are storing the pointer to the quietest one. so for the next poorer we are going to store the pointer which contains the quietest
                answer[poorer] = min(quieter_person, quieter_richer, key = lambda prsn : quiet[prsn])
                richer_count[poorer] -= 1
                if not richer_count[poorer]:
                    queue.append(poorer)
        return answer"
loud and rich,"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        graph = {} # graph as adjacency list 
        for x, y in richer: graph.setdefault(y, []).append(x)
        
        @lru_cache(None)
        def fn(x): 
            """"""Return richer &amp; loudest person given person.""""""
            ans = x
            for xx in graph.get(x, []): 
                if quiet[fn(xx)] < quiet[ans]: ans = fn(xx)
            return ans 
        
        return [fn(x) for x in range(len(quiet))]"
peak index in a mountain array,"class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        return (arr.index(max(arr)))"
peak index in a mountain array,"class Solution(object):
    def peakIndexInMountainArray(self, arr):
        """"""
        :type arr: List[int]
        :rtype: int
        """"""
        
        Brute force
        for i in range(1,len(arr)-1):
            if arr[i-1] < arr[i] and arr[i+1] < arr[i]:
                return i"
car fleet,"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        ans = prev = 0
        for pp, ss in sorted(zip(position, speed), reverse=True): 
            tt = (target - pp)/ss # time to arrive at target 
            if prev < tt: 
                ans += 1
                prev = tt
        return ans"
car fleet,"class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        """"""
        sort the start position.
        the car behind can only catch up no exceed.
        so if the car start late and speed is faster, it will catch up the car ahead of itself and they become a fleet.
        there is a target(or desitination),so use arrive time to measure. 
        
        start late but arrive ealier means the car is behind and will catch up before arriving the destination.
        
        position  10  8  5  3  0
        distance  2   4  7  9  12
        speed.    2   4  1  3  1
        time.     1   1  7  3  12
                      ^     ^
                      |     |
                     catch  catch up the previous car before target, join the fleet
		stack = [1] , [1],[1,7],[1,7][1,7,12] 			 
                                
        """"""
        stack = []
        for pos, v in sorted(zip(position, speed),reverse = True):

            dist = target - pos
            time = dist / v 
            
            if not stack:
                stack.append(time)
            elif time > stack[-1]:
                stack.append(time)

        return len(stack)"
k similar strings,"class Solution:
    # DFS
    def kSimilarity(self, A: str, B: str) -> int:
        N = len(A)
        def dfs(A, B, pos):
            if A == B:
                return 0
            
            while A[pos] == B[pos]:
                pos += 1
                
            minCnt = float('inf')
            for i in range(pos + 1, N):
                if B[i] == A[pos] and B[i] != A[i]:
                    B[i], B[pos] = B[pos], B[i]
                    tmp = dfs(A, B, pos + 1) + 1
                    minCnt = min(tmp, minCnt)
                    B[i], B[pos] = B[pos], B[i]
                    
            return minCnt
        
        return dfs(list(A), list(B), 0)

    # DFS with memorization
    def kSimilarity1(self, A: str, B: str) -> int:
        N = len(A)
        def dfs(A, B, pos):
            sB = ''.join(B)
            if sB in map:
                return map[sB]
            
            if A == B:
                return 0
            
            while A[pos] == B[pos]:
                pos += 1
                
            minCnt = float('inf')
            for i in range(pos + 1, N):
                if B[i] == A[pos] and B[i] != A[i]:
                    B[i], B[pos] = B[pos], B[i]
                    tmp = dfs(A, B, pos + 1) + 1
                    minCnt = min(tmp, minCnt)
                    B[i], B[pos] = B[pos], B[i]
                    
            map[sB] = minCnt
            return minCnt
                    
        map = collections.defaultdict()
        return dfs(list(A), list(B), 0)
    
    # BFS
    def kSimilarity2(self, A: str, B: str) -> int:
        N = len(B)
        q = collections.deque([B])
        visited = set(B)
        
        cnt = 0
        pos = 0
        while q:
            qSize = len(q)
            
            for _ in range(qSize):
                cur = q.popleft()
                if cur == A:
                    return cnt
                
                pos = 0
                while cur[pos] == A[pos]:
                    pos += 1
                
                lCur = list(cur)
                for i in range(pos + 1, N):
                    if lCur[i] == A[pos] and lCur[i] != A[i]:
                        lCur[i], lCur[pos] = lCur[pos], lCur[i]
                        
                        sCur = ''.join(lCur)
                        if sCur not in visited:
                            q.append(sCur)
                            
                        visited.add(sCur)
                        lCur[i], lCur[pos] = lCur[pos], lCur[i]
            cnt += 1
            
        return cnt"
k similar strings,"class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        #the deque keeps track of the set of strings that we want to perform swaps on
        #at the start, the deque contains only s1
        deque = collections.deque([s1])
        
        #this set wasn't mentioned in the ""intuition"" part. it helps us avoid doing repeated work by adding the same strings to our deque
        seen = set() 
        
        answ=0 #counter for the number of ""swaps"" done so far
        
        
        while deque:
            for _ in range(len(deque)): #loops through each string in the deque
                
                string = deque.popleft() #gets the first string in the deque
                if string ==s2: return answ
                
                #finds the first non-matching letter in s1
                #this satisfies condition 1 of a ""useful"" swap
                #ex: this would be s1[3] in the above example
                i=0
                while string[i]==s2[i]:
                    i+=1
                
                #checks all the other letters for potential swaps
                for j in range(i+1, len(string)):
                    if string[i]==s2[j]!=s1[j]: #checks conditions 2 and 3 of a useful swap
                        
                        #swaps the letters at positions i and j
                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]
                        
                        #adds the ""new string"" if it was not previously added
                        if new not in seen:
                            seen.add(new)
                            deque.append(new)
            
            #record that one more swap was done for each string in the deque
            answ+=1"
score of parentheses,"class Solution:
    def scoreOfParentheses(self, s: str) -> int:
        stk = [0]   # temp value to help us

        for char in s:
            if char == '(':
                stk.append(0)   # new parent: current sum = 0
            else:
                # An expression will be closed
                # Find its value: either 1 for empty () or 2 * its sub-expressions
                # we can calc both with a simple max()
                value = max(2 * stk.pop(), 1)

                # Add the expression sum to its parent current sum
                #  Assume we have expression E that is (CHD)
                # where C, H, D are valid-subexpressions with values 5, 10, 4
                # then E is (5+10+4) = (19) = 38
                # Every time we finish an expression, we add its value to its parent
                # get the parent and update its sum with a finished sub-expression
                stk[-1] += value

        return stk.pop()
		```"
score of parentheses,"class Solution:
    def scoreOfParentheses(self, S: str) -> int:
        res, balance = 0, 0
        for index, par in enumerate(S):
            balance += 1 if par == ""("" else -1
            if index and S[index - 1] + par == ""()"":
                res += 2 ** balance
        return res"
minimum cost to hire k workers,"class Solution:
    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:
        ans, rsm = inf, 0
        pq = [] # max-heap 
        for q, w in sorted(zip(quality, wage), key=lambda x: x[1]/x[0]): 
            rsm += q 
            heappush(pq, -q)
            if len(pq) > k: rsm += heappop(pq)
            if len(pq) == k: ans = min(ans, rsm * w/q)
        return ans"
minimum cost to hire k workers,"class Solution:
    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:
        n=len(wage)
        arr=[[wage[i]/quality[i],quality[i]] for i in range(n)]
        arr.sort(key=lambda x:x[0])
        kSmallest=0
        pq=[]
        for i in range(k):
            heapq.heappush(pq,-arr[i][1])
            kSmallest+=arr[i][1]
        minCost=arr[k-1][0]*kSmallest
        for c in range(k,n):
            if pq and abs(pq[0])>arr[c][1]:
                qRem=-heappop(pq)
                kSmallest-=qRem
                kSmallest+=arr[c][1]
                heappush(pq,-arr[c][1])
            minCost=min(minCost,arr[c][0]*kSmallest)
        return minCost"
mirror reflection,"class Solution:
    def mirrorReflection(self, p: int, q: int) -> int:

        L = lcm(p,q)

        if (L//q)%2 == 0:
            return 2

        return (L//p)%2"
mirror reflection,"class Solution:
    def mirrorReflection(self, p: int, q: int) -> int:
        # L*G = p*q  <=> L/q = p/G <=> L/p = q/G

        G = gcd(p,q)
        p//= G
        q//= G
        
        if p%2 == 0:
            return 2

        return q%2"
buddy strings,"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:

        freq1=[0]*26
        freq2=[0]*26
        diff =0

        if(len(s)!=len(goal)):
            return False
        for i in range(len(s)):
            if(s[i]!=goal[i]):
                diff+=1
            freq1[ord(s[i])-ord('a')]+=1
            freq2[ord(goal[i])-ord('a')]+=1
        unique= True
        for idx in range(len(freq1)):
            if(freq1[idx]!=freq2[idx]):
                return False
            if(freq1[idx]>1):
                unique = False
        if(diff==2 or (unique==False and diff==0)):
            return True"
buddy strings,"class Solution:
#     O(n) || O(26)
# Runtime: 40ms 78.04% memory: 14.2mb 60.39%
    def buddyStrings(self, string: str, goal: str) -> bool:
        left, right = 0, len(string) - 1

        if len(string) != len(goal):
            return False

        if string == goal and len(set(string)) < len(string):
            return True


        difference = []

        for i in range(len(string)):
            if string[i] != goal[i]:
                difference.append((string[i], goal[i]))


        if len(difference) == 2 and difference[0] == difference[-1][::-1]: 
            return True


        return False"
lemonade change,"class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        change5=0
        change10=0
        change20=0
        for i in range(len(bills)):
            if bills[i]==5:
                change5+=1
            elif bills[i]==10:
                change10+=1
                change5-=1
            elif bills[i]==20:
                if change10>0 :
                    change5-=1
                    change10-=1
                else:
                    change5-=3
                change20+=1
            if change5<0 or change10<0 or change20<0:
                return False
        return True"
lemonade change,"class Solution:
#     O(n) || O(1)
# Runtime: 1159ms 49.65% Memory: 18mb 49.96%
    def lemonadeChange(self, bills: List[int]) -> bool:
        fiveBills, tenBills = 0, 0

        for i in bills:
            if i == 5:
                fiveBills += 1
            elif i == 10:
                tenBills += 1
                fiveBills -= 1
            elif tenBills > 0:
                tenBills -= 1
                fiveBills -= 1
            else:
                fiveBills -= 3

            if fiveBills < 0:
                return False


        return True"
score after flipping matrix,"class Solution:
    def matrixScore(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        for i in range(m):
            if A[i][0] == 0: 
                for j in range(n): A[i][j] ^= 1 
        
        for j in range(n): 
            cnt = sum(A[i][j] for i in range(m))
            if cnt < m - cnt: 
                for i in range(m): A[i][j] ^= 1
        
        return sum(int("""".join(map(str, A[i])), 2) for i in range(m))"
score after flipping matrix,"class Solution:
    def matrixScore(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        col = [0] * n                                              # a list to count 1 in each column
        for i in range(m):
            for j in range(n-1, -1, -1):                           # start from the right, so we can use A[i][0] as a reference
                A[i][j] = (1-A[i][j]) if not A[i][0] else A[i][j]  # flip row if start of this row is 0
                col[j] += A[i][j]
        for j in range(1, n):                                      # flip column when necessary
            if (m % 2 and col[j] <= m // 2) or (not m % 2 and col[j] < m // 2):
                for i in range(m): A[i][j] = 1-A[i][j]
        return sum(sum(2**(n-1-j) * A[i][j] for j in range(n)) for i in range(m)) # calculate the sum"
shortest subarray with sum at least k,"class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -> int:
        loc = {0: -1}
        stack = [0] # increasing stack
        ans, prefix = inf, 0
        for i, x in enumerate(nums): 
            prefix += x
            ii = bisect_right(stack, prefix - k)
            if ii: ans = min(ans, i - loc[stack[ii-1]])
            loc[prefix] = i
            while stack and stack[-1] >= prefix: stack.pop()
            stack.append(prefix)
        return ans if ans < inf else -1"
shortest subarray with sum at least k,"class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -> int:
        ans = inf 
        queue = deque([(-1, 0)])
        prefix = 0
        for i, x in enumerate(nums): 
            prefix += x
            while queue and prefix - queue[0][1] >= k: ans = min(ans, i - queue.popleft()[0])
            while queue and queue[-1][1] >= prefix: queue.pop()
            queue.append((i, prefix))
        return ans if ans < inf else -1"
all nodes distance k in binary tree,"class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
    
        graph=defaultdict(list)
        #create undirected graph
        stack=[root]
        while stack:
            node=stack.pop()
            if node==target:
                targetVal=node.val
            if node.left:
                graph[node.val].append(node.left.val)
                graph[node.left.val].append(node.val)
                stack.append(node.left)
            if node.right:
                graph[node.val].append(node.right.val)
                graph[node.right.val].append(node.val)
                stack.append(node.right)
        
        #start BFS
        q=deque([(targetVal,0)]) #startNode distance=0
        seen=set()
        seen.add(targetVal)
        res=[]
        while q:
            node,depth=q.popleft()
            if depth==k: 
                res.append(node)
            if depth>k: break #no need to continue

            for neigh in graph[node]:
                if neigh not in seen:
                    q.append((neigh,depth+1))
                    seen.add(neigh)
        return res"
all nodes distance k in binary tree,"class Solution:
    def dfs_add_parent(self, node: TreeNode, parent: Optional[TreeNode] = None):
        node.parent = parent
        if node.right:
            self.dfs_add_parent(node.right, node)
        if node.left:
            self.dfs_add_parent(node.left, node)
            
        
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        self.dfs_add_parent(root)
        found_k_dist = []
        visited = set()
        def dfs_get_distance(node: TreeNode, current: int):
            visited.add(node)
            if current == k:
                found_k_dist.append(node.val)
				return
            for neighbor in [node.parent, node.left, node.right]:
                if neighbor and neighbor not in visited:
                    dfs_get_distance(neighbor, current + 1)
					
        dfs_get_distance(target, 0)
        
        return found_k_dist"
shortest path to get all keys,"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:
        m, n = len(grid), len(grid[0])
        
        ii = jj = total = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ""@"": ii, jj = i, j
                elif grid[i][j].islower(): total += 1
        
        ans = 0
        seen = {(ii, jj, 0)}
        queue = [(ii, jj, 0)]
        while queue: 
            newq = []
            for i, j, keys in queue: 
                if keys == (1 << total) - 1: return ans 
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != ""#"": 
                        kk = keys 
                        if grid[ii][jj].islower(): kk |= 1 << ord(grid[ii][jj]) - 97
                        if (ii, jj, kk) in seen or grid[ii][jj].isupper() and not kk &amp; (1 << ord(grid[ii][jj])-65): continue 
                        newq.append((ii, jj, kk))
                        seen.add((ii, jj, kk))
            ans += 1
            queue = newq
        return -1"
shortest path to get all keys,"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:
        m, n = len(grid), len(grid[0])
        directions = [-1, 0, 1, 0, -1]

        symbols = {""."", ""#"", ""@""}
        start = None
        num_keys = 0
        for i in range(m):
            for j in range(n):
                temp = grid[i][j]
                if temp == ""@"":
                    start = (i, j)
        
                num_keys += (temp not in symbols)
            
        num_keys //= 2

        FULL_KEYS = (1 << num_keys) - 1 

        q = [start + (0, 0)]
        visited = {(start[0], start[1], 0)}
        while q:
            i, j, original_keys, d = q.pop(0)

            for k in range(4):
                keys = original_keys
                x, y = i + directions[k], j + directions[k + 1]

                if 0 <= x < m and 0 <= y < n and grid[x][y] != ""#"":
                    if grid[x][y] == ""."" or grid[x][y] == ""@"":
                        if (x, y, keys) not in visited:
                            visited.add((x, y, keys))
                            q.append((x, y, keys, d + 1))
                    elif 0 <= ord(grid[x][y]) - ord(""A"") < 26:
                        lock = ord(grid[x][y]) - ord(""A"")
                        
                        if keys &amp; (1 << lock) != 0 and (x, y, keys) not in visited:
                            visited.add((x, y, keys))
                            q.append((x, y, keys, d + 1))
                    else:
                        temp = ord(grid[x][y]) - ord(""a"")
                        if keys &amp; (1 << temp) == 0:
                            keys |= (1 << temp)
                            if keys == FULL_KEYS:
                                return d + 1
                        if (x, y, keys) not in visited:
                            visited.add((x, y, keys))
                            q.append((x, y, keys, d + 1))
        
        return -1"
smallest subtree with all the deepest nodes,"class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        
        @lru_cache(None)
        def fn(node):
            """"""Return height of tree rooted at node.""""""
            if not node: return 0
            return 1 + max(fn(node.left), fn(node.right))
        
        node = root
        while node: 
            left, right = fn(node.left), fn(node.right)
            if left == right: return node
            elif left > right: node = node.left
            else: node = node.right"
smallest subtree with all the deepest nodes,"class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        fn = lru_cache(None)(lambda x: 1 + max(fn(x.left), fn(x.right)) if x else 0)
        
        node = root
        while node: 
            if fn(node.left) == fn(node.right): return node 
            elif fn(node.left) < fn(node.right): node = node.right
            else: node = node.left
        return node"
prime palindrome,"class Solution:
    def primePalindrome(self, N: int) -> int:
        def isPrime(N):
            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))
        
        # N must be a palindrome with odd number of digits.
        # The return value will have odd number of digits too.
        def nextPalindrome(N):
            if N in [999, 99999, 9999999]:
                return (N + 1) * 10 + 1
            n = str(N // 10 ** (len(str(N))//2) + 1)
            return int(n + n[-2::-1])
        
        if N <= 11: 
            while not isPrime(N):
                N += 1
            return N
        
        if (digits := len(str(N))) % 2 == 0:
            N = 10 ** digits + 1
        else:
            n = str(N // 10 ** (len(str(N))//2))
            if (p := int(n + n[-2::-1])) >= N:
                N = p
            else:
                N = nextPalindrome(p)
                
        while not isPrime(N):
            N = nextPalindrome(N)
        return N"
prime palindrome,"class Solution:
    def primePalindrome(self, n: int) -> int:
        def is_prime(n):
            if n == 1: return False
            for i in range(2, int(n**0.5)+1):
                if n % i == 0: return False
            return True                
        
        n_str = str(n)
        l = len(n_str)        
        for k in range(max(0, l//2-1), 5):
            for i in range(10**k, 10**(k+1)):                            # odd length
                i_str = str(i)
                if k > 0 and i_str[0] in ['2','4','5','6','8']: continue # pruning
                cur = i_str + i_str[-2::-1]
                cur_int = int(cur)
                if cur_int >= n and is_prime(cur_int): 
                    return cur_int
                
            for i in range(10**k, 10**(k+1)):                            # even length
                i_str = str(i)
                if i_str[0] in ['2','4','5','6','8']: continue           # pruning
                cur = i_str + i_str[::-1]
                cur_int = int(cur)
                if cur_int >= n and is_prime(cur_int): 
                    return cur_int
        return -1"
transpose matrix,"class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        m,n=len(matrix),len(matrix[0])
        ans = [[None] * m for _ in range(n)]
        for i in range(m):
            for j in range(n):
                ans[j][i]=matrix[i][j]
        
        return ans"
transpose matrix,"class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        return list(map(list,zip(*matrix))) # we need to explicitly cast as zip returns tuples"
binary gap,"class Solution:
    def binaryGap(self, n: int) -> int:
        if(bin(n).count('1'))==1:
            return 0
        c=0
        x=bin(n)[2:]
        for i in range(len(x)):
            if(x[i]=='1'):
                j=i+1
                while j<len(x):
                    if(x[j]=='1'):
                        c=max(j-i,c)
                        break
                    j+=1
        return c"
binary gap,"class Solution:
    def binaryGap(self, n: int) -> int:
        binary = bin(n)
        binary= binary[2:]
        found = False
        max_count =0
        for i in range(len(binary)):
             if(binary[i]=='1' and found ==False):
                 start= i
                 found = True
             elif(binary[i]=='1' and found==True):
                 count = i- start
                 start= i
                 if(count>max_count):
                     max_count= count
        return max_count"
reordered power of 2,"class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        for i in range(32):
            if Counter(str(n))==Counter(str(2**i)):
                return True
        return False"
reordered power of 2,"class Solution:
    def reorderedPowerOf2(self, n: int) -> bool:
        i, arr = 0, []
        v = 2**i
        while v <= 10**9: arr.append(sorted(str(v))); i+=1; v = 2**i
        return sorted(str(n)) in arr"
advantage shuffle,"class Solution:
    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
        sorted_a = sorted(A, reverse=True)                                         # descending order
        sorted_b = sorted(enumerate(B), key=lambda x: (x[1], x[0]), reverse=True)  # descending order with original index
        n, j = len(B), 0
        ans = [-1] * n
        for i, (ori_idx, val) in enumerate(sorted_b):                 # A greedily tries to cover value in B as large as possible
            if sorted_a[j] > val: ans[ori_idx], j = sorted_a[j], j+1
        for i in range(n):                                            # assign rest value in A to ans
            if ans[i] == -1: ans[i], j = sorted_a[j], j+1
        return ans"
advantage shuffle,"class Solution:
    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
        n = len(nums1)
        nums2_hq_desc = []
        for i, num in enumerate(nums2):
            # need to negate num to sort in descending order
            heapq.heappush(nums2_hq_desc, (-num, i))
        nums1.sort()
        
        res = [0] * n
        left, right = 0, n-1 # two pointers on the sorted nums1 array
        
        while (left <= right):
            max2 = heapq.heappop(nums2_hq_desc)
            maxVal2, idx2 = max2
            # need to negate again to make num positive
            maxVal2 = -maxVal2
            if (maxVal2 < nums1[right]):
                # use current num to compete when it's stronger than maxVal2
                res[idx2] = nums1[right]
                right -= 1
            else:
                # use the weakest num to compete when maxVal2 >= nums[right]
                res[idx2] = nums1[left]
                left += 1
            
        return res"
minimum number of refueling stops,"class Solution:          # Here's the plan:
                         # 
                         # 1) We only need to be concerned with two quantities: the dist traveled (pos)
                         #    and the fuel acquired (fuel). We have to refuel before pos > fuel.
                         # 
                         # 2) Because  we have an infinite capacity tank, we only have to plan where to acquire
                         #    fuel before pos > fuel, and common sense says to stop at the station within range
                         #    with the most fuel.
                         # 
                         # 3) And that's a job for a heap. we heappush the stations that are within range of present
                         #    fuel, and heappop the best choice if and when we need fuel.
                         #  
                         # 4) We are finished when a) we have acquired sufficient fuel such that fuel >= target 
                         #    (return # of fuelings), or b) fuel < target and the heap is empty (return -1).
                       
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:

        fuel, heap, count = startFuel, [], 0            # <-- initialize some stuff
        
        stations.append([target, 0])                    # <-- this handles the ""stations = []"" test

        while stations:
            if fuel >= target: return count             # <-- 4)            

            while stations and stations[0][0] <= fuel:  # <-- 3)
                _, liters = stations.pop(0)
                heappush(heap,-liters)

            if not heap: return -1                      # <-- 4)
            fuel-= heappop(heap)

            count+= 1"
minimum number of refueling stops,"class Solution:
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        if not stations:
            if startFuel >= target:
                return 0
            else:
                return -1
        dp = [0] * (len(stations) + 1)
        dp[0] = startFuel
        # utilize index as stop number
        for i in range(len(stations)):
            for j in range(i,-1,-1):
                if dp[j] >= stations[i][0]:
                    dp[j+1] = max(dp[j+1], dp[j] + stations[i][1])
        for i in range(len(dp)):
            if dp[i] >= target:
                return i
        return -1"
leaf similar trees,"class Solution:
    def __init__(self):
        self.n = []
        
    def dfs(self, root):
        if root:
			# checking if the node is leaf
            if not root.left and not root.right:  
				# appends the leaf nodes to the list - self.n 
                self.n.append(root.val)  
				
            self.dfs(root.left)
            self.dfs(root.right)
            
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        self.dfs(root1)
        a = self.n
        self.n = []
        self.dfs(root2)
        
        if a == self.n:
            return True
        else:
            return False"
leaf similar trees,"class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
        def leaf_gen(rt: TreeNode):
            if (None, None) == (rt.left, rt.right):
                yield rt.val
            else:
                if rt.left:
                    yield from leaf_gen(rt.left)
                if rt.right:
                    yield from leaf_gen(rt.right)

        return all(l1 == l2 for l1, l2 in itertools.zip_longest(leaf_gen(root1), leaf_gen(root2)))"
length of longest fibonacci subsequence,"class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        arrset=set(arr)
        res=0
        for i in range(len(arr)):
            for j in range(i+1,len(arr)):
                a,b,l=arr[i],arr[j],2
                while(a+b in arrset):
                    a,b,l=b,a+b,l+1
                res=max(res,l)
        return res if res>=3 else 0"
length of longest fibonacci subsequence,"class Solution(object):
    def lenLongestFibSubseq(self, arr):
        n = len(arr)
        
        longest = defaultdict(int)
        index = {}
        for i in range(n):
            index[arr[i]] = i 
          
        res = 0 
        for i in range(n):
            for j in range(i+1, n):
                k = arr[i] + arr[j]
                if k in index:
                    idx = index[k]
                    longest[(j, idx)] = longest[(i, j)] + 1
                    res = max(res, longest[(j, idx)])
        if res >= 1:
            return res+2
        else:
            return 0"
walking robot simulation,"class Solution:
    def robotSim(self, c: List[int], b: List[List[int]]) -> int:
        x, y, d, b, M = 0, 0, 0, set([tuple(i) for i in b]), 0
        for i in c:
            if i < 0: d = (d + 2*i + 3)%4
            else:
                if d in [1,3]:
                    for x in range(x, x+(i+1)*(2-d), 2-d):
                        if (x+(2-d), y) in b: break
                else:
                    for y in range(y, y+(i+1)*(1-d), 1-d):
                        if (x, y+(1-d)) in b: break
            M = max(M, x**2 + y**2)
        return M
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
walking robot simulation,"class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        facing = best = 0
        distance = lambda x, y: x**2 + y**2
        current = (0, 0)
        obstacles = {(p[0], p[1]) for p in obstacles}

        for c in commands:
            if c == -1:
                facing = (facing + 1) % 4
            elif c == -2:
                facing = (facing + 3) % 4
            elif 1 <= c <= 9:
                for i in range(c):
                    newx = current[0] + directions[facing][0]
                    newy = current[1] + directions[facing][1]
                    if (newx, newy) not in obstacles:
                        current = (newx, newy)
                        best = max(best, distance(current[0], current[1]))
                    else:
                        break
            else:
                raise ValueError
        return best"
koko eating bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        k = 1
        while True:
            total_time = 0
            for i in piles:
                total_time += ceil(i / k)
            if total_time > h:
                k += 1
            else:
                return k"
koko eating bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        k = ceil(sum(piles)/h)
        while True:
            total_time = 0
            for i in piles:
                total_time += ceil(i/k)
                if total_time > h:
                    break # as time exceeds H
            if total_time <= h:
                return k # answer found as time is in the given limits.
            k += 1"
middle of the linked list,"class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        
        slow, fast = head, head
        
        while fast:
            
            fast = fast.next
            if fast:
                fast = fast.next
            else:
                # fast has reached the end of linked list
                # slow is on the middle point now
                break
        
            slow = slow.next
        
        return slow"
middle of the linked list,"class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        count = 0
      **  tmp = head
        while tmp:
            count+=1
            tmp = tmp.next
            
        middle = count//2
        l = 0
        while l < middle:
            head = head.next
            l+=1
        return head"
stone game,"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        
		# Alex always win finally, no matter which step he takes first.
        return True"
stone game,"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        return True"
nth magical number,"class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
	    # inclusion-exclusion principle
        ab = lcm(a,b)
        lo, hi = 0, n*min(a, b)
        while lo < hi: 
            mid = lo + hi >> 1
            if mid//a + mid//b - mid//ab < n: lo = mid + 1
            else: hi = mid 
        return lo % 1_000_000_007"
nth magical number,"class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        def gcd(x,y):
            if(x==0):
                return y
            return gcd(y%x,x)
        lcm=(a*b)//gcd(a,b)
        s=set()
        x=a
        while(x<=lcm):
            s.add(x)
            x+=a
        x=b
        while(x<=lcm):
            s.add(x)
            x+=b
        
        le=0
        l=[]
   
        for i in s:
            l.append(i)
            le+=1
        l.sort()    #sort all multiples of a and b which are less than their lcm.
        
        #below approach is based on pattern observation. Try to take some example and observer the pattern(e.g n=4,8,9,16,18,41 #a=3, b=7)
        r=n%le
        q=n//(le+1)
      
        if(q==0):
            return l[n-1]
        else:
            q=n//le
            res=  ((q*l[-1])%1000000007)
            if(r>0):
                  res=(res+ l[r-1]) %1000000007
            return res"
profitable schemes,"class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        # A[i][j][k] = # schemes using subset of first i crimes, using <= j people, with total profit >= k 
        A = [[[0 for k in range(minProfit + 1)] for j in range(n + 1)] for i in range(len(profit) + 1)]
        # if using first 0 crimes, only one way, and that if minProfit <= 0
        for j in range(n + 1):
            A[0][j][0] = 1
        for i in range(1, len(profit) + 1):
            for j in range(n + 1):
                for k in range(minProfit + 1):
                    # we are here calculating A[j][j][k]
                    # two cases, either we use i'th crime or not. 
                    # but if i'th crime requires more than j people, we con't use it
                    if group[i-1] > j:
                        A[i][j][k] = A[i-1][j][k]
                    else:
                        # if i'th crime gets profit greater than k, then we have no restriction 
                        # on the rest of the groups
                        if profit[i-1] > k:
                            A[i][j][k] = (A[i-1][j][k] + A[i-1][j-group[i-1]][0]) % (10**9 + 7)
                        else:
                            A[i][j][k] = (A[i-1][j][k] + A[i-1][j-group[i-1]][k-profit[i-1]]) % (10**9 + 7)
        return A[len(profit)][n][minProfit]"
profitable schemes,"class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        m = len(group)
        dp = [[[0] * (minProfit+1) for _ in range(n+1)] for _ in range(m+1)]
        for j in range(n+1): dp[m][j][0] = 1
        for i in range(m-1, -1, -1): 
            for j in range(n+1): 
                for k in range(minProfit+1): 
                    dp[i][j][k] = dp[i+1][j][k]
                    if group[i] <= j: dp[i][j][k] += dp[i+1][j-group[i]][max(0, k-profit[i])]
                    dp[i][j][k] %= 1_000_000_007
        return dp[0][n][minProfit]"
decoded string at index,"class Solution:
    def decodeAtIndex(self, s: str, k: int) -> str:
        lens = [0]
        
        for c in s:
            if c.isalpha():
                lens.append(lens[-1] + 1)
            else:
                lens.append(lens[-1] * int(c))
                
        for idx in range(len(s), 0, -1):
            k %= lens[idx]
            if k == 0 and s[idx - 1].isalpha():
                return s[idx - 1]
        
        return"
decoded string at index,"class Solution:
    def decodeAtIndex(self, S: str, K: int) -> str:
        K -= 1 # 0-indexed 
        
        stack = []
        i = 0
        for c in S: 
            if c.isdigit(): i *= int(c)
            else: 
                stack.append((i, c))
                if K <= i: break 
                i += 1
        
        while K != i: 
            if K < i: i, ans = stack.pop()
            else: K %= i+1 
        return ans"
boats to save people,"class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort()
        lo = 0
        hi = len(people)-1
        boats = 0
        while lo <= hi:
            if people[lo] + people[hi] <= limit:
                lo += 1
                hi -= 1
            else:
                hi -= 1
            boats += 1
        return boats"
boats to save people,"class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort()
        lo, hi, ans = 0, len(people) - 1, 0
        while lo <= hi:
            if people[hi] + people[lo] <= limit: lo += 1
            hi -= 1; ans += 1
        return ans"
reachable nodes in subdivided graph,"class Solution:
    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
        graph = collections.defaultdict(dict)
        for s, e, n in edges: # n: subnodes in edge
            graph[s][e] = n
            graph[e][s] = n
        
        seen = set() # (start, end, step)
        q = collections.deque()
        for n in graph[0]:
            q.append((0, n, 0))
        
        res = 1
        move = maxMoves
        while q:
            for _ in range(len(q)):
                start, end, step = q.popleft()
                seen.add((start, end, step))
                seen.add((end, start, graph[end][start]-step+1))
                
                if step == graph[start][end] + 1: #check if reached next node
                    for n in graph[end]:
                        if (end, n, 1) not in seen:
                            q.append((end, n, 1))
                            res += 1
                            
                else:
                    if (start, end, step+1) not in seen and (end, start, graph[end][start]-step) not in seen:
                        q.append((start, end, step+1))
                        res += 1
                    
            move -= 1  
            if move == 0:
                break

        return res"
reachable nodes in subdivided graph,"class Solution:
    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
        graph = defaultdict(dict)
        for u, v, w in edges: graph[u][v] = graph[v][u] = w
        
        ans = 0
        pq = [(0, 0)] # min-heap 
        
        seen = [False] * n
        used = defaultdict(int)
        
        while pq: 
            x, u = heappop(pq)
            if not seen[u]: 
                ans += 1
                seen[u] = True 
                for v, c in graph[u].items(): 
                    if not used[u, v]: 
                        if used[v, u] < graph[v][u]: 
                            used[u, v] = min(maxMoves - x, graph[v][u] - used[v, u])
                            ans += used[u, v]
                        if x + c + 1 <= maxMoves and not seen[v]: heappush(pq, (x + c + 1, v))
        return ans"
projection area of 3d shapes,"class Solution:
    def projectionArea(self, grid: List[List[int]]) -> int:
        p = len(grid)
        x, y, c = [], [0]*p, 0
        for i in range(p):
            x.append(0)
            for j in range(p):
                n = grid[i][j]
                if n > 0:
                    c += 1
                if x[i] < n:
                    x[i] = n
                if y[j] < n:
                    y[j] = n

        return (sum(x)+sum(y)+c)"
projection area of 3d shapes,"class Solution:
    def projectionArea(self, grid: List[List[int]]) -> int:
        area = 0
        for i in grid:
            area += len(i) - i.count(0) + max(i)
        for i in zip(*grid):
            area += max(i)
        return area"
uncommon words from two sentences,"class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
        uncommon = []
        
        def find_uncommon(s , t):
            ans = []
            for i in s:
                if(s.count(i) == 1 and i not in t):
                    ans.append(i)
            
            return ans
        
        return find_uncommon(A.split() , B.split()) + find_uncommon(B.split() , A.split())"
uncommon words from two sentences,"class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
        A = A.split() + B.split() # Simply add both the strings by converting it into list using split()
        resLis = [] # to store the result list
        for i in A: #traverse the list 
            if A.count(i) == 1: #if the count of string present in list is 1 then append it to the resLis
                resLis.append(i)
        return resLis #return the resLis"
spiral matrix iii,"class Solution:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        ans = []
        left, right = cStart, cStart+1
        top, bottom = rStart, rStart+1
        current = 1
        move = 0
        while current <= rows*cols:
            # fill top
            for i in range(left+move, right+1):
                if self.inbound(top, i, rows, cols):
                    ans.append([top, i])
                    current += 1
            left -= 1
            # fill right
            for i in range(top+1, bottom+1):
                if self.inbound(i, right, rows, cols):
                    ans.append([i, right])
                    current += 1
            top -= 1
            # fill bottom
            for i in range(right-1, left-1, -1):
                if self.inbound(bottom, i, rows, cols):
                    ans.append([bottom, i])
                    current += 1
            right += 1
            # fill left
            for i in range(bottom-1, top-1, -1):
                if self.inbound(i, left, rows, cols):
                    ans.append([i, left])
                    current += 1
            bottom += 1
            move = 1
        return ans
    def inbound(self, r, c, rows, cols):
        return 0<=r<rows and 0<=c<cols"
spiral matrix iii,"class Solution:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        total, cnt, step, i = rows * cols, 1, 1, 0
        ans = [[rStart, cStart]]
        direction = {0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)} # setup direction movements
        while cnt < total:
            for k in range(step):
                rStart, cStart = rStart+direction[i][0], cStart + direction[i][1]
                if 0 <= rStart < rows and 0 <= cStart < cols:
                    ans.append([rStart, cStart])
                    cnt += 1       # count visited 
            i = (i + 1) % 4        # changing direction
            step += not i % 2      # increase step every 2 directions
        return ans"
possible bipartition,"class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        dislike = [[] for _ in range(n)]
        for a, b in dislikes:
            dislike[a-1].append(b-1)
            dislike[b-1].append(a-1)

        groups = [0] * n
        for p in range(n):
            if groups[p] == 0:
                groups[p] = 1
                q = deque([p])
                while q: # bfs
                    a = q.pop()
                    for b in dislike[a]:
                        if groups[b] == 0:
                            groups[b] = 1 if groups[a] == 2 else 2
                            q.appendleft(b)
                        elif groups[a] == groups[b]:
                            return False
        return True"
possible bipartition,"class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        visited=[0]*n
        group=[-1]*n
        adj=[[] for _ in range(n)]
        for i,j in dislikes:
            adj[i-1].append(j-1)
            adj[j-1].append(i-1)
            
        for k in range(n):
            if visited[k]==0:
                lst=[[k,0]]
                visited[k]=1
                group[k]=0
                while lst:
                    x,c=lst.pop(0)
                    for i in adj[x]:
                        if visited[i]==0:
                            lst.append([i,(c+1)%2])
                            visited[i]=1
                            group[i]=(c+1)%2
                        else:
                            if group[i]!=(c+1)%2:
                                return False
        
        return True"
super egg drop,"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return min moves given n floors and k eggs.""""""
            if k == 1: return n
            if n == 0: return 0 
            lo, hi = 1, n + 1
            while lo < hi: 
                mid = lo + hi >> 1
                if fn(mid-1, k-1) < fn(n-mid, k): lo = mid + 1
                else: hi = mid 
            return 1 + max(fn(lo-1, k-1), fn(n-lo, k))
        
        return fn(n, k)"
super egg drop,"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        dp = [[0]*(k+1) for _ in range(n+1) ] # (n+1) x (k+1)
        for i in range(n+1): dp[i][1] = i
        for j in range(k+1): dp[0][j] = 0

        for j in range(2, k+1): # j eggs
            x = 1
            for i in range(1, n+1): # i floors
                while x <= i and dp[i-x][j] > dp[x-1][j-1]: x += 1
                dp[i][j] = 1 + dp[x-1][j-1]
        return dp[n][k]"
fair candy swap,"class Solution:
    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:
        difference = (sum(A) - sum(B)) / 2
        A = set(A)
        for candy in set(B):
            if difference + candy in A:
                return [difference + candy, candy]"
fair candy swap,"class Solution:
    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:
        a,b=sum(A),sum(B)
        diff=(a-b)//2
        i,j=0,0
        A.sort()
        B.sort()
        while i<len(A) and j<len(B):
            temp = A[i]-B[j]
            if temp == diff:
                return [A[i],B[j]]
            elif temp<diff:
                i+=1
            else:
                j+=1"
construct binary tree from preorder and postorder traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        mp = {x: i for i, x in enumerate(inorder)} # relative position 
		root = None
	    stack = []
        for x in preorder: 
            if not root: root = node = TreeNode(x)
            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)
            else: 
                while stack and mp[stack[-1].val] < mp[x]: node = stack.pop() # retrace 
                node.right = node = TreeNode(x)
            stack.append(node)
        return root"
construct binary tree from preorder and postorder traversal,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        mp = {x: i for i, x in enumerate(inorder)} # relative position 
        root = None
        stack = []
        for x in reversed(postorder): 
            if not root: root = node = TreeNode(x)
            elif mp[x] > mp[stack[-1].val]: stack[-1].right = node = TreeNode(x)
            else: 
                while stack and mp[stack[-1].val] > mp[x]: node = stack.pop() # retrace 
                node.left = node = TreeNode(x)
            stack.append(node)
        return root"
find and replace pattern,"class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        
        def helper( s ):
            
            # dictionary
            # key   : character
            # value : serial number in string type
            char_index_dict = dict()
            
            # given each unique character a serial number
            for character in s:
                
                if character not in char_index_dict:
                    char_index_dict[character] = str( len(char_index_dict) )
            
            
            # gererate corresponding pattern string
            return ''.join( map(char_index_dict.get, s) )

        #--------------------------------------------------------    
            
        pattern_string = helper(pattern)
        
        return [ word for word in words if helper(word) == pattern_string ]"
find and replace pattern,"class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        result = []
        for word in words:
            if len(set(pattern)) == len(set(word)):
                tempDict = {}
                Flag = False
                for i in range(len(pattern)):
                    if pattern[i] not in tempDict:
                        Flag= True
                        tempDict[pattern[i]] = word[i]
                    elif pattern[i] in tempDict and tempDict[pattern[i]] != word[i]:
                        Flag = False
                        break
                if Flag== True:
                    result.append(word)
        return result"
sum of subsequence widths,"class Solution:
    def sumSubseqWidths(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        nums.sort()

        dp = [0] * n

        p = 2
        temp = nums[0]

        for i in range(1, n):
            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD
            p = (2*p)%MOD
            temp = ((2*temp)%MOD + nums[i])%MOD
        
        return dp[n-1]"
sum of subsequence widths,"class Solution:
    def sumSubseqWidths(self, nums: List[int]) -> int:
        nums.sort()
        ans = 0
        n = len(nums)
        
        for i in range(n):
            mx = (2**i)*nums[i]
            mn = (2**(n-1-i))*nums[i]
            ans += (mx-mn)
        
        return ans%(10**9+7)"
surface area of 3d shapes,"class Solution:
    def surfaceArea(self, grid: List[List[int]]) -> int:
        
        l = len(grid)
        area=0
        for row in range(l):
            for col in range(l):
                if grid[row][col]:
                    area += (grid[row][col]*4) +2 #surface area of each block if blocks werent connected
                if row: #row>0
                    area -= min(grid[row][col],grid[row-1][col])*2 #subtracting as area is common among two blocks
                if col: #col>0
                    area -= min(grid[row][col],grid[row][col-1])*2 #subtracting as area is common among two blocks
        return area"
surface area of 3d shapes,"class Solution:
    def surfaceArea(self, grid: List[List[int]]) -> int:
        n = len(grid)
        
        def area(i, j):
            v = grid[i][j]
            if v == 0:
                return 0

            up = min(v, grid[i - 1][j]) if i else 0
            right = min(v, grid[i][j + 1]) if j < n - 1 else 0
            down = min(v, grid[i + 1][j]) if i < n - 1 else 0
            left = min(v, grid[i][j - 1]) if j else 0

            return 2 + 4*v - up - right - down - left
        
        return sum(area(i, j) for i in range(n) for j in range(n))"
groups of special equivalent strings,"class Solution:
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        
        signature = set()
        
        # Use pair of sorted even substring and odd substring as unique key
        
        for idx, s in enumerate(A):
            signature.add( ''.join( sorted( s[::2] ) ) + ''.join( sorted( s[1::2] ) )  )
        
        return len( signature )"
groups of special equivalent strings,"class Solution:
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        return len({''.join(sorted(a[::2]) + sorted(a[1::2])) for a in A})"
all possible full binary trees,"class Solution:
    def allPossibleFBT(self, N: int) -> List[TreeNode]:
		# Any full binary trees should contain odd number of nodes
		# therefore, if N is even, return 0
		if N % 2 == 0:
			return []
		# for all odd n that are less than N, store all FBTs
        trees_all = collections.defaultdict(list)
		
		#when there is one node, only one tree is available
        trees_all[1] = [TreeNode(0)]
        for n in range(3, N+1, 2):
            for k in range(1, n, 2):
                # trees with k nodes on the left
                # trees with n - k - 1 nodes on the right
				# consider all potential pairs
                for tree1, tree2 in itertools.product(trees_all[k],
													  trees_all[n-k-1]):
                    tree = TreeNode(0)
                    tree.left = tree1
                    tree.right = tree2
                    trees_all[n].append(tree)
                    
        return trees_all[N]"
all possible full binary trees,"class Solution:
    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:
        output = []
        if not n % 2:
            return output
        
        def FBT(m):
            if m == 1:
                return [TreeNode(0)]
            res = []
            for i in range(1, m - 1):
                for left in FBT(i):
                    for right in FBT(m - 1 - i):
                        root = TreeNode(0, left, right)
                        res.append(root)
            return res
        
        return FBT(n)"
monotonic array,"class Solution:
    def isMonotonic(self, A: List[int]) -> bool:
        if A[-1] < A[0]: 
            A = A[::-1]
        
        for i in range(1, len(A)):
            if A[i] < A[i-1]:
                return False
        return True"
monotonic array,"class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        a = sorted(nums)
        b = sorted(nums,reverse=True)
        if nums == a or nums == b:
            return True
        return False"
increasing order search tree,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        
        prev_node = None
        
        def helper( node: TreeNode):
                           
            if node.right:
                helper( node.right )

            # prev_novde always points to next larger element for current node
            nonlocal prev_node

            # update right link points to next larger element
            node.right = prev_node

            # break the left link of next larger element
            if prev_node:
                prev_node.left = None

            # update previous node as current node
            prev_node = node

            if node.left:
                helper( node.left)
                
        # ---------------------------------------
        helper( root )
        
        return prev_node"
increasing order search tree,"class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        node = root
        stack = []
        prev = None
        lowest = None
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:    
                node = stack.pop()
                if not lowest:
                    lowest = node
                node.left = None
                if prev:
                    prev.right = node
                prev = node
                node = node.right
        return lowest"
bitwise ors of subarrays,"class Solution:
    def subarrayBitwiseORs(self, arr: List[int]) -> int:
        
        
        ans=set(arr)
        
        # each element is a subarry
        
        
        one = set()
        
        # to get the ans for the subarray of  size >1
        # starting from 0th element to the ending element
        
        
        one.add(arr[0])
        
        for i in  range(1,len(arr)):
            
            two=set()
            
            for j in one:
                
                two.add(j |  arr[i])
                
                # subarray from the element in one set to the current ele(i th one)
                
                ans.add(j| arr[i])
                
            
            two.add(arr[i])
            
            # adding curr element to set two so that from next iteration we can take sub array starting from curr element 
            
            one = two
            
        return len(ans)"
bitwise ors of subarrays,"class Solution:
    def subarrayBitwiseORs(self, A: List[int]) -> int:
        ans, vals = set(), set()
        for x in A: 
            vals = {x | xx for xx in vals} | {x}
            ans |= vals
        return len(ans)"
orderly queue,"class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        if k > 1:
            return """".join(sorted(s))
        
        res = s
        for i in range(0,len(s)):
            s = s[1:] + s[0]
            res = min(res,s)
                
        return res"
orderly queue,"class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        st=""""
        lst=list(s)
        lst.sort()
        queue=list(s)
        flg=defaultdict(lambda :0)
        if k==1:
            pt=[z for z in range(len(lst)) if s[z]==lst[0]]
            mn=s[pt[0]:]+s[:pt[0]]
            for p in range(len(pt)):
                mn=min(mn,s[pt[p]:]+s[:pt[p]])
            return mn
        ct=k
        if k==len(s):
            return """".join(lst)
        while k>0:
            if queue[0][0]==lst[0]:
                st+=queue.pop(0)[0]
                lst.pop(0)
                k-=1
                for nm in flg:
                    flg[nm]=0
            else:
                mn=queue[0]
                ind=0
                for i in range(1,min(ct,len(queue)-1)):
                    if queue[i]<mn and queue[i]!=lst[0] and flg[queue[i]]!=1:
                        ind=i
                x=queue.pop(ind)
                queue.append(x)
                flg[x]=1
        if ct>1:
            queue.sort()
        return st+"""".join(queue)"
numbers at most n given digit set,"class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        digits = set(int(d) for d in digits)
        dLen = len(digits)
        nStr = str(n)
        nLen = len(nStr)
        
        res = sum(dLen**i for i in range(1, nLen)) # lower dimensions
        
        def helper(firstDigit, slots):
            if slots == 1:
                return sum(d <= firstDigit for d in digits)

            return sum(d < firstDigit for d in digits) * dLen**(slots - 1)
        
        for i in range(nLen):
            curDigit = int(nStr[i])

            res += helper(curDigit, nLen - i)
            
            if not curDigit in digits: # makes no sense to continue
                break
    
        return res"
numbers at most n given digit set,"class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        s = str(n)
        prev = 1
        for i, ch in enumerate(reversed(s)): 
            k = bisect_left(digits, ch)
            ans = k*len(digits)**i
            if k < len(digits) and digits[k] == ch: ans += prev 
            prev = ans
        return ans + sum(len(digits)**i for i in range(1, len(s)))"
valid permutations for di sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        
        @cache 
        def fn(i, x): 
            """"""Return number of valid permutation given x numbers smaller than previous one.""""""
            if i == len(s): return 1 
            if s[i] == ""D"": 
                if x == 0: return 0 # cannot decrease
                return fn(i, x-1) + fn(i+1, x-1)
            else: 
                if x == len(s)-i: return 0 # cannot increase 
                return fn(i, x+1) + fn(i+1, x)
        
        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007"
valid permutations for di sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val) in mem:
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+2):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)"
fruit into baskets,"class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        fruit_types = Counter()
        distinct = 0
        max_fruits = 0
        
        left = right = 0
        while right < len(fruits):
            # check if it is a new fruit, and update the counter
            if fruit_types[fruits[right]] == 0:
                distinct += 1
            fruit_types[fruits[right]] += 1
            
            # too many different fruits, so start shrinking window
            while distinct > 2:
                fruit_types[fruits[left]] -= 1
                if fruit_types[fruits[left]] == 0:
                    distinct -= 1
                left += 1
            
            # set max_fruits to the max window size
            max_fruits = max(max_fruits, right-left+1)
            right += 1
        
        return max_fruits"
fruit into baskets,"class Solution:
    def totalFruit(self, fruits: List[int]) -> int:

        start =0 
        end = 0
        d = {}
        max_val = 0
        while end < len(fruits):
            d[fruits[end]] = end
            if len(d) >=3:
                min_val = min(d.values())
                del d[fruits[min_val]]
                start = min_val +1 

            max_val = max(max_val,end -start +1)
            end += 1
        return max_val"
sort array by parity,"class Solution:
    def sortArrayByParity(self, A: List[int]) -> List[int]:
        i, j = 0, len(A) - 1
        while i < j:
        	if A[i] % 2 == 1 and A[j] % 2 == 0: A[i], A[j] = A[j], A[i]
        	i, j = i + 1 - A[i] % 2, j - A[j] % 2
        return A"
sort array by parity,"class Solution:
    def sortArrayByParity(self, A: List[int]) -> List[int]:
        return sorted(A, key = lambda x : x % 2)

class Solution:
    def sortArrayByParity(self, A: List[int]) -> List[int]:
        return [i for i in A if not i % 2] + [i for i in A if i % 2]


- Junaid Mansuri
(LeetCode ID)@hotmail.com"
super palindromes,"class Solution:
    
        
        
    nums = []
    for i in range(1, 10**5):
        odd = int(str(i)+str(i)[:-1][::-1])**2
        even = int(str(i)+str(i)[::-1])**2
            
        if str(odd) == str(odd)[::-1]:
            nums.append(odd)
                
        if str(even) == str(even)[::-1]:
            nums.append(even)
        
    nums = sorted(list(set(nums)))
    def superpalindromesInRange(self, left: str, right: str) -> int:
        output = []
        for n in self.nums:
            if int(left) <= n <= int(right):
                output.append(n)
                
        return len(output)"
super palindromes,"class Solution:
    def superpalindromesInRange(self, left: str, right: str) -> int:

        min_num, max_num = int(left), int(right)
        count, limit = 0, 20001
        
        # odd pals
        for num in range(limit + 1):
            num_str = str(num)
            if num_str[0] != 1 or num_str[0] != 4 or num_str[0] != 5 or num_str[0] != 6 or num_str[0] != 9:
                pal = num_str + num_str[:-1][::-1]
                num_sqr = int(pal) ** 2

                if num_sqr > max_num:
                    break

                if num_sqr >= min_num and str(num_sqr) == str(num_sqr)[::-1]:
                    count += 1
        
        # even pals
        for num in range(limit + 1):
            num_str = str(num)
            if num_str[0] != 1 or num_str[0] != 4 or num_str[0] != 5 or num_str[0] != 6 or num_str[0] != 9:
                pal = num_str + num_str[::-1]
                num_sqr = int(pal) ** 2

                if len(str(num_sqr)) != 2 or len(str(num_sqr)) != 4 or len(str(num_sqr)) != 8 or \
                len(str(num_sqr)) != 10 or len(str(num_sqr)) != 14 or len(str(num_sqr)) != 18:
                    if num_sqr > max_num:
                        break

                    if num_sqr >= min_num and str(num_sqr) == str(num_sqr)[::-1]:
                        count += 1
						
        return count"
sum of subarray minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        M = 10 ** 9 + 7

        # right bound for current number as minimum
		q = []
        n = len(arr)
        right = [n-1] * n        
        
        for i in range(n):
            # must put the equal sign to one of the bound (left or right) for duplicate nums (e.g. [71, 55, 82, 55])
            while q and arr[i] <= arr[q[-1]]:
                right[q.pop()] = i - 1
            q.append(i)

        # left bound for current number as minimum
        q = []
        left = [0] * n
        for i in reversed(range(n)):
            while q and arr[i] < arr[q[-1]]:
                left[q.pop()] = i + 1
            q.append(i)
        
        # calculate sum for each number
        ans = 0
        for i in range(n):
            l, r =  abs(i - left[i]), abs(i - right[i])
            # for example:  xx1xxx
            # left take 0, 1, 2 numbers (3 combs) and right take 0, 1, 2, 3 numbers (4 combs)
            covered = (l + 1) * (r + 1)
            ans = (ans + arr[i] * covered) % M
        
        return ans"
sum of subarray minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        res = 0
        stack = [-1]                                        # We are adopting increasing stack to solve this problem.
        arr += [0]                                          # The trick is as same as problem 84,
                                                            # put 0 in the last of arr, also keeping stack[0] always the smallest element without affecting res.
            
            
        for i in range(len(arr)):                           
            while arr[i] < arr[stack[-1]]:                  
                mid = stack.pop()                           # mid is the idx of ""num"" which is the smallest element in current interval.  
                num = arr[mid]
                right = i                                   # ""right"" is the right first element smaller than ""num""
                left = stack[-1]                            # ""left"" is the left first element smaller than ""num""
                res += num * (right-mid) * (mid-left)
            stack.append(i)
        
        return res % (10**9 + 7)"
smallest range i,"class Solution:
    def smallestRangeI(self, A: List[int], K: int) -> int:

        M, m = max(A), min(A)
        diff, extension = M - m, 2*K
        
        if diff <= extension:
            return 0
        
        else:
            return diff - extension"
smallest range i,"class Solution:
    def smallestRangeI(self, nums: List[int], k: int) -> int:
        if len(nums) <=1:
            return 0
        diff=max(nums)-min(nums)
		## diff after 
        new_diff=diff-2*k
        if new_diff < 0:
            return 0
        else:
            return new_diff"
snakes and ladders,"class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        
        # creating a borad map to loop-up the square value
        board_map = {}
        i = 1
        b_rev = board[::-1]
        for d, r in enumerate(b_rev):
			# reverse for even rows - here d is taken as direction 
            if d%2 != 0: r = r[::-1] 
            for s in r:
                board_map[i] = s
                i += 1
        
        # BFS Algorithm
        q = [(1, 0)] # (curr, moves)
        v = set()
        goal = len(board) * len(board) # end square
        
        while q:
            curr, moves = q.pop(0)
            # win situation
            if curr == goal: return moves
            # BFS on next 6 places (rolling a die)
            for i in range(1, 7):
                # skip square outside board
                if curr+i > goal: continue
                # get value from mapping
                next_pos = curr+i if board_map[curr+i] == -1 else board_map[curr+i]
                if next_pos not in v:
                    v.add(next_pos)
                    q.append((next_pos, moves+1))
        
        return -1"
snakes and ladders,"class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        N = len(board)
        seen = set()
        queue = collections.deque()
        queue.append((1,0))
        flatten = self.getFlattenBoard(board)
        
        # bfs
        while queue:
            label, step = queue.popleft()
            if flatten[label] != -1:
                label = flatten[label]
            if label == N * N:
                return step
            
            # Get the next steps
            for x in range(1 ,7):
                nextLabel = label + x
                if nextLabel <= N * N and nextLabel not in seen:
                    seen.add(nextLabel)
                    queue.append((nextLabel,step + 1))
        return -1
        
    
    def getFlattenBoard(self, board): 
        N = len(board)
        # Use i to keep track of the direction of labels
        i = 0
        # The first cell in the flatten array is the extra element so the index in board can match the index in flatten array
        flatten = [-1] 
        
        #Iterating from the bottom row 
        for row in range(N-1, -1, -1):
            # store labels from left to right
            if i % 2 == 0:
                for col in range(N):
                    flatten.append(board[row][col])
            #store labels from right to left
            else: 
                for col in range(N-1,-1,-1):
                    flatten.append(board[row][col])
            i += 1 
        
        return flatten"
smallest range ii,"class Solution:
    def smallestRangeII(self, A: List[int], K: int) -> int:
        A.sort()
        res = A[-1] - A[0]
        
        for indx in range(0, len(A) - 1):
            # assuming that A[indx] is the max val
            min_val = min(A[0] + K, A[indx + 1] - K)
            max_val = max(A[indx] + K, A[-1] - K)
            res = min(res, max_val - min_val)

        return res"
smallest range ii,"class Solution:
    def smallestRangeII(self, A: List[int], K: int) -> int:
        A.sort()
        ans = A[-1] - A[0]
        for i in range(1, len(A)): 
            mn = min(A[0] + K, A[i] - K) # move up A[:i]
            mx = max(A[i-1]+K, A[-1] - K) # move down A[i:]
            ans = min(ans, mx - mn)
        return ans"
sort an array,"class Solution:
    def sortArray(self, N: List[int]) -> List[int]:
        L = len(N)
        return [N.pop(min(range(L-i), key = lambda x: N[x])) for i in range(L)]"
sort an array,"class Solution:
    def sortArray(self, N: List[int]) -> List[int]:
        L, B = len(N), 1
        while B:
            B = 0
            for i in range(L-1):
                if N[i] > N[i+1]: N[i], N[i+1], B = N[i+1], N[i], 1
        return N"
cat and mouse,"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp;1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)"
x of a kind in a deck of cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        x = Counter(deck).values()
        return reduce(gcd, x) > 1"
x of a kind in a deck of cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        return gcd(*Counter(deck).values())>1"
partition array into disjoint intervals,"class Solution:
    def partitionDisjoint(self, nums: List[int]) -> int:
        """"""
        Intuition(logic) is to find two maximums.
        One maximum is for left array and other maximum is for right array.
        
        But the condition is that, the right maximum should be such that, 
        no element after that right maximum should be less than the left maximum. 
        
        If there is any element after right maximum which is less than left maximum,
        that means there is another right maximum possible and therefore in that case assign
        left maximum to right maximum and keep searching the array for correct right
        maximum till the end.
        """"""
        #start with both left maximum and right maximum with first element.
        left_max = right_max = nums[0]
        # our current index
        partition_ind = 0
        # Iterate from 1 to end of the array
        for i in range(1,len(nums)):
            #update right_max always after comparing with each nums
            #in order to find our correct right maximum
            right_max = max(nums[i], right_max)
            """"""
			if current element is less than left maximum, that means this 
            element must belong to the left subarray. 
              * so our partition index will be updated to current index 
              * and left maximum will be updated to right maximum. 
             Why left maximum updated to right maximum ?
              Because when we find any element less than left_maximum, that 
              means the right maximum which we had till now is not valid and we have
              to find the valid right maximum again while iterating through the end of the loop.
			""""""
            if nums[i] < left_max:
                left_max = right_max
                partition_ind = i
        
        return partition_ind+1"
partition array into disjoint intervals,"class Solution:
	def partitionDisjoint(self, nums: List[int]) -> int:
		lng = len(nums)
		maxx, minn = nums[0], min(nums[1:])
    
		for i in range(lng):
			maxx = max(maxx, nums[i])
			if minn == nums[i]: minn = min(nums[i + 1:])
			if maxx <= minn: return i + 1"
word subsets,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        result = []
        tempDict = Counter()
        for w in words2:
            tempDict |= Counter(w)
        print(tempDict)
        
        for w in words1:
            if not tempDict - Counter(w):
                result.append(w)
        return result"
word subsets,"class Solution:
    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:
        ans = set(words1)
        letters = {}
        for i in words2:
            for j in i:
                count = i.count(j)
                if j not in letters or count > letters[j]:
                    letters[j] = count
        for i in words1:
            for j in letters:
                if i.count(j) < letters[j]:
                    ans.remove(i)
                    break
        return list(ans)"
reverse only letters,"class Solution:
    def reverseOnlyLetters(self, S: str) -> str:
    	S = list(S)
    	c = [c for c in S if c.isalpha()]
    	for i in range(-1,-len(S)-1,-1):
    		if S[i].isalpha(): S[i] = c.pop(0)
    	return """".join(S)
		
		
- Python 3
- Junaid Mansuri"
reverse only letters,"class Solution:
    def reverseOnlyLetters(self, s: str) -> str:
        
        y='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        one = 0
        
        two = len(s)-1
        
        s= list(s)
        
        while one < two:
            
            if s[one] in y:
                if s[two] in y:
                    s[one], s[two] = s[two] , s[one]
                    one+=1
                    two-=1
                else:
                    two-=1
            else:
                one+=1
        return ''.join(s)"
maximum sum circular subarray,"class Solution:
    def maxSubarraySumCircular(self, A: List[int]) -> int:
        
        array_sum = 0
        
        local_min_sum, global_min_sum = 0, float('inf')
        local_max_sum, global_max_sum = 0, float('-inf')
        
        for number in A:
            
            local_min_sum = min( local_min_sum + number, number )
            global_min_sum = min( global_min_sum, local_min_sum )
            
            local_max_sum = max( local_max_sum + number, number )
            global_max_sum = max( global_max_sum, local_max_sum )
            
            array_sum += number
        
        
        
        # global_max_sum denotes the maximum subarray sum without crossing boundary
        # arry_sum - global_min_sum denotes the maximum subarray sum with crossing boundary
        
        if global_max_sum > 0:
            return max( array_sum - global_min_sum, global_max_sum )
        else:
            # corner case handle for all number are negative
            return global_max_sum"
maximum sum circular subarray,"class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        
        def maxSubArray( A: List[int]) -> int:
        
            size = len(A)
            
            dp = [ 0 for _ in range(size)]
            dp[0] = A[0]

            for i in range(1, size):

                dp[i] = max(dp[i-1] + A[i], A[i])

            return max(dp)
        
        # -----------------------------------------------------------
        
        ## Boundary case, only one element
        if len(nums) == 1:
            return nums[0]
        
        ## General cases:
        
        # Maximal without first element
        drop = maxSubArray(nums[1:])
        
        # Maxiaml with first element selected
        pick = sum(nums) + max(0, maxSubArray([-number for number in nums[1:]]))
        
        return max(drop, pick)"
number of music playlists,"class Solution:
    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:
        
        @cache
        def fn(i, x): 
            """"""Return number starting from ith position with x songs already appeared.""""""
            if i == goal: return x == n 
            ans = 0 
            if x < n: ans += (n-x) * fn(i+1, x+1) # a new song
            if k < x: ans += (x-k) * fn(i+1, x) # an old song
            return ans % 1_000_000_007
        
        return fn(0, 0)"
minimum add to make parentheses valid,"class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        count = 0
        
        x = y = 0
        
        for i in s:
            if(i == '('):
                x += 1
            else:
                x -= 1
            
            if(x < 0):
                count += 1
                x = 0
            if(y < 0):
                count += 1
                y = 0
        
        return count + x + y"
minimum add to make parentheses valid,"class Solution:
    def minAddToMakeValid(self, s: str) -> int:
        stack = []
        for c in s:
            if len(stack):
                if stack[-1] == '(' and c == ')':
                    stack.pop()
                else:
                    stack.append(c)
            else:
                stack.append(c)            
        return len(stack)"
sort array by parity ii,"class Solution:
def sortArrayByParityII(self, nums: List[int]) -> List[int]:
    
    odd,even = [],[]
    for n in nums:
        if n%2: odd.append(n)
        else: even.append(n)
    
    o,e = 0,0
    for i in range(len(nums)):
        if i%2==0:
            nums[i]=even[e]
            e+=1
        else:
            nums[i]=odd[o]
            o+=1
    
    return nums"
sort array by parity ii,"class Solution:
def sortArrayByParityII(self, nums: List[int]) -> List[int]:
    
    e = 0                            #even_index
    o = 1                            #odd_index
    
    while e<len(nums) and o<len(nums):
        if nums[e]%2==0:
            e+=2
        else:
            if nums[o]%2!=0:
                o+=2
            else:
                nums[e],nums[o] = nums[o],nums[e]
                e+=2
                o+=2
                            
    return num"
3sum with multiplicity,"class Solution:
    def threeSumMulti(self, arr: List[int], target: int) -> int:
        arr.sort()
		# the rest of the code here"
3sum with multiplicity,"class Solution:
    def threeSumMulti(self, arr: List[int], target: int) -> int:
        arr.sort()
		for i in range(len(arr)-2):
			# do something
			pass
		# the rest of the code here"
minimize malware spread,"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            nodes.add(i)
            for j, conn in enumerate(graph[i]):
                if conn and j not in nodes:
                    dfs(j)
        
        maxRemoval, minNode = -1, float('inf')
        for node in initial:
            nodes = set()
            dfs(node)
            
            if nodes &amp; initial == {node}:
                l = len(nodes)
                if l > maxRemoval or (l == maxRemoval and node < minNode):
                    minNode = node
                    maxRemoval = l
                    
        return minNode if maxRemoval > -1 else min(initial)"
long pressed name,"class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        ni = 0       # index of name
        ti = 0       # index of typed
        while ni <= len(name) and ti < len(typed):
            if ni < len(name) and typed[ti] == name[ni]:
                ti += 1
                ni += 1
            elif typed[ti] == name[ni-1] and ni != 0:
                ti += 1
            else:
                return False
            
        return ni == len(name) and ti == len(typed)"
long pressed name,"class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        n=len(name)
        m=len(typed)
        
        if m<n:
            return False
        i=j=0
        while(True):
            print(i,j)
            if i==n and j==m:
                return True
            
            if i<n and j<m and name[i]==typed[j]:
                i+=1
                j+=1
            elif j>0 and j<m and typed[j-1]==typed[j]:

                j+=1
            else:
                return False
        ```"
flip string to monotone increasing,"class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        """"""
                     0 0 1 1 0
        oneCount:    0 0 1 2 2
        zeroCount:   1 1 0 0 1
        flipCount:   0 0 0 0 1
        
        
                     0 1 0 1 0
        oneCount:    0 1 1 2 2
        zeroCount:   1 0 1 1 2
        flipCount:   0 0 1 1 2
        
                     0 0 0 1 1 0 0 0
        oneCount:    0 0 0 1 2 2 2 2
        zeroCount:   1 1 1 0 0 1 2 3
        flipCount:   0 0 0 0 0 1 2 2
        """"""
        oneCount = 0
        zeroCount = 0
        flipCount = 0
        for c in s:
            if c == ""1"":
                oneCount += 1
            if c == ""0"":
                zeroCount += 1
            flipCount = min(zeroCount,oneCount)
            zeroCount = flipCount
        return flipCount"
flip string to monotone increasing,"class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        zero, one = [0] * n, [0] * n
        prefix = suffix = 0
        for i in range(n):
            if s[i] == '1':
                prefix += 1
            zero[i] = prefix       # flip '1' to '0'
            if s[n-1-i] == '0':
                suffix += 1
            one[n-1-i] = suffix    # flip '0' to '1' (from right to left)
            
        ans = sys.maxsize
        for i in range(n-1):
            ans = min(ans, zero[i] + one[i+1])  # `i` and its left are all '0', and '1's are on its right
        else:    
            ans = min(ans, zero[n-1], one[0])   # zero[n-1] -> all zeros, one[0] -> all ones
        return ans"
three equal parts,"class Solution:
    def threeEqualParts(self, arr: List[int]) -> List[int]:
        # count number of ones
        ones = sum(arr)
        if ones % 3 != 0:
            return [-1, -1]
        elif ones == 0:  # special case: all zeros
            return [0, 2]
        
        # find the start index of each group of ones
        c = 0
        starts = []
        for i, d in enumerate(arr):
            if d == 1:
                if c % (ones // 3) == 0:
                    starts.append(i)
                c += 1

        # scan the groups in parallel to compare digits
        i, j, k = starts
        while k < len(arr):  # note that the last/rightmost group must include all digits till the end
            if arr[i] == arr[j] == arr[k]:
                i += 1
                j += 1
                k += 1
            else:
                return [-1, -1]
        return [i-1, j]"
three equal parts,"class Solution:
    def threeEqualParts(self, arr: List[int]) -> List[int]:
        # gather the indices of the ones
        ones = [i for i, d in enumerate(arr) if d == 1]

        if not ones:
            return [0, 2]
        elif len(ones) % 3 != 0:
            return [-1, -1]

        # get the start indices of the 3 groups
        i, j, k = ones[0], ones[len(ones)//3], ones[len(ones)//3*2]

        # calculate the size/length of what each group should be
        length = len(arr) - k  # note that the last/rightmost group must include all digits till the end
                               # so we know that the size of each group is `len(arr) - k` (where `k` is start of third group)

        # compare the three groups
        if arr[i:i+length] == arr[j:j+length] == arr[k:k+length]:
            return [i+length-1, j+length]
        
        return [-1, -1]"
minimize malware spread ii,"class Solution:
    # the key observation for me is the fact that we don't need to
    # really delete the initial in the graph. We can simply ignore
    # the deleted initial while we are doing BFS. So basically we
    # do BFS with each deleted value on initial, and we get the
    # minimal count of the connected graph. Note if two deleted
    # values give same count of connected graph, then we choose
    # smaller value. that's why I used a tuple, (BFS(a), a) this 
    # will first compare BFS(a), if they are equal then it compares
    # a.
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def BFS(delval):
            seen, lst = set(), list(initial)
            while lst:
                node = lst.pop()
                if node == delval or node in seen: continue
                seen.add(node)
                lst += [i for i, val in enumerate(graph[node]) if val]
            return len(seen)
        return min(initial, key=lambda a: (BFS(a), a))"
minimize malware spread ii,"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            for j, conn in enumerate(graph[i]):
                if conn and j not in initial and j not in nodes:
                    nodes.add(j)
                    dfs(j)
        
        sourceDict = defaultdict(list)
        for node in initial:
            nodes = set()
            dfs(node)
            
            for i in nodes:
                sourceDict[i].append(node)
        
        counter = defaultdict(int)
        maxVal, minNode = -1, float('inf')
        for infected, sources in sourceDict.items():
            if len(sources) == 1:
                src = sources[0]
                counter[src] += 1
                if counter[src] > maxVal or (counter[src] == maxVal and src < minNode):
                    minNode = src
                    maxVal = counter[src]
                    
        return minNode if maxVal > -1 else min(initial)"
unique email addresses,"class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def parse(email):
            local, domain = email.split('@')
            local = local.split('+')[0].replace('.',"""")
            return f""{local}@{domain}""
        
        return len(set(map(parse, emails)))"
unique email addresses,"class Solution:
def numUniqueEmails(self, emails: List[str]) -> int:
    
    res = set()
    for email in emails:
        local,domain = email.split('@')
        tmp = """"
        for c in local:
            if c==""."": continue
            elif c==""+"": break
            else: tmp+=c
        res.add(tmp+""@""+domain)
    
    return len(res)"
binary subarrays with sum,"class Solution:
    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        ans = prefix = 0
        seen = {0: 1}
        for x in A:
            prefix += x
            ans += seen.get(prefix - S, 0)
            seen[prefix] = 1 + seen.get(prefix, 0)
        return ans"
binary subarrays with sum,"class Solution:
    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        ans = ii = rsm = val = 0
        for i, x in enumerate(A): 
            rsm += x
            if x: val = 0
            while ii <= i and rsm >= S: 
                if rsm == S: val += 1
                rsm -= A[ii]
                ii += 1
            ans += val
        return ans"
minimum falling path sum,"class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        
        r=len(matrix)
        c=len(matrix[0])
        
        for i in range(1,r):
            for j in range(c):
                
                if j==0:
                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j+1])
                    
                elif j==c-1:
                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1])
                    
                else:
                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1],matrix[i-1][j+1])
                    
        
        return min(matrix[r-1])"
minimum falling path sum,"class Solution:
    def minFallingPathSum(self, A: List[List[int]]) -> int:
        
        size = len(A)
        
        if size == 1:
            # Quick response for single row
            return A[0][0]
        

        # Update A[y][x] from second row to last row
        for y in range( 1, size):
		
			# sacn each column from 0 to size-1
            for x in range( size ):
                
				# find falling path of minimal cost with optimal substructure
                min_prev = A[y-1][x] 
                
                if x > 0:
                    min_prev = min( min_prev, A[y-1][x-1] )
                
                if x < size-1:
                    min_prev = min( min_prev, A[y-1][x+1] )
                
                # update the cost of falling path, destination is [y][x], with optimal substructure
                A[y][x] = A[y][x] + min_prev
                
        
        # the cost of minimum falling path is the minimum value of last row
        return min( A[size-1] )"
beautiful array,"class Solution:
    def recurse(self, nums):
        if len(nums) <= 2: return nums
        return self.recurse(nums[::2]) + self.recurse(nums[1::2])
    
    def beautifulArray(self, n: int) -> List[int]:
        return self.recurse([i for i in range(1, n+1)])"
beautiful array,"class Solution:
    def beautifulArray(self, n: int) -> List[int]:
        return sorted(range(1, n+1), key=lambda x: bin(x)[:1:-1])"
shortest bridge,"class Solution:
    def shortestBridge(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        i, j = next((i, j) for i in range(m) for j in range(n) if A[i][j])
        
        # dfs 
        stack = [(i, j)]
        seen = set(stack)
        while stack: 
            i, j = stack.pop()
            seen.add((i, j)) # mark as visited 
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 <= ii < m and 0 <= jj < n and A[ii][jj] and (ii, jj) not in seen: 
                    stack.append((ii, jj))
                    seen.add((ii, jj))
        
        # bfs 
        ans = 0
        queue = list(seen)
        while queue:
            newq = []
            for i, j in queue: 
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: 
                        if A[ii][jj] == 1: return ans 
                        newq.append((ii, jj))
                        seen.add((ii, jj))
            queue = newq
            ans += 1"
shortest bridge,"class Solution:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        n = len(grid)
        island = []
        
        def dfs(row,col):
            grid[row][col] = 2
            island.append((row,col,0))
            moves = ((row+1,col),(row-1,col),(row,col+1),(row,col-1))
            for x,y in moves:
                if 0<=x<n and 0<=y<n and grid[x][y] == 1:
                    dfs(x,y)
        
        flag = True
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    dfs(i,j)
                    flag = False
                    break
            if not flag:break
                
        queue = island
        while queue:
            r,c,dis = queue.pop(0)
            if grid[r][c] == 1:return dis
            moves = ((r+1,c),(r-1,c),(r,c-1),(r,c+1))
            for x,y in moves:
                if 0<=x<n and 0<=y<n and grid[x][y]!=2:
                    if grid[x][y] == 1:return dis
                    grid[x][y] = 2
                    queue.append((x,y,dis+1))
        return -1"
knight dialer,"class Solution:
    def knightDialer(self, n: int) -> int:
        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        
        
        for _ in range(n-1):
            dp = [0 for _ in range(10)]
            dp[0] = arr[5] + arr[7]
            dp[1] = arr[6] + arr[8]
            dp[2] = arr[3] + arr[7]
            dp[3] = arr[2] + arr[8] + arr[9]
            dp[4] = 0
            dp[5] = arr[0] + arr[6] + arr[9]
            dp[6] = arr[1] + arr[5]
            dp[7] = arr[0] + arr[2]
            dp[8] = arr[1] + arr[3]
            dp[9] = arr[3] + arr[5]
            arr = dp
        return sum(arr) % (10**9+7)"
knight dialer,"class Solution:
    def knightDialer(self, n: int) -> int:
        dp = [1] * 10
        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],
                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]
        for _ in range(n-1):
            dp_next = [0] * 10
            for digit in range(10):
                for move_digit in moves[digit]:
                    dp_next[digit] += dp[move_digit]
                    
            dp = dp_next
        
        return sum(dp) % (10**9 + 7)"
stamping the sequence,"class Solution:
    def movesToStamp(self, stamp: str, target: str) -> List[int]:
        N,M = len(target),len(stamp)
        move = 0
        maxmove = 10*N
        ans = []
        def check(string):
            for i in range(M):
                if string[i] == stamp[i] or string[i] == '?':
                    continue
                else:
                    return False
            return True
        
        while move < maxmove:
            premove = move
            for i in range(N-M+1):
                if check(target[i:i+M]):
                    move += 1
                    ans.append(i)
                    target = target[:i] + ""?""*M + target[i+M:]
                    if target == ""?""*N : return ans[::-1]
            if premove == move:return []
        return []"
stamping the sequence,"class Solution:
    def movesToStamp(self, s: str, t: str) -> List[int]:
        options = {i*'*' + s[i:j] + (len(s)-j)*'*' for i in range(len(s)) for j in range(i, len(s)+1)} - {'*'*len(s)}
        res = []
        target = list(t)
        
        updates = -1
        while updates:
            i = updates = 0
            t = ''.join(target)
            while i <= len(t) - len(s):
                if t[i:i+len(s)] in options:
                    res.append(i)
                    target[i:i+len(s)] = ['*']*len(s)
                    updates += 1
                i += 1
                
        return res[::-1] if set(target) == {'*'} else []"
reorder data in log files,"class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        l = []
        d = []
        for i in logs:
            if i.split()[1].isdigit():
                d.append(i)
            else:
                l.append(i)
        l.sort(key = lambda x : x.split()[0])
        l.sort(key = lambda x : x.split()[1:])
        return l + d"
reorder data in log files,"class Solution:
    def reorderLogFiles(self, G: List[str]) -> List[str]:
    	A, B, G = [], [], [i.split() for i in G]
    	for g in G:
    		if g[1].isnumeric(): B.append(g)
    		else: A.append(g)
    	return ["" "".join(i) for i in sorted(A, key = lambda x: x[1:]+[x[0]]) + B]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
range sum of bst,"class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:
        res = 0
        
        q = deque([root])
        while q:
            c = q.popleft()
            v, l, r = c.val, c.left, c.right

            if lo <= v and v <= hi:
                res += v
                
            if l and (lo < v or v > hi):
                q.append(l)
                
            if r and (lo > v or v < hi):
                q.append(r)
            
        return res"
range sum of bst,"class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
        if not root: return 0
        res = root.val if low <= root.val <= high else 0
        if root.val <= low: return res + self.rangeSumBST(root.right, low, high)
        if root.val >= high: return res + self.rangeSumBST(root.left, low, high)
        return res + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)"
minimum area rectangle,"class Solution:
    def minAreaRect(self, points: List[List[int]]) -> int:
        x_axis = defaultdict(dict)
        y_axis = defaultdict(dict)
        d = {}
        points.sort()
        
        ans = float('inf')
        
        for point in points:
            x_axis[point[0]][point[1]] = True
            y_axis[point[1]][point[0]] = True
            d[(point[0],point[1])] = True

        for point in points:
            x1 = point[0]
            y1 = point[1]
            for y2 in x_axis[x1]:
                if y2 == y1:continue
                for x2 in y_axis[y2]:
                    if x2 == x1:continue
                    if (x2,y1) in  d:
                        tmp = abs(x2-x1) * abs(y2-y1)
                        if tmp < ans : ans = tmp
        return ans if ans!=float('inf') else 0"
minimum area rectangle,"class Solution:
    def minAreaRect(self, points: List[List[int]]) -> int:
        xy = {}
        for x, y in points:
            if x not in xy:
                xy[x] = set()
            xy[x].add(y)
        
        result = float('inf')
        
        xs = list(xy.keys())
        
        for i in range(len(xs)-1):
            x1 = xs[i]
            if len(xy[x1]) < 2:
                continue
            for j in range(i+1, len(xs)):
                x2 = xs[j]
                if len(xy[x2]) < 2:
                    continue
                
                commonY = list(xy[x1]&amp;xy[x2])
                if len(commonY) < 2:
                    continue
                    
                commonY.sort()
                for l in range(len(commonY)-1):
                    result = min(result, abs(x1-x2) * (commonY[l+1] - commonY[l]))
        
        return result if result != float('inf') else 0"
distinct subsequences ii,"class Solution:
    def distinctSubseqII(self, s: str) -> int:
        n = len(s)
        MOD = 1000000007
        dp = {}
        
        def recursion(string,index):
            ans = 1 if index > 0 else 0
            used = {}
            for idx in range(index,n):
                if s[idx] in used:continue
                used[s[idx]] = True
                ans += recursion(string + s[idx] , idx + 1)
            
            return ans
        
        res = recursion("""",0)%MOD
        return res"
distinct subsequences ii,"class Solution:
    def distinctSubseqII(self, s: str) -> int:
        n = len(s)
        dp = [0]*n
        last = dict()
        ans = 0
        for i in range(n):
            to_add = True
            limit = -1
            if s[i] in last:
                to_add = False
                limit = last[s[i]] - 1
            tmp = 0
            for j in range(i-1,limit,-1):
                tmp += dp[j]
            if to_add:tmp+=1
            last[s[i]] = i
            dp[i] = tmp
            ans += dp[i]
        return ans%1000000007"
valid mountain array,"class Solution:
    def validMountainArray(self, A: List[int]) -> bool:
        if len(A)<3:return False
        l=len(A)
        i,j=0,l-1
        while i<j and A[i]<A[i+1]:
            i+=1
        while j>0 and A[j]<A[j-1]:
            j-=1
        if i==j and j!=l-1 and i!=0:return True
        return False"
valid mountain array,"class Solution:
    def validMountainArray(self, arr: List[int]) -> bool:
        if len(arr)<=2 or max(arr)==arr[0] or max(arr)==arr[len(arr)-1]:
            return False
        f=True
        for i in range(len(arr)-1):
            if f and arr[i]>=arr[i+1]:
                f=False
            if not f and arr[i]<=arr[i+1]:
                return False
        return True"
di string match,"class Solution:
    def diStringMatch(self, s: str) -> List[int]:
        ans = []
        a , b = 0 , len(s)
        
        for i in s:
            if(i == 'I'):
                ans.append(a)
                a += 1
            else:
                ans.append(b)
                b -= 1
        
        if(s[-1] == 'D'):
            ans.append(a)
        else:
            ans.append(b)
                       
        return ans"
di string match,"class Solution:
    def diStringMatch(self, S: str) -> List[int]:
    	return (lambda x: [x.pop() if i == 'D' else x.popleft() for i in S]+[x[0]])(collections.deque(range(len(S)+1)))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
find the shortest superstring,"class Solution:
    def shortestSuperstring(self, words: List[str]) -> str:
        n = len(words)
        graph = [[0]*n for _ in range(n)] # graph as adjacency matrix 
        
        for i in range(n):
            for j in range(n): 
                if i != j: 
                    for k in range(len(words[j])): 
                        if words[i].endswith(words[j][:k]): 
                            graph[i][j] = len(words[j]) - k 
                            
        @cache
        def fn(prev, mask): 
            """"""Return length of shortest superstring &amp; current choice of word.""""""
            if mask == 0: return 0, None
            vv, kk = inf, None
            for k in range(n): 
                if mask &amp; 1<<k: 
                    v, _ = fn(k, mask ^ 1<<k)
                    offset = len(words[k]) if prev == -1 else graph[prev][k]
                    if v + offset < vv: vv, kk = v + offset, k
            return vv, kk
        
        ans = []
        prev = -1 
        mask = (1<<n) - 1
        while mask: 
            _, k = fn(prev, mask)
            if ans: ans.append(words[k][-graph[prev][k]:])
            else: ans.append(words[k])
            prev = k
            mask ^= 1<<k 
        return """".join(ans)"
delete columns to make sorted,"class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        zipped=list(map(list,zip(*A)))
        count=0
        for item in zipped:
            if item!=sorted(item):
                count+=1
        return count"
delete columns to make sorted,"class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        
        res = 0
        for pos in range(len(A[0])):
            for word in range(len(A)-1):
                if A[word][pos] > A[word+1][pos]:
                    res += 1
                    break
        return res"
minimum increment to make array unique,"class Solution:
    def minIncrementForUnique(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        ans = 0
        for i in range(1,n):
            if nums[i] <= nums[i-1]:
                # this is the case for making item unique
                diff = nums[i-1] + 1 - nums[i]
                ans += diff
                nums[i] = nums[i-1] + 1
        return ans"
minimum increment to make array unique,"class Solution:
    def minIncrementForUnique(self, A: List[int]) -> int:
        A.sort()
        count = 0
        for i in range(1, len(A)):
            cur = A[i]
            prev = A[i-1]
            if(prev >= cur ):
                A[i] = prev + 1
                count += prev - cur + 1
        return count"
validate stack sequences,"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stack = []
        for i in pushed:
            stack.append(i)
            while stack and popped and stack[-1] == popped[0]:
                stack.pop()
                popped.pop(0)
        return not stack"
validate stack sequences,"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        s = []
        ipush = 0
        ipop = 0
        
        try:
            while ipush < len(pushed) or ipop < len(popped):
                if len(s) == 0 or (len(s) != 0 and s[-1] != popped[ipop]):
                    s.append(pushed[ipush])
                    ipush += 1
                elif s[-1] == popped[ipop]:
                    s.pop()
                    ipop += 1
        except IndexError:
            return False
        
        return True"
most stones removed with same row or column,"class Solution:
		def removeStones(self, stones: List[List[int]]) -> int:
			
			def remove_point(a,b):                           # Function to remove connected points from the ongoing graph. 
				points.discard((a,b))
				for y in x_dic[a]:
					if (a,y) in points:
						remove_point(a,y)

				for x in y_dic[b]:
					if (x,b) in points:
						remove_point(x,b)

			x_dic = defaultdict(list)
			y_dic = defaultdict(list)
			points= {(i,j) for i,j in stones}
			
			for i,j in stones:                                # Construction of graph by x_coordinates and y_coordinates.
				x_dic[i].append(j)
				y_dic[j].append(i)

			cnt = 0
			for a,b in stones:                                # counting of distinct connected graph.
				if (a,b) in points:
					remove_point(a,b)
					cnt+=1

			return len(stones)-cnt"
most stones removed with same row or column,"class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        n = len(stones)
        visited = [False]*n
        rows = defaultdict(list)
        cols = defaultdict(list)
        ans = 0
        for i,point in enumerate(stones):
            rows[point[0]].append(i)
            cols[point[1]].append(i)
        
        def dfs(node):
            visited[node] = True
            count = 1
            for x in rows[stones[node][0]]:
                if visited[x] == False:
                    count += dfs(x)
            for x in cols[stones[node][1]]:
                if visited[x] == False:
                    count += dfs(x)
            return count
            
        for i in range(n):
            if visited[i] == False:
                size = dfs(i)
                ans += size-1
        return ans"
bag of tokens,"class Solution:
    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        score=0
        tokens.sort()
        i=0
        j=len(tokens)-1
        mx=0
        while i<=j:
            if tokens[i]<=power:
                power-=tokens[i]
                score+=1
                i+=1
                mx=max(mx,score)
            elif score>0:
                score-=1
                power+=tokens[j]
                j-=1
            else:
                break
        return mx"
bag of tokens,"class Solution:
    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        tokens.sort()
        i,j = 0,len(tokens)-1
        points = maxPoints = 0
        while i<=j:
            if power>=tokens[i]:
                power-=tokens[i]
                points+=1
                maxPoints = max(maxPoints,points)
                i+=1
            elif points>0:
                points-=1
                power+=tokens[j]
                j-=1
            else:
                return maxPoints
        return maxPoints"
largest time for given digits,"class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        hh = mm = -1
        for x in set(permutations(A, 4)): 
            h = 10*x[0] + x[1]
            m = 10*x[2] + x[3]
            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m
        return f""{hh:02}:{mm:02}"" if hh >= 0 else """""
largest time for given digits,"class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        
        def permutations(i=0): 
            """"""Return all permutations via generator.""""""
            if i == len(A): yield A
            for ii in range(i, len(A)): 
                A[i], A[ii] = A[ii], A[i]
                yield from permutations(i+1)
                A[i], A[ii] = A[ii], A[i]
        
        hh = mm = -1
        for x in permutations(): 
            h = 10*x[0] + x[1]
            m = 10*x[2] + x[3]
            if h < 24 and m < 60 and 60*hh + mm < 60*h + m: hh, mm = h, m 
        return f""{hh:02}:{mm:02}"" if hh >= 0 else """""
reveal cards in increasing order,"class Solution:
    def deckRevealedIncreasing(self, D: List[int]) -> List[int]:
    	L, Q, _ = len(D)-1, collections.deque(), D.sort()
    	for _ in range(L): Q.appendleft(D.pop()), Q.appendleft(Q.pop())
    	return D + list(Q)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
reveal cards in increasing order,"class Solution:
    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
        def reveal(n):
            lst = list(range(n))
            ans = []
            i = 0
            while lst:
                if not i&amp;1: ans.append(lst.pop(0))
                else: lst.append(lst.pop(0))
                i += 1
            return ans
        ans = reveal(len(deck))
        ans = sorted([v, i] for i, v in enumerate(ans))
        deck.sort()
        return (deck[j] for i,j in ans)"
flip equivalent binary trees,"class Solution:
    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        if not root1 or not root2:
            return not root1 and not root2
        if root1.val != root2.val: return False
        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))"
flip equivalent binary trees,"class Solution:
    def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:
        queue = deque([(root1, root2)])
        while queue:
            node1, node2 = queue.pop()
            if (not node1) and (not node2):
                continue
            elif (not node1) or (not node2) or (node1.val != node2.val):
                return False
            L1, R1, L2, R2 = node1.left, node1.right, node2.left, node2.right
            if (L1 and L2 and L1.val == L2.val) or (R1 and R2 and R1.val == R2.val):
                queue.append((L1, L2))
                queue.append((R1, R2))
            else:
                queue.append((L1, R2))
                queue.append((L2, R1))
        return True"
largest component size by common factor,"class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        m = max(nums)
        uf = UnionFind(m+1)
        for x in nums: 
            for p in range(2, int(sqrt(x))+1): 
                if x%p == 0: 
                    uf.union(x, p)
                    uf.union(x, x//p)
        freq = Counter(uf.find(x) for x in nums)
        return max(freq.values())"
largest component size by common factor,"class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        m = max(nums)
        spf = list(range(m+1))
        for x in range(4, m+1, 2): spf[x] = 2
        for x in range(3, int(sqrt(m+1))+1): 
            if spf[x] == x: 
                for xx in range(x*x, m+1, x): 
                    spf[xx] = x 
        
        uf = UnionFind(len(nums))
        mp = {}
        for i, x in enumerate(nums): 
            while x > 1: 
                if spf[x] in mp: uf.union(i, mp[spf[x]])
                else: mp[spf[x]] = i
                x //= spf[x]
        return max(uf.rank)"
verifying an alien dictionary,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        hm = {ch: i for i, ch in enumerate(order)}

        prev_repr = list(hm[ch] for ch in words[0])
        for i in range(1, len(words)):
            cur_repr = list(hm[ch] for ch in words[i])

            if cur_repr < prev_repr:
                return False

            prev_repr = cur_repr

        return True"
verifying an alien dictionary,"class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        l1 = {c:i for i,c in enumerate(order)}
        l2 = [[l1[i] for i in word] for word in words]
        return l2 == sorted(l2)"
array of doubled pairs,"class Solution:
    def canReorderDoubled(self, arr: List[int]) -> bool:
        count = collections.Counter(arr)
        for n in sorted(arr, key=abs):
            if count[n] == 0:
                continue
            if count[n * 2] == 0:
                return False
            count[n] -= 1
            count[n * 2] -= 1
        
        return True"
array of doubled pairs,"class Solution:
    def canReorderDoubled(self, arr: List[int]) -> bool:
        arr.sort(key=abs)  # Sort the array based on the absolute value
        cnt = Counter(arr)  # Count the number of each element in arr
        while cnt:
            x = next(iter(cnt.keys()))  # Get the next unique element x
			# Handle conditionals (written on multiple lines for clarity)
            if 2*x not in cnt or \  # Condition 1: 2x does not exist in arr
					(x == 0 and cnt[x]&amp;1) or \  # Condition 2: Odd number of 0s in arr
					cnt[2*x] < cnt[x]:  # Condition 3: Insufficient 2x to pair with x in arr
                return False
            cnt[2*x] -= cnt[x]  # Remove the number of 2x elements needed for pairing with x
            _ = cnt.pop(x)  # All x paired; remove x entirely (for iteration purposes)
            if cnt[2*x] == 0 and x != 0:
                _ = cnt.pop(2*x)  # Only remove 2x if there are no more 2x left
        return True"
delete columns to make sorted ii,"class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        m, n = len(A), len(A[0])
        ans, in_order = 0, [False] * (m-1)
        for j in range(n):
            tmp_in_order = in_order[:]
            for i in range(m-1):
				# previous step, rows are not in order; and current step rows are not in order, remove this column
                if not in_order[i] and A[i][j] > A[i+1][j]: ans += 1; break  
				# previous step, rows are not in order, but they are in order now
                elif A[i][j] < A[i+1][j] and not in_order[i]: tmp_in_order[i] = True
			# if column wasn't removed, update the row order information
            else: in_order = tmp_in_order  
            # not necessary, but speed things up
            if all(in_order): return ans   
        return ans"
delete columns to make sorted ii,"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs)
        col_size = len(strs[0])
        # a b c d e f g h i j k l m n o p q r s t u v w x y z
        
        i = 0
        ans = 0
        
        def getRemoved(idx):
             # removing the idx column 
            for x in range(n):           
                strs[x] = strs[x][:idx] + strs[x][idx+1:]
        
        while i < col_size:
            tmp = strs[0][:i+1]
            flag = True
            similar = False
            
            for j in range(1,n):                 
                if  strs[j][:i+1] < tmp :
                    # previous element is larger ( unsorted )
                    flag = False
                    break
                
                elif strs[j][:i+1] > tmp : 
                    # previous element is smaller ( sorted )
                    tmp = strs[j][:i+1]
                
                else:
                    # previous element is equal ( not clear )
                    tmp = strs[j][:i+1]
                    similar = True
            
            if flag == True and similar == False:
                # all are sorted and we are ready to return ans
                return ans
            
            elif flag == True and similar == True:
                # all are sorted but can't be decided for further columns. check for next col
                i += 1
            
            elif flag == False:
                # unsorted column = removal
                getRemoved(i)
                # increment the answer and since we removed i th col decrement col_size
                ans += 1
                col_size -= 1
        
        return ans"
tallest billboard,"class Solution:
    def tallestBillboard(self, rods: List[int]) -> int:
        dp = {0: 0}
        for x in rods: 
            for k, v in dp.copy().items(): 
                dp[k+x] = max(dp.get(k+x, 0), v)
                if k >= x: dp[k-x] = max(dp.get(k-x, 0), v+x)
                else: dp[x-k] = max(dp.get(x-k, 0), v+k)
        return dp[0]"
tallest billboard,"class Solution:
    def tallestBillboard(self, rods: List[int]) -> int:
        
        def fn(arr): 
            """"""Possible a mapping from diff to length""""""
            mp = defaultdict(int)
            for t in range(1, len(arr)+1): 
                for total in combinations(arr, t): 
                    tt = sum(total)
                    for p in range(0, t+1): 
                        for part in combinations(total, p): 
                            pp = sum(part)
                            mp[pp*2 - tt] = max(mp[pp*2 - tt], pp)
            return mp 
        
        left = rods[:len(rods)//2]
        right = rods[len(rods)//2:]
        
        mp = fn(left)
        keys = sorted(mp.keys())
        
        ans = 0 
        for diff, v in fn(right).items(): 
            k = bisect_left(keys, -diff)
            if k < len(keys) and keys[k] == -diff: 
                ans = max(ans, mp[-diff] + v)
        return ans"
prison cells after n days,"class Solution:
    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:
        def nextday(cells):
            next_day_cells = [0] *len(cells)
            for i in range(1,len(cells)-1):
                if cells[i-1] == cells[i+1]: 
                        next_day_cells[i] = 1
                else:
                        next_day_cells[i] = 0
            return next_day_cells
        
        seen = {}
        while N > 0:
            c = tuple(cells)
            if c in seen:
                N %= seen[c] - N
            seen[c] = N

            if N >= 1:
                N -= 1
                cells = nextday(cells)

        return cells"
prison cells after n days,"class Solution(object):
    def prisonAfterNDays(self, cells, N):
        """"""
        :type cells: List[int]
        :type N: int
        :rtype: List[int]
        """"""
        def next(state):
            return tuple([1 if i>0 and i<len(state)-1 and state[i-1] == state[i+1] else 0 for i in range(len(state))])
        
        seen = {}
        state = tuple(cells)
        i = 0
        remaining = 0
        while i < N:
            if state in seen:
                cycle = i - seen[state]
                remaining = (N-i)%cycle
                break
            seen[state] = i
            state = next(state)
            i+=1
        
        while remaining > 0:
            state = next(state)
            remaining-=1
        return state"
check completeness of a binary tree,"class Solution:
    def isCompleteTree(self, root: TreeNode) -> bool:
                        # The criteria for an n-level complete tree:
                        #
                        #    The first n-1 rows have no null nodes.
                        #
                        #    The nth row has no non-null nodes to the right of the left-most null
                        #     node encountered (if it exists).
                        #
                        # The plan is to bfs the tree, left to right, level by level. We mark the
                        # instance of the first null popped from the queue and then ensure the remaining
                        # queue is only null nodes. If so, both criteria are satisfied and True is
                        # returned. If not, False is returned.

        queue = deque([root])                       #   <-- initialize the queue

        while queue[0]:                             #   <-- if and while top queue node is not null, pop   
            node = queue.popleft()                  #       it and then push its left child and right  
            queue.extend([node.left, node.right])   #       child onto the queue.

        while queue and not queue[0]:               #   <-- if and while top queue node is null, pop it. 
            queue.popleft()                         #        

        if queue: return False                      #   <-- If the queue is not empty, it must be non-null, so 
        return True                                 #       return False; if the queue is empty, return True."
check completeness of a binary tree,"class Solution:
    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:
        
        res=[]
        from collections import deque
        q=deque()
        q.append((root,1))
        
        while q:
            node,ind=q.popleft()
            res.append(ind)
            if node.left:
                q.append((node.left,2*ind))
            if node.right:
                q.append((node.right,2*ind+1))
        
        for i in range(len(res)-1):
            if res[i+1]-res[i]!=1:
                return False
        
        return True"
regions cut by slashes,"class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
        def dfs(i: int, j: int) -> int:
            if min(i, j) < 0 or max(i, j) >= len(g) or g[i][j] != 0:
                return 0
            g[i][j] = 1
            return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)
        n, regions  = len(grid), 0
        g = [[0] * n * 3 for i in range(n * 3)]
        for i in range(n):
            for j in range(n):
                if grid[i][j] == '/':
                    g[i * 3][j * 3 + 2] = g[i * 3 + 1][j * 3 + 1] = g[i * 3 + 2][j * 3] = 1
                elif grid[i][j] == '\\':
                    g[i * 3][j * 3] = g[i * 3 + 1][j * 3 + 1] = g[i * 3 + 2][j * 3 + 2] = 1
        for i in range(n * 3):
            for j in range(n * 3):
                regions += 1 if dfs(i, j) > 0 else 0
        return regions"
regions cut by slashes,"class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
        
        def check(x,y,t):
            if x>=0 and y>=0 and x<row and y<col and (x,y,t) not in visited:
                return True
            return False
        
        row,col=len(grid),len(grid[0])
        visited=set()
        
        def dfs(r,c,t):
            if check(r,c,t):
                visited.add((r,c,t))
                if t==1:
                    dfs(r,c+1,3)# going right
                elif t==2:
                    dfs(r+1,c,0)# going down
                elif t==3:
                    dfs(r,c-1,1) # going back
                elif t==0: 
                    dfs(r-1,c,2)# going up
                if grid[r][c]!=""/"":
                    dfs(r,c,t^1) #trick to traverse 0 to 1 or 3 to 2 and viceversa
                if grid[r][c]!=""\\"":
                    dfs(r,c,t^3)#trick to traverse 3 to 0 or 1 to 2 and viceversa
        
        cntofregion=0
        for i in range(row):
            for j in range(col):
                for typ in range(4):
                    if (i,j,typ) not in visited:
                        dfs(i,j,typ)
                        cntofregion+=1
        return cntofregion"
delete columns to make sorted iii,"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions
        
        @cache 
        def fn(k, prev):
            """"""Return min deleted columns to make sorted.""""""
            if k == n: return 0 
            ans = 1 + fn(k+1, prev) # delete kth column
            if prev == -1 or all(strs[i][prev] <= strs[i][k] for i in range(m)): 
                ans = min(ans, fn(k+1, k)) # retain kth column
            return ans 
        
        return fn(0, -1)"
n repeated element in size 2n array,"class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        
        list1 = []
        for i in nums :
            if i in list1 :
                return i
            else :
                list1.append(i)"
n repeated element in size 2n array,"class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        
        set1 = set()
        for i in nums :
            if i in set1 :
                return i
            else :
                set1.add(i)"
maximum width ramp,"class Solution:
    def maxWidthRamp(self, A: List[int]) -> int:
        ans = 0
        stack = []
        for i in range(len(A)): 
            if not stack or A[stack[-1]] > A[i]: stack.append(i)
            else: 
                lo, hi = 0, len(stack)
                while lo < hi: 
                    mid = lo + hi >> 1
                    if A[stack[mid]] <= A[i]: hi = mid
                    else: lo = mid + 1
                ans = max(ans, i - stack[lo])
        return ans"
maximum width ramp,"class Solution:
    def maxWidthRamp(self, A: List[int]) -> int:
        ans = 0
        stack = []
        for i in range(len(A)): 
            if not stack or A[stack[-1]] > A[i]: stack.append(i)
        
        for i in reversed(range(len(A))): 
            while stack and A[stack[-1]] <= A[i]: 
                ans = max(ans, i - stack.pop())
        return ans"
minimum area rectangle ii,"class Solution:
    def minAreaFreeRect(self, points: List[List[int]]) -> float:
        ans = inf
        seen = {}
        for i, (x0, y0) in enumerate(points):
            for x1, y1 in points[i+1:]:
                cx = (x0 + x1)/2
                cy = (y0 + y1)/2
                d2 = (x0 - x1)**2 + (y0 - y1)**2
                for xx, yy in seen.get((cx, cy, d2), []): 
                    area = sqrt(((x0-xx)**2 + (y0-yy)**2) * ((x1-xx)**2 + (y1-yy)**2))
                    ans = min(ans, area)
                seen.setdefault((cx, cy, d2), []).append((x0, y0))
        return ans if ans < inf else 0"
minimum area rectangle ii,"class Solution:
    def minAreaFreeRect(self, points: List[List[int]]) -> float:
        N = len(points)
        
        seen = set()
        for point in points:
            seen.add(tuple(point))

        # length^2
        def length2(a, b):
            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])
        
        best = 1e30
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                
                lij = length2(points[i], points[j])
                for k in range(N):
                    if i == k or j == k:
                        continue
                    
                    # given i->j line, add to k to find l
                    dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]
                    
                    pl = (points[k][0] + dx, points[k][1] + dy)
                    if pl not in seen:
                        continue
                    
                    lik = length2(points[i], points[k])
                    ljk = length2(points[j], points[k])

                    lil = length2(points[i], pl)
                    ljl = length2(points[j], pl)
                    lkl = length2(points[k], pl)
                    
                    if lij == lkl and lik == ljl and lil == ljk:
                        best = min(best, sqrt(lij * lik * lil) / sqrt(max(lij, lik, lil)))
                    
        if best >= 1e29:
            return 0
        return best"
least operators to express number,"class Solution:
    def leastOpsExpressTarget(self, x: int, target: int) -> int:
        
        @cache
        def fn(val): 
            """"""Return min ops to express val.""""""
            if val < x: return min(2*val-1, 2*(x-val))
            k = int(log(val)//log(x))
            ans = k + fn(val - x**k)
            if x**(k+1) < 2*val: 
                ans = min(ans, k + 1 + fn(x**(k+1) - val))
            return ans 
        
        return fn(target)"
least operators to express number,"class Solution:
    def solve(self,x,target):
        if target in self.dp : return self.dp[target]
        
        # when target == 1 we can solve just by doing x/x  
        if target == 1: return 1
        
         # current value = x and operations performed  = 0
        cur = x
        op = 0
       
        # if cur < target : the best decision is to multiply
        while cur < target:    
            cur *= x
            op += 1
        
        # if cur == target : we reached using minimum possible operations 
        if cur == target :
            return op
        
        if op == 0:
            # cur is already larger than target
            # x/x + make(target-1) : make 2 operations + solve(target-1)
            ans = 2 + self.solve(x,target - 1)
        else:
            # we try to reach nearest val via multiply less than target
            # and find ans for remaining i.e. target - cur/x 
            # here op becomes op - 1 so op - 1 + 1 becomes op
            ans = op + self.solve(x,target-(cur//x))
            
        if cur - target < target :
            # diff between cur and target is less than target
            # i.e. we can make cur and remove cur - target
            tmp = op + 1 + self.solve(x,cur - target)
            if tmp < ans : ans = tmp
        
        # finally use dp for memoization
        self.dp[target] = ans
        return ans"
univalued binary tree,"class Solution:
    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
        val = root.val
        
        def helper(root):
            return root is None or (root.val == val and helper(root.left) and helper(root.right))
        
        return helper(root)"
univalued binary tree,"class Solution:
    def isUnivalTree(self, R: TreeNode) -> bool:
        def IUT(n):
            if n == None: return True
            if n.val != R.val: return False
            return IUT(n.left) and IUT(n.right)
        return IUT(R)
		
		
- Junaid Mansuri
- Chicago, IL"
vowel spellchecker,"class Solution:
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        
        # Convert words and vowels to sets for O(1) lookup times
        words = set(wordlist)
        vowels = set('aeiouAEIOU')
        
        # Create two maps.  
        # One for case insensitive word to all words that match ""key"" -> [""Key"", ""kEy"", ""KEY""]
        # The other for vowel insensitive words ""k*t*"" -> [""Kite"", ""kato"", ""KUTA""]
        case_insensitive = collections.defaultdict(list)            
        vowel_insensitive = collections.defaultdict(list)
        for word in wordlist:
            case_insensitive[word.lower()].append(word)
            key = ''.join(char.lower() if char not in vowels else '*' for char in word)
            vowel_insensitive[key].append(word)

        res = []
        for word in queries:

            # Case 1: When query exactly matches a word
            if word in words:
                res.append(word)
                continue

            # Case 2: When query matches a word up to capitalization
            low = word.lower()
            if low in case_insensitive:
                res.append(case_insensitive[low][0])
                continue

            # Case 3: When query matches a word up to vowel errors
            key = ''.join(char.lower() if char not in vowels else '*' for char in word)
            if key in vowel_insensitive:
                res.append(vowel_insensitive[key][0])
                continue

            res.append('')

        return res"
vowel spellchecker,"class Solution:
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        orig = set(wordlist) # original words O(1) lookup 
        case = {} # diff in case
        vowel = {} # diff in vowel
        
        for word in wordlist: 
            key = word.lower()
            case.setdefault(key, []).append(word)
            for c in ""aeiou"": key = key.replace(c, ""*"")
            vowel.setdefault(key, []).append(word)
        
        ans = []
        for word in queries: 
            if word in orig: ans.append(word)
            else: 
                key = word.lower()
                if key in case: ans.append(case[key][0])
                else: 
                    for c in ""aeiou"": key = key.replace(c, ""*"")
                    if key in vowel: ans.append(vowel[key][0])
                    else: ans.append("""")
        return ans"
numbers with same consecutive differences,"class Solution:
	def numsSameConsecDiff(self, n: int, k: int) -> List[int]:
		graph = defaultdict(list)
		for i in range(0, 10):
			if i-k >= 0:
				graph[i].append(i-k)
			if i +k < 10:
				graph[i].append(i+k)
		start = [i for i in graph if i!= 0]
		for j in range(n-1):
			new = set()
			for i in start:
				last = i%10
				for k in graph[last]:
					new.add(i*10 + k)
			start = new
		return list(start)"
numbers with same consecutive differences,"class Solution:
		def numsSameConsecDiff(self, n: int, k: int) -> List[int]:
			numset = [1, 2, 3, 4, 5, 6, 7, 8, 9]

			for i in range(n - 1):
				res = []
				for num in numset:
					cur = num % 10

					if cur + k <= 9: res.append(num * 10 + cur + k)
					if k != 0 and cur - k >= 0: res.append(num * 10 + cur - k)

				numset = res

			return res"
binary tree cameras,"class Solution:
    def minCameraCover(self, root: TreeNode) -> int:
        # set the value of camera nodes to 1
        # set the value of monitored parent nodes to 2
        def dfs(node: Optional[TreeNode]) -> int:
            if not node:
                return 0
            res = dfs(node.left)+dfs(node.right)
            # find out if current node is a root node / next node in line to be monitored
            curr = min(node.left.val if node.left else float('inf'), node.right.val if node.right else float('inf'))
            if curr == 0:
                # at least one child node requires monitoring, this node must have a camera
                node.val = 1
                res += 1
            elif curr == 1:
                # at least one child node is a camera, this node is already monitored
                node.val = 2
            # if curr == float('inf'), the current node is a leaf node; let the parent node monitor this node
            # if curr == 2, all child nodes are being monitored; treat the current node as a leaf node
            return res
        # ensure that root node is monitored, otherwise, add a camera onto root node
        return dfs(root)+(root.val == 0)"
binary tree cameras,"class Solution:
    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        def postorder(node):
            if not node:
                return (0, math.inf)
            
            l_count, l_state = postorder(node.left)
            r_count, r_state = postorder(node.right)
            
            state = min(l_state, r_state)
            total_cameras = l_count + r_count
            
            if state==0: # children are not monitored
                return (total_cameras + 1, 1) # install camera in current node
            
            if state==1: # one of the children is monitored and has camera
                return (total_cameras, 2) # set current node state as monitored but no camera
            
            return (total_cameras, 0) # set current node as unmonitored
        
        # adding dummy parent for the root for handling cases where root need a camera
        dummy=TreeNode(-1, root) 
        
        return postorder(dummy)[0]"
pancake sorting,"class Solution:
    def pancakeSort(self, arr: List[int]) -> List[int]:

        if arr == sorted(arr):
            return []
        
        flips = []
        end = len(arr) - 1
        
        # find the max flip all the numbers from the first position to the max position 
        # ==> from 0 to max_position = k
        # ==> if max not at the end : flip again until the max is at the end of the array 
        # ==> from 0 to max_position = k
        # end = end - 1
        # repeat previous steps

        while end > 0:
            
            max_num = max(arr[:end+1])
            index_num = arr.index(max_num)
            
            if index_num != end:
                k = index_num + 1
                arr = arr[0:k][::-1] + arr[k:]
                flips.append(k)
                arr = arr[:end+1][::-1] + arr[end+1:]
                flips.append(end+1)
            else:
                k = end
                arr = arr[0:k][::-1] + arr[k:]
                flips.append(k)
            
            end -= 1

        return flips"
pancake sorting,"class Solution:
    def pancakeSort(self, arr: List[int]) -> List[int]:
        #helper function to flip the numbers in the array
		def flip(i, j):
            while i < j:
                arr[i], arr[j] = arr[j], arr[i]
                j -= 1
                i += 1
        
        #sort from 0 to i
        def sort(i):
			#base case where all the numbers are sorted, thus no more recursive calls
            if i < 0:
                return []
            ret = []
			#find the biggest number, which always will be the len(arr), or i + 1
            idx = arr.index(i + 1)
			# if the biggest number is in the right place, as in idx == i, then we don't change anything, but just move to sort the next biggest number
            if idx == i:
                return sort(i - 1)
            
			#we flip it with the first element (even if the biggest number is the first element, it will flip itself (k = 1) and does not affect the result
            ret.append(idx + 1)
            flip(0, idx)
			#we know the biggest number is the first element of the array. Flip the whole array in the boundary so that the biggest number would be in the last of the subarray (notice not len(arr) - 1 because that will flip the already-sorted elements as well)
            ret.append(i + 1)
            flip(0, i)
			#sort the next biggest number by setting a new boundary i - 1
            return ret + sort(i - 1)
            
            
        return sort(len(arr) - 1)"
powerful integers,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        bx = int(log(bound)/log(x)) if x > 1 else 0
        by = int(log(bound)/log(y)) if y > 1 else 0 
        
        ans = set()
        for i in range(bx+1): 
            for j in range(by+1):
                if x**i + y**j <= bound: 
                    ans.add(x**i + y**j)
        return ans"
powerful integers,"class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if x == 1 and y == 1:
            if bound >= 2:
                return [2]
            else:
                return []
        ans = []

        if x == 1 or y == 1:
            num = max(x, y)
            exponent = 0
            while num**exponent < bound:
                ans.append(num**exponent+1)
                exponent += 1

            if num**exponent == bound:
                ans.append(num**exponent)
            return set(ans)
        
        i, j = 0, 0
        while True:
            ans.append(x**i+y**j)
            j += 1
            if x**i+y**j > bound:
                j = 0
                i += 1
                if x**i+y**j > bound:
                    return set(ans)"
flip binary tree to match preorder traversal,"class Solution:
    def __init__(self):
        self.flipped_nodes = []
        self.index = 0
        
    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
        queue = deque([root])
        while queue:
            node = queue.pop()
            if not node: continue
            if node.val != voyage[self.index]: return [-1]
            self.index += 1
            if node.left and node.left.val != voyage[self.index]:
                self.flipped_nodes.append(node.val)
                node.left, node.right = node.right, node.left
            queue.append(node.right), queue.append(node.left)
        return self.flipped_nodes"
flip binary tree to match preorder traversal,"class Solution:
    def __init__(self):
        self.flipped_nodes = []
        self.index = 0
        self.flag = False
        
    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
        def preorder(node = root):
            if not node: return
            if node.val != voyage[self.index]:
                self.flag = True
                return
            self.index += 1
            if node.left and node.left.val != voyage[self.index]:
                self.flipped_nodes.append(node.val)
                node.left, node.right = node.right, node.left
            preorder(node.left), preorder(node.right)

        preorder()
        return self.flipped_nodes if not self.flag else [-1]"
equal rational numbers,"class Solution:
    def isRationalEqual(self, S: str, T: str) -> bool:
        L, A = [len(S), len(T)], [S,T]
        for i,p in enumerate([S,T]):
            if '(' in p:
                I = p.index('(')
                A[i] = p[0:I] + 7*p[I+1:L[i]-1]
        return abs(float(A[0])-float(A[1])) < 1E-7
		
		
- Junaid Mansuri"
equal rational numbers,"class Solution:
    def isRationalEqual(self, s: str, t: str) -> bool:
        repeat = 1000
        
        res =  []
                
        for word in (s, t):
            stack = []
            for char in word:
                if char == "")"":
                    nums = """"
                    char = """"
                    
                    while char != ""("" and stack:
                        nums += char
                        char = stack.pop(-1)
        
                    stack.append( nums[::-1] * repeat )
                else:
                    stack.append(char)
            
            res.append(("""".join(stack))[:100])
            
        return float(res[0]) == float(res[1])
                    

        ```"
k closest points to origin,"class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[0:k]"
k closest points to origin,"class Solution:
    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
        return sorted(points, key=lambda p: p[0]*p[0] + p[1]*p[1])[:K]"
subarray sums divisible by k,"class Solution:
    def subarraysDivByK(self, A: List[int], k: int) -> int:
        dic = collections.defaultdict(int)
        dic[0] = 1
        ans = 0
        presum = 0
        for num in A:
            presum += num
            ans += dic[presum%k]
            dic[presum%k] += 1
        return ans
	```"
subarray sums divisible by k,"class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        d = defaultdict(lambda:0)
        d[0] = 1
        n = len(nums)
        summ = 0
        ans = 0
        for i in range(n):
            summ += nums[i]
            ans += d[summ%k]
            d[summ%k] += 1
        return ans"
odd even jump,"class Solution:
    def oddEvenJumps(self, A: List[int]) -> int:
        
		# find next index of current index that is the least larger/smaller
        def getNextIndex(sortedIdx):
            stack = []
            result = [None] * len(sortedIdx)
        
            for i in sortedIdx:
                while stack and i > stack[-1]:
                    result[stack.pop()] = i
                stack.append(i)
            return result
        
        sortedIdx = sorted(range(len(A)), key= lambda x: A[x])
        oddIndexes = getNextIndex(sortedIdx)
        sortedIdx.sort(key=lambda x: -A[x])
        evenIndexes = getNextIndex(sortedIdx)
        
		# [odd, even], the 0th jump is even
        dp = [[0,1] for _ in range(len(A))]
        
        for i in range(len(A)):
            if oddIndexes[i] is not None:
                dp[oddIndexes[i]][0] += dp[i][1]
            if evenIndexes[i] is not None:
                dp[evenIndexes[i]][1] += dp[i][0]
				
        return dp[-1][0] + dp[-1][1]"
odd even jump,"class Solution:
    def oddEvenJumps(self, arr: List[int]) -> int:
        large = [-1] * len(arr)
        small = [-1] * len(arr)
        
        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (x[1], x[0])): 
            while stack and stack[-1] < i: large[stack.pop()] = i 
            stack.append(i)
        
        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (-x[1], x[0])): 
            while stack and stack[-1] < i: small[stack.pop()] = i
            stack.append(i)
        
        odd = [0] * len(arr)
        even = [0] * len(arr)
        odd[-1] = even[-1] = 1
        for i in reversed(range(len(arr))): 
            if 0 <= large[i]: odd[i] = even[large[i]]
            if 0 <= small[i]: even[i] = odd[small[i]]
        return sum(odd)"
largest perimeter triangle,"class Solution:
    def largestPerimeter(self, A: List[int]) -> int:
        A.sort(reverse = True)
        for i in range(3,len(A)+1):
            if(A[i-3] < A[i-2] + A[i-1]):
                return sum(A[i-3:i])
        return 0"
largest perimeter triangle,"class Solution:
    def largestPerimeter(self, A: List[int]) -> int:
        
		# sort side length in descending order
        A.sort( reverse = True )
        
		# Try and test from largest side length
        for i in range( len(A) - 2):
            
            if A[i] < A[i+1] + A[i+2]:
                # Early return when we find largest perimeter triangle
                return A[i] + A[i+1] + A[i+2]
        
        # Reject: impossible to make triangle
        return 0"
squares of a sorted array,"class Solution:
    def sortedSquares(self, A: List[int]) -> List[int]:
        return_array = [0] * len(A)
        write_pointer = len(A) - 1
        left_read_pointer = 0
        right_read_pointer = len(A) - 1
        left_square = A[left_read_pointer] ** 2
        right_square = A[right_read_pointer] ** 2
        while write_pointer >= 0:
            if left_square > right_square:
                return_array[write_pointer] = left_square
                left_read_pointer += 1
                left_square = A[left_read_pointer] ** 2
            else:
                return_array[write_pointer] = right_square
                right_read_pointer -= 1
                right_square = A[right_read_pointer] ** 2
            write_pointer -= 1
        return return_array"
squares of a sorted array,"class Solution:
    
    def generate_sorted_squares(self, nums):
        
        # Start by doing our binary search to find where
        # to place the pointers.
        left = 0
        right = len(nums)
        while right - left > 1:
            mid = left + (right - left) // 2
            if nums[mid] > 0:
                right = mid
            else:
                left = mid
        
        # And now the main generator loop. The condition is the negation
        # of the StopIteration condition for the iterator approach.
        while left >= 0 or right < len(nums):
            if left < 0:
                right += 1
                yield nums[right - 1] ** 2
            elif right >= len(nums):
                left -= 1
                yield nums[left + 1] ** 2
            else:
                left_square = nums[left] ** 2
                right_square = nums[right] ** 2
                if left_square < right_square:
                    left -= 1
                    yield left_square
                else:
                    right += 1
                    yield right_square
        
    
    def sortedSquares(self, A: List[int]) -> List[int]:
        return list(self.generate_sorted_squares(A))"
longest turbulent subarray,"class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        cur, mx, t = 1, 1, None
        for i in range(1, len(arr)):
            # Start of subarray
            if t == None:
                if arr[i] != arr[i-1]: 
                    cur = 2
                    t = arr[i] > arr[i-1]
            # Valid element in subarray, continue cur subarray
            elif (t and arr[i] < arr[i-1]) or (not t and arr[i] > arr[i-1]):
                cur += 1; t = not t
            # Invalid element in subarray, start new subarray
            else:
                if arr[i] == arr[i-1]: t = None
                mx = max(mx, cur)
                cur = 2
        
        return max(mx, cur)"
longest turbulent subarray,"class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        def cmp(odd, prev, curr):
			return curr < prev if odd else curr > prev
        
        n = len(arr)
        ans = 1
        for flip in [False, True]:
            l = 0
            for r in range(1, n):
                odd = r &amp; 1
                prev = arr[r-1]
                curr = arr[r]
                if flip: odd = not odd
                if not cmp(odd, prev, curr): l = r
                ans = max(ans, r-l+1)
        
        return ans"
distribute coins in binary tree,"class Solution:
    def distributeCoins(self, v: Optional[TreeNode], parent=None) -> int:
        if v is None:
            return 0
        m = self.distributeCoins(v.left, v) + self.distributeCoins(v.right, v)
        if v.val != 1:
            parent.val += v.val - 1
            m += abs(v.val - 1)
        return m"
distribute coins in binary tree,"class Solution:
    def distributeCoins(self, root: TreeNode) -> int:
        count = 0

        def traverse(node: TreeNode) -> int:
            nonlocal count
            if not node:
                return 0
            move = node.val + traverse(node.left) + traverse(node.right) - 1
            count += abs(move)
            return move

        traverse(root)
        return count"
unique paths iii,"class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
		# first, prepare the starting and ending points
		# simultaneously, record all the non-obstacle coordinates
        start = end = None
        visit = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    visit.add((i, j))
                elif grid[i][j] == 1:
                    start = (i, j)
                elif grid[i][j] == 2:
                    end = (i, j)
                    visit.add((i, j))
        
        def backtrack(x, y, visit):
            if (x, y) == end:
				# implement success condition: valid only if there are no more coordinates to visit
                return len(visit) == 0
            result = 0  # assume no valid paths by default
			
			# we need to try every possible path from this coordinate
            if (x-1, y) in visit:
				# the coordinate directly above this one is non-obstacle, try that path
                visit.remove((x-1, y))  # first, note down the 'visited status' of the coordinate
                result += backtrack(x-1, y, visit)  # then, DFS to find all valid paths from that coordinate
                visit.add((x-1, y))  # last, reset the 'visited status' of the coordinate
            if (x+1, y) in visit:
				# the coordinate directly below this one is non-obstacle, try that path
                visit.remove((x+1, y))
                result += backtrack(x+1, y, visit)
                visit.add((x+1, y))
            if (x, y-1) in visit:
				# the coordinate directly to the left of this one is non-obstacle, try that path
                visit.remove((x, y-1))
                result += backtrack(x, y-1, visit)
                visit.add((x, y-1))
            if (x, y+1) in visit:
				# the coordinate directly to the right of this one is non-obstacle, try that path
                visit.remove((x, y+1))
                result += backtrack(x, y+1, visit)
                visit.add((x, y+1))
            return result
        
        return backtrack(start[0], start[1], visit)  # we start from the starting point, backtrack all the way back, and consolidate the result"
unique paths iii,"class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        
        # iterate through the grid to get relevant info
        start = None  # to store starting point
        count = 0  # to count number of squares to walk over
        for i in range(m):
            for j in range(n):
                count += grid[i][j] == 0
                if not start and grid[i][j] == 1:
                    start = (i, j)
        
        def backtrack(i: int, j: int) -> int:
            """"""
            Backtracking algo to find all valid paths from (i, j).
            :param i: Index of row (where top = 0) of coordinate.
            :param j: Index of column (where left = 0) of coordinate.
            :returns: Total number of valid paths from (i, j).
            """"""
            nonlocal count
            result = 0
            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):
                # border check
                if 0 <= x < m and 0 <= y < n:
                    if grid[x][y] == 0:
                        # traverse down this path
                        grid[x][y] = -1
                        count -= 1
                        result += backtrack(x, y)
                        # backtrack and reset
                        grid[x][y] = 0
                        count += 1
                    elif grid[x][y] == 2:
                        # check if all squares have been walked over
                        result += count == 0
            return result
        
        # perform DFS + backtracking to find valid paths
        return backtrack(start[0], start[1])"
triples with bitwise and equal to zero,"class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for x in nums: 
            for y in nums: 
                freq[x&amp;y] += 1
        
        ans = 0
        for x in nums: 
            mask = x = x ^ 0xffff
            while x: 
                ans += freq[x]
                x = mask &amp; (x-1)
            ans += freq[0]
        return ans"
triples with bitwise and equal to zero,"class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for x in nums: 
            for y in nums: 
                freq[x&amp;y] += 1
        
        ans = 0
        for x in nums: 
            mask = x = x ^ 0xffff
            while x: 
                ans += freq[x]
                x = mask &amp; (x-1)
            ans += freq[0]
        return ans"
minimum cost for tickets,"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
		#create the total costs for the days 
        costForDays = [0 for _ in range(days[-1] + 1) ]
		#since days are sorted in ascending order, we only need the index of the days we haven't visited yet
        curIdx = 0
		
        for d in range(1, len(costForDays)):
			#if we do not need to travel that day
			#we don't need to add extra costs
            if d < days[curIdx]:
                costForDays[d] = costForDays[d - 1]
                continue
            
			#else this means we need to travel this day
			#find the cost if we were to buy a 1-day pass, 7-day pass and 30-day pass
            costs_extra_1 = costForDays[d - 1] + costs[0]
            costs_extra_7 = costForDays[max(0, d - 7)] + costs[1] 
            costs_extra_30 = costForDays[max(0, d - 30)] + costs[2]
            
			#get the minimum value
            costForDays[d] = min(costs_extra_1, costs_extra_7, costs_extra_30)
			
			#update the index to the next day we need to travel
            curIdx += 1
			
        return costForDays[-1]"
minimum cost for tickets,"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        dp = [0] * (days[-1]+1)
        date = 0 
        for idx in range(1,len(dp)):
            if idx == days[date]:
                one_day = dp[idx-1] + costs[0]
                seven_day = dp[idx-7] + costs[1] if idx - 7 >= 0 else costs[1]
                thirty_day = dp[idx-30] + costs[2] if idx - 30 >= 0 else costs[2]
                dp[idx] = min(one_day,seven_day,thirty_day)
                date += 1
            else:
                dp[idx] = dp[idx-1]
        return dp[-1]"
string without aaa or bbb,"class Solution:
    def strWithout3a3b(self, a: int, b: int) -> str:
        res = []
        while a + b > 0:
            if len(res) >= 2 and res[-2:] == ['a', 'a']:
                res.append('b')
                b-=1
            elif len(res) >= 2 and res[-2:] == ['b', 'b']:
                res.append('a')
                a-=1
            elif a > b:
                res.append('a')
                a-=1
            else:
                res.append('b')
                b-=1
            
        return ''.join(res)"
string without aaa or bbb,"class Solution:
    def strWithout3a3b(self, a: int, b: int) -> str:
        ans = []
        while a and b: 
            if ans[-2:] == [""b""]*2 or 2*b < a: 
                ans.append(""a"")
                a -= 1
            else: 
                ans.append(""b"")
                b -= 1
        ans.extend(a*[""a""] + b*[""b""])
        return """".join(ans)"
sum of even numbers after queries,"class Solution:
    # the idea is we don't calculate the even sum from scratch for each query
    # instead, we calculate it at the beginning
    # since each query only updates one value, 
    # so we can adjust the even sum base on the original value and new value
    def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        # calculate the sum of all even numbers
        evenSum = sum(x for x in nums if x % 2 == 0)
        ans = []
        for val, idx in queries:
            # if original nums[idx] is even, then we deduct it from evenSum
            if nums[idx] % 2 == 0: evenSum -= nums[idx]
            # in-place update nums
            nums[idx] += val
            # check if we need to update evenSum for the new value
            if nums[idx] % 2 == 0: evenSum += nums[idx]
            # then we have evenSum after this query, push it to ans 
            ans.append(evenSum)
        return ans"
sum of even numbers after queries,"class Solution:
    def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        sm=0
        for i in range(len(nums)):
            if nums[i]%2==0:
                sm+=nums[i]
        lst=[]
        for i in range(len(queries)):
            prev=nums[queries[i][1]]
            nums[queries[i][1]]+=queries[i][0]
            curr=nums[queries[i][1]]
            if prev%2==0:
                if curr%2==0:
                    sm+=(curr-prev)
                else:
                    sm-=prev
            else:
                if curr%2==0:
                    sm+=curr
            lst.append(sm)
        return lst"
interval list intersections,"class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        
        idx_a, idx_b = 0, 0
        size_a, size_b = len(A), len(B)
        
        intersection = []
        
        # Scan each possible interval pair
        while idx_a < size_a and idx_b < size_b :
            
            # Get start-time as well as end-time
            start_a, end_a = A[idx_a]
            start_b, end_b = B[idx_b]
            
            
            # Compute common start time and end time for current interval pair
            common_start = max( start_a, start_b )
            common_end = min( end_a, end_b )
            
            if common_start <= common_end:
                # Find one common overlapped interval
                intersection.append( [common_start, common_end] )
                
            if end_a <= end_b:
                # Try next interval of A
                idx_a += 1
                
            else:
                # Try next interval of B
                idx_b += 1
        
        return intersection"
interval list intersections,"class Solution:
    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -> List[List[int]]:
        res = []
        s,e = 0,1
        i,j = 0,0
        
        while i < len(firstList) and j < len(secondList):
            a = firstList[i] # fetching the interval
            b = secondList[j] # fetching the interval
            # checking for the overlapping 
            if b[s] <= a[e] and b[e] >= a[s]:
                # fetching the intersection point
                intersectionPoint = [max(a[s],b[s]),min(a[e],b[e])]
                res.append(intersectionPoint) # appending intersectionPoint into result list
                
            if a[e] > b[e]:
                j += 1
            else:
                i += 1
        return res"
vertical order traversal of a binary tree,"class Solution:
    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
        results = defaultdict(list)
        
        queue = [ (root, 0, 0) ]
        
        while queue:
            node, pos, depth = queue.pop(0)
            if not node: continue
            results[(pos,depth)].append(node.val)
            results[(pos,depth)].sort()
            queue.extend( [ (node.left, pos-1, depth+1), (node.right, pos+1, depth+1) ] )
            
            
        res = defaultdict(list)
        keys = sorted(list(results.keys()), key=lambda x: (x[0], x[1]))
        
        
        for k in keys:
            pos, depth = k
            res[pos].extend(results[k])

        return res.values()"
vertical order traversal of a binary tree,"class Solution:
    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        def dfs(root,r,c):
            if root:
                ans.append([r,c,root.val])
                dfs(root.left,r+1,c-1)
                dfs(root.right,r+1,c+1)
            return
        dfs(root,0,0)
        ans=sorted(ans,key=lambda x:(x[1],x[0],x[2]))
        d=defaultdict(list)
        for i,j,k in ans:
            d[j].append(k)
        l=[]
        for i in d.values():
            l.append(i)
        return l"
smallest string starting from leaf,"class Solution:
    res = 'z' * 13           # init max result, tree depth,  12< log2(8000) < 13
    
    def smallestFromLeaf(self, root: TreeNode) -> str:
        
        def helper(node: TreeNode, prev):
            prev = chr(97 + node.val) + prev
            
            if not node.left and not node.right:
                self.res = min(self.res, prev)
                return
            
            if node.left:
                helper(node.left, prev)
            if node.right:
                helper(node.right, prev)
        
        helper(root, """")
        return self.res"
smallest string starting from leaf,"class Solution:
    def smallestFromLeaf(self, root: TreeNode) -> str:
        paths = []
        
        def dfs(node, string):
            # Translate node value to letter via ASCII
            string += chr(node.val + 97)
            
            if node.left: dfs(node.left, string)
            if node.right: dfs(node.right, string)
            # At leaf node, add reversed tree path to ""paths""
            if not node.right and not node.left: paths.append(string[::-1])
                
        dfs(root, '')
        # Sort in lexicographical order and return first path
        paths.sort()
        return paths[0]"
add to array form of integer,"class Solution:
    def addToArrayForm(self, num: List[int], k: int) -> List[int]:
        return list(str(int("""".join([str(x) for x in num])) + k))"
add to array form of integer,"class Solution:
    def addToArrayForm(self, num: List[int], k: int) -> List[int]:
        return [int(i) for i in str(int(''.join([str(i) for i in num]))+k)]"
satisfiability of equality equations,"class Solution:     # Here's the plan:
                    #   1) We make an undirected graph in which the nodes are integers
                    #      (as lower-case letters) and each edge connects integers
                    #      that are equal.
                    #   2) We use a union-find process to determine the connected graphs
                    #   3) We keep track of the pairs (a,b) such that a =! b. If the any
                    #      such pair are in the same connected graph, then return False,
                    #      otherwise return True.
    def equationsPossible(self, equations: List[str]) -> bool:
        parent, diff = {}, []

        def find(x):
            if x not in parent: return x
            else: return find(parent[x])

        for s in equations:                 # <-- 1)
            a, b = s[0], s[3]

            if s[1]== ""="":                  # <-- 2)
                x, y = find(a), find(b)
                if x!=y:
                    parent[y] = x
            else:    
                diff.append((a,b))          # <-- 3)

        return all(find(a)!=find(b) for a, b in diff)"
satisfiability of equality equations,"class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        """"""
        Time: O(N), Space: O(N)
        """"""
        parent = {}
        
        def union(c1, c2):
            pc1 = find(c1)
            pc2 = find(c2)
            if pc1 == pc2:
                return
            parent[pc2] = pc1
        
        def find(c):
            if not parent.get(c):
                parent[c] = c
                return c
            if parent[c] == c:
                return c
            
            return find(parent[c])
        
        # First make the disjoint sets by traversing the equals
        for eq in equations: 
            if eq[1] == '=':
                x, y = eq[0], eq[3]
                union(x, y)
        
        # for all inequalities, their parents must be different
        for eq in equations:
            if eq[1] == '!':
                if find(eq[0]) == find(eq[3]):
                    return False
        return True"
broken calculator,"class Solution:
    def brokenCalc(self, x: int, y: int) -> int:
        if y<=x:
            return x-y
        else:
            res=0
            while x<y:
                if y%2==1:
                    y+=1
                else:
                    y=y//2
                res+=1
            res+=(x-y)
            return res"
broken calculator,"class Solution:
    def brokenCalc(self, startValue: int, target: int) -> int:
        res = 0 # taking a counter. 
        while target > startValue: # checking if target value is greater then startValue. 
            res += 1 # as if target is greater implies we`ll be having atleast one operation. 
            if target%2==0:
                target //=2 # in case number is even. 
            else:
                target += 1 # in case number odd. 
        return res + startValue - target# startValue - target is for (target<=staetValue)."
subarrays with k different integers,"class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        
        def window(nums, k):
            left = 0
            right = 0

            res = 0
            in_set = set()
            hash_map = collections.Counter()

            while right < len(nums):
                in_set.add(nums[right])
                hash_map[nums[right]] += 1

                while len(in_set) > k:
                    hash_map[nums[left]] -= 1
                    if hash_map[nums[left]] == 0:
                        in_set.remove(nums[left])
                    left += 1

                res += (right - left + 1)

                right += 1
            return res
    
       return window(nums, k) - window(nums, k - 1)"
subarrays with k different integers,"class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        ans = 0
        n = len(nums)
        latest = {}
        unique = 0
        prev = 0
        for i in range(n):
            if nums[i] not in latest:
                unique += 1
            latest[nums[i]] = i
            if unique > k :
                while True:
                    if latest[nums[prev]] == prev:
                        latest.pop(nums[prev])
                        prev += 1
                        unique -= 1                        
                        break
                    else:
                        prev += 1
                        
            if unique == k:
                ans += 1
                tmp = prev
                while True:
                    if latest[nums[tmp]] != tmp:
                        ans += 1
                        tmp += 1
                    else:
                        break
        return ans"
cousins in binary tree,"class Solution:
    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:
		# Check if root node is x or y
        if root.val == x or root.val == y:
            return False
		# Prepare for BFS, initialise variables
        curr, flag = [root.left, root.right], False
		
        while curr:
            tmp = []
			# Check nodes two-by-two
            for i in range(0, len(curr), 2):
				# Case 1: x and y are both found
				# This indicates that they have the same parent
                if curr[i] and curr[i+1] and \
                       ((curr[i].val == x and curr[i+1].val == y) or \
                       (curr[i+1].val == x and curr[i].val == y)):
                    return False
				# Case 2: Either one of x or y is found
                elif (curr[i] and (curr[i].val == x or curr[i].val == y)) or \
                        (curr[i+1] and (curr[i+1].val == x or curr[i+1].val == y)):
                    if flag:
						# Previously, the other node has been found in the same depth
						# This is our success condition, return True
                        return True
					# Otherwise, this is the first node in the current depth to be found
                    flag = True
				
				# Simultaneously, we can prepare the nodes for the subsequent depth
				# Note to append both left and right regardless of existence
                if curr[i]:
                    tmp.append(curr[i].left)
                    tmp.append(curr[i].right)
                if curr[i+1]:
                    tmp.append(curr[i+1].left)
                    tmp.append(curr[i+1].right)
			
			# Before we proceed to the next depth, check:
            if flag:
				# One of the nodes has already been found
				# This means that the other node cannot be of the same depth
				# By definition, this means that the two nodes are not cousins
                return False
            curr = tmp  # Assign the new nodes as the current ones
		
		# The program will never reach here since x and y are guaranteed to be found
		# But you can return False if you want"
cousins in binary tree,"class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        q = [root]
        while(q):
            toggle = 0
            parents = []
            for i in range(len(q)): # Level wise exploration starts here
                temp = q[0] # storing the first element in a temp variable
                q.pop(0) # Dequeuing the first element and exploring its neighbours below
                if(temp.left):
                    q.append(temp.left)
                    if(temp.left.val==x or temp.left.val==y):
                        toggle += 1
                        parents.append(temp)
                if(temp.right):
                    q.append(temp.right)
                    if(temp.right.val==x or temp.right.val==y):
                        toggle += 1
                        parents.append(temp)
			# Level wise exploration ends here
            # if toggle == 2 that means both x and y are on same level/depth
            if((toggle==2) and (parents[0] != parents[1])):
                return True # x and y are cousins
        return False"
rotting oranges,"class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        visit, curr = set(), deque()
		# find all fresh and rotten oranges
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    visit.add((i, j))
                elif grid[i][j] == 2:
                    curr.append((i, j))
        result = 0
        while visit and curr:
			# BFS iteration
            for _ in range(len(curr)):
                i, j = curr.popleft()  # obtain recent rotten orange
                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):
                    if coord in visit:  # check if adjacent orange is fresh
                        visit.remove(coord)
                        curr.append(coord)
            result += 1
		# check if fresh oranges remain and return accordingly
        return -1 if visit else result"
rotting oranges,"class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        rotten = []
        # build initial array of rotten oranges
        rows = len(grid)
        columns = len(grid[0])
        for i in range(rows):
            for j in range(columns):
                if grid[i][j] == 2:
                    rotten.append((i, j))

        # get unvisited neighbors of all rotten oranges
        def add_neighbors(rotten):
            neighbors = []
            for i, j in rotten:
                if i > 0 and grid[i - 1][j] == 1:
                    neighbors.append((i - 1, j))
                    grid[i-1][j] = 2
                if j > 0 and grid[i][j - 1] == 1:
                    neighbors.append((i, j - 1))
                    grid[i][j-1] = 2
                if i < rows - 1 and grid[i + 1][j] == 1:
                    neighbors.append((i + 1, j))
                    grid[i + 1][j] = 2
                if j < columns - 1 and grid[i][j + 1] == 1:
                    neighbors.append((i, j + 1))
                    grid[i][j+1] = 2
            return neighbors

        minutes = 0
        while (1):
            rotten = add_neighbors(rotten)
            if len(rotten) == 0:
                break
            minutes += 1

        for i in range(rows):
            for j in range(columns):
                if grid[i][j] == 1:
                    return -1

        return minutes"
minimum number of k consecutive bit flips,"class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        ans = 0
        q = []
        for i in range(len(nums)):
            if len(q) % 2 == 0:
                if nums[i] == 0:
                    if i+k-1 <= len(nums)-1:
                        ans += 1
                        q.append(i+k-1)
                    else:
                        return -1
            else:
                if nums[i] == 1:
                    if i+k-1 <= len(nums)-1:
                        ans += 1
                        q.append(i+k-1)
                    else:
                        return -1
            if q:
                if q[0] == i:
                    q.pop(0)
        return ans"
minimum number of k consecutive bit flips,"class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        ans = flip = 0 
        queue = deque()
        for i, x in enumerate(nums):
            if queue and i == queue[0]: 
                flip ^= 1
                queue.popleft()
            if x == flip: 
                if len(nums) - i < k: return -1
                ans += 1
                flip ^= 1
                queue.append(i+k)
        return ans"
number of squareful arrays,"class Solution(object):
    def numSquarefulPerms(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def dfs(temp,num,count = 0):
            if len(num)==0:
                return count+1
            for i in xrange(len(num)):
                if (i>0 and num[i]==num[i-1]) or (len(temp) > 0 and math.sqrt(num[i] + temp[-1]) % 1 != 0):
                    continue
                count = dfs(temp+[num[i]],num[:i]+num[i+1:],count)
            return count
        
        nums.sort()
        res = dfs([],nums)
        return res"
number of squareful arrays,"class Solution:
    def numSquarefulPerms(self, nums: List[int]) -> int:
        
        @cache
        def fn(v, mask): 
            """"""Return squareful arrays given prev value and mask.""""""
            if not mask: return 1 
            ans = 0 
            seen = set()
            for i, x in enumerate(nums): 
                if x not in seen and (mask == (1 << len(nums)) - 1 or mask &amp; (1 << i) and int(sqrt(x+v))**2 == x+v): 
                    seen.add(x)
                    ans += fn(x, mask ^ (1 << i))
            return ans 
        
        return fn(-1, (1 << len(nums)) - 1)"
find the town judge,"class Solution:
    def findJudge(self, N: int, trust: List[List[int]]) -> int:
        Trusted = [0] * (N+1)
        for (a, b) in trust:
            Trusted[a] -= 1
            Trusted[b] += 1
            
        for i in range(1, len(Trusted)):
            if Trusted[i] == N-1:
                return i
        return -1"
find the town judge,"class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        trust_to, trusted = defaultdict(int), defaultdict(int)

        for a, b in trust:
            trust_to[a] += 1
            trusted[b] += 1
        
        for i in range(1, n+1):
            if trust_to[i] == 0 and trusted[i] == n - 1:
                return i
        
        return -1"
maximum binary tree ii,"class Solution:
    def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root: return TreeNode(val)
        if val > root.val: return TreeNode(val, root)
        root.right = self.insertIntoMaxTree(root.right, val)
        return root"
maximum binary tree ii,"class Solution:
    def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        
        # that can be solved using DFS, as it is quite easy to
        # keep track of the parent node there
        
        # take care of the edge case that there is no root
        if not root:
            return TreeNode(val=val)
        
        # take care of the edge case that root is smaller
        if root.val < val:
            return TreeNode(val=val, left=root)
        
        # get into the dfs (we need to keep track of the parent)
        # self.attached = False
        dfs(root.right, root, val)
        return root
        
def dfs(node, parent, val):

    # check the break conditions
    if node is None or node.val < val:
        
        # we always attach the node to the parent right (as it
        # is the last value in the array)
        # also we append the previous subtree to the left
        # following the same logic
        parent.right = TreeNode(val=val, left=parent.right)
        return

    # we alway go to the right (since this is the
    # way it would be done during build as our value
    # is appended to the right of a to make b)
    # Names a and b are from the examples
    dfs(node.right, node, val)"
available captures for rook,"class Solution:
    def numRookCaptures(self, b: List[List[str]]) -> int:
        I, J = divmod(sum(b,[]).index('R'),8)
        C = """".join([i for i in [b[I]+['B']+[b[i][J] for i in range(8)]][0] if i != '.'])
        return C.count('Rp') + C.count('pR')
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
available captures for rook,"class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        n = 8
        for i in range(n):  # find rook location
            for j in range(n):
                if board[i][j] == 'R':
                    x, y = i, j
                    break
        
        res = 0
        for i in range(x-1, -1, -1):  # check north
            if board[i][y] == 'p':
                res += 1
                break
            if board[i][y] == 'B':
                break
        
        for i in range(x+1, n):  # check south
            if board[i][y] == 'p':
                res += 1
                break
            if board[i][y] == 'B':
                break
        
        for j in range(y-1, -1, -1):  # check west
            if board[x][j] == 'p':
                res += 1
                break
            if board[x][j] == 'B':
                break
        
        for j in range(y+1, n):  # check east
            if board[x][j] == 'p':
                res += 1
                break
            if board[x][j] == 'B':
                break
        
        return res"
minimum cost to merge stones,"class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        if (len(stones)-1) % (k-1): return -1 # impossible
        
        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)
        
        @cache
        def fn(lo, hi): 
            """"""Return min cost of merging stones[lo:hi].""""""
            if hi - lo < k: return 0 # not enough stones
            ans = inf 
            for mid in range(lo+1, hi, k-1): 
                ans = min(ans, fn(lo, mid) + fn(mid, hi))
            if (hi-lo-1) % (k-1) == 0: ans += prefix[hi] - prefix[lo]
            return ans 
        
        return fn(0, len(stones))"
minimum cost to merge stones,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        _cuts = [0] + sorted(cuts) + [n]
        N = len(_cuts)
        
        @lru_cache(None)
        def helper(lp,rp):
            nonlocal _cuts
            if rp-lp==1:
                return 0
            return _cuts[rp]-_cuts[lp] + min([helper(lp,i)+helper(i,rp) for i in range(lp+1,rp)])
            
        return helper(0,N-1)"
grid illumination,"class Solution:
    def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
        lamps = {(r, c) for r, c in lamps}
        
        row, col, left, right = dict(), dict(), dict(), dict()
        for r, c in lamps:
            row[r] = row.get(r, 0) + 1
            col[c] = col.get(c, 0) + 1
            left[r - c] = left.get(r - c, 0) + 1
            right[r + c] = right.get(r + c, 0) + 1

        res = list()
        for qr, qc in queries:
            if row.get(qr, 0) or col.get(qc, 0) or left.get(qr - qc, 0) or right.get(qr + qc, 0):
                res.append(1)
            else:
                res.append(0)

            for r, c in product(range(qr - 1, qr + 2), range(qc - 1, qc + 2)):
                if (r, c) in lamps:
                    lamps.remove((r, c))
                    row[r] -= 1
                    col[c] -= 1
                    left[r - c] -= 1
                    right[r + c] -= 1

        return res"
grid illumination,"class Solution:
    def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
        rows = collections.Counter()
        cols = collections.Counter()
        diags1 = collections.Counter()
        diags2 = collections.Counter()
        lamps = {tuple(lamp) for lamp in lamps}
        
        for i, j in lamps:
            rows[i] += 1
            cols[j] += 1
            diags1[i + j] += 1
            diags2[i - j] += 1
        
        ans = []
        directions = ((-1, -1), (-1, 0), (-1, 1),
                      (0, -1), (0, 0), (0, 1),
                      (1, -1), (1, 0), (1, 1))
        
        for i, j in queries:
            if rows[i] or cols[j] or diags1[i + j] or diags2[i - j]:
                ans.append(1)
            else:
                ans.append(0)
            
            for di, dj in directions:
                newI, newJ = i + di, j + dj
                if (newI, newJ) not in lamps:
                    continue
                lamps.remove((newI, newJ))
                rows[newI] -= 1
                cols[newJ] -= 1
                diags1[newI + newJ] -= 1
                diags2[newI - newJ] -= 1
        
        return ans"
find common characters,"class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        alphabet = string.ascii_lowercase
        d = {c: 0 for c in alphabet}
        
        for k, v in d.items():
            d[k] = min([word.count(k) for word in A])

        res = []
        for c, n in d.items():
            if n > 0:
                res += [c] * n
        return res"
find common characters,"class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        ans = []
        for i in set(A[0]):
            x = []
            for j in A:
                x.append(j.count(i))
            a = 0
            while a < min(x):
                ans.append(i)
                a += 1
        return ans"
check if word is valid after substitutions,"class Solution:
    def isValid(self, s: str) -> bool:
        stack=[]
        for i in s:
            if i == 'a':stack.append(i)
            elif i=='b':
                if not stack:return False
                else:
                    if stack[-1]=='a':stack.pop()
                    else:return False
                    stack.append(i)
            else:
                if not stack:return False
                else:
                    if stack[-1]=='b':stack.pop()
                    else:return False

        return len(stack)==0"
check if word is valid after substitutions,"class Solution:
    def isValid(self, s: str) -> bool:
        incomplete = True
        
        while incomplete:
            if 'abc' in s:
                s= s.replace('abc','')
            else:
                incomplete = False
        
        return s == ''"
max consecutive ones iii,"class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        left = 0
        answer = 0
        counts = {0: 0, 1: 0}
        
        for right, num in enumerate(nums):
            counts[num] += 1
            
            while counts[0] > k:
                counts[nums[left]] -= 1
                left += 1
                
            curr_window_size = right - left + 1
            answer = max(answer, curr_window_size)
            
        return answer"
max consecutive ones iii,"class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        zero_index = [i for i, v in enumerate(A) if v == 0]
        if K >= len(zero_index):
            return len(A)
        res = 0
        for i in range(0, len(zero_index) - K + 1):
            one_start = zero_index[i-1] + 1 if i > 0 else 0
            one_end = zero_index[i+K] - 1 if i+K < len(zero_index) else len(A) - 1
            res = max(res, one_end - one_start + 1)
        return res"
maximize sum of array after k negations,"class Solution:
	def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
		A.sort()
		i = 0
		while i < len(A) and K>0:
			if A[i] < 0: # negative value
				A[i] = A[i] * -1 # update the list, change negative to positive
				K-=1

			elif A[i] > 0: # positive value
				if K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum
					return sum(A)
				else: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question

			else: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum

			i+=1

		if K > len(A): # that means we have changed all values to positive
			A.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2
			if K % 2 == 0: # Here onwards is basically the same thing from before
				return sum(A)
			else: return sum(A) - 2 * min(A)

		return sum(A)"
maximize sum of array after k negations,"class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
    	S, a = sum(A), sorted([i for i in A if i < 0])
    	L, b = len(a), min([i for i in A if i >= 0])
    	if L == 0: return S if K % 2 == 0 else S - 2*b
    	if K <= L or (K - L) % 2 == 0: return S - 2*sum(a[:min(K,L)])
    	return S - 2*sum(a[:-1]) if -a[-1] < b else S - 2*sum(a) - 2*b
		
		
- Junaid Mansuri"
clumsy factorial,"class Solution:
    def clumsy(self, N: int) -> int:
    	return N + ([1,2,2,-1][N % 4] if N > 4 else [0,0,0,3,3][N])"
clumsy factorial,"class Solution:
    def clumsy(self, N: int) -> int:
    	return eval(str(N)+''.join([['*','//','+','-'][(N-i-1)%4]+str(i) for i in range(N-1,0,-1)]))"
minimum domino rotations for equal row,"class Solution:
    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:
        total = len(tops)
        top_fr, bot_fr, val_total = [0]*7, [0]*7, [total]*7
        for top, bot in zip(tops, bottoms):
            if top == bot:
                val_total[top] -= 1
            else:
                top_fr[top] += 1
                bot_fr[bot] += 1
                
        for val in range(1, 7):
            if (val_total[val] - top_fr[val]) == bot_fr[val]:
                return min(top_fr[val], bot_fr[val])
            
        return -1"
minimum domino rotations for equal row,"class Solution:
	def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:

		frequency_tops = {1:0,2:0,3:0,4:0,5:0,6:0}

		for i in tops:
			if i not in frequency_tops:
				frequency_tops[i] = 1
			else:
				frequency_tops[i] = frequency_tops[i] + 1

		frequency_bottoms = {1:0,2:0,3:0,4:0,5:0,6:0}

		for i in bottoms:
			if i not in frequency_bottoms:
				frequency_bottoms[i] = 1
			else:
				frequency_bottoms[i] = frequency_bottoms[i] + 1

		swap_number = 0

		for i in range(1,7):
			if frequency_tops[i] + frequency_bottoms[i] >= len(tops):
				swap_number = i

		if swap_number == 0:
			return -1

		min_num1 = len(tops)-frequency_tops[swap_number]
		min_num2 = len(bottoms)-frequency_bottoms[swap_number]


		for i in range(len(tops)):
			if swap_number not in [tops[i],bottoms[i]]:
				return -1

		return min(min_num1,min_num2)"
construct binary search tree from preorder traversal,"class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        node_stack = []
        node = root = TreeNode(preorder[0])
        for n in preorder[1:]:
            if n <= node.val:
                node.left = TreeNode(n)
                node_stack.append(node)
                node = node.left
            else:
                while node_stack and n > node_stack[-1].val:
                    node = node_stack.pop()
                node.right = TreeNode(n)
                node = node.right
        return root"
construct binary search tree from preorder traversal,"class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        
        root_index = 0
        
        def helper( preorder, upperbound):
            
            nonlocal root_index
            
            if root_index == len(preorder) or preorder[root_index] > upperbound:
                return None
            
            root = TreeNode( preorder[root_index] )
            
            # update root index by adding one
            root_index += 1
            
            root.left = helper( preorder, root.val )
            root.right = helper( preorder, upperbound )

            return root
                
        return helper( preorder, float('inf') )"
complement of base 10 integer,"class Solution:
    def bitwiseComplement(self, n: int) -> int:
        if n == 0:
            return 1
        else:
            result = 0
            factor = 1
            
            while(n > 0):
                result += factor * (1 if n%2 == 0 else 0)
                factor *= 2
                n //= 2
            return result"
complement of base 10 integer,"class Solution:
    def bitwiseComplement(self, N: int) -> int:
        sum_ = 1
        
        while N > sum_:
            sum_ = sum_ * 2 + 1
        
        return sum_ - N"
pairs of songs with total durations divisible by 60,"class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        res  , count  = 0,  [0] * 60
        for one in range(len(time)):
            index = time[one] % 60
            res += count[(60 - index)%60] # %60 is for index==0
            count[index] += 1
        return res"
pairs of songs with total durations divisible by 60,"class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        HashMap = {}
        pairs = 0
        
        for t in time:
            numMod = t % 60
            
            if numMod == 0:
                if 0 in HashMap:
                    pairs += HashMap[0]
            elif (60 - numMod) in HashMap:
                pairs += HashMap[60 - numMod]
                
            if numMod in HashMap:
                HashMap[numMod] += 1
            else:
                HashMap[numMod] = 1
                
        return pairs"
capacity to ship packages within d days,"class Solution:
def shipWithinDays(self, weights: List[int], D: int) -> int:
    
    def feasible(capacity):
        days = 1
        local = 0
        for w in weights:
            local+=w
            if local>capacity:
                local = w
                days+=1
                if days>D:
                    return False
        return True
            
                
    left, right = max(weights), sum(weights)
    while left < right:
        mid = left + (right-left)//2
        if feasible(mid):
            right = mid
        else:
            left = mid + 1
            
    return left"
capacity to ship packages within d days,"class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        def isEnough(capacity):  #helper function, to check if given capacity is enough
            count = 1
            max_weight = capacity
            for weight in weights:
                if weight > max_weight:
                    max_weight = capacity
                    count += 1
                max_weight -= weight
            return True if count <= days else False

        left, right = max(weights), sum(weights)
        while left < right:
            mid = left + (right - left) // 2
            if isEnough(mid):
                right = mid
            else:
                left = mid + 1
        return left"
numbers with repeated digits,"class Solution:
    def numDupDigitsAtMostN(self, N: int) -> int:
    	T = [9,261,4725,67509,831429,9287109,97654149,994388229]
    	t = [99,999,9999,99999,999999,9999999,99999999,999999999]
    	if N < 10:
    		return 0
    	L = len(str(N))
    	m, n = [1], []
    	g = 11-L
    	for i in range(L):
    		n.append(int(str(N)[i]))
    		m.append(g)
    		g = g*(12-L+i)
    	S = 0
    	for i in range(L):
    		if len(set(n[:L-i-1])) != len(n)-i-1:
    			continue
    		k = 0
    		for j in range(10):
    			if j not in n[:L-i-1] and j > n[L-i-1]:
    				k += 1
    		S += k*m[i]
    	return(T[L-2]-(t[L-2]-N-S))
	
- Python 3
- Junaid Mansuri"
partition array into three parts with equal sum,"class Solution:
    def canThreePartsEqualSum(self, A: List[int]) -> bool:
    	S = sum(A)
    	if S % 3 != 0: return False
    	g, C, p = S//3, 0, 0
    	for a in A[:-1]:
    		C += a
    		if C == g:
    			if p == 1: return True
    			C, p = 0, 1
    	return False"
partition array into three parts with equal sum,"class Solution:
    def canThreePartsEqualSum(self, A: List[int]) -> bool:
    	return (lambda x,y: x in y and 2*x in y and 3*x in y)(sum(A)//3,itertools.accumulate(A))
				
				
				
Junaid Mansuri
Chicago, IL"
best sightseeing pair,"class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:      
      dp = [0]*(len(values))
      dp[0] = values[0]
      maxVal = 0
      
      for i in range(1, len(values)):
        dp[i] = max(dp[i-1], values[i-1]+i-1)
        maxVal = max(maxVal, dp[i]+values[i]-i)
      
      return maxVal"
best sightseeing pair,"class Solution:

    def maxScoreSightseeingPair(self, values: List[int]) -> int:    
      maxVal = 0
      cur = 0            
      for i in range(1, len(values)):
        cur = max(cur, values[i-1]+i-1)
        maxVal = max(maxVal, cur+values[i]-i)
      return maxVal"
smallest integer divisible by k,"class Solution:
    def smallestRepunitDivByK(self, k: int) -> int:
        if not k % 2 or not k % 5: return -1
        n = length = 1
        while True:
            if not n % k: return length
            length += 1
            n = 10*n + 1"
smallest integer divisible by k,"class Solution:
    def smallestRepunitDivByK(self, k: int) -> int:
        if not k % 2 or not k % 5: return -1
        r = length = 1
        while True:
            r = r % k
            if not r: return length
            length += 1
            r = 10*r + 1"
binary string with substrings representing 1 to n,"class Solution:
    def queryString(self, S: str, N: int) -> bool:
        for x in range(N, 0, -1):
            if bin(x)[2:] not in S: return False 
        return True"
binary string with substrings representing 1 to n,"class Solution:
    def queryString(self, S: str, N: int) -> bool:
        ans = set()
        for i in range(len(S)):
            for ii in range(i, i + N.bit_length()): 
                x = int(S[i:ii+1], 2)
                if 1 <= x <= N: ans.add(x)
        return len(ans) == N"
convert to base 2,"class Solution:
    def baseNeg2(self, n: int) -> str:
        ans = """"
        while n != 0:
            if n%-2 != 0 :
                ans = '1' + ans
                n = (n-1)//-2
            else:
                ans = '0' + ans
                n = n//-2
        return ans if ans !="""" else '0'"
convert to base 2,"class Solution:
    def baseNeg2(self, n: int) -> str:
        result = """"
        while n != 0:
            if n%2 != 0 :
                result = '1' + result
                n = (n-1)//-2
            else:
                result = '0' + result
                n = n//-2
        return result if result != """" else '0'"
binary prefix divisible by 5,"class Solution:
    def prefixesDivBy5(self, A: List[int]) -> List[bool]:
    	n = 0
    	for i in range(len(A)): A[i], n = (2*n + A[i]) % 5 == 0, (2*n + A[i]) % 5
    	return A
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
binary prefix divisible by 5,"class Solution:
    def prefixesDivBy5(self, A: List[int]) -> List[bool]:
        s='';l=[]
        for i in A:
            s+=str(i)
            l.append(int(s,2)%5==0)
        return l"
next greater node in linked list,"class Solution:
    def nextLargerNodes(self, head: ListNode) -> List[int]:
        result = []
        stack = []
        for i, current in enumerate(self.value_iterator(head)):
            result.append(0)
            while stack and stack[-1][0] < current:
                _, index = stack.pop()
                result[index] = current
            stack.append((current, i))
        return result

    def value_iterator(self, head: ListNode):
        while head is not None:
            yield head.val
            head = head.next"
next greater node in linked list,"class Solution:
    def nextLargerNodes(self, head: ListNode) -> List[int]:
        res, stack, idx = [], [], 0
        while head:
            while stack and stack[-1][0] < head.val:
                _, i = stack.pop()
                res[i] = head.val
            
            res.append(0)
            stack.append((head.val, idx))
            idx += 1
            head = head.next
        return res"
number of enclaves,"class Solution:
def numEnclaves(self, A: List[List[int]]) -> int:
    row, col = len(A), len(A[0])
    
    if not A or not A[0]:
        return 0
    
    boundary1 = deque([(i,0) for i in range(row) if A[i][0]==1]) + deque([(i,col-1) for i in range(row) if A[i][col-1]==1])
    boundary2 = deque([(0,i) for i in range(1,col-1) if A[0][i]==1]) + deque([(row-1,i) for i in range(1,col-1) if A[row-1][i]==1])
        
    queue = boundary1+boundary2
    
    
    def bfs(queue,A):
        visited = set()
        while queue:
            x,y = queue.popleft()
            A[x][y] = ""T""
            if (x,y) in visited: continue
            visited.add((x,y))
            for nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:
                if 0<=nx<row and 0<=ny<col and A[nx][ny]==1:
                    A[nx][ny] = ""T""
                    queue.append((nx,ny))
        return A
    
    bfs(queue,A)
    
    count = 0
    for x in range(row):
        for y in range(col):
            if A[x][y] == 1:
                count+=1
    return count"
number of enclaves,"class Solution:
def numEnclaves(self, A: List[List[int]]) -> int:
    row, col = len(A), len(A[0])
    
    if not A or not A[0]:
        return 0
    
    def dfs(x,y,A):
        if 0<=x<row and 0<=y<col and A[x][y] ==1:
            A[x][y] = ""T""
            dfs(x+1,y,A)
            dfs(x-1,y,A)
            dfs(x,y+1,A)
            dfs(x,y-1,A)
        
        
    for x in range(row):
        dfs(x,0,A)
        dfs(x,col-1,A)
    
    for y in range(1,col-1):
        dfs(0,y,A)
        dfs(row-1,y,A)
    
    count=0
    for x in range(row):
        for y in range(col):
            if A[x][y]==1:
                count+=1
    
    return count"
remove outermost parentheses,"class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        
        stack=[]
        counter=0
        for i in S:
            if i=='(':
                counter=counter+1
                if counter==1:
                    pass
                else:
                    stack.append(i)
            else:
                counter=counter-1
                if counter == 0:
                    pass
                else:
                    stack.append(i)
        return (''.join(stack))"
remove outermost parentheses,"class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        ans=[];o=0
        for i in S:
            if i=='(' and o>0:
                ans.append(i)
            if i==')' and o>1:
                ans.append(')')
            o+=1 if i=='(' else -1
        return ''.join(ans)"
sum of root to leaf binary numbers,"class Solution:
    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        def dfs(node, path):
            if not node: return 0

            path = (path << 1) + node.val
			
            if not node.left and not node.right:
                return path
            
            return dfs(node.left, path) + dfs(node.right, path)
            
        return dfs(root, 0)"
sum of root to leaf binary numbers,"class Solution:
    def sumRootToLeaf(self, root: TreeNode) -> int:
        bfs = [root]
        l = []
        while bfs:
            node = bfs.pop(0)
            if node.left:
                x = node.left.val
                node.left.val = str(node.val) + str(x)
                bfs.append(node.left)
            if node.right:
                x = node.right.val
                node.right.val = str(node.val) + str(x)
                bfs.append(node.right)
            if not node.left and not node.right:
                l.append(str(node.val))
        return sum([int(i,2) for i in l])"
camelcase matching,"class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        
        def match(p, q):
            i = 0
            for j, c in enumerate(q):
                if i < len(p) and p[i] == q[j]: i += 1
                elif q[j].isupper(): return False
            return i == len(p)
        
        return [True if match(pattern, s) else False for s in queries]"
camelcase matching,"class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        res = []
        for word in queries:
            i = j = 0
            while i < len(word):
                if j < len(pattern) and word[i] == pattern[j]:
                    i += 1
                    j += 1
                elif word[i].isupper():
                    break
                else:
                    i += 1
            if i == len(word) and j == len(pattern):
                res.append(True)
            else:
                res.append(False)
        return res"
video stitching,"class Solution:
    def videoStitching(self, clips: List[List[int]], T: int) -> int:
        end, end2, res = -1, 0, 0
        for i, j in sorted(clips):
            if end2 >= T or i > end2:
                break
            elif end < i <= end2:
                res, end = res + 1, end2
            end2 = max(end2, j)
        return res if end2 >= T else -1"
video stitching,"class Solution:
    def videoStitching(self, clips: List[List[int]], time: int) -> int:
        if (time == 0): return 0
        clips.sort(key=lambda i: (i[0], -i[1]))
        output = [clips[0]]
        start, end = output[-1][0], output[-1][1]
        
        for currStart, currEnd in clips[1:]:
            if (currStart <= end <= currEnd and end < time):
                # pop the last clip if the second last clip overlaps with current clip and current clip is longer than the last clip
                if (len(output) > 1 and currStart <= output[-2][1]):
                    output.pop()
                start = min(start, currStart)
                end = max(end, currEnd)
                output.append([currStart, currEnd])

        
        if (start <= 0 and end >= time):
            return len(output)
        else:
            return -1"
divisor game,"class Solution:
    def divisorGame(self, N: int) -> bool:
        return N % 2 == 0
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
divisor game,"class Solution:
    def divisorGame(self, N: int) -> bool:
        if N%2 ==1:
            return False
        else:
            return True"
maximum difference between node and ancestor,"class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        def dfs(root, mn, mx):
            # Base Case: If we reach None, just return 0 in order not to affect the result
            if not root: return 0
            
			# The best difference we can do using the current node can be found:
            res = max(abs(root.val - mn), abs(root.val - mx))
			
			# Recompute the new minimum and maximum taking into account the current node
            mn, mx = min(mn, root.val), max(mx, root.val)
			
			# Recurse left and right using the newly computated minimum and maximum
            return max(res, dfs(root.left, mn, mx), dfs(root.right, mn, mx))
        
        # Initialize minimum `mn` and maximum `mx` equals value of given root
        return dfs(root, root.val, root.val)"
maximum difference between node and ancestor,"class Solution:
    def maxAncestorDiff(self, root: TreeNode) -> int:
        self.maxx = 0
        self.dfs(root)
        return self.maxx
    
    def dfs(self, root):
        if not root.left and not root.right: return root.val, root.val
        
        if not root.left: l_min, l_max = root.val, root.val 
        else: l_min, l_max = self.dfs(root.left)
            
        if not root.right: r_min, r_max = root.val, root.val
        else: r_min, r_max = self.dfs(root.right)
        
        self.maxx=max(self.maxx,abs(root.val-l_min),abs(root.val-l_max),abs(root.val-r_min),abs(root.val-r_max))
        return min(root.val,l_min,r_min), max(root.val,l_max,r_max)"
longest arithmetic subsequence,"class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        dp = {}
        for i, a2 in enumerate(A[1:], start=1):
            for j, a1 in enumerate(A[:i]):
                d = a2 - a1
                if (j, d) in dp:
                    dp[i, d] = dp[j, d] + 1
                else:
                    dp[i, d] = 2
        return max(dp.values())"
longest arithmetic subsequence,"class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        ans = 0
        cnt = defaultdict(lambda: 1)
        seen = set()
        for x in A: 
            for xx in seen: 
                cnt[x, x-xx] = 1 + cnt[xx, x-xx]
                ans = max(ans, cnt[x, x-xx])
            seen.add(x)
        return ans"
recover a tree from preorder traversal,"class Solution:
    def recoverFromPreorder(self, S: str) -> TreeNode:
        stack = []
        depth, val = 0, """"
        for i, x in enumerate(S): 
            if x == ""-"": 
                depth += 1
                val = """"
            else: 
                val += S[i]
                if i+1 == len(S) or S[i+1] == ""-"": 
                    node = TreeNode(int(val))
                    while len(stack) > depth: stack.pop()
                    if stack:
                        if not stack[-1].left: stack[-1].left = node
                        else: stack[-1].right = node
                    stack.append(node)
                    depth = 0
        return stack[0]"
recover a tree from preorder traversal,"class Solution:
    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:
        
        # edge condition as there might be an empty string
        if not traversal:
            return traversal
        
        # --------------------------------------------------------------
        # This part contains: splitting the string into the dashes and
        # values for each node
		# Pass 1
        # --------------------------------------------------------------
        
        # traverse the string and split it
        split = []
        start = 0
        for index, character in enumerate(traversal[:-1]):
            
            # once we hit a number and the next character is a dash
            # we have a split point
            if character != '-' and traversal[index+1] == '-':
                
                # append the split and set the index to the next character
                split.append(traversal[start:index+1])
                start = index + 1
                
        # since the last node has not been appended 
        # (there is not dash following a number)
        # we need to append the last element
        split.append(traversal[start:])
        
        # get the root as it is the first element in the list
        root = TreeNode(int(split[0]))
        split = split[1:]
        
        # --------------------------------------------------------------
        # This part contains: going through the nodes and building the
        # tree
		# Pass 2
        # --------------------------------------------------------------
        
        last_node = root
        current_level = 1
        # go trough the string
        for node in split:
            
            # replace the dashes to get the value and the amount of dashes
            value = node.replace('-', '')
            level = len(node) - len(value)
            value = int(value)
            
            if level > current_level:  # we go a layer deeper
                
                # get the next interesting node
                # since we are building the tree from
                # left to right, we always want to take
                # the rightmost route
                if last_node.right:
                    last_node = last_node.right
                else:
                    last_node = last_node.left
                
                
            # once we hit a node that is above the one we are attaching
            # to, we need to traverse down the tree from the root again
            elif level < current_level:  # we need to change the level
                # go back to the root
                last_node = root
                
                # go through the nodes for each level
                temp_level = 1
                while temp_level < level:
                    
                    # get the next interesting node
                    # since we are building the tree from
                    # left to right, we always want to take
                    # the rightmost route
                    if last_node.right:
                        last_node = last_node.right
                    else:
                        last_node = last_node.left
                    temp_level += 1
            
            # check whether we already have a left node and 
            # attach the current node
            if last_node.left is None:
                last_node.left = TreeNode(value)
            else:
                last_node.right = TreeNode(value)
                
            # update the level
            current_level = level
            
        return root"
two city scheduling,"class Solution(object):
    def twoCitySchedCost(self, costs):
        """"""
        :type costs: List[List[int]]
        :rtype: int
        """"""
        a = sorted(costs, key=lambda x: x[0]-x[1])
        Sa = 0
        Sb = 0
        for i in range(len(a)//2):
            Sa += a[i][0]
            
        for i in range(len(a)//2, len(a)):
            Sb += a[i][1]
        return Sa + Sb"
two city scheduling,"class Solution:
    def twoCitySchedCost(self, costs: List[List[int]]) -> int:
        '''
        Example:
        [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]
        
        Answer Choices (what to choose for min cost):
        City A - 259, 184, 577 
        City B - 54, 118, 667
        Answer Total Score: 1859
        
        Calculate scores for each pair and determine which cities to pick.
        Higher score = higher priority to pick lower cost city
        
        Score = abs(cityA - cityB)
        
        722 - [840, 118] - City B
        511 - [259, 770] - City A
        394 - [448, 54] - City B
        259 - [926, 667] - City B
        108 - [577,459] - City A
        45 - [184, 139] - City A
        '''
        people = len(costs) / 2
        a,b = people,people

        scores = [[abs(a-b),(a,b)] for a,b in costs] # calc the score, store the pair
        scores.sort(reverse=True)
        
        totalScore = 0
        # Scores - [[Calculated Score, (CityA-Cost, CityB-Cost)], ... ] This is what the scores array looks like
        for x in scores:
            choice = x[1]
            if choice[0] <= choice[1] and a > 0 or b == 0: # b == 0 means we reached n choices for city B already
                a -= 1
                totalScore += choice[0]
            elif choice[0] > choice[1] and b > 0 or a == 0:
                b -= 1
                totalScore += choice[1]
        return totalScore"
matrix cells in distance order,"class Solution:
    def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        d = {}
        for i in range(R):
            for j in range(C):
                d[(i,j)] = d.get((i,j),0) + abs(r0-i) + abs(c0-j)
        return [list(i) for i,j in sorted(d.items(), key = lambda x : x[1])]"
matrix cells in distance order,"class Solution:
    def allCellsDistOrder(self, R: int, C: int, r: int, c: int) -> List[List[int]]:
    	return sorted([[i,j] for i in range(R) for j in range(C)], key = lambda y: abs(y[0]-r)+abs(y[1]-c))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
maximum sum of two non overlapping subarrays,"class Solution:
    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        prefix = [0]
        for x in A: prefix.append(prefix[-1] + x) # prefix sum w/ leading 0
        ans = lmx = mmx = -inf 
        for i in range(M+L, len(A)+1): 
            lmx = max(lmx, prefix[i-M] - prefix[i-L-M])
            mmx = max(mmx, prefix[i-L] - prefix[i-L-M])
            ans = max(ans, lmx + prefix[i] - prefix[i-M], mmx + prefix[i] - prefix[i-L])
        return ans"
maximum sum of two non overlapping subarrays,"class Solution:
    def getMaxSubarraySum(self,arr,size):
        n = len(arr)
        if n < size: return 0
        best = tmp = sum(arr[:size])
        for i in range(1,n-size+1):
            tmp = tmp + arr[i+size-1] - arr[i-1]
            if tmp > best:best = tmp
        return best
    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:
        n = len(nums)
        summ = sum(nums[:firstLen])
        ans = summ  + self.getMaxSubarraySum(nums[firstLen:],secondLen)   
        for i in range(1,n-firstLen+1):
            summ = summ + nums[i+firstLen-1] - nums[i-1]
            a = self.getMaxSubarraySum(nums[:i],secondLen)
            b = self.getMaxSubarraySum(nums[i+firstLen:],secondLen)
            m = a if a > b else b
            if summ + m > ans: ans = summ + m
        return ans"
moving stones until consecutive,"class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        x, y, z = sorted([a, b, c])
        if x + 1 == y == z - 1:
            min_steps = 0
        elif y - x > 2 and z - y > 2:
            min_steps = 2
        else:
            min_steps = 1
        max_steps = z - x - 2
        return [min_steps, max_steps]"
moving stones until consecutive,"class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
    	[a,b,c] = sorted([a,b,c])
    	return [1 if 2 in [b-a,c-b] else (0 + (b-a != 1) + (c-b != 1)), c-a-2]
		
		
- Junaid Mansuri
(LeeCode ID)@hotmail.com"
coloring a border,"class Solution:
    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        
        rows, cols = len(grid), len(grid[0])
        border_color = grid[row][col]
        border = []
        
		# Check if a node is a border node or not
        def is_border(r, c):
            if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:
                return True

            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                nr, nc = r + dr, c + dc
                if grid[nr][nc] != border_color:
                    return True
            return False                
        
        def dfs(r, c):
            if r < 0 or c < 0 or r == rows or c == cols or (r, c) in visited or grid[r][c] != border_color:
                return
            visited.add((r, c))
            
            if is_border(r, c):
                border.append((r, c))
            
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)
        
        visited = set()
        dfs(row, col)
        for r, c in border:
            grid[r][c] = color
        return grid"
coloring a border,"class Solution:
    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        
        rows,cols = len(grid),len(grid[0])
        queue = [(row,col)]
        oldColor = grid[row][col]
        
        vis =  [[False for i in range(cols)] for j in range(rows)]
        vis[row][col] = True
        toChange = [[False for i in range(cols)] for j in range(rows)]
        
        def isChangable(r,c):
            if (r == 0 or grid[r-1][c] != oldColor) or (r == rows-1 or grid[r+1][c] != oldColor) \
            or (c == 0 or grid[r][c-1] != oldColor) or (c == cols-1 or grid[r][c+1] != oldColor):
                return True
            return False
        
        while queue:
            r,c = queue.pop(0)
            
            if isChangable(r,c) == True: toChange[r][c] = True
            
            for x,y in ((r+1,c),(r-1,c),(r,c-1),(r,c+1)):
                
                if 0<=x<rows and 0<=y<cols and grid[x][y] == oldColor and not vis[x][y]:                  
                    vis[x][y] = True
                    queue.append((x,y))
        
        for i in range(rows):
            for j in range(cols):
                if toChange[i][j] == True:
                    grid[i][j] = color
        
        return grid"
uncrossed lines,"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        e1=len(nums1)
        e2=len(nums2)
        @lru_cache(None,None)
        def dfs(s1,s2):
            best=-float('inf')
            if s1>=e1 or s2>=e2:
                return 0
            temp=[]
            op1=0
			#finding element in array2 which is equal to element in array1 from where we want to draw line
            for idx in range(s2,e2):
                if nums2[idx]==nums1[s1]:
                    temp.append(idx)
			#drawing line to all those element and checking which gives maximum value
            for j in temp:
                op1=1+dfs(s1+1,j+1)
                best=max(op1,best)
			#choosing to not draw line from current element of array1
            op2=dfs(s1+1,s2)
			#returning max of both options.
            return max(op2,best)
        return dfs(0,0)"
uncrossed lines,"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        m=len(nums1)
        n=len(nums2)
        dp=[]
        for i in range (m+1):
            dp.append([0]*(n+1))
        #print(dp)
        cnt=0
        for i in range (m+1):
            dp[i][0]=0
        for i in range (n+1):
            dp[0][i]=0
        for i in range (1,m+1):
            for j in range (1,n+1):
                if nums1[i-1]==nums2[j-1]:
                    dp[i][j]=max((dp[i-1][j-1]+1),max(dp[i-1][j],dp[i][j-1]))
                else:
                    dp[i][j]=max(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])

        return dp[-1][-1]"
escape a large maze,"class Solution:
    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        blocked = set(map(tuple, blocked))
        
        def fn(x, y, tx, ty): 
            """"""Return True if (x, y) is not looped from (tx, ty).""""""
            seen = {(x, y)}
            queue = [(x, y)]
            level = 0 
            while queue: 
                level += 1
                if level > 200: return True 
                newq = []
                for x, y in queue: 
                    if (x, y) == (tx, ty): return True 
                    for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): 
                        if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: 
                            seen.add((xx, yy))
                            newq.append((xx, yy))
                queue = newq
            return False 
        
        return fn(*source, *target) and fn(*target, *source)"
escape a large maze,"class Solution:
    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        blocked = set(map(tuple, blocked))
        
        def dfs(sx, sy, tx, ty): 
            """"""Return True if (x, y) is not looped from (tx, ty).""""""
            seen = {(sx, sy)}
            stack = [(sx, sy)]
            while stack: 
                x, y = stack.pop()
                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True 
                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): 
                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: 
                        seen.add((xx, yy))
                        stack.append((xx, yy))
            return False 
        
        return dfs(*source, *target) and dfs(*target, *source)"
valid boomerang,"class Solution:
    def isBoomerang(self, points: List[List[int]]) -> bool:
        x1, y1 = points[0]
        x2, y2 = points[1]
        x3, y3 = points[2]
        
        area = abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2
        return area != 0"
valid boomerang,"class Solution:
    def isBoomerang(self, points: List[List[int]]) -> bool:
        a,b,c=points
        return (b[1]-a[1])*(c[0]-b[0]) != (c[1]-b[1])*(b[0]-a[0])"
binary search tree to greater sum tree,"class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        s = 0
        def f(root):
            if root is None: return
            nonlocal s
            f(root.right)
            #print(s,root.val)
            s = s + root.val
            root.val = s
            f(root.left)
        f(root)
        return root"
binary search tree to greater sum tree,"class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        self.convert_to_list(root)
        self.modify_tree(root)
        return root
        
    def modify_tree(self, root):
        def rec(root):
            i = 0
            if root:
                rec(root.left)
                index = self.list.index(root.val)
                root.val = sum(self.list[index:])
                rec(root.right)
            return 0
        rec(root)
    
        
    def convert_to_list(self, root):
        self.list = []
        def rec(root):
            if root:
                rec(root.left)
                self.list.append(root.val)
                rec(root.right)
        rec(root)"
minimum score triangulation of polygon,"class Solution:
    def minScoreTriangulation(self, A: List[int]) -> int:
    	SP, LA = [[0]*50 for i in range(50)], len(A)
    	def MinPoly(a,b):
    		L, m = b - a + 1, math.inf; 
    		if SP[a][b] != 0 or L < 3: return SP[a][b]
    		for i in range(a+1,b): m = min(m, A[a]*A[i]*A[b] + MinPoly(a,i) + MinPoly(i,b))
    		SP[a][b] = m; return SP[a][b]
    	return MinPoly(0,LA-1)"
minimum score triangulation of polygon,"class Solution:
    def minScoreTriangulation(self, A: List[int]) -> int:
    	SP, L = [[0]*50 for _ in range(50)], len(A)
    	for i in range(2,L):
    		for j in range(L-i):
    			s, e, SP[s][e] = j, j + i, math.inf
    			for k in range(s+1,e): SP[s][e] = min(SP[s][e], A[s]*A[k]*A[e] + SP[s][k] + SP[k][e])
    	return SP[0][L-1]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
moving stones until consecutive ii,"class Solution:
    def numMovesStonesII(self, stones: list[int]) -> list[int]:
        """"""
        1. For the higher bound, it is determined by either moving the leftmost
            to the right side, or by moving the rightmost to the left side:
            1.1 If moving leftmost to the right side, the available moving
                positions are A[n - 1] - A[1] + 1 - (n - 1) = 
                A[n - 1] - A[1] - n + 2
            1.2 If moving rightmost to the left side, the available moving
                positions are A[n - 2] - A[0] + 1 - (n - 1) = 
                A[n - 2] - A[0] - n + 2.
        2. For the lower bound, we could use sliding window to find a window
            that contains the most consecutive stones (A[i] - A[i - 1] = 1):
            2.1 Generally the moves we need are the same as the number of
                missing stones in the current window.
            2.3 When the window is already consecutive and contains all the
                n - 1 stones, we need at least 2 steps to move the last stone
                into the current window. For example, 1,2,3,4,10:
                2.3.1 We need to move 1 to 6 first as we are not allowed to
                    move 10 to 5 as it will still be an endpoint stone.
                2.3.2 Then we need to move 10 to 5 and now the window becomes
                    2,3,4,5,6.
        """"""
        A, N = sorted(stones), len(stones)
        maxMoves = max(A[N - 1] - A[1] - N + 2, A[N - 2] - A[0] - N + 2)
        minMoves = N

        # Calculate minimum moves through sliding window.
        start = 0
        for end in range(N):
            while A[end] - A[start] + 1 > N:
                start += 1

            if end - start + 1 == N - 1 and A[end] - A[start] + 1 == N - 1:
                # Case: N - 1 stones with N - 1 positions.
                minMoves = min(minMoves, 2)
            else:
                minMoves = min(minMoves, N - (end - start + 1))

        return [minMoves, maxMoves]"
moving stones until consecutive ii,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        high = max(stones[-1] - stones[1], stones[-2] - stones[0]) - (len(stones) - 2)
        
        ii, low = 0, inf
        for i in range(len(stones)): 
            while stones[i] - stones[ii] >= len(stones): ii += 1
            if i - ii + 1 == stones[i] - stones[ii] + 1 == len(stones) - 1: low = min(low, 2)
            else: low = min(low, len(stones) - (i - ii + 1))
        return [low, high]"
robot bounded in circle,"class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        x = y = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        i = 0
        while True:
            for do in instructions:
                if do == 'G':
                    x += directions[i][0]
                    y += directions[i][1]
                elif do == 'R':
                    i = (i + 1) % 4
                else:
                    i = (i - 1) % 4
                    
            if i == 0:
                return x == 0 and y == 0"
robot bounded in circle,"class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        direc, pos = 0, [0, 0]
        for c in instructions:
            if c == ""L"": direc = (direc + 1) % 4
            elif c == ""R"": direc = (direc - 1) % 4
            elif c == ""G"":
                if direc == 0: pos[1] += 1
                elif direc == 1: pos[0] -= 1
                elif direc == 2: pos[1] -= 1
                else: pos[0] += 1
        return pos == [0, 0] or direc != 0"
flower planting with no adjacent,"class Solution:
    def gardenNoAdj(self, N: int, paths: List[List[int]]) -> List[int]:
        G = defaultdict(list)
        for path in paths:
            G[path[0]].append(path[1])
            G[path[1]].append((path[0]))
        colored = defaultdict()

        def dfs(G, V, colored):
            colors = [1, 2, 3, 4]
            for neighbour in G[V]:
                if neighbour in colored:
                    if colored[neighbour] in colors:
                        colors.remove(colored[neighbour])
            colored[V] = colors[0]

        for V in range(1, N + 1):
            dfs(G, V, colored)

        ans = []
        for V in range(len(colored)):
            ans.append(colored[V + 1])

        return ans"
flower planting with no adjacent,"class Solution:
    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:
        graph = {} # graph as adjacency list 
        for u, v in paths: 
            graph.setdefault(u-1, []).append(v-1)
            graph.setdefault(v-1, []).append(u-1)
            
        ans = [0]*n
        for i in range(n): 
            ans[i] = ({1,2,3,4} - {ans[ii] for ii in graph.get(i, [])}).pop()
        return ans"
partition array for maximum sum,"class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        n = len(arr)
        dp = [0]*n
        
        # handle the first k indexes differently
        for j in range(k): dp[j]=max(arr[:j+1])*(j+1)
        
        # we can get rid of index i by running i times
        for j in range(k,n):
            curr = []
            for m in range(k):
                curr.append(dp[j-m-1] + max(arr[(j-m):(j+1)]) * (m+1))
            dp[j] = max(curr)

        return dp[-1]"
partition array for maximum sum,"class Solution:
    def recursion(self,idx,arr,n,maxx,size,k):
        if idx == n:
            return maxx * size  
        if (idx,size,maxx) in self.dp: return self.dp[(idx,size,maxx)]
        ch1 = self.recursion(idx+1,arr,n,max(maxx,arr[idx]),size+1,k) if size < k else 0
        ch2 = self.recursion(idx+1,arr,n,arr[idx],1,k) + maxx*size
        best = ch1 if ch1 > ch2 else ch2
        self.dp[(idx,size,maxx)] = best
        return best
        
        
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        # we will try partitioning in every way possible
        self.dp = {}
        return self.recursion(1,arr,len(arr),arr[0],1,k)"
longest duplicate substring,"class Solution:
    def longestDupSubstring(self, s: str) -> str:
        length = len(s)
        l,r = 0, length-1        
        result = []
        while l<r:
            mid = (l+r)//2
            d = {}
            max_string = """"
            for i in range(length-mid):
                    if d.get(s[i:i+mid+1],0):
                        max_string = s[i:i+mid+1]
                        break
                    d[s[i:i+mid+1]] = 1
            if max_string:
                l = mid+1
                result.append(max_string)
            else:
                r = mid
        return max(result,key=len) if result else """""
longest duplicate substring,"class Solution:
	def longestDupSubstring(self, s: str) -> str:

		def checkDuplicate(window):
			visit = set()
			for i in range(0, len(s) - window):
				substring = s[i : i + window + 1]
				if substring in visit:
					return substring
				visit.add(substring)

			return None

		l, r = 0, len(s) - 1
		res = """"

		while l < r:
			mid = l + (r - l) // 2
			duplicate = checkDuplicate(mid)

			if duplicate:
				res = duplicate
				l = mid + 1
			else:
				r = mid

		return res"
last stone weight,"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones.sort()
        while stones:
            s1 = stones.pop()  # the heaviest stone
            if not stones:  # s1 is the remaining stone
                return s1
            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1
            if s1 > s2:
                # we need to insert the remaining stone (s1-s2) into the list
                pass
            # else s1 == s2; both stones are destroyed
        return 0  # if no more stones remain"
last stone weight,"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones.sort()
        while stones:
            s1 = stones.pop()  # the heaviest stone
            if not stones:  # s1 is the remaining stone
                return s1
            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1
            if s1 > s2:
                # the remaining stone will be s1-s2
                # loop through stones to find the index to insert the stone
                for i in range(len(stones)+1):
                    if i == len(stones) or stones[i] >= s1-s2:
                        stones.insert(i, s1-s2)
                        break
            # else s1 == s2; both stones are destroyed
        return 0  # if no more stones remain"
remove all adjacent duplicates in string,"class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack=[s[0]]
        for i in range(1,len(s)):
            if(stack and stack[-1]==s[i]):
                stack.pop()
            else:
                stack.append(s[i])
        return """".join(stack)"
remove all adjacent duplicates in string,"class Solution:
    def removeDuplicates(self, s: str) -> str:
        ans=[]
        for a in s:
            if(len(ans)>0 and ans[-1]==a):
                ans.pop()
            else:
                ans.append(a)
        return("""".join(ans))"
longest string chain,"class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        
        words.sort(key=len)
        dic = {}
        
        for i in words:
            dic[ i ] = 1
            
            for j in range(len(i)):
                
                # creating words by deleting a letter
                successor = i[:j] + i[j+1:]
                if successor in dic:
                    dic[ i ] = max (dic[i], 1 + dic[successor])
        
        res = max(dic.values())
        return res"
longest string chain,"class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        n=len(words)
        words_set={w:idx for idx, w in enumerate(words)}
        
        @cache
        def dp(i):                 
            curr=words[i]
            max_length=0
            for idx in range(len(curr)):
                new_wc = curr[:idx] + curr[idx+1:]
                if new_wc in words_set:
                    max_length=max(max_length, 1 + dp(words_set[new_wc]))
        
            return max_length
        
        return max(dp(i)+1 for i in range(n))"
last stone weight ii,"class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        
        @lru_cache(None)
        def fn(i, v): 
            """"""Return minimum weight of stones[i:] given existing weight.""""""
            if i == len(stones): return abs(v)
            return min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))
        
        return fn(0, 0)"
last stone weight ii,"class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        s = {0}
        for st in stones:
            tmp = set()
            for i in s:
                tmp.add(abs(i + st))
                tmp.add(abs(i - st))
            s = tmp
        return min(s) if len(s) > 0 else 0"
height checker,"class Solution:
    def heightChecker(self, heights: List[int]) -> int:
   
        max_val = max(heights)
        
        # Create frequency table
        freq = [0] * (max_val + 1)
        for num in heights: freq[num] += 1
        for num in range(1, len(freq)): freq[num] += freq[num-1]

        # Create places table
        places = [0] * len(heights)
        for num in heights:
            places[freq[num]-1] = num
            freq[num] -= 1

        return sum([a!=b for a, b in zip(heights, places)])"
height checker,"class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        k = sorted(heights)
        count = 0
		
        for i in range(len(heights)):
            if k[i] != heights[i]:
                count += 1
        return count"
grumpy bookstore owner,"class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
        # a sliding window approach
        currsum = 0
        # first store the sum as if the owner has no super power
        for i in range(len(grumpy)):
            if not grumpy[i]:
                currsum += customers[i]
        
        # now assuming he has the power, take the first window 
        # and add to the previous sum
        for i in range(X):
            if grumpy[i]:
                currsum += customers[i]
        
        maxsum = currsum
        
        # Now the sliding window starts
        # i and j are the two opposite ends of the window
        i = 0
        j = X
        while j < len(customers):
            if grumpy[j]:
                currsum += customers[j]
            if grumpy[i]:
                currsum -= customers[i]
			# we subtract above as the window has already passed over that customer
            if currsum > maxsum:
                maxsum = currsum
            i += 1
            j += 1
        return maxsum"
grumpy bookstore owner,"class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
        satisfied=0
        n=len(grumpy)
        satisfied=sum([customers[i]*(1-grumpy[i]) for i in range(n)])
        max_satisfied=satisfied
        for i in range(n):
            if grumpy[i]==1: satisfied+=customers[i]    
            if i>=minutes:
                if grumpy[i-minutes]==1: satisfied-=customers[i-minutes]
            max_satisfied=max(satisfied,max_satisfied)
        return max_satisfied
		```"
previous permutation with one swap,"class Solution:
	 def prevPermOpt1(self, nums: List[int]) -> List[int]:
		n = len(nums)-1
		left = n

    // find first non-decreasing number
    while left >= 0 and nums[left] >= nums[left-1]:
        left -= 1
        
	// if this hits, it means we have the smallest possible perm 
    if left <= 0:
        return nums
	
	// the while loop above lands us  at +1, so k is the actual value
    k = left - 1
    
    // find the largest number that's smaller than k 
    // while skipping duplicates
    right = n
    while right >= left:
        if nums[right] < nums[k] and nums[right] != nums[right-1]:
            nums[k], nums[right] = nums[right], nums[k]
            return nums
            
        right -= 1
   
    return nums"
previous permutation with one swap,"class Solution:
    def prevPermOpt1(self, arr: List[int]) -> List[int]:    
        n = len(arr)
        for i in range(n-2,-1,-1):
            if arr[i] > arr[i+1]:
                for j in range(n-1,i,-1):
                    if arr[j] < arr[i] and (j == i-1 or arr[j] != arr[j-1]):
                        arr[i],arr[j] = arr[j],arr[i]
                        return arr
        return arr"
distant barcodes,"class Solution:
    def rearrangeBarcodes(self, B: List[int]) -> List[int]:
        L, A, i = len(B), [0]*len(B), 0
        for k,v in collections.Counter(B).most_common():
            for _ in range(v):
                A[i], i = k, i + 2
                if i >= L: i = 1
        return A



class Solution:
    def rearrangeBarcodes(self, B: List[int]) -> List[int]:
        L, C = len(B), collections.Counter(B)
        B.sort(key = lambda x: (C[x],x))
        B[1::2], B[::2] = B[:L//2], B[L//2:]
        return B
		
		
- Junaid Mansuri"
distant barcodes,"class Solution:
    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:
        freq = {}
        for x in barcodes: freq[x] = 1 + freq.get(x, 0)
            
        ans, i = [None] * len(barcodes), 0
        for k, v in sorted(freq.items(), key=lambda x: x[1], reverse=True): 
            for _ in range(v): 
                ans[i] = k 
                i = i+2 if i+2 < len(ans) else 1
        return ans"
greatest common divisor of strings,"class Solution:
    def gcdOfStrings(self, s1: str, s2: str) -> str:
        return s1[:math.gcd(len(s1), len(s2))] if s1 + s2 == s2 + s1 else ''"
greatest common divisor of strings,"class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        m, n = len(str1), len(str2)
        
        for i in range(min(m, n), 0, -1):
            if n % i > 0 or m % i > 0: continue
                
            a, b = m // i, n // i
            test = str2[:i]
            if test * a == str1 and test * b == str2:
                return test
        
        return ''"
flip columns for maximum number of equal rows,"class Solution:
def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
    
    dic = defaultdict(int)
    for row in matrix:
        local=[]
        for c in row:
            local.append(c^row[0])
        dic[tuple(local)]+=1
    
    return max(dic.values())"
flip columns for maximum number of equal rows,"class Solution:
    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        d = {}
        for row in matrix:
            if row[0] == 0:
                d[tuple(row)] = d.get(tuple(row),0)+1
            else:
                x = []
                for i in row:
                    if i == 0:
                        x.append(1)
                    else:
                        x.append(0)
                d[tuple(x)] = d.get(tuple(x),0)+1
        return max(d.values())"
adding two negabinary numbers,"class Solution:
    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:
        ans = list()
        m, n = len(arr1), len(arr2)
        i, j = m-1, n-1
        def add(a, b):                                         # A helper function to add -2 based numbers
            if a == 1 and b == 1:
                cur, carry = 0, -1
            elif (a == -1 and b == 0) or (a == 0 and b == -1):    
                cur = carry = 1
            else:    
                cur, carry = a+b, 0
            return cur, carry                                  # Return current value and carry
        carry = 0
        while i >= 0 or j >= 0:                                # Two pointers from right side
            cur, carry_1, carry_2 = carry, 0, 0
            if i >= 0:
                cur, carry_1 = add(cur, arr1[i])
            if j >= 0:    
                cur, carry_2 = add(cur, arr2[j])
            carry = carry_1 + carry_2
            ans.append(cur)
            i, j = i-1, j-1
        ans = [1,1] + ans[::-1] if carry == -1 else ans[::-1]  # Add [1, 1] if there is a carry -1 leftover
        for i, v in enumerate(ans):                            # Remove leading zero and return
            if v == 1:
                return ans[i:]
        else:
            return [0]"
adding two negabinary numbers,"class Solution(object):
    def addNegabinary(self, arr1, arr2):
        """"""
        to add two ""-2"" based numbers up
        we can simply do the calculation per bit
        and map out all the possible cases with carry
        
        in ""-2"" based numbers, because the values of bits
        alter between negative and positive, so the carry/borrow
        will be reversed to -1/1
        
        so when the sum on one bit >= 2, the carry can be -1 to 
        the higher bit
        and if the higher bit with carry sum to -1, it needs to 
        borrow from the even higher bit, resulting in a carry of 1
        
        # 12 possible cases in 5 categories in total
        # case (| case) -> bit sum -> (bit, carry)
        # 0,0,-1 -> -1 -> (1, 1)
        # 0,0,0 | 1,0,-1 | 0,1,-1 -> 0 -> (0, 0)
        # 0,0,1 | 1,0,0 | 0,1,0 | 1,1,-1 -> 1 -> (1, 0)
        # 1,1,0 | 1,0,1 | 0,1,1 -> 2 -> (0, -1)
        # 1,1,1 -> 3 -> (1, -1)
        
        the 2nd catogery can produce leading zeros
        """"""
        
        CASE_MAPS = {
            -1: (1, 1),
            0: (0, 0),
            1: (1, 0),
            2: (0, -1),
            3: (1, -1),
        }
        
        res, carry = [], 0
        
        while arr1 or arr2 or carry:
            bit = carry
            
            if arr1: bit += arr1.pop()
            if arr2: bit += arr2.pop()
            
            bit, carry = CASE_MAPS[bit]
            
            res += [bit]
            
        while len(res) > 1 and res[-1] == 0:
            res.pop()
        
        return res[::-1]"
number of submatrices that sum to target,"class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        # find the rows and columns of the matrix
        n,m = len(matrix) , len(matrix[0])
        # find the prefix sum for each row
        for i in range(n):
            for j in range(1,m):
                matrix[i][j] += matrix[i][j-1]
        ans = 0
        # fix the left boundary of the column
        for start in range(m):
            # fix the right boundary of the column
            for end in range(start,m):
                # a dictionary to map data
                d = defaultdict(lambda:0)
                d[0] = 1
                summ = 0
                # now we do check at each row
                for i in range(n):
                    curr = matrix[i][end]
                    if start > 0: curr -= matrix[i][start-1]
                    summ += curr
                    ans += d[summ - target]
                    d[summ] += 1
        return ans"
number of submatrices that sum to target,"class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions 
        
        ans = 0 
        freq = defaultdict(int)
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m): 
            for j in range(n): 
                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
                for jj in range(-1, j): 
                    diff = prefix[i+1][j+1] - prefix[i+1][jj+1] 
                    ans += freq[jj, j, diff - target]
                    if diff == target: ans += 1
                    freq[jj, j, diff] += 1
        return ans"
occurrences after bigram,"class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        ans, stack = [], []
        for w in text.split():
            if len(stack) > 1 and stack[-2] == first and stack[-1] == second:
                ans.append(w)
            stack.append(w)
        return ans"
occurrences after bigram,"class Solution:
#     Runtime: 43ms 59.41% || Memory: 13.9mb 73.25%
#       O(n) || O(1) if you dont count return result as a extra space
    def findOcurrences(self, string: str, first: str, second: str) -> List[str]:
        result = []
        string = string.split()
        for i in range(len(string) - 2):
            currStr = string[i]
            secNxtStr = string[i + 1]
            thirdNxtStr = string[i + 2]

            if currStr == first and secNxtStr == second:
                result.append(thirdNxtStr)


        return result"
letter tile possibilities,"class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        record = [0] * 26
        for tile in tiles: record[ord(tile)-ord('A')] += 1
        def dfs(record):
            s = 0
            for i in range(26):
                if not record[i]: continue
                record[i] -= 1
                s += dfs(record) + 1 
                record[i] += 1
            return s    
        return dfs(record)"
letter tile possibilities,"class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        ds=[]
        self.ans=set()
        self.solve(tiles,ds)
        return len(self.ans)
    def solve(self,tiles,ds):
        for i in range(len(tiles)):
            ds.append(tiles[i])
            self.ans.add("""".join(ds[:]))
            self.solve(tiles[:i]+tiles[i+1:],ds)
            ds.pop()
        return"
insufficient nodes in root to leaf paths,"class Solution:
    def sufficientSubset(self, root: TreeNode, limit: int, pathSum = 0) -> TreeNode:
        if not root: return None
        if not root.left and not root.right:
            if pathSum + root.val < limit:
                return None
            return root
        root.left = self.sufficientSubset(root.left, limit, pathSum + root.val)
        root.right = self.sufficientSubset(root.right, limit, pathSum + root.val)
        if not root.left and not root.right:
            return None
        return root"
insufficient nodes in root to leaf paths,"class Solution:
    def sufficientSubset(self, root: Optional[TreeNode], limit: int) -> Optional[TreeNode]:
        
        def traverse(node, pathSum):
            #For non-leaf nodes return invalid path sum
            if(node is None):   return limit - 1, None
            
            pathSumWithCurrentNode = pathSum + node.val
            
            #For leaf node return the path sum
            if(node.left is None and node.right is None):
                leftPathSum = rightPathSum = pathSumWithCurrentNode
            else:
                leftPathSum, node.left = traverse(node.left, pathSumWithCurrentNode)
                rightPathSum, node.right = traverse(node.right, pathSumWithCurrentNode)
                
            if(leftPathSum >= limit or rightPathSum >= limit):
                #including the current node
                return max(leftPathSum, rightPathSum), node
            
            #Removing the current node
            return min(leftPathSum, rightPathSum), None
        
        _, newRoot = traverse(root, 0)
        return newRoot"
smallest subsequence of distinct characters,"class Solution:
    def smallestSubsequence(self, s: str) -> str:
        loc = {x: i for i, x in enumerate(s)}
        stack = []
        for i, x in enumerate(s): 
            if x not in stack: 
                while stack and x < stack[-1] and i < loc[stack[-1]]: stack.pop()
                stack.append(x)
        return """".join(stack)"
smallest subsequence of distinct characters,"class Solution:
    def smallestSubsequence(self, s: str) -> str:
        d = defaultdict(list)
        for index,character in enumerate(s):
            d[character].append(index)
        unique = sorted([ x for x in d])
        
        # what should be the character at index = 1
        size = len(unique)
        ans = """"
        used = {}
        left = 0
        for i in range(size):
            for character in unique:
                if character in used:continue
                if d[character][-1] < left: continue
                # find the new left
                idx = bisect.bisect_left(d[character],left)
                new_left = d[character][idx]
                # check if current character can be used
                flag = True
                for character2 in unique:
                    if character2 in used or character2 == character: continue
                    if d[character2][-1] < new_left:
                        flag = False
                        break
                if flag == True:
                    left = new_left
                    ans += character
                    used[character] = True
                    break
        return ans"
duplicate zeros,"class Solution:
	def duplicateZeros(self, arr: List[int]) -> None:
		i = 0
		n = len(arr)
		while(i<n):
			if arr[i]==0:
				arr.pop()
				arr.insert(i,0)
				i+=1
			i+=1"
duplicate zeros,"class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        cnt = arr.count(0)

        for i in reversed(range(len(arr))):
            if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy the number over to correct position
            if arr[i] == 0:
                cnt -= 1
                if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy again if the number is 0"
largest values from labels,"class Solution:
    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:
        ans = 0
        freq = {}
        for value, label in sorted(zip(values, labels), reverse=True):
            if freq.get(label, 0) < use_limit: 
                ans += value
                num_wanted -= 1
                if not num_wanted: break 
                freq[label] = 1 + freq.get(label, 0)
        return ans"
largest values from labels,"class Solution:
    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:
        ans = 0 
        freq = defaultdict(int)
        for value, label in sorted(zip(values, labels), reverse=True): 
            if 0 < num_wanted and freq[label] < use_limit: 
                ans += value
                num_wanted -= 1
                freq[label] += 1
        return ans"
shortest path in binary matrix,"class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        # check if source and target are not clear cells
        if grid[0][0] != 0 or grid[-1][-1] != 0:
            return -1
        
        N = len(grid)            
        # offsets required for all 8 directions
        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        
        q = deque()
        q.append((0,0)) # starting point
        visited = {(0, 0)}
        
        
        # finds unvisited clear cells using 8 offsets
        def get_neighbours(x,y):
            for x_offset, y_offset in offsets:
                new_row = x + x_offset
                new_col = y + y_offset
                
                if 0 <= new_row < N and 0 <= new_col < N and not grid[new_row][new_col] and (new_row, new_col) not in visited:
                    yield (new_row, new_col)                                                
            
        
        current_distance = 1 # start with one clear cell
        # standard iterative BFS traversal
        while q:
            length = len(q)
            
            # loop through all the cells at the same distance
            for _ in range(length):
                row, col = q.popleft()
                
                if row == N-1 and col==N-1: # reached target
                    return current_distance
                
                # loop though all valid neignbours
                for p in get_neighbours(row, col):
                    visited.add(p)
                    q.append(p)
                                    
            current_distance+=1 # update the level or distance from source
        
        return -1"
shortest path in binary matrix,"class Solution:
    NO_CLEAR_PATH = -1

    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dirs = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 0), (-1, 1), (0, 1), (1, 1)]
        dp = [[None] * n for _ in range(n)]

        def countCellsToTarget(i, j):
            if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] == 1: return self.NO_CLEAR_PATH
            if (i, j) == (n-1, n-1): return 1
            #if dp[i][j] is not None: return dp[i][j] # memoization removed

            result = math.inf
            grid[i][j] = 1

            for di, dj in dirs:
                ii, jj = i + di, j + dj

                cellsToTarget = countCellsToTarget(ii, jj)
                if cellsToTarget < 1: continue
                result = min(result, 1 + cellsToTarget)

            if result == math.inf: result = self.NO_CLEAR_PATH
            grid[i][j] = 0
            dp[i][j] = result
            return result
        
        return countCellsToTarget(0, 0)"
shortest common supersequence,"class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        n,m = len(str1),len(str2)
        dp = [[0 for j in range(m+1)]for i in range(n+1)]
        for i in range(1,n+1):
            for j in range(1,m+1):
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = 1+dp[i-1][j-1]
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        i,j = n,m
        ans = """"
        while(i>0 and j>0):
            if str1[i-1] == str2[j-1]:
                ans += str1[i-1]
                i -= 1
                j -= 1
            else:
                if(dp[i-1][j] > dp[i][j-1]):
                    ans += str1[i-1]
                    i -= 1
                else:
                    ans += str2[j-1]
                    j -= 1
        while(i>0):
            ans += str1[i-1]
            i -= 1
        while(j>0):
            ans += str2[j-1]
            j -= 1
        return ans[::-1]"
shortest common supersequence,"class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        m = len(str1)
        n = len(str2) 
        
        # construct the dp table
        t = [[0 for j in range(n + 1)] for i in range(m + 1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                if str1[i-1] == str2[j-1]:
                    t[i][j] = 1 + t[i-1][j-1]
                else:
                    t[i][j] = max(t[i-1][j], t[i][j-1])
            
            

        i = len(str1)
        j = len(str2)
        
        string = ''
        
        while i>0 and j>0:
            if str1[i-1] == str2[j-1]:
                string += str1[i-1]
                i -= 1
                j -= 1
            else:
                if t[i][j-1] > t[i-1][j]:
                    string += str2[j-1]
                    j -= 1
                else:
                    string += str1[i-1]
                    i -= 1
        # now atleast ome string must have been exhausted
        # so for remaining string
        
        
        # if str1 is remaining
        while i>0:
            string += str1[i-1]
            i -= 1
        
        # if str2 is remaining
        while j>0:
            string += str2[j-1]
            j -= 1
        
        return string[::-1]"
statistics from a large sample,"class Solution:
    def sampleStats(self, count: List[int]) -> List[float]:
        return [
            #Minimum
            min(i for i,c in enumerate(count) if c != 0),
            #Maximum
            max(i for i,c in enumerate(count) if c != 0),
            #Mean
            sum(i*c for i,c in enumerate(count)) / sum(c for c in count if c != 0),
            #Media
            (lambda total:
                (
                    next(i for i,s in enumerate(itertools.accumulate(count)) if s >= total//2+1)+
                    next(i for i,s in enumerate(itertools.accumulate(count)) if s >= total//2+total%2)
                )/2
            )(sum(c for c in count if c != 0)),
            #Mode
            max(((i,c) for i,c in enumerate(count) if c != 0),key=(lambda x: x[1]))[0]
        ]"
statistics from a large sample,"class Solution:
    def sampleStats(self, count: List[int]) -> List[float]:
        running_sum = 0
        min_elem = 300
        max_elem = -1
        most_frequent_value, max_freq = None, 0
        current_idx = 0
        all_counter = sum(count)
        
        medium_idx = all_counter // 2
        medium_sum = 0
        if all_counter % 2 == 0:
            medium_idx = medium_idx, medium_idx - 1
        else:
            medium_idx = medium_idx, medium_idx
        
        for value, counter in enumerate(count):
            if medium_idx[0] >= current_idx and medium_idx[0] < current_idx + counter:
                medium_sum += value
            if medium_idx[1] >= current_idx and medium_idx[1] < current_idx + counter:
                medium_sum += value
            current_idx += counter
            
            running_sum += value * counter
            
            if min_elem == 300 and counter:
                min_elem = value
            max_elem = max(value, max_elem) if counter else max_elem
            
            if counter > max_freq:
                most_frequent_value = value
                max_freq = counter
        return min_elem, max_elem, running_sum / all_counter, medium_sum / 2, most_frequent_value"
car pooling,"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        path = [0]*1000
        
        for num, a, b in trips:
            for loc in range (a, b):
                path[loc] += num
                if path[loc] > capacity: return False
                
        return True"
car pooling,"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        trips.sort(key = lambda x:x[2])
        stations = trips[-1][-1]
        people = [0]*(stations+1)
        for count , start , end in trips:
            people[start] += count
            people[end] -= count
        if people[0] > capacity: return False
        for i in range(1,stations+1):
            people[i] += people[i-1]
            if people[i] > capacity: return False
        return True"
find in mountain array,"class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        
        def fn(lo, hi, mult): 
            """"""Return index of target between lo (inclusive) and hi (exlusive).""""""
            while lo < hi: 
                mid = lo + hi >> 1
                if mountain_arr.get(mid) == target: return mid 
                elif mountain_arr.get(mid)*mult < target*mult: lo = mid + 1
                else: hi = mid 
            return -1 
        
        lo, hi = 0, mountain_arr.length()
        while lo < hi: 
            mid = lo + hi >> 1
            if mid and mountain_arr.get(mid-1) < mountain_arr.get(mid): lo = mid + 1
            else: hi = mid 
        if (x := fn(0, lo, 1)) != -1: return x 
        if (x := fn(lo, mountain_arr.length(), -1)) != -1: return x 
        return -1"
find in mountain array,"class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        length = mountain_arr.length() - 1
        if mountain_arr.get(0) == target:
            return 0
        min_idx = sys.maxsize
        if mountain_arr.get(length) == target:
            min_idx = length

        //check left of peak first 
        l,r = 0, length
        while l <= r:
            middle = (l + r) // 2
            val = mountain_arr.get(middle)
            if middle < length:
                if val == target:
                    min_idx = min(min_idx,middle)
                plus1 = mountain_arr.get(middle+1)
                if val < plus1:
                    if val < target:
                        l = middle + 1
                    else:
                        r = middle -  1
                else:
                    r = middle - 1
            else:
                break
        
        //check right of peak next
        l, r = 0, length
        while l <= r:
            middle = (l + r) // 2
            val = mountain_arr.get(middle)
            if middle < length:
                if val == target:
                    min_idx = min(min_idx,middle)
                plus1 = mountain_arr.get(middle+1)
                if val > plus1:
                    if val > target:
                        l = middle + 1
                    else: 
                        r = middle - 1
                else:
                    l = middle + 1
            else:
                break



        // if we have not found the element, its time to just 
        // return -1 
        return min_idx if min_idx != sys.maxsize else -1"
brace expansion ii,"class Solution:
    def braceExpansionII(self, expression: str) -> List[str]:
        stack,res,cur=[],[],[]
        for i in range(len(expression)):
            v=expression[i]
            if v.isalpha():
                cur=[c+v for c in cur or ['']]
            elif v=='{':
                stack.append(res)
                stack.append(cur)
                res,cur=[],[]
            elif v=='}':
                pre=stack.pop()
                preRes=stack.pop()
                cur=[p+c for c in res+cur for p in pre or ['']]
                res=preRes
            elif v==',':
                res+=cur
                cur=[]
        return sorted(set(res+cur))"
brace expansion ii,"class Solution:
    def braceExpansionII(self, expression: str) -> List[str]:
        mp, stack = {}, []
        for i, x in enumerate(expression): 
            if x == ""{"": stack.append(i)
            elif x == ""}"": mp[stack.pop()] = i 
        
        def fn(lo, hi): 
            """"""Return expanded outcome of expression[lo:hi].""""""
            ans = [[""""]]
            if lo+1 < hi: 
                i = lo
                while i < hi: 
                    if expression[i] == "","": ans.append([""""])
                    else: 
                        if expression[i] == ""{"": 
                            y = fn(i+1, mp[i])
                            i = mp[i]
                        else: y = expression[i]
                        ans.append([xx+yy for xx in ans.pop() for yy in y])
                    i += 1
            return sorted({xx for x in ans for xx in x}) 
        
        return fn(0, len(expression))"
distribute candies to people,"class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        # create an array of size num_people and initialize it with 0
        list_people = [0] * num_people
        
        # starting value
        index = 1
        
        # iterate until the number of candies are more than 0
        while candies > 0:
            
            # if candies are more than index value, add the index value to the location 
            if candies > index:
                # we are using mod operation by the num_people to locate the index of the array
                # we are subtracting by 1 because the array index starts at 0
                list_people[(index - 1) % num_people] += index
            else:
                # if candies are less than index value, add all remaining candies to location
                list_people[(index - 1) % num_people] += candies
            
            # subtract the candies with index values
            candies -= index
            
            # increment the index values
            index += 1
        
        # return the resultant array
        return(list_people)"
distribute candies to people,"class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        res = [0] * num_people
        index = 0
        while candies > 0:
            res[index % num_people] += min(index + 1, candies)
            index += 1
            candies -= index
        return res"
path in zigzag labelled binary tree,"class Solution:
    
    def pathInZigZagTree(self, label: int) -> List[int]:
        rows = [(1, 0)] #row represented by tuple (min_element_in_row, is_neg_order)
        while rows[-1][0]*2 <= label:
            rows.append((rows[-1][0]*2, 1 - rows[-1][1]))
            
        power, negOrder = rows.pop()
        
        res = []
        while label > 1:
            res.append(label)
                
            if negOrder:
                # adjust label position and find parent with division by 2
                # a, b - range of current row 
                a, b = power, power*2 -1
                label = (a + (b - label))//2
            else:
                # divide label by 2 and adjust parent position
                # a, b - range of previous row
                a, b = power//2, power - 1
                label = b - (label//2 - a)
                
            power, negOrder = rows.pop()
            
                          
        res.append(1)
                          
        return res[::-1]"
path in zigzag labelled binary tree,"class Solution:
    def pathInZigZagTree(self, label: int) -> List[int]:
        
        x = label
        mask = 0 
        while x > 1:
            x >>= 1
            mask <<= 1
            mask |= 1
            
        x = label
        res = deque()
        while x:
            res.appendleft(x)
            x >>= 1
            mask >>= 1
            x ^= mask
        return res"
filling bookcase shelves,"class Solution:
    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:
        n = len(books)
        dp = [sys.maxsize] * n
        dp[0] = books[0][1]                                # first book will always on it's own row
        for i in range(1, n):                              # for each book
            cur_w, height_max = books[i][0], books[i][1]
            dp[i] = dp[i-1] + height_max                   # initialize result for current book `dp[i]`
            for j in range(i-1, -1, -1):                   # for each previou `book[j]`, verify if it can be placed in the same row as `book[i]`
                if cur_w + books[j][0] > shelfWidth: break
                cur_w += books[j][0]
                height_max = max(height_max, books[j][1])  # update current max height
                dp[i] = min(dp[i], (dp[j-1] + height_max) if j-1 >= 0 else height_max) # always take the maximum heigh on current row
        return dp[n-1]"
filling bookcase shelves,"class Solution:
    def recursion(self, idx , n , height , width):
        if idx == n:return height
        
        if (idx,height,width) in self.dp: return self.dp[(idx,height,width)]
        
        choice1 = self.recursion(idx+1,n,max(self.books[idx][1],height), width - self.books[idx][0])\
        if width >= self.books[idx][0] else float('inf')
        
        choice2 = self.recursion(idx+1,n,self.books[idx][1], self.shelfWidth - self.books[idx][0]) + height
        
        ans = min(choice1,choice2)
        self.dp[(idx,height,width)] = ans
        return ans
    
    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:
        self.books = books
        self.shelfWidth = shelfWidth
        self.dp = {}
        return self.recursion(0,len(books),0,shelfWidth)"
parsing a boolean expression,"class Solution:
    operands = {""!"", ""&amp;"", ""|"", ""t"", ""f""}
    values = {""t"", ""f""}

    def parseBoolExpr(self, expression: str) -> bool:
        stack = []
        for c in expression:
            if c == "")"":
                val = stack.pop()
                args = set()
                while val in Solution.values:
                    args.add(val)
                    val = stack.pop()
                if val == ""!"":
                    stack.append(""f"" if ""t"" in args else ""t"")
                elif val == ""&amp;"":
                    stack.append(""f"" if ""f"" in args else ""t"")
                elif val == ""|"":
                    stack.append(""t"" if ""t"" in args else ""f"")
            elif c in Solution.operands:
                stack.append(c)
        return stack[0] == ""t"""
parsing a boolean expression,"class Solution:
    def parseBoolExpr(self, expression: str) -> bool:
        logics = []
        stack = []
        
        def cal(tmp, top, op):
            if op == '!':
                tmp = 't' if tmp == 'f' else 'f'
            elif op == '&amp;':
                tmp = 't' if (tmp == 't' and top == 't') else 'f'
            elif op == '|':
                tmp = 't' if (tmp == 't' or top == 't') else 'f'
            return tmp

        for i in expression:
            if i in ('!', '&amp;', '|'):
                logics.append(i)
            elif i == ')':
                op = logics.pop()
                tmp = stack.pop()
                while stack:
                    top = stack.pop()
                    # print(tmp, top, op)
                    if op == '!' and top == '(': tmp = cal(tmp, tmp, op)
                    if top == '(': break
                    tmp = cal(tmp, top, op)
                stack.append(tmp)
            elif i == ',': continue
            else:
                stack.append(i)
            # print(stack, logics, i)
        
        if logics:
            op = logics.pop()
            tmp = stack.pop()
            while stack:
                top = stack.pop()
                tmp = cal(tmp, top, op)
            stack.append(tmp)
        
        return True if stack[0] == 't' else False
        
                    
# Time: O(N)
# Space: O(N)"
defanging an ip address,"class Solution:
    def defangIPaddr(self, address: str) -> str:
        address=address.replace(""."",""[.]"")
        return address"
defanging an ip address,"class Solution:
    def defangIPaddr(self, address: str) -> str:
        return address.replace('.','[.]')"
corporate flight bookings,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        res = [0]*n
        for first, last, seat in bookings:
            res[first - 1] += seat
            if last < n:
                res[last] -= seat
        return accumulate(res)"
corporate flight bookings,"class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        arr = [[0, 0] for i in range(n)]
        ans = []
        
        for i, j, k in bookings:
            arr[i-1][0] += k
            arr[j-1][1] += k
        
        curr = 0
        
        for i in range(len(arr)):
            ans.append(curr + arr[i][0])
            curr += arr[i][0] - arr[i][1]
    
        return ans"
delete nodes and return forest,"class Solution:
    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:
        to_delete = set(to_delete) # O(1) lookup 
        
        def fn(node, pval):
            """"""Return node upon deletion of required values.""""""
            if not node: return 
            if node.val in to_delete: 
                node.left = fn(node.left, None)
                node.right = fn(node.right, None)
                return 
            else: 
                if not pval: ans.append(node)
                node.left = fn(node.left, node.val)
                node.right = fn(node.right, node.val)
                return node 
        
        ans = []
        fn(root, None)
        return ans"
delete nodes and return forest,"class Solution:
    def delNodes(self, root_node: TreeNode, to_delete: List[int]) -> List[TreeNode]:
        blacklist = set(to_delete)
        forest = []
        def helper(root, parent):
            """"""
            Delete all blacklisted nodes from the tree rooted at `root`, append all resulting
            non-empty trees to the forest, then return root (or None if the root is blacklisted).
            `parent` is the parent node of `root` (or None if it has no parent).
            """"""
            if root is None:
                return None
            
            if root.val in blacklist:
                helper(root.left, None)
                helper(root.right, None)
                return None
            
            root.left = helper(root.left, root)
            root.right = helper(root.right, root)
            if parent is None:
                forest.append(root)
            return root
                  
        helper(root_node, None)
        return forest"
maximum nesting depth of two valid parentheses strings,"class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        ans=[]
        prev=1
        for i in seq:
            if i=='(':
                if prev==0:
                    ans.append(1)
                else:
                    ans.append(0)
            else:
                ans.append(prev)
            if prev==0:
                prev=1
            else:
                prev=0
        return ans"
maximum nesting depth of two valid parentheses strings,"class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        m,c,n=0,0,len(seq)
        for i in range(n):
            if seq[i]=='(':
                c+=1
                m=max(c,m) # Here m is the maximium depth of the VPS
            elif seq[i]==')': 
                c-=1
        a=[]
        m//=2 # Minimum depth possible by breaking string in two parts A and B
        for i in range(n):
            if seq[i]=='(':
                c+=1
                if c<=m:
                    a.append(0) #For A
                else:
                    a.append(1) #For B
            else:
                if c<=m:
                    a.append(0)
                else:
                    a.append(1)
                c-=1
        return a"
relative sort array,"class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
		# initialise a dictionary since we're going to want to count the occurences of each element in arr1
        dic = {}
		# this loop populates the dictionary with the number of occurences for each element
        for elem in arr1:
            if dic.get(elem) is None:
                dic[elem] = 1
            else:
                dic[elem] = dic[elem] + 1
		# initialise a new list to store the values which exist in both arr2 and arr1
        output = []
		# populate output with the elements multiplied by their occurences (e.g. [1]*2 = [1, 1])
        for elem in arr2:
            output += [elem]*dic[elem]
		# initialise a new list to store the elements which are in arr1 but not arr2
        extra_output = []
		# populate extra_output with these elements multiplied by their occurences. 
		# Note: set(arr1)-set(arr2) provides us with the set of numbers which exist in arr1 but not in arr2
        for elem in set(arr1)-set(arr2):
            extra_output += [elem]*dic[elem]
		# return the first list and the sorted second list
        return output + sorted(extra_output)"
relative sort array,"class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        sorted_lst = []

        for x in arr2:
            while x in arr1:
                sorted_lst.append(x)
                arr1.remove(x)

        return(sorted_lst+sorted(arr1))"
lowest common ancestor of deepest leaves,"class Solution:
    def ht(self, node):
        if not node:
            return 0
        return max(self.ht(node.left), self.ht(node.right)) + 1
    
    def dfs(self, node):
        if not node:
            return None
        left, right = self.ht(node.left), self.ht(node.right)
        if left == right:
            return node
        if left > right:
            return self.dfs(node.left)
        if left < right:
            return self.dfs(node.right)

    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        return self.dfs(root)"
lowest common ancestor of deepest leaves,"class Solution:
    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root.left and not root.right:
            return root
        stk=[[-1,root,[]]]
        hp=[]
        dic={}
        heapq.heapify(hp)
        while stk:
            temp=stk.pop()
            dic[temp[1].val]=temp[1]
            heapq.heappush(hp,[temp[0],temp[1].val,temp[2]])
            new=[*temp[2],temp[1].val]
            if temp[1].left:
                stk.append([temp[0]-1,temp[1].left,new])
            if temp[1].right:
                stk.append([temp[0]-1,temp[1].right,new])
        ans=[heapq.heappop(hp)]
        while hp[0][0]==ans[-1][0]:
            ans.append(heapq.heappop(hp))
            ans[-1][2]=set(ans[-1][2])
        if len(ans)==1:
            return dic[ans[0][1]]
        for i in range(-1,-len(ans[0][2])-1,-1):
            b=True
            for j in range(1,len(ans)):
                if ans[0][-1][i] not in ans[j][-1]:
                    b=False
            if b:
                return dic[ans[0][-1][i]]
        return dic[ans[0][-1][-1]]"
longest well performing interval,"class Solution:
def longestWPI(self, hours: List[int]) -> int:
    
    dic = defaultdict(int)
    dummy = [1 if hours[0]>8 else -1]
    for h in hours[1:]:
        c = 1 if h>8 else -1
        dummy.append(dummy[-1]+c)
    
    res = 0
    for i in range(len(dummy)):
        if dummy[i]>0:
            res = max(res,i+1)
        else:
            if dummy[i]-1 in dic:
                res = max(res,i-dic[dummy[i]-1])
            if dummy[i] not in dic:
                dic[dummy[i]] = i
    
    return res"
longest well performing interval,"class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        n = len(hours)
        ans = 0
        prefix_sum = [0]*n
        d = {}
        for i in range(n):
            prefix_sum[i] = 1 if hours[i] > 8 else -1
            prefix_sum[i] += prefix_sum[i-1]
            if prefix_sum[i] > 0 : 
                ans = i + 1
            else:
                if prefix_sum[i] - 1 in d:
                    j = d[prefix_sum[i] - 1]
                    if i - j > ans: ans = i - j
            if prefix_sum[i] not in d: d[prefix_sum[i]] = i
        return ans"
smallest sufficient team,"class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        
        # Firstly, convert all the sublists in people into sets for easier processing.
        for i, skills in enumerate(people):
            people[i] = set(skills)
        
        # Remove all skill sets that are subset of another skillset, by replacing the subset with an
        # empty set. We do this rather than completely removing, so that indexes aren't 
        # disrupted (which is a pain to have to sort out later).
        for i, i_skills in enumerate(people):
            for j, j_skills in enumerate(people):
                if i != j and i_skills.issubset(j_skills):
                    people[i] = set()
        
        # Now build up a dictionary of skills to the people who can perform them. The backtracking algorithm
        # will use this.
        skills_to_people = collections.defaultdict(set)
        for i, skills in enumerate(people):
            for skill in skills:
                skills_to_people[skill].add(i)
            people[i] = set(skills)
        
        # Keep track of some data used by the backtracking algorithm.
        self.unmet_skills = set(req_skills) # Backtracking will remove and readd skills here as needed.
        self.smallest_length = math.inf # Smallest team length so far.
        self.current_team = [] # Current team members.
        self.best_team = [] # Best team we've found, i,e, shortest team that covers skills/
        
		# Here is the backtracking algorithm.
        def meet_skill(skill=0):
			# Base case: All skills are met.
            if not self.unmet_skills:
				# If the current team is smaller than the previous we found, update it.
                if self.smallest_length > len(self.current_team):
                    self.smallest_length = len(self.current_team)
                    self.best_team = self.current_team[::] # In Python, this makes a copy of a list.
                return # So that we don't carry out the rest of the algorithm.
                        
            # If this skill is already met, move onto the next one.
            if req_skills[skill] not in self.unmet_skills:
                return meet_skill(skill + 1)
				# Note return is just to stop rest of code here running. Return values
				# are not caught and used.
            
            # Otherwise, consider all who could meet the current skill.
            for i in skills_to_people[req_skills[skill]]:
                
				# Add this person onto the team by updating the backtrading data.
                skills_added_by_person = people[i].intersection(self.unmet_skills)
                self.unmet_skills = self.unmet_skills - skills_added_by_person
                self.current_team.append(i)
                
				# Do the recursive call to further build the team.
                meet_skill(skill + 1)
                
                # Backtrack by removing the person from the team again.
                self.current_team.pop()
                self.unmet_skills = self.unmet_skills.union(skills_added_by_person)
        
		# Kick off the algorithm.
        meet_skill()        
        return self.best_team"
smallest sufficient team,"class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        mp = {skill : i for i, skill in enumerate(req_skills)} # digitized skills
        
        cand = []
        for skills in people: 
            val = 0
            for skill in skills: 
                val |= 1 << mp[skill] # digitized skill
            cand.append(val)
        
        @cache
        def fn(i, mask): 
            """"""Return smallest sufficient team of people[i:] for skills in mask.""""""
            if mask == 0: return []
            if i == len(people): return [0]*100 # impossible
            if not (mask &amp; cand[i]): return fn(i+1, mask)
            return min(fn(i+1, mask), [i] + fn(i+1, mask &amp; ~cand[i]), key=len)
        
        return fn(0, (1 << len(req_skills)) - 1)"
number of equivalent domino pairs,"class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        m = collections.defaultdict(int)
        ans = 0
        for a, b in dominoes:
            if a > b: a, b = b, a
            v = 10*a + b
            if v in m:
                ans += m[v]
            m[v] += 1
        return ans"
number of equivalent domino pairs,"class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        
        #Keep track of the dominoes with a dictionary
		#counter[ DOMINO ] = COUNT
        counter = defaultdict( int );
        
        #Total will be the total number of pairs
        total = 0;
        
        #Go through all of the dominoes
        for i in range( len ( dominoes ) ):
            #Check the pair at the index
            pair = dominoes[ i ];
            
            #Pull the two values
            first = pair[ 0 ];
            second = pair[ 1 ];
            
            #Sort them by value
			#This way, the reversed matches will go into the same count
            smaller = min ( first, second );
            bigger = max( first, second );
            
            #Reassemble into tuple
			#This will act as our key for each domino
            pair_sorted = ( smaller, bigger );
            
            #If the current domino is already in our counter
            #Add to the total the previous matches
            
            #That is
            #If we have already added matching dominoes
            #Our current one will match with all the previous
            if pair_sorted in counter:
                total += counter[ pair_sorted ];
            
            #Lastly, we increment the count of the current
            counter [ pair_sorted ] += 1;
            
            
        return total;"
shortest path with alternating colors,"class Solution:
    def shortestAlternatingPaths(self, n, red_edges, blue_edges):
        neighbors = [[[], []] for _ in range(n)]
        ans = [[0, 0]]+[[2*n, 2*n] for _ in range(n-1)]
        for u, v in red_edges: neighbors[u][0].append(v)
        for u, v in blue_edges: neighbors[u][1].append(v)
        
        def dfs(u, c, dist):
            for v in neighbors[u][c]:
                if dist+1<ans[v][c]:
                    ans[v][c] = dist+1
                    dfs(v, 1-c, dist+1)
                    
        dfs(0, 0, 0)
        dfs(0, 1, 0)
        return [x if x<2*n else -1 for x in map(min, ans)]"
shortest path with alternating colors,"class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:
        edges = {0: defaultdict(list), 1: defaultdict(list)}
        
        for src,dest in redEdges:
            edges[0][src].append(dest)
        
        for src,dest in blueEdges:
            edges[1][src].append(dest)
            
            
        queue,result1, result2 = [(0,0,0),(0,1,0)], [float(""inf"")]*n, [float(""inf"")]*n
        
        result1[0], result2[0] = 0, 0
        while queue:
            node, direction, distance = queue.pop(0)
            for neighbour in edges[direction][node]:
                if direction and result2[neighbour] > distance + 1:
                    result2[neighbour] = 1 + distance
                    queue.append((neighbour, 1 - direction, 1 + distance))
                elif not direction and result1[neighbour] > distance + 1:
                    result1[neighbour] = 1 + distance
                    queue.append((neighbour, 1 - direction, 1 + distance))
                    
                        
            
            
        for i in range(n):
            result1[i] = min(result1[i], result2[i])
            if result1[i] == float(""inf""):
                result1[i] = -1
        
        return result1"
minimum cost tree from leaf values,"class Solution:
def mctFromLeafValues(self, arr: List[int]) -> int:
    
    arr = [float('inf')] + arr + [float('inf')]
    n, res = len(arr), 0
    
    while n>3:
        mi = min(arr)
        ind = arr.index(mi)
        
        if arr[ind-1]<arr[ind+1]:
            res+=arr[ind-1]*arr[ind]
        else:
            res+=arr[ind+1]*arr[ind]
        
        arr.remove(mi)
        n = len(arr)
    
    return res"
minimum cost tree from leaf values,"class Solution:
    def mctFromLeafValues(self, arr: List[int]) -> int:
        ans = 0
        while len(arr) > 1: 
            i = arr.index(min(arr))
            ans += arr.pop(i)*min(arr[max(0,i-1):i+1])
        return ans"
maximum of absolute value expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        minA = minB = minC = minD = math.inf
        maxA = maxB = maxC = maxD = -math.inf

        for i, (num1, num2) in enumerate(zip(arr1, arr2)):
            minA = min(minA, i + num1 + num2)
            maxA = max(maxA, i + num1 + num2)
            minB = min(minB, i + num1 - num2)
            maxB = max(maxB, i + num1 - num2)
            minC = min(minC, i - num1 + num2)
            maxC = max(maxC, i - num1 + num2)
            minD = min(minD, i - num1 - num2)
            maxD = max(maxD, i - num1 - num2)
        
        return max(maxA - minA, maxB - minB,
                   maxC - minC, maxD - minD)"
maximum of absolute value expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        '''
        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|
        total 2(+ or -)**(no. of modules) == 2**3 cases

        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j
            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)

        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j
            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)
        
        ...etc
        '''
        val1,val2,val3,val4=[],[],[],[]
        for i in range(len(arr1)):
            val1.append(i+arr1[i]+arr2[i])
            val2.append(i+arr1[i]-arr2[i])
            val3.append(i-arr1[i]+arr2[i])
            val4.append(i-arr1[i]-arr2[i])
        ans=0
        ans=max(ans,max(val1)-min(val1))
        ans=max(ans,max(val2)-min(val2))
        ans=max(ans,max(val3)-min(val3))
        ans=max(ans,max(val4)-min(val4))
        return ans"
n th tribonacci number,"class Solution:
    def tribonacci(self, n: int) -> int:
    	a, b, c = 0, 1, 1
    	for i in range(n): a, b, c = b, c, a + b + c
    	return a
		
		
- Junaid Mansuri"
n th tribonacci number,"class Solution(object):
    def sol(self, n, dp):
        if n == 0: return 0
        if n == 1 or n == 2: return 1
        if dp[n] != 0: return dp[n]
        dp[n] = self.sol(n - 1, dp) + self.sol(n - 2, dp) + self.sol(n - 3, dp)
        return dp[n]
    def tribonacci(self, n):
        dp = [0] * (n + 1)
        return self.sol(n, dp)"
alphabet board path,"class Solution:
    def __init__(self):
        board = [""abcde"", ""fghij"", ""klmno"", ""pqrst"", ""uvwxy"", ""z""]
        self.d = {c:(i, j) for i, row in enumerate(board) for j, c in enumerate(row)}
                
    def alphabetBoardPath(self, target: str) -> str:
        ans, prev = '', (0, 0)
        for c in target:
            cur = self.d[c]
            delta_x, delta_y = cur[0]-prev[0], cur[1]-prev[1]
            h = 'R'*delta_y if delta_y > 0 else 'L'*(-delta_y)                    
            v = 'D'*delta_x if delta_x > 0 else 'U'*(-delta_x)                    
            ans += (h+v if cur == (5,0) else v+h) + '!'
            prev = cur
        return ans"
alphabet board path,"class Solution:
    def alphabetBoardPath(self, target: str) -> str:
        
        # Map row and column for all characters
        board = [""abcde"", ""fghij"", ""klmno"", ""pqrst"", ""uvwxy"", ""z""]       
        map_row = {char: r for r, characters in enumerate(board) for c, char in enumerate(characters)}
        map_col = {char: c for r, characters in enumerate(board) for c, char in enumerate(characters)}
                
        res = []
        r = c = 0
        for char in target:
            target_r, target_c = map_row[char], map_col[char]

            if r != target_r or c != target_c:
                if r == 5 and c == 0: # special case: if at 'z', can only move up
                    res.append('U')
                    r -= 1
                    
				# Go to target column
                hori_move = abs(target_c - c)
                res.append('R' * hori_move if c < target_c else 'L' * hori_move)
                if c > target_c: 
                    hori_move *= -1
                c += hori_move
                          
				# Go to target row
                verti_move = abs(target_r - r)
                res.append('D' * verti_move if r < target_r else 'U' * verti_move)
                if r > target_r:  verti_move *= -1   
                r += verti_move
                    
            res.append('!')
        
        return ''.join(res)"
largest 1 bordered square,"class Solution:
    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[(0, 0)] * (n) for _ in range((m))] 
        for i in range(m):                      # calculate prefix-sum as `hint` section suggested
            for j in range(n):
                if not grid[i][j]:
                    continue
                dp[i][j] = (dp[i][j][0] + dp[i-1][j][0] + 1, dp[i][j][1] + dp[i][j-1][1] + 1)
        for win in range(min(m, n)-1, -1, -1):  # for each window size
            for i in range(m-win):              # for each x-axis
                for j in range(n-win):          # for each y-axis
                    if not grid[i][j]: continue # determine whether square of (i, j), (i+win, j+win) is 1-boarded
                    x1, y1 = dp[i+win][j+win]   # bottom-right corner
                    x2, y2 = dp[i][j+win]       # upper-right corner
                    x3, y3 = dp[i+win][j]       # bottom-left corner
                    x4, y4 = dp[i][j]           # upper-left corner
                    if y1 - y3 == x1 - x2 == y2 - y4 == x3 - x4 == win:
                        return (win+1) * (win+1)
        return 0"
largest 1 bordered square,"class Solution:
    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        
        width = len(grid[0])
        height = len(grid)
        
        dp = [[(0, 0)] * width for x in range(height)]
        
        max_len = 0
        for i in range(height):
            for j in range(width):
                if grid[i][j] == 0:
                    dp[i][j] == (0, 0)
                else:
                    if max_len == 0: max_len = 1
                    if i == 0 and j == 0: 
                        dp[i][j] = (1, 1)
                    elif i == 0:
                        dp[i][j] = (1, dp[i][j-1][1] + 1)
                    elif j == 0:
                        dp[i][j] = (dp[i-1][j][0] + 1, 1)
                    else:
                        dp[i][j] = (dp[i-1][j][0] + 1, dp[i][j-1][1] + 1) # height and width
                        for k in range(max_len, min(dp[i][j])): # k+1 is side length of the square
                            if dp[i-k][j][1] >= k + 1 and dp[i][j-k][0] >= k + 1:
                                max_len = k+1
        #print(dp)
        return max_len * max_len"
stone game ii,"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        suffix_sum = self._suffix_sum(piles)

        @lru_cache(None)
        def dfs(pile: int, M: int, turn: bool) -> Tuple[int, int]:
            # turn: true - alex, false - lee
            sum_alex, sum_lee = suffix_sum[pile], suffix_sum[pile]

            for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):
                sum_alex_next, sum_lee_next = dfs(
                    next_pile, max(M, next_pile - pile), not turn
                )
                range_sum = suffix_sum[pile] - suffix_sum[next_pile]

                if turn:
                    if sum_lee_next < sum_lee:
                        sum_alex = sum_alex_next + range_sum
                        sum_lee = sum_lee_next
                else:
                    if sum_alex_next < sum_alex:
                        sum_alex = sum_alex_next
                        sum_lee = sum_lee_next + range_sum

            return sum_alex, sum_lee

        return dfs(0, 1, True)[0]"
stone game ii,"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        suffix_sum = self._suffix_sum(piles)

        @lru_cache(None)
        def dfs(pile: int, M: int) -> int:
            sum_next_player = suffix_sum[pile]

            for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):
                sum_next_player = min(
                    sum_next_player, dfs(next_pile, max(M, next_pile - pile))
                )

            sum_player = suffix_sum[pile] - sum_next_player

            return sum_player

        return dfs(0, 1)"
longest common subsequence,"class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        
        dp = []
        
        # Fill the matrix
        for _ in range(len(text1)+1):
            row = []
            for _ in range(len(text2)+1):
                row.append(0)
            
            dp.append(row)
        
        
        longest_length = 0
        
        # Start looping throught the text1 and text2
        for i in range(1, len(text1)+1):
            for j in range(1, len(text2)+1):
                
                # If characters match
				# fill the current cell by adding one to the diagonal value
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    # If characters do not match
					# Fill the cell with max value of previous row and column
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                
                # Keep track of the MAXIMUM value in the matrix
                longest_length = max(longest_length, dp[i][j])
        
        return longest_length"
longest common subsequence,"class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n = len(text1)
        m = len(text2)
        dp = [[-1 for i in range(m+1)] for i in range(n+1)]
        
        for j in range(m+1):
            dp[0][j] = 0
            
        for i in range(n+1):
            dp[i][0] = 0    
            
        for ind1 in range(1,n+1):
            for ind2 in range(1,m+1):
                if(text1[ind1-1] == text2[ind2-1]):
                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1]
                else:
                    dp[ind1][ind2] = max(dp[ind1-1][ind2],dp[ind1][ind2-1])
        return dp[n][m]"
decrease elements to make array zigzag,"class Solution:
    def movesToMakeZigzag(self, nums: List[int]) -> int:
        def greedy(nums, small_first=True):
            if n <= 1: return 0
            ans = 0
            for i in range(n-1):
                if small_first and nums[i] >= nums[i+1]:
                    ans += nums[i] - (nums[i+1]-1)
                    nums[i] = nums[i+1] - 1
                elif not small_first and nums[i] <= nums[i+1]:
                    ans += nums[i+1] - (nums[i]-1)
                    nums[i+1] = nums[i] - 1
                small_first = not small_first
            return ans    
        n = len(nums)
        return min(greedy(nums[:], True), greedy(nums[:], False))"
decrease elements to make array zigzag,"class Solution:
    def solve(self,arr,n,x):
        idx = 1
        ans = 0
        while idx < n:
            if idx == 0: idx += 1
            if idx % 2 == x:
                if arr[idx-1] >= arr[idx]:
                    ans += arr[idx-1] - arr[idx] + 1
                    arr[idx-1] = arr[idx] - 1
                    idx = idx-1
                else:
                    idx = idx+1
            else:
                if arr[idx-1] <= arr[idx]:
                    ans += arr[idx] - arr[idx - 1] + 1
                    arr[idx] = arr[idx-1] - 1
                idx += 1               
        return ans
    
    def movesToMakeZigzag(self, nums: List[int]) -> int:
        ans1 = self.solve([x for x in nums],len(nums),0)
        ans2 = self.solve([x for x in nums],len(nums),1)
        return min(ans1,ans2)"
binary tree coloring game,"class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:
        first = None
        def count(node):
            nonlocal first
            total = 0
            if node: 
                if node.val == x: first = node
                total += count(node.left) + count(node.right) + 1
            return total
        
        s = count(root) # Get total number of nodes, and x node (first player's choice)
        l = count(first.left) # Number of nodes on left branch 
        r = count(first.right) # Number of nodes on right branch 
        p = s-l-r-1 # Number of nodes on parent branch (anything else other than node, left subtree of node or right subtree of node)
        return l+r < p or l+p < r or r+p < l"
binary tree coloring game,"class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:
        l = r = 0
        def count(node):
            nonlocal l, r
            total = 0
            if node: 
                l_count, r_count = count(node.left), count(node.right)
                if node.val == x: 
                    l, r = l_count, r_count
                total += l_count + r_count + 1
            return total
        s = count(root) 
        p = s-l-r-1 
        return l+r < p or l+p < r or r+p < l"
longest chunked palindrome decomposition,"class Solution:
    def longestDecomposition(self, text: str) -> int:
        
		# Used a prime number generator on the internet to grab a prime number to use.
        magic_prime = 32416189573
        
		# Standard 2 pointer technique variables.
        low = 0
        high = len(text) - 1
        
		# These are the hash tracking variables.
		cur_low_hash = 0
        cur_high_hash = 0
        cur_hash_length = 0
        
		# This is the number of parts we've found, i.e. the k value we need to return.
		k = 0
        
        while low < high:
            
			# To put the current letter onto our low hash (i.e. the one that goes forward from
			# the start of the string, we shift up the existing hash by multiplying by the base
			# of 26, and then adding on the new character by converting it to a number from 0 - 25.
            cur_low_hash *= 26 # Shift up by the base of 26.
            cur_low_hash += ord(text[low]) - 97 # Take away 97 so that it's between 0 and 25.
            
			
			# The high one, i.e. the one backwards from the end is a little more complex, as we want the 
			# hash to represent the characters in forward order, not backwards. If we did the exact same
			# thing we did for low, the string abc would be represented as cba, which is not right.	
			
			# Start by getting the character's 0 - 25 number.
			high_char = ord(text[high]) - 97
			
			# The third argument to pow is modular arithmetic. It says to give the answer modulo the
			# magic prime (more on that below). Just pretend it isn't doing that for now if it confuses you. 
            # What we're doing is making an int that puts the high character at the top, and then the 
			# existing hash at the bottom.
			cur_high_hash = (high_char * pow(26, cur_hash_length, magic_prime)) + cur_high_hash            
            
			# Mathematically, we can safely do this. Impressive, huh? I'm not going to go into here, but
			# I recommend studying up on modular arithmetic if you're confused.
			# The algorithm would be correct without doing this, BUT it'd be very slow as the numbers could
			# become tens of thousands of bits long. The problem with that of course is that comparing the
			# numbers would no longer be O(1) constant. So we need to keep them small.
			cur_low_hash %= magic_prime 
            cur_high_hash %= magic_prime
            
			# And now some standard 2 pointer technique stuff.
            low += 1
            high -= 1
            cur_hash_length += 1
            
			# This piece of code checks if we currently have a match.
            # This is actually probabilistic, i.e. it is possible to get false positives.
            # For correctness, we should be verifying that this is actually correct.
            # We would do this by ensuring the characters in each hash (using
			# the low, high, and length variables we've been tracking) are
			# actually the same. But here I didn't bother as I figured Leetcode
			# would not have a test case that broke my specific prime.
			if cur_low_hash == cur_high_hash:
                k += 2 # We have just added 2 new strings to k.
                # And reset our hashing variables.
				cur_low_hash = 0
                cur_high_hash = 0
                cur_hash_length = 0
        
		# At the end, there are a couple of edge cases we need to address....
		# The first is if there is a middle character left.
		# The second is a non-paired off string in the middle.
        if (cur_hash_length == 0 and low == high) or cur_hash_length > 0:
            k += 1
        
        return k"
longest chunked palindrome decomposition,"class Solution:
    def longestDecomposition(self, text: str) -> int:
        n=len(text)-1
        dp=[[-1 for i in range(n+1)] for j in range(n+1)]
        def dfs(start,end):
            if start>end:
                return 0
            if dp[start][end]!=-1:
                return dp[start][end]
            best=1
            l,r=start,end
            mid=(r+l)//2
            while r>mid:
                chunk=end-r+1
                if text[l:l+chunk]==text[r:end+1]:
                    val=dfs(l+chunk,r-1)+2
                    best=max(best,val)
                r-=1
            dp[start][end]=best
            return dp[start][end]
        return dfs(0,n)"
day of the year,"class Solution:
    def dayOfYear(self, date: str) -> int:
        y, m, d = map(int, date.split('-'))
        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        if (y % 400) == 0 or ((y % 4 == 0) and (y % 100 != 0)): days[1] = 29
        return d + sum(days[:m-1])"
day of the year,"class Solution:
    def dayOfYear(self, date: str) -> int:
        year, month, day = date.split('-')
        
        year = int(year)
        month = int(month)
        day = int(day)
        
        isleapYear = (year % 4 == 0 and year % 100 != 0) or year % 400 == 0
        cnt = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        
        if isleapYear:
            cnt[1] = cnt[1] + 1
        
        ans = 0
        for i in range(month-1):
            ans += cnt[i]
        
        return ans + day"
number of dice rolls with target sum,"class Solution:
    def numRollsToTarget(self, d: int, f: int, target: int) -> int:
        if d*f < target: return 0        # Handle special case, it speed things up, but not necessary
        elif d*f == target: return 1     # Handle special case, it speed things up, but not necessary
        mod = int(10**9 + 7)
        dp = [[0] * (target+1) for _ in range(d+1)] 
        for j in range(1, min(f+1, target+1)): dp[1][j] = 1
        for i in range(2, d+1):
            for j in range(1, target+1):
                for k in range(1, f+1):
                    if j - k >= 0: dp[i][j] += dp[i-1][j-k]
                dp[i][j] %= mod        
        return dp[-1][-1]"
number of dice rolls with target sum,"class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        modulo = 10**9+7

        @lru_cache(None)
        def dp(dice_left: int, target_left: int) -> int:
            if dice_left == 0:
                if target_left == 0:
                    return 1
                return 0
            res = 0
            for i in range(1, k+1):
                res += dp(dice_left-1, target_left-i)
                res %= modulo
            return res % modulo

        return dp(n, target)"
swap for longest repeated character substring,"class Solution:
    def maxRepOpt1(self, text: str) -> int:
        first_occurence,last_occurence = {},{}
        ans,prev,count = 1,0,0
        n = len(text)
        
        for i in range(n):
            if text[i] not in first_occurence: first_occurence[text[i]] = i
            last_occurence[text[i]] = i
            
        for i in range(n+1):
            if i < n and text[i] == text[prev]:
                count += 1
            else:
                if first_occurence[text[prev]] < prev or last_occurence[text[prev]] > i : count += 1
                ans = max(ans,count)
                count = 1
                prev = i
        
        def someWork(item,before,after):
            count = 0
            while before >= 0 and text[before] == item: 
                count += 1
                before -= 1
            while after < n and text[after] == item:
                count += 1
                after += 1
            if first_occurence[item] <= before or last_occurence[item] >= after:count+=1
            return count
        
        for i in range(1,n-1):
            ans = max(ans,someWork(text[i+1],i-1,i+1))
        return ans"
swap for longest repeated character substring,"class Solution:
    def maxRepOpt1(self, text: str) -> int:
        freq = {}
        for ch in text:
            freq[ch] = freq.get(ch, 0)+1
        
        n=len(text)
        i=0
        distinct = 0
        cur={}
        def include(ind):
            nonlocal distinct
            ch = text[ind]
            cur[ch] = cur.get(ch,0)+1
            if cur[ch] == 1:
                distinct+=1 
        def exclude(ind):
            nonlocal distinct
            ch = text[ind]
            cur[ch]-=1
            if cur[ch]==0:
                cur.pop(ch)
                distinct-=1
        for j in range(n):
            #expansion
            include(j)

            if distinct >= 3:
                #movement
                exclude(i)
                i+=1
                continue
            if distinct == 2:
                keys = list(cur.keys())
                a,b = keys[0], keys[1]
                if cur[a] == 1 or cur[b] == 1:
                    if cur[a] == 1:
                        if freq[b] == cur[b]:
                            exclude(i)
                            i+=1
                    else:
                        if freq[a] == cur[a]:
                            exclude(i)
                            i+=1
                else:
                    exclude(i)
                    i+=1
        return n-i"
find words that can be formed by characters,"class Solution:
#     O(n^2) || O(1)
# Runtime: 96ms 97.20% Memory: 14.5mb 84.92%
    def countCharacters(self, words: List[str], chars: str) -> int:
        ans=0
        for word in words:
            for ch in word:
                if word.count(ch)>chars.count(ch):
                    break
            else:
                ans+=len(word)
        
        return ans"
find words that can be formed by characters,"class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        return sum(len(word) if collections.Counter(word) <= collections.Counter(chars) else 0 for word in words)"
maximum level sum of a binary tree,"class Solution:
    def maxLevelSum(self, root: TreeNode) -> int:
        
        queue = deque() #init a queue for storing nodes as we traverse the tree
        queue.append(root) #first node (level = 1) inserted
        
        #bfs = []  #just for understanding- this will be a bfs list to store nodes as we conduct the search, but we don't need it here.
        
        level_sum = 0 # for sum of each level
        level_nodes = 1 # for knowing when a particular level has ended
        
        sum_of_levels = [] #list to store all levels sum of nodes
        
        while queue: #begin BFS
            node = queue.popleft() 
            #bfs.append(node)
            level_sum += node.val #add node 
            
            if node.left:
                queue.append(node.left)
            
            if node.right:
                queue.append(node.right)
            
            level_nodes -= 1   #reduce level number by 1, as we popped out a node
            if level_nodes == 0: # if 0, then a level has ended, so calculate the sum
                sum_of_levels.append(level_sum)
                level_sum = 0
                level_nodes = len(queue)
        
        return sum_of_levels.index(max(sum_of_levels)) + 1  #return index of max level sum"
maximum level sum of a binary tree,"class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        def dfs(node, level):
            if not node:
                return
            
            sums[level] += node.val                
            dfs(node.left, level + 1)
            dfs(node.right, level +1 )
        
        sums = defaultdict(int)
        dfs(root, 1)
        
        result = 1
        max_sum = sums[1]
        for level, s in sums.items():
            if s > max_sum:
                max_sum = s
                result = level
        
        return result"
as far from land as possible,"class Solution:
    def maxDistance(self, grid: List[List[int]]) -> int:
        
		# The # of rows and # of cols
        M, N, result = len(grid), len(grid[0]), -1
        
		# A list of valid points
        valid_points = {(i, j) for i in range(M) for j in range(N)}
        
		# A double-ended queue of ""land"" cells
        queue = collections.deque([(i, j) for i in range(M) for j in range(N) if grid[i][j] == 1])
        
        # Check if all land, or all water, an edge case
        if len(queue) == M*N or len(queue) == 0:
            return -1
        
		# BFS
        while queue:
			
			# One iteration here
            for _ in range(len(queue)):
                i, j = queue.popleft()
                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                    if (x, y) not in valid_points: continue
                    if grid[x][y] == 1: continue 
                    queue.append((x, y))
                    grid[x][y] = 1 # We mark water cells as land to avoid visiting them again
                    
			# Increase the iteration/result count
            result += 1
            
        return result"
as far from land as possible,"class Solution:
    def maxDistance(self, grid: List[List[int]]) -> int:
        n = len(grid)
        queue = []
        vist = [[False for i in range(n)] for j in range(n)] 
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    queue.append((i,j,0))
                    vist[i][j] = True
        ans = 0
        while queue:
            r,c,d = queue.pop(0)
            if grid[r][c] == 0 :ans = max(ans,d)
            for x,y in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):
                if 0 <= x < n and 0 <= y < n and vist[x][y] == False:
                    vist[x][y] = True
                    queue.append((x,y,d+1))
        return ans if ans != 0 else -1"
last substring in lexicographical order,"class Solution:
    def lastSubstring(self, s: str) -> str:
    	S, L, a = [ord(i) for i in s] + [0], len(s), 1
    	M = max(S)
    	I = [i for i in range(L) if S[i] == M]
    	if len(I) == L: return s
    	while len(I) != 1:
    		b = [S[i + a] for i in I]
    		M, a = max(b), a + 1
    		I = [I[i] for i, j in enumerate(b) if j == M]
    	return s[I[0]:]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
last substring in lexicographical order,"class Solution:
    def lastSubstring(self, s: str) -> str:
        n = len(s)
        cmax = max(s)
        indexes = [ i for i,c in enumerate(s) if c == cmax ]
        gap = 1
        while len(indexes) > 1:
            new_indexes = []
            cmax = max(s[i+gap] for i in indexes if i+gap < n)
            for i,st in enumerate(indexes):
                if i > 0 and indexes[i-1] + gap == st: continue
                if st + gap < n and s[st + gap] == cmax:new_indexes.append(st)
            indexes = new_indexes
            gap += 1
        return s[indexes[0]:]"
invalid transactions,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        invalid = []
        
        for i, t1 in enumerate(transactions):
            name1, time1, amount1, city1 = t1.split(',')
            if int(amount1) > 1000:
                invalid.append(t1)
                continue
            for j, t2 in enumerate(transactions):
                if i != j: 
                    name2, time2, amount2, city2 = t2.split(',')
                    if name1 == name2 and city1 != city2 and abs(int(time1) - int(time2)) <= 60:
                        invalid.append(t1)
                        break
        
        return invalid"
invalid transactions,"class Solution:
    def invalidTransactions(self, transactions: List[str]) -> List[str]:
        hashmap = {}
		#Hashset is used to skip redudant transactions being added to the result
		#We will only store index of the transaction because the same transaction can repeat.
        result = set()
        for i, t in enumerate(transactions):
            name, time, amount, city =  t.split("","")
			#If there is no transaction record for the user
            if name not in hashmap:
                hashmap[name] = []
                if int(amount) > 1000:
                    result.add(i)
			#If there are pass transaction records
            else:
				#Fetching past transaction from hashmap
                prevTrans = hashmap[name]
				#Iterating over the past transaction of the user and finding anomalies
                for j in range(len(prevTrans)):
                    prevName, prevTime, prevAmount, prevCity = transactions[prevTrans[j]].split("","")
                    #Checking whether the amount exceeds $1000
					if int(amount) > 1000:
                        result.add(i)
					#Checking whether it occurs within (and including) 60 minutes of another transaction with the same name in a different city.
                    if abs(int(time) - int(prevTime)) <= 60 and city != prevCity:
                        result.add(i)
                        result.add(prevTrans[j])
			#Recording transaction in the hashmap for the user
            hashmap[name].append(i)
		
		#Fetching transaction using indexes stored in the result set and returning
        return [transactions[t] for t in result]"
compare strings by frequency of the smallest character,"class Solution:
	def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
		def f(s):
			t = sorted(list(s))[0]
			return s.count(t)
		query = [f(x) for x in queries]
		word = [f(x) for x in words]
		m = []
		for x in query:
			count = 0
			for y in word:
				if y>x:
					count+=1
			m.append(count)
		return m"
compare strings by frequency of the smallest character,"class Solution:
    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
        def f(x):
            return x.count(min(x))

        ans = []
        
        for i in queries:
            count = 0
            for j in words:
                if(f(i) < f(j)):
                    count += 1
            
            ans.append(count)
        
        return ans"
remove zero sum consecutive nodes from linked list,"class Solution:
	def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:

		dummy = ListNode(0,head)
		pre = 0
		dic = {0: dummy}

		while head:
			pre+=head.val
			dic[pre] = head
			head = head.next

		head = dummy
		pre = 0
		while head:
			pre+=head.val
			head.next = dic[pre].next
			head = head.next

		return dummy.next"
remove zero sum consecutive nodes from linked list,"class Solution:
    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fake = ListNode(0, head)
        
        d = {0: fake}
        
        prefix_sum = 0
        while head:
            prefix_sum += head.val
            d[prefix_sum] = head
            head = head.next
            
        head = fake
        prefix_sum = 0
        while head:
            prefix_sum += head.val
            head.next = d[prefix_sum].next
            head = head.next
            
        return fake.next"
prime arrangements,"class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        # find number of prime indices
        # ways to arrange prime indices
        # is prime indices factorial
        # amount of non-prime indices is
        # n - prime indices 
        # the factorial of non - prime indices
        # times the factorial of prime indices
        # is the amount of ways to arrange the 
        # prime numbers and i be valid 
        # use helper to find factorial of a number
        # use helper to see if a number is prime
        # time O(n ^ 2) space O(1)

        def isPrime(num):
            if num <= 1:
                return False
            for i in range(2, num // 2 + 1):
                if num % i == 0:
                    return False
            return True

        def factorial(num):
            res = 1
            for i in range(1, num + 1):
                res *= i
            return res
        
        primes = 0
        for num in range(1, n + 1):
            if isPrime(num):
                primes += 1
        return int(factorial(primes) * factorial(n - primes) % (10**9 + 7))"
prime arrangements,"class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        if n <= 2:
            return 1

        primesList = [False]*2 + [True]*(n - 1)
        for i in range(2, math.floor(math.sqrt(n)) + 1):
            if not primesList[i]:
                continue
            for j in range(i * i, n + 1, i):
                primesList[j] = False
        
        primes = sum(primesList)    
        return (math.factorial(primes) * math.factorial(n - primes)) % (10 ** 9 + 7)"
can make palindrome from substring,"class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        prefix = [[0]*26]
        for c in s: 
            elem = prefix[-1].copy()
            elem[ord(c)-97] += 1
            prefix.append(elem)
        
        ans = []
        for left, right, k in queries: 
            cnt = sum(1&amp;(prefix[right+1][i] - prefix[left][i]) for i in range(26))
            ans.append(cnt <= 2*k+1)
        return ans"
can make palindrome from substring,"class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for c in s: 
            prefix.append(prefix[-1] ^ (1 << (ord(c)-97)))
        
        ans = []
        for left, right, k in queries: 
            cnt = bin(prefix[right+1] ^ prefix[left]).count(""1"")
            ans.append(cnt <= 2*k+1)
        return ans"
number of valid words for each puzzle,"class Solution:
    def mask(self, word: str) -> int:
        result = 0
        for ch in word:
            result |= 1 << (ord(ch)-ord('a'))
        return result

    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
        word_count = Counter(self.mask(word) for word in words)
        result = []
        for puzzle in puzzles:
            original_mask, first = self.mask(puzzle[1:]), self.mask(puzzle[0])
            curr_mask, count = original_mask, word_count[first]
            while curr_mask:
                count += word_count[curr_mask|first]
                curr_mask = (curr_mask-1)&amp;original_mask
            result.append(count)
        return result"
number of valid words for each puzzle,"class Solution:
    def gen_combinations(self, word):
        if not word:
            yield 0
        else:
            c = word.pop()
            for v in self.gen_combinations(word):
                yield v
                yield v | (1 << (ord(c) - ord('a')))
            
    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
        table = defaultdict(Counter)
        for w in words:
            chars = set(list(w)) 
            if len(chars) > 7:
                continue
            h = reduce(operator.or_, [1 << (ord(c) - ord('a')) for c in chars], 0)
            for c in chars:
                table[c][h] += 1
        for i, p in enumerate(puzzles):
            puzzles[i] = sum(table[p[0]][h] for h in self.gen_combinations(list(p)))
        return puzzles"
distance between bus stops,"class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        a, b = min(start, destination), max(start, destination)
        return min(sum(distance[a:b]), sum(distance) - sum(distance[a:b]))"
distance between bus stops,"class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        if start > destination:
            start, destination =  destination, start
        
        d1 = sum(distance[start: destination])
        d2 = sum(distance[:start]) + sum(distance[destination:])
        
        return min(d1, d2)"
day of the week,"class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        prev_year = year - 1
        days = prev_year * 365 + prev_year // 4 - prev_year // 100 + prev_year // 400
        days += sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:month - 1])
        days += day

        if month > 2 and ((year % 4 == 0 and year % 100 != 0) or year % 400 == 0):
            days += 1

        return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][days % 7]"
day of the week,"class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        
        def fn(y, m, d): 
            """"""Return year-month-day in number format.""""""
            if m < 3: 
                y -= 1
                m += 12
            return 365*y + y//4 - y//100 + y//400 + (153*m + 8)//5 + d
        
        weekday = (""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday"")
        return weekday[(fn(year, month, day) - fn(2021, 4, 11)) % 7]"
maximum subarray sum with one deletion,"class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        n = len(arr)
        #maximum subarray starting from the last element i.e. backwards 
        prefix_sum_ending = [float('-inf')]*n
        #maximum subarray starting from the first element i.e forwards
        prefix_sum_starting = [float('-inf')]*n
        prefix_sum_ending[n-1] = arr[n-1]
        prefix_sum_starting[0] = arr[0]
        
        for i in range(1,n):
            prefix_sum_starting[i] = max(prefix_sum_starting[i-1]+arr[i], arr[i])
        for i in range(n-2,-1,-1):
            prefix_sum_ending[i] = max(prefix_sum_ending[i+1]+arr[i], arr[i])
           
        max_without_deletion = max(prefix_sum_starting)
        max_with_deletion = float('-inf')
        for i in range(1,n-1):
            max_with_deletion = max(max_with_deletion, prefix_sum_starting[i-1]+prefix_sum_ending[i+1])
            
        return max(max_without_deletion, max_with_deletion)"
maximum subarray sum with one deletion,"class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        ans = d0 = d1 = -inf # delete 0 &amp; delete 1 element
        for x in arr:
            d0, d1 = max(x, x + d0), max(d0, x + d1)
            ans = max(ans, d0, d1)
        return ans"
make array strictly increasing,"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        arr2.sort()
        
        @cache
        def fn(i, prev): 
            """"""Return min ops to make arr1[i:] increasing w/ given previous element.""""""
            if i == len(arr1): return 0 
            ans = inf 
            if (prev < arr1[i]): ans = fn(i+1, arr1[i])
            k = bisect_right(arr2, prev)
            if k < len(arr2): ans = min(ans, 1 + fn(i+1, arr2[k]))
            return ans 
        
        ans = fn(0, -inf)
        return ans if ans < inf else -1"
make array strictly increasing,"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        n1 , n2, dp = len(arr1) , len(arr2) , {}
        arr2.sort()
        
        def solve(i , j , prev):
            
            if i == n1:return 0
            
            if (i,j,prev) in dp: return dp[(i,j,prev)]
            
            k = bisect.bisect_right(arr2[j:],prev) + j
        
            ans = float('inf') if k == n2 else solve(i+1,k+1,arr2[k]) + 1
            
            if arr1[i] > prev:ans = min(ans,solve(i+1 , j ,arr1[i]))
            
            dp[(i,j,prev)] = ans
            
            return ans
        
        
        ans = solve(0,0,-float('inf'))
        
        return ans if ans != float('inf') else -1"
maximum number of balloons,"class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        c = collections.Counter(text)
        return min(c['b'],c['a'],c['l']//2,c['o']//2,c['n'])"
maximum number of balloons,"class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        b = a = l = o = n = 0
        for i in text:
            if i == 'b': b += 1
            elif i == 'a': a += 1
            elif i == 'l': l += 1
            elif i == 'n': n += 1
            elif i == 'o': o += 1
        count = 0
        while b and a and l and o and n:
            if b and a and l - 1 and o - 1 and n:
                count += 1
                b =- 1
                a -= 1
                l -= 2
                o -= 2
                n -= 1
            else: break
        return count"
reverse substrings between each pair of parentheses,"class Solution:
    def reverseParentheses(self, s: str) -> str:
        def solve(string):
            n = len(string)
            word = """"
            i = 0
            while i <n:
                if string[i] == '(':
                    new = """"
                    count = 0
                    while True:
                        count += 1 if string[i] == '(' else -1 if string[i] == ')' else 0
                        if count == 0: break
                        new += string[i]
                        i += 1
                    i += 1
                    word += solve(new[1:])
                else:
                    word += string[i]
                    i += 1
            return word[::-1]
        return solve(s)[::-1]"
reverse substrings between each pair of parentheses,"class Solution:
    def reverseParentheses(self, s: str) -> str:
        stack = []
        for i in s:
            if i == ')':
                tmp = """"
                while stack[-1] != '(':
                    tmp += stack.pop()
                stack.pop()
                for j in tmp: stack.append(j)
            else:
                stack.append(i)
        return """".join(stack)"
k concatenation maximum sum,"class Solution:
    def kadane(self, nums):
        for i in range(1, len(nums)):
            if nums[i-1] > 0:
                nums[i] += nums[i-1]
        return max(max(nums), 0)
    
    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
        sums = sum(arr)
        mod = 10**9 + 7
        if k == 1:
            return self.kadane(arr) % (mod)
        if sums > 0:
            return (self.kadane(arr+arr) + (k-2)*sums) % (mod)
        else:
            return self.kadane(arr+arr) % (mod)"
k concatenation maximum sum,"class Solution:
    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
        rsm = val = 0 
        sm = sum(arr)
        if k > 1: arr *= 2
        for x in arr: 
            val = max(0, val + x)
            rsm = max(rsm, val)
        return max(rsm, rsm + max(0, k-2)*sm) % 1_000_000_007"
critical connections in a network,"class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        
        dic = collections.defaultdict(list)
        for c in connections:
            u, v = c
            dic[u].append(v)
            dic[v].append(u)
            
        
        timer = 0
        
        depth, lowest, parent, visited = [float(""inf"")]*n, [float(""inf"")]*n, [float(""inf"")]*n, [False]*n
        res = []
        
        def find(u):
            
            nonlocal timer
            
            visited[u] = True
            depth[u], lowest[u] = timer, timer
            timer += 1
            
            for v in dic[u]:   
                
                if not visited[v]:
                    parent[v] = u
                    find(v)
                    if lowest[v]>depth[u]:
                        res.append([u,v])
                
                if parent[u]!=v:
                    lowest[u] = min(lowest[u], lowest[v])
                
        find(0)
        return res"
critical connections in a network,"class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        '''
        disc = discovery time of each node in the graph
        _____________________
        |The concept of 'LOW'|
        low values means to which scc this node belongs to and that if this node is reachable to
        its ancestor (basically is there any way ,  if yes then we assign the low value of this node to the low value of its ancestor which will signify that this node belongs to the SCC and that the edge from this node to the ancestor node is the back edge
        when this node will backtrack to its parent node then it will say that look the connection between you(Parent) and me(child) is not a critical connection because I can be dicovered without your help(Parent) and we all belong to one SCC hence we update the parents low value to the min of low[parent],low[child])
        Next imp thing : 
        _____________________________________________
        |Condition to check if this edge is a bridge | 
        
        eg : SCC1 -----> SCC2
            disc=0       disc =1
            low=0        low=1
        SCC1 =      1->2->3->1           SCC2= 4->5->4
             disc   0  1  2  0           disc   3  4  3
             low    0  0  0  0           low    3  3  3
             
        suppose there s an edge from 1 to 4 and we start our dfs from node 1 then we know that 
        the discovery of node 1 is done before the discovery of node 4 
        now we cant simply compare the dicovery time of the nodes(thats not correct)
        hence we use the low value of the chid to check 
        ___________________________________
        | if dicovery[parent] < low[child] |
        MEANS , That the dicovery ofthe parent was done before that of child hence its value is small if the edge is critical edge 
        else if this edge is not a critical edge then the low value of the child is lesser than or equal to parent
        '''
        disc = [-1]*n
        low = [-1]*n
        self.time = 0
        graph = defaultdict(list)
        bridges = []
        for u,v in connections:
            graph[u].append(v)
            graph[v].append(u)
        
        def dfs(node,parent):
            #print(parent)
            if disc[node] != -1:
                return 
            
            disc[node] = self.time
            low[node] = self.time
            self.time += 1
            
            for neighbor in graph[node]:
                if neighbor == parent:
                    continue
                dfs(neighbor,node)
                
                low[node] = min(low[neighbor],low[node])
                
                if disc[node] < low[neighbor] :
                    bridges.append([node,neighbor])
                    
        dfs(0,-1)
        #print(low)
        return bridges"
minimum absolute difference,"class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        m = float('inf')
        out = []
        for i in range(1, len(arr)):
            prev = arr[i - 1]
            curr = abs(prev - arr[i])
            if curr < m:
                out = [[prev, arr[i]]]
                m = curr
            elif curr == m: out.append([prev, arr[i]])
        return out"
minimum absolute difference,"class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        
        mini, res = abs(arr[1] - arr[0]), [arr[0:2]]
        
        for i in range(2, len(arr)):
            diff = abs(arr[i] - arr[i - 1])
            
            if diff > mini:
                continue

            if diff < mini:
                mini, res = diff, list()
                
            res.append([arr[i - 1], arr[i]])
                
        return res"
ugly number iii,"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        # inclusion-exclusion principle
        ab = a*b//gcd(a, b)
        bc = b*c//gcd(b, c)
        ca = c*a//gcd(c, a)
        abc = ab*c//gcd(ab, c)
        
        lo, hi = 1, n*min(a, b, c)
        while lo < hi: 
            mid = lo + hi >> 1
            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1
            else: hi = mid 
        return lo"
ugly number iii,"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        times = [1,1,1]
        smallest = inf
        while n != 0:
            smallest = min ( times[0]*a,times[1]*b,times[2]*c)
            if times[0]*a == smallest: times[0] += 1
            if times[1]*b == smallest: times[1] += 1
            if times[2]*c == smallest: times[2] += 1
            n -= 1
        return smallest"
smallest string with swaps,"class Solution:
    def union(self, a, b):
        self.parent[self.find(a)] = self.find(b)
		
    def find(self, a):
        if self.parent[a] != a:
            self.parent[a] = self.find(self.parent[a])

        return self.parent[a]
        
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
		# 1. Union-Find
        self.parent = list(range(len(s)))
        for a, b in pairs:
            self.union(a, b)

		# 2. Grouping
        group = defaultdict(lambda: ([], []))  
        for i, ch in enumerate(s):
            parent = self.find(i)
            group[parent][0].append(i)
            group[parent][1].append(ch)

		# 3. Sorting
        res = [''] * len(s)
        for ids, chars in group.values():
            ids.sort()
            chars.sort()
            for ch, i in zip(chars, ids):
                res[i] = ch
                
        return ''.join(res)"
smallest string with swaps,"class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        # Start of Union Find Data Structure
        p = list(range(len(s)))  # parent
        # each element in the pairs == node
        # used to store each node's parent based on its index
        # eg. pairs = [[0,3],[1,2]], p = [0, 1, 1, 0]
        # element 3 in pairs == p index 3 == 0 (because parent node of 3 is 0)

        def find(x):
            if x != p[x]:
                p[x] = find(p[x])
            return p[x]

        def union(x, y):
            px = find(x)
            py = find(y)
            if px != py:
                p[py] = px
                
        # End of Union Find Data Structure

        # Grouping
        for x, y in pairs:
            union(x, y)

        dic = defaultdict(list)
        for idx, el in enumerate(p):
            dic[find(el)].append(idx)
        
        # eg. pairs = [[0,3],[1,2]], dic = {0: [0, 3], 1: [1, 2]}

        # Sorting
        res = list(s)
        for key in dic.keys():
            idx_list = dic[key]
            char_list = [s[i] for i in idx_list]
            char_list.sort()

            # eg. idx_list = [0, 3], char_list = [b, d]
            # for loop below, idx = [0, b], char = [3, d]
            for idx, char in zip(idx_list, char_list):
                res[idx] = char

        return """".join(res)"
sort items by groups respecting dependencies,"class Solution:
    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:
        for i in range(n): 
            if group[i] == -1: group[i] = i + m # re-group 
        
        graph0 = {} # digraph of groups 
        indeg0 = [0]*(m+n) # indegree of groups 
        
        graph1 = {} # digrpah of items 
        indeg1 = [0]*n # indegree of items
        
        for i, x in enumerate(beforeItems): 
            for xx in x: 
                if group[xx] != group[i]: 
                    graph0.setdefault(group[xx], []).append(group[i])
                    indeg0[group[i]] += 1
                graph1.setdefault(xx, []).append(i)
                indeg1[i] += 1
        
        def fn(graph, indeg): 
            """"""Return topological sort of graph using Kahn's algo.""""""
            ans = []
            stack = [k for k in range(len(indeg)) if indeg[k] == 0]
            while stack: 
                n = stack.pop()
                ans.append(n)
                for nn in graph.get(n, []):
                    indeg[nn] -= 1
                    if indeg[nn] == 0: stack.append(nn)
            return ans 
        
        tp0 = fn(graph0, indeg0) 
        if len(tp0) != len(indeg0): return [] 
        
        tp1 = fn(graph1, indeg1)
        if len(tp1) != len(indeg1): return []
        
        mp0 = {x: i for i, x in enumerate(tp0)}
        mp1 = {x: i for i, x in enumerate(tp1)}
        
        return sorted(range(n), key=lambda x: (mp0[group[x]], mp1[x]))"
unique number of occurrences,"class Solution:
    def uniqueOccurrences(self, A: List[int]) -> bool:
    	return (lambda x: len(x) == len(set(x)))(collections.Counter(A).values())
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
unique number of occurrences,"class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        from collections import Counter
        c = Counter(arr)
        return len(c) == len({c[x] for x in c})"
get equal substrings within budget,"class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        n = len(s)
        cost,start,ans = 0,0,0
        for i in range(n):
            diff = abs(ord(s[i]) - ord(t[i]))
            if cost + diff <= maxCost:
                # we can increase our sliding window
                cost += diff
            else:
                # we are unable to increase our sliding window
                ans = max(ans,i - start)
                while True:
                    cost -= abs(ord(s[start]) - ord(t[start]))
                    start += 1
                    if cost + diff <= maxCost: break
                if cost + diff > maxCost: start = i + 1
                else: cost += diff
                    
        ans = max(ans,n - start)
        return ans"
get equal substrings within budget,"class Solution:
    def equalSubstring(self, s: str, t: str, M: int) -> int:
    	L, D, m, i, j = len(s)+1, [abs(ord(s[i])-ord(t[i])) for i in range(len(s))], 0, 0, 0
    	C = [0]+list(itertools.accumulate(D))
    	while i < L - m:
    		while j < L and C[j]-C[i] <= M: m, j = max(m, j - i), j + 1
    		i += 1
    	return m
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com"
remove all adjacent duplicates in string ii,"class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:        
        stck = [['$', 0]]     # a placeholder to mark stack is empty. This eliminates the need to do an empty check later
        
        for c in s:
            if stck[-1][0] == c:
                stck[-1][1]+=1 # update occurences count of top element if it matches current character
                if stck[-1][1] == k:
                    stck.pop()
            else:
                stck.append([c, 1])            
        
        return ''.join(c * cnt for c, cnt in stck)"
remove all adjacent duplicates in string ii,"class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:        
        stck = []    
        
        for c in s:                            
            if stck and stck[-1][0] == c: # check if stack is not empty
                stck[-1][1]+=1
                if stck[-1][1] == k:
                    stck.pop()
            else:
                stck.append([c, 1])            
        
        return ''.join(c * cnt for c, cnt in stck)"
minimum moves to reach target with rotations,"class Solution:
    def minimumMoves(self, G: List[List[int]]) -> int:
    	N, S, T, V, c = len(G), [(0, 0, 'h')], [], set(), 0
    	while S:
    		for i in S:
    			if i in V: continue
    			if i == (N-1, N-2, 'h'): return c
    			(a, b, o), _ = i, V.add(i)
	    		if o == 'h':
    				if b + 2 != N and G[a][b+2] == 0: T.append((a, b+1, o))
    				if a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: T.append((a+1, b, o)), T.append((a, b, 'v'))
    			elif o == 'v':
    				if a + 2 != N and G[a+2][b] == 0: T.append((a+1, b, o))
    				if b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: T.append((a, b+1, o)), T.append((a, b, 'h'))
    		S, T, c = T, [], c + 1
    	return -1"
minimum moves to reach target with rotations,"class Solution:
    def minimumMoves(self, G: List[List[int]]) -> int:
    	N, V, M, self.t, self.m = len(G), set(), collections.defaultdict(int), 0, math.inf
    	print(N)
    	def dfs(a,b,o):
    		if (a,b,o) in V or M[(a,b,o)] == 2 or self.t > self.m: return
    		if (a,b,o) == (N-1,N-2,'h'):
    			self.m = min(self.m,self.t)
    			for i in V: M[i] = 1
    			return
    		self.t, _ = self.t + 1, V.add((a,b,o))
    		if o == 'h':
    			if b + 2 != N and G[a][b+2] == 0: dfs(a, b+1, o)
    			if a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: dfs(a+1, b, o), dfs(a, b, 'v')
    		elif o == 'v':
    			if a + 2 != N and G[a+2][b] == 0: dfs(a+1, b, o)
    			if b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: dfs(a, b+1, o), dfs(a, b, 'h')
    		if M[(a,b,o)] == 0: M[(a,b,o)] = 2
    		self.t, _ = self.t - 1, V.remove((a,b,o))
    	dfs(0,0,'h')
    	return -1 if self.m == math.inf else self.m"
minimum cost to move chips to the same position,"class Solution:
def minCostToMoveChips(self, position: List[int]) -> int:
    
    dic = Counter([n%2 for n in position])
    return min(dic[0],dic[1])"
minimum cost to move chips to the same position,"class Solution:
def minCostToMoveChips(self, position: List[int]) -> int:
    
    dic = defaultdict(int)
    for n in position:
        dic[n%2] += 1
        
    return min(dic[0],dic[1])"
longest arithmetic subsequence of given difference,"class Solution:
    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        """"""
        dp is a hashtable, dp[x] is the longest subsequence ending with number x
        """"""
        dp = {}
        for x in arr:
            if x - difference in dp:
                dp[x] = dp[x-difference] + 1
            else:
                dp[x] = 1
            
        return max(dp.values())"
longest arithmetic subsequence of given difference,"class Solution:
    def longestSubsequence(self, arr: List[int], d: int) -> int:
        if not arr:
            return 0
        cache={}
        maxc=0
        for i in arr:
            if i-d in cache:
                cache[i]=cache[i-d]+1
            else:
                cache[i]=1
            maxc=max(maxc,cache[i])
        return maxc"
path with maximum gold,"class Solution:
	def getMaximumGold(self, grid: List[List[int]]) -> int:
		m = len(grid)
		n = len(grid[0])
		def solve(i,j,grid,vis,val):
			# print(i,j,grid,vis,val)
			if(i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or vis[i][j]):
				# print(i,m,j,n)
				return val
			vis[i][j] = True
			a = solve(i,j-1,grid,vis,val+grid[i][j])
			b = solve(i,j+1,grid,vis,val+grid[i][j])
			c = solve(i+1,j,grid,vis,val+grid[i][j])
			d = solve(i-1,j,grid,vis,val+grid[i][j])
			vis[i][j] = False
			return max(a,b,c,d)
		ma = 0
		for i in range(len(grid)):
			for j in range(len(grid[0])):
				if(grid[i][j] != 0):
					vis = [[False for i in range(len(grid[0]))] for j in range(len(grid))]
					ma = max(ma,solve(i,j,grid,vis,0))
		return ma"
path with maximum gold,"class Solution:
    def __init__(self):
        self.max_gold = 0
        
    def backtracking(self, grid, i, j, cur_gold):
        cur_val = grid[i][j]
        grid[i][j] = 0
        
        if i > 0 and grid[i - 1][j] != 0:
            self.backtracking(grid, i - 1, j, [cur_gold[0] + cur_val])
        if i < len(grid) - 1 and grid[i + 1][j] != 0:
            self.backtracking(grid, i + 1, j, [cur_gold[0] + cur_val])
        if j > 0 and grid[i][j - 1] != 0:
            self.backtracking(grid, i, j - 1, [cur_gold[0] + cur_val])
        if j < len(grid[0]) - 1 and grid[i][j + 1] != 0:
            self.backtracking(grid, i, j + 1, [cur_gold[0] + cur_val])
        
        self.max_gold = max(self.max_gold, cur_gold[0] + cur_val)
        grid[i][j] = cur_val
        
    def getMaximumGold(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if grid[i][j] != 0:
                    self.backtracking(grid, i, j, [0])
        
        return self.max_gold"
count vowels permutation,"class Solution:
    def countVowelPermutation(self, n: int) -> int:
        dp_array = [[0] * 5 for _ in range(n + 1)]
        dp_array[1] = [1, 1, 1, 1, 1]
        for i in range(2, n + 1):
            # a is allowed to follow e, i, or u.
            dp_array[i][0] = dp_array[i - 1][1] + dp_array[i - 1][2] + dp_array[i - 1][4]
            # e is allowed to follow a or i.
            dp_array[i][1] = dp_array[i - 1][0] +  dp_array[i - 1][2]
            # i is allowed to follow e or o.
            dp_array[i][2] = dp_array[i - 1][1] + dp_array[i - 1][3]
            # o is allowed to follow i
            dp_array[i][3] = dp_array[i - 1][2]
            # u is allowed to follow i or o.
            dp_array[i][4] = dp_array[i - 1][2] + dp_array[i - 1][3]
        return sum(dp_array[n]) % ((10 ** 9) + 7)"
count vowels permutation,"class Solution:
    def countVowelPermutation(self, n: int) -> int:
        # dp[i][j] means the number of strings of length i that ends with the j-th vowel.
        dp = [[1] * 5] + [[0] * (5) for _ in range(n - 1)]
        moduler = math.pow(10, 9) + 7
        for i in range(1, n):
            # For vowel a
            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % moduler
            # For vowel e
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % moduler
            # For vowel i
            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % moduler
            # For vowel o
            dp[i][3] = (dp[i - 1][2]) % moduler
            # For vowel u
            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % moduler
            
        return int(sum(dp[-1]) % moduler)"
split a string in balanced strings,"class Solution:
    def balancedStringSplit(self, S: str) -> int:
        m = c = 0
        for s in S:
            if s == 'L': c += 1
            if s == 'R': c -= 1
            if c == 0: m += 1
        return m"
split a string in balanced strings,"class Solution:
    def balancedStringSplit(self, S: str) -> int:
        m, c, D = 0, 0, {'L':1, 'R':-1}
        for s in S: c, m = c + D[s], m + (c == 0)
        return m
		
		
- Junaid Mansuri"
queens that can attack the king,"class Solution:
    # Time: O(1)
    # Space: O(1)
    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
        queen_set = {(i, j) for i, j in queens}
        res = []
        
        for dx, dy in [[0, 1], [1, 0], [-1, 0], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]]:
            x, y = king[0], king[1]
            while 0 <= x < 8 and 0 <= y < 8:
                x += dx
                y += dy
                if (x, y) in queen_set:
                    res.append([x, y])
                    break
        return res"
queens that can attack the king,"class Solution:
    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
        ans = []
        x, y = king
        queens = {(x, y) for x, y in queens}
        for dx in (-1, 0, 1):
            for dy in (-1, 0, 1):
                for k in range(1, 8):
                    xx, yy = x+k*dx, y+k*dy
                    if (xx, yy) in queens: 
                        ans.append([xx, yy])
                        break 
        return ans"
dice roll simulation,"class Solution:
    def dieSimulator(self, n: int, rollMax: List[int]) -> int:
        MOD = 10 ** 9 + 7
        
        @lru_cache(None)
        def func(idx, prevNum, prevNumFreq):
            if idx == n:
                return 1
            
            ans = 0
            for i in range(1, 7):
                if i == prevNum:
                    if prevNumFreq < rollMax[i - 1]:
                        ans += func(idx + 1, i, prevNumFreq + 1)
                        
                else:
                    ans += func(idx + 1, i, 1)
            
            return ans % MOD
        
        return func(0, 0, 0)"
dice roll simulation,"class Solution:
    def dieSimulator(self, n: int, rollMax: List[int]) -> int:
        
        @cache
        def fn(n, x, r):
            """"""Return number of sequences with n rolls left with r occurrences of x.""""""
            if n == 0: return 1
            ans = 0
            for xx in range(6): 
                if xx != x: ans += fn(n-1, xx, 1)
                elif xx == x and r < rollMax[x]: ans += fn(n-1, x, r+1)
            return ans 
        
        return sum(fn(n-1, x, 1) for x in range(6)) % 1_000_000_007"
maximum equal frequency,"class Solution:
    def maxEqualFreq(self, nums: List[int]) -> int:
        cnt, freq, maxfreq, ans = collections.defaultdict(int), collections.defaultdict(int), 0, 0
        for i, num in enumerate(nums):
            cnt[num] = cnt.get(num, 0) + 1
            freq[cnt[num]] += 1
            freq[cnt[num]-1] -= 1
            maxfreq = max(maxfreq, cnt[num])
            if maxfreq == 1:
                ans = i+1
            elif maxfreq*freq[maxfreq] == i:
                ans = i+1
            elif (maxfreq-1)*(freq[maxfreq-1]+1) == i:
                ans = i+1
        return ans"
maximum equal frequency,"class Solution:
    def maxEqualFreq(self, nums: List[int]) -> int:
        ans = 0
        n = len(nums)
        countToFreq = defaultdict(int)
        # key = count value = Freq ex 2 occured 3 times  in nums so 2 : 3
        freqToCount = defaultdict(int)
        # key = freq value = count ex 2 numbers occured 3 times in nums so 2 : 3
        
        for i,val in enumerate(nums):
            
            x = countToFreq[val] + 1
            freqToCount[x - 1] -= 1
            if freqToCount[x - 1] <= 0 : freqToCount.pop(x - 1)
            freqToCount[x] += 1
            countToFreq[val] = x
            
            # if a single item is repeated for i + 1 times like [1,1,1]
            if countToFreq[val] == i + 1 :ans = i + 1
            
            # if all items are having same frequency like [2,2,1,1,3,3]
            elif (i < n-1 and len(freqToCount) == 1) or (len(freqToCount) == 1 and max(freqToCount.keys())==1): ans = i + 1
            
            # if all items have same frequency except one having 1 freq like [2,2,3,3,1]
            elif len(freqToCount) == 2 and 1 in freqToCount and freqToCount[1] == 1:ans = i +1
            
            # if all items have same frequenct except one having freq common + 1 like[1,1,2,2,3,3,3]
            elif len(freqToCount) == 2:
                keys,values = [],[]
                for j in freqToCount:keys.append(j) , values.append(freqToCount[j])
                if (keys[0]==1+keys[1] and values[0]==1) or (keys[1]==1+keys[0] and values[1]==1):ans = i + 1
        return ans"
airplane seat assignment probability,"class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else 0.5"
airplane seat assignment probability,"class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        s = 1
        for i in range(2, n):
            s += s/i
        return s/n"
check if it is a straight line,"class Solution:
    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        x1, y1 = coordinates[0]
        x2, y2 = coordinates[1]
        for x, y in coordinates[2:]:
            if (y2 - y1) * (x - x1) != (x2 - x1) * (y - y1):
                return False
        return True"
check if it is a straight line,"class Solution:
    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        
        x0, y0 = coordinates[0]
        x1, y1 = coordinates[1]
        
        dy = y1 - y0
        dx = x1 - x0
        
        for i in range(len(coordinates)):
            x = coordinates[i][0]
            y = coordinates[i][1]
            
            if dx*(y - y1) != dy*(x - x1):
                return False
        else:
            return True"
remove sub folders from the filesystem,"class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        ans = []
        for i, path in enumerate(sorted(folder)):
            if i == 0 or not path.startswith(ans[-1] + ""/""):
                ans.append(path)
        return ans"
remove sub folders from the filesystem,"class Solution:
    def removeSubfolders(self, arr: List[str]) -> List[str]:
        arr.sort(key=len)
        
        files = []
        
        while arr:
            curr = arr.pop(0)
            temp = []
            for i in arr:
                if(curr + '/' in i and i.index(curr + '/') == 0):
                    pass
                else:
                    temp.append(i)
            
            files.append(curr)
            arr = temp
        
        return files"
replace the substring for balanced string,"class Solution:
    def balancedString(self, s: str) -> int:
        counter = collections.Counter(s)
        n = len(s) // 4
        extras = {}
        for key in counter:
            if counter[key] > n:
                extras[key] = counter[key] - n
        
        if not extras: return 0
        i = 0
        res = len(s)
        for j in range(len(s)):
            if s[j] in extras:
                extras[s[j]] -= 1
            
            while max(extras.values()) <= 0:
                res = min(res, j-i+1)
                if s[i] in extras:
                    extras[s[i]] += 1
                i += 1
                
                
        return res"
replace the substring for balanced string,"class Solution:
    def balancedString(self, s: str) -> int:
        # take window sum of all 4 ?
        # instead of window sum, 
        # should we maintain remaining sum!
        # fre of elements outside the window ;)
        
        # initially window is empty..
        remaining_fre = collections.Counter(s)
        res = n = len(s)
        left = 0
        for right, c in enumerate(s):
            remaining_fre[c] -= 1
            
            # while window is valid that is:
            # remaining does not have any EXTRA elements!!
            # EXTRA element is any (element > n/4)
            while left < n and all(remaining_fre[ch] <= n/4 for ch in 'QWER'):
                
                res = min(res, right-left+1)
                remaining_fre[s[left]] += 1 # he goes out of window! into remaining
                left += 1
                
        return res
    
""""""

WHILE LEFT < N 


while loop condition is most trick!!! :
https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/JavaC%2B%2BPython-Sliding-Window

Important
Does i <= j + 1 makes more sense than i <= n.
Strongly don't think, and i <= j + 1 makes no sense.

Answer the question first:
Why do we need such a condition in sliding window problem?

Actually, we never need this condition in sliding window solution
(Check all my other solutions link at the bottom).

Usually count the element inside sliding window,
and i won't be bigger than j because nothing left in the window.
"""""""
maximum profit in job scheduling,"class Solution:
def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:

    jobs = sorted([(startTime[i],endTime[i],profit[i]) for i in range(len(startTime))])
    heap=[]
    cp,mp = 0,0                           # cp->current profit, mp-> max-profit
    for s,e,p in jobs:
        while heap and heap[0][0]<=s:
            et,tmp = heapq.heappop(heap)
            cp = max(cp,tmp)
        heapq.heappush(heap,(e,cp+p))
        mp = max(mp,cp+p)
    
    return mp"
maximum profit in job scheduling,"class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        combos = [] 
        for index in range(len(startTime)):
            combos.append( (startTime[index], endTime[index], profit[index] ))
        combos.sort(key = lambda x: x[0])
    
        maxProfit = 0 # this is based on start time
        heap = [] #  (endTime, profit)
        for combo in combos:
            
            start = combo[0]
            while heap and heap[0][0] <= start:
                # pop all with endtime <= curr start time
                # remember our max profit is based start time !
                maxProfit = max(heapq.heappop(heap)[1], maxProfit)
            
            heappush(heap, (combo[1], maxProfit + combo[2]))
        
        for remainCombo in heap:
            # update the max profit to endtime based 
            maxProfit = max(maxProfit, remainCombo[1])
            
        return maxProfit"
find positive integer solution for a given equation,"def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
	x, y = 1, z
	pairs = []
	
	while x<=z and y>0:
		cf = customfunction.f(x,y)
		if cf==z:
			pairs.append([x,y])
			x, y = x+1, y-1
		elif cf > z:
			y -= 1
		else:
			x += 1
	return pairs"
find positive integer solution for a given equation,"class Solution:
    def findSolution(self, C: 'CustomFunction', z: int) -> List[List[int]]:
        A, Y = [], z+1        
        for x in range(1,z+1):
            if C.f(x,1) > z: return A
            for y in range(Y,0,-1):
                if C.f(x,y) == z:
                    Y, _ = y-1, A.append([x,y])
                    break
        return A"
circular permutation in binary representation,"class Solution:
    def circularPermutation(self, n: int, start: int) -> List[int]:
        ans = []
        for i in range(1<<n): 
            ans.append(start ^ i ^ i >> 1)
        return ans"
circular permutation in binary representation,"class Solution:
    def circularPermutation(self, n: int, start: int) -> List[int]:
        ans = [start]
        seen = set(ans)
        
        def fn(i, x): 
            """"""Return circular permutation with x at i.""""""
            if i == 2**n: 
                diff = ans[-1] ^ start
                if not diff &amp; (diff-1): return ans 
            for k in range(n): 
                xx = x ^ 1 << k 
                if xx not in seen: 
                    seen.add(xx)
                    ans.append(xx)
                    if tmp := fn(i+1, xx): return tmp 
                    ans.pop()
                    seen.remove(xx)
        
        return fn(1, start)"
maximum length of a concatenated string with unique characters,"class Solution:
def maxLength(self,arr):
    
    unique = ['']
    res = 0
    for i in range(len(arr)):
        for j in range(len(unique)):
            local = arr[i]+unique[j]
            if len(local)==len(set(local)):
                unique.append(local)
                res=max(res,len(local))
    
    return res"
maximum length of a concatenated string with unique characters,"class Solution:
	res = 0 
	def maxLength(self,arr):
		self.backtrack(arr,0,"""")
		return self.res

	def backtrack(self,arr,ind,local):
		if len(local)!=len(set(local)):
			return
			
		self.res = max(self.res,len(local))
		for i in range(ind,len(arr)):
			self.backtrack(arr,i+1,local+arr[i])"
tiling a rectangle with the fewest squares,"class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        if n == m: return 1
        depth = [0]*m
        
        def fn(x): 
            """"""Explore tiling rectangle area via backtracking.""""""
            nonlocal ans 
            if x < ans: 
                if min(depth) == n: ans = x # all tiled
                else: 
                    i = min(depth)
                    j = jj = depth.index(i) # (i, j)
                    while jj < m and depth[jj] == depth[j]: jj += 1
                    k = min(n - i, jj - j)
                    for kk in reversed(range(1, k+1)): 
                        for jj in range(j, j+kk): depth[jj] += kk
                        fn(x+1)
                        for jj in range(j, j+kk): depth[jj] -= kk
                            
        ans = max(n, m)
        fn(0)
        return ans"
tiling a rectangle with the fewest squares,"class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        # edge case 1 allowing early quit processing. 
        if n == m : 
            return 1 
        # edge case 2, occurs according to tiling problem. Only one for which implementation breaks. 
        elif (n==11 and m == 13) or (n==13 and m==11) : 
            return 6 
        else : 
            # memo usage of results. Build from result 1 go to end result. Bottom up progression. 
            memo = [[0 for _ in range(m+1)] for _ in range(n+1)]
            # loop from 1 to n inclusive 
            for n_measure in range(1, n+1) : 
                # loop 1 to m inclusive 
                for m_measure in range(1, m+1) : 
                    # if we are at equal measures, this is a square 
                    if (n_measure == m_measure) : 
                        # mark it as 1 as these are our measures so this can be covered by equal square 
                        memo[n_measure][m_measure] = 1
                        continue
                    # only do half the array 
                    else : 
                        if m_measure < n and n_measure < m and memo[m_measure][n_measure] != 0 : 
                            memo[n_measure][m_measure] = memo[m_measure][n_measure]
                            continue
                    # otherwise, set sub rectangles 1 and 2 and minimal rectangle to infinity to start 
                    sub_rectangle1, sub_rectangle2, min_rectangle = inf, inf, inf
                    offset = 1 
                    # starting with offset of 1 go to min of n and m 
                    while offset <= min(n_measure, m_measure) : 
                        # if we have run off the smaller, break at this point 
                        if (m_measure - offset < 0) or (n_measure - offset < 0) : 
                            break
                        # get sub rectangles 1 and 2 based off of which slicing you're doing 
                        sub_rectangle1 = memo[n_measure][m_measure-offset] + memo[n_measure-offset][offset]
                        sub_rectangle2 = memo[n_measure-offset][m_measure] + memo[offset][m_measure-offset]
                        # set min to minimum of the results now built 
                        min_rectangle = min(min_rectangle, sub_rectangle1, sub_rectangle2)
                        # increment offset as if you are doing two different measures simultaneously 
                        offset += 1 
                    # memoize current result minmal plus 1 more for work done for this square itself. 
                    memo[n_measure][m_measure] = min_rectangle + 1
            return memo[n][m]"
minimum swaps to make strings equal,"class Solution:
    def minimumSwap(self, s1: str, s2: str) -> int:
        if s1 == s2:
            return 0
        else:
            count = 0
            d = {('xx','yy'):1,('xy','yx'):2,('yy','xx'):1,('yx','xy'):2}
            x = []
            y = []
            for i,j in zip(s1,s2):
                if i != j:
                    x.append(i)
                    y.append(j)
            x.sort()
            y.sort(reverse=True)
            i,j = 0,0
            if len(x)%2 != 0 or len(y)%2 != 0:
                return -1
            while i < len(x) and j < len(y):
                z = (''.join(x[i:i+2]),''.join(y[i:i+2]))
                if z not in d:
                    return -1
                else:
                    count += d[z]
                i += 2
                j += 2
            return count"
minimum swaps to make strings equal,"class Solution:
    def minimumSwap(self, s1: str, s2: str) -> int:
        xy = yx = 0
        for c1, c2 in zip(s1, s2):
            if c1 == 'x' and c2 == 'y':
                xy += 1
            elif c1 == 'y' and c2 == 'x':
                yx += 1
        
        if (xy + yx) % 2:
            return -1
        
        return xy // 2 + yx // 2 + (xy % 2) * 2"
count number of nice subarrays,"class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        right ,left = 0,0
        ans = 0 
        odd_cnt = 0
        ans = 0
        cur_sub_cnt = 0
        for right in range(len(nums)):
            
            if nums[right]%2 == 1:
                odd_cnt += 1
                cur_sub_cnt = 0
                
            while odd_cnt == k:
                if nums[left]%2 == 1:
                    odd_cnt -= 1
                cur_sub_cnt += 1
                left += 1
                
            ans += cur_sub_cnt
            
        return ans"
count number of nice subarrays,"class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        odd_ls = []
        for i, num in enumerate(nums):
            if num % 2 == 1:
                odd_ls.append(i)
                
        odd_ls = [-1] + odd_ls + [len(nums)]
        count = 0
        for i in range(1, len(odd_ls) - k):
            count += (odd_ls[i] - odd_ls[i - 1]) * (odd_ls[i + k] - odd_ls[i + k - 1])
        
        return count"
minimum remove to make valid parentheses,"class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        
        open = 0
        s = list(s)
        
        for i, c in enumerate(s):
            if c == '(': open += 1
            elif c == ')':
                if not open: s[i] = """"
                else: open -= 1
        
        for i in range(len(s)-1, -1, -1):
            if not open: break
            if s[i] == '(': s[i] = """"; open -= 1
        
        return """".join(s)"
minimum remove to make valid parentheses,"class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        stack = []
        s = list(s)
        for i in range(len(s)):
            if s[i] == ""("": stack.append(i)
            elif s[i] == "")"":
                if stack: stack.pop()
                else: s[i] = """"
        for i in stack:
            s[i] = """"
        return """".join(s)"
check if it is a good array,"class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        import math 
        n = len(nums)
        if n ==1:
            return nums[0] ==1
        d = math.gcd(nums[0], nums[1])
        for i in range(n):
            d = math.gcd(nums[i], d)
        return d ==1"
check if it is a good array,"class Solution:
    def gcd(self,a,b):
        while a%b != 0:
            mod = a%b
            a = b
            b = mod 
        return b
    def isGoodArray(self, nums: List[int]) -> bool:
        gc = nums[0]
        for i in range(1,len(nums)):
            gc = self.gcd(gc,nums[i])
        return True if gc == 1 else False"
cells with odd values in a matrix,"class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        row_data = [0]*m
        col_data = [0]*n
        
        for tup in indices:
            row_data[tup[0]] = row_data[tup[0]] + 1
            col_data[tup[1]] = col_data[tup[1]] + 1
        
        odd_count = 0 
        for rowp in range(m):
            for colp in range(n):
                val = row_data[rowp] + col_data[colp]
                if val % 2 != 0:
                    odd_count+=1
        
        return odd_count"
cells with odd values in a matrix,"class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        
        
        row=[0]*m
        col = [0]*n
        
        
        for x,y in indices:
            
            row[x]+=1
            col[y]+=1
            
        ans=0
        for i in range(m):
            for j in range(n):
                
                if (row[i]+col[j])%2:
                    ans+=1
        return ans"
reconstruct a 2 row binary matrix,"class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        s, n = sum(colsum), len(colsum)
        if upper + lower != s: return []
        u, d = [0] * n, [0] * n
        for i in range(n):
            if colsum[i] == 2 and upper > 0 and lower > 0:
                u[i] = d[i] = 1
                upper, lower = upper-1, lower-1
            elif colsum[i] == 1:    
                if upper > 0 and upper >= lower:
                    u[i], upper = 1, upper-1
                elif lower > 0 and lower > upper:
                    d[i], lower = 1, lower-1
                else: return []    
            elif not colsum[i]: continue
            else: return []
        return [u, d]"
reconstruct a 2 row binary matrix,"class Solution:
    def reconstructMatrix(self, U: int, L: int, C: List[int]) -> List[List[int]]:
        M, u = [[0]*len(C) for _ in range(2)], C.count(2)
        if U + L != sum(C) or u > min(L,U): return []
        for j,s in enumerate(C):
            if s == 2: M[0][j] = M[1][j] = 1
        for j,s in enumerate(C):
            if s == 1:
                if u < U: M[0][j], u = 1, u + 1
                else: M[1][j] = 1
        return M
            
			
- Junaid Mansuri"
number of closed islands,"class Solution:
def closedIsland(self, grid: List[List[int]]) -> int:
    
    def dfs(i,j):
        if grid[i][j]==1:
            return True
        if i<=0 or i>=m-1 or j<=0 or j>=n-1:
            return False
        grid[i][j]=1
        up=dfs(i-1,j)
        down=dfs(i+1,j)
        left=dfs(i,j-1)
        right=dfs(i,j+1)
        return left and right and up and down
     
    m,n = len(grid),len(grid[0])
    c=0
	# iterate through the grid from 1 to length of grid for rows and columns.
    # the iteration starts from 1 because if a 0 is present in the 0th column, it can't be a closed island.
    for i in range(1,m-1):
        for j in range(1,n-1):
			# if the item in the grid is 0 and it is surrounded by
            # up, down, left, right 1's then increment the count.
            if grid[i][j]==0 and dfs(i,j):
                c+=1
    return c"
number of closed islands,"class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        result = 0
        
        def dfs(grid, r, c):
            if not 0 <= r < len(grid) or not 0 <= c < len(grid[0]):
                return False
            if grid[r][c] != 0:
                return True
            
            grid[r][c] = 2
            return all([dfs(grid, r - 1, c),
                        dfs(grid, r + 1, c),
                        dfs(grid, r, c - 1),
                        dfs(grid, r, c + 1)])
        
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 0 and dfs(grid, r, c):
                    result += 1
        
        return result"
maximum score words formed by letters,"class Solution:
    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:
        count , n , dp = [0]*26 , len(words) , {}
        
        for c in letters: count[ord(c) - 97] += 1
        
        def recursion(index,count):
            if index == n: return 0
            
            tpl = tuple(count)
            
            if (index,tpl) in dp: return dp[(index,tpl)]
            
            ans = recursion(index + 1, count)
            
            flag , tmp , cpy , add = True , defaultdict(int) , count.copy() , 0
            for c in words[index]: tmp[c] += 1
            
            for key in tmp:
                if tmp[key] <= cpy[ord(key) - 97]:
                    cpy[ord(key) - 97] -= tmp[key]
                    add += score[ord(key) - 97] * tmp[key] 
                else:
                    flag = False
                    break
            if flag : ans = max(ans, recursion(index + 1, cpy) + add)
            
            dp[(index,tpl)] = ans
            
            return ans
        
        return recursion(0 , count)"
maximum score words formed by letters,"class Solution:
    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:
        freq=[0 for i in range(26)]
        for c in letters:
            freq[ord(c)-97]+=1
        return self.solve(0,words,letters,freq,score)
    def solve(self,ind,words,letters,freq,score):
        if ind==len(words):
            return 0
        # not including
        wniScore=0+self.solve(ind+1,words,letters,freq,score)
        #including
        wiScore,flag,cwScore=[0]*3
        for c in words[ind]:
            if freq[ord(c)-97]==0:
                flag=1
            freq[ord(c)-97]-=1
            cwScore+=score[ord(c)-97]
        if not flag:
            wiScore=cwScore+self.solve(ind+1,words,letters,freq,score)
        #correcting freq array before backtracking
        for c in words[ind]:
            freq[ord(c)-97]+=1
        return max(wniScore,wiScore)"
shift 2d grid,"class Solution:
    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array
        n = len(nums)
        k = k % n
        nums[:] = nums[n - k:] + nums[:n - k]
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        arr = [i for sublist in grid for i in sublist] # Flatten out the array
        self.rotate(arr,k) # Rotate the array 
        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix
        return grid # Return 2d Result"
shift 2d grid,"class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        res=[]
        m,n=len(grid),len(grid[0])
        k=k%(m*n)
        for i in grid:
            for j in i:
                res.append(j)
        res=res[m*n-k:]+res[0:m*n-k]
        cp=n
        aux=[]
        ans=[]
        for i in res:
            aux.append(i)
            cp-=1
            if cp==0:
                ans.append(aux)
                aux=[]
                cp=n
        return ans"
greatest sum divisible by three,"class Solution:
    def maxSumDivThree(self, N: List[int]) -> int:
        A, B, S = heapq.nsmallest(2,[n for n in N if n % 3 == 1]), heapq.nsmallest(2,[n for n in N if n % 3 == 2]), sum(N)
        if S % 3 == 0: return S
        if S % 3 == 1: return S - min(A[0], sum(B) if len(B) > 1 else math.inf)
        if S % 3 == 2: return S - min(B[0], sum(A) if len(A) > 1 else math.inf)
		
		
- Junaid Mansuri
- Chicago, IL"
greatest sum divisible by three,"class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        dp,n = {} , len(nums)
        
        def recursion(index,mod):
            if index == n: 
                return 0 if mod == 0 else -inf
            if (index,mod) in dp: return dp[(index,mod)]
            a = recursion(index + 1, (mod + nums[index]) % 3) + nums[index]
            b = recursion(index + 1 , mod)
            ans = max(a,b)
            dp[(index,mod)] = ans
            return ans
        return recursion(0,0)"
minimum moves to move a box to their target location,"class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        
        neighbors = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        
        def player_bfs(st_row, st_col, tgt_row, tgt_col):
            nonlocal rows, cols
            if (st_row, st_col) == (tgt_row, tgt_col):
                return True
            q = deque([(st_row, st_col)]) 
            seen = [[False] * cols for _ in range(rows)]
            seen[st_row][st_col] = True
            
            while q:
                row, col = q.pop()
                for r, c in neighbors:
                    if 0 <= row+r < rows and 0 <= col+c < cols and not seen[row+r][col+c] and grid[row+r][col+c] == '.':
                        if row+r == tgt_row and col+c == tgt_col:
                            return True
                        seen[row+r][col+c] = True
                        q.appendleft((row+r, col+c))
            return False
            
        def box_bfs(st_row, st_col):
            nonlocal rows, cols, target
            q = deque([(st_row, st_col, start[0], start[1], 0)])
            seen = {st_row, st_col, start[0], start[1]}
            
            while q:
                row, col, prow, pcol, moves = q.pop()
                grid[row][col] = 'B'
                for r, c in neighbors:
                    box_can_move = 0 <= row+r < rows and 0 <= col+c < cols and (row+r, col+c, row-r, col-c) not in seen and grid[row+r][col+c] == '.'
                    if box_can_move and player_bfs(prow, pcol, row-r, col-c):
                        if (row+r, col+c) == target:
                            return moves + 1
                        seen.add((row+r, col+c, row-r, col-c))
                        q.appendleft((row+r, col+c, row-r, col-c, moves+1))
                grid[row][col] = '.'
            
            return -1
        
        start = target = box = None
        rows, cols = len(grid), len(grid[0])
        for r, row in enumerate(grid):
            for c, pos in enumerate(row):
                if pos == 'S':
                    start = (r, c)
                    grid[r][c] = '.'
                elif pos == 'T':
                    target = (r, c)
                    grid[r][c] = '.'
                elif pos == 'B':
                    box = (r, c)
                    grid[r][c] = '.'
        
        return box_bfs(*box)"
minimum moves to move a box to their target location,"class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        # dfs to move person
        # bfs to move box
        m = len(grid)
        n = len(grid[0])
        dirc = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        si, sj, bi, bj, tari, tarj = -1, -1, -1, -1, -1, -1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == ""S"":
                    si, sj = i, j
                if grid[i][j] == ""B"":
                    bi, bj = i, j
                if grid[i][j] == ""T"":
                    tari, tarj = i, j
        
        def ok(i, j, bi=-1, bj=-1):
            if i < 0 or j < 0 or i >= m or j >= n:
                return False
            if grid[i][j] == ""#"" or (i == bi and j == bj):
                return False
            return True
        
        def p_reachable(si, sj, ti, tj, bi, bj):
            if not ok(ti, tj, bi, bj):
                return False
            vis = set()
            def dfs(i, j):
                vis.add((i, j))
                if i == ti and j == tj:
                    return True
                flag = False
                for d in dirc:
                    newi, newj = i + d[0], j + d[1]
                    if ok(newi, newj, bi, bj) and (newi, newj) not in vis:
                        flag = flag or dfs(newi, newj)
                return flag
            return dfs(si, sj)
        
        queue = deque()
        queue.append(((bi, bj), (si, sj)))
        bvis = set()
        cnt = 0
        while queue:
            l = len(queue)
            for i in range(l):
                cur = queue.popleft()
                if cur[0][0] == tari and cur[0][1] == tarj:
                    return cnt
                for d in dirc:
                    newbi = cur[0][0] + d[0]
                    newsi = cur[0][0] - d[0]
                    newbj = cur[0][1] + d[1]
                    newsj = cur[0][1] - d[1]
                    if ok(newbi, newbj) and ((newbi, newbj), (cur[0][0], cur[0][1])) not in bvis and p_reachable(cur[1][0], cur[1][1], newsi, newsj, cur[0][0], cur[0][1]):
                        queue.append(((newbi, newbj), (cur[0][0], cur[0][1])))
                        bvis.add(((newbi, newbj), (cur[0][0], cur[0][1])))
            cnt += 1
        return -1"
minimum time visiting all points,"class Solution:
    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:
        timer = 0
        for i in range(len(points)-1):
            dx = abs(points[i+1][0] - points[i][0])
            dy = abs(points[i+1][1] - points[i][1])
            
            timer = timer + max(dx,dy)
        
        return timer"
minimum time visiting all points,"class Solution:
    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:
        d=0
        for i in range(len(points)-1):
            d+=max(abs(points[i][0]-points[i+1][0]),abs(points[i][1]-points[i+1][1]))
        return d"
count servers that communicate,"class Solution:
def countServers(self, grid: List[List[int]]) -> int:
    
    m,n = len(grid),len(grid[0])
    rows = [0]*m
    cols = [0]*n
    total = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j]==1:
                rows[i]+=1
                cols[j]+=1
                total+=1
    
    cnt = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j]==1 and rows[i]==1 and cols[j]==1:
                cnt+=1
    
    return total-cnt"
count servers that communicate,"class Solution:
	def countServers(self, grid: List[List[int]]) -> int:
		#DFS    
		def solve(r,c):
			grid[r][c]=-1
			nonlocal ans
			ans+=1
			for i in range(len(grid)):
				if grid[i][c]==1:
					solve(i, c)

			for j in range(len(grid[0])):
				if grid[r][j]==1:
					solve(r, j)
		count=0
		for i in range(len(grid)):
			for j in range(len(grid[0])):
				if grid[i][j]==1:
					ans=0
					solve(i,j)
					if ans>1:
						count+=ans
		return count"
search suggestions system,"class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        list_ = []
        products.sort()
        for i, c in enumerate(searchWord):
            products = [ p for p in products if len(p) > i and p[i] == c ]
            list_.append(products[:3])
        return list_"
search suggestions system,"class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        list_ = []
        products.sort()
        for i, c in enumerate(searchWord):
            products = list(filter(lambda p: p[i] == c if len(p) > i else False, products))
            list_.append(products[:3])
        return list_"
number of ways to stay in the same place after some steps,"class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        M = 10 ** 9 + 7
        @lru_cache(None)
        def dfs(pos, steps):
            # if we walk outside the array or use all the steps
            # then return 0
            if pos < 0 or pos > steps or pos > arrLen - 1: return 0
            # if we use all the steps, return 1 only if pos is 0
            if steps == 0: return pos == 0
            return (
                # move to the left
                dfs(pos - 1, steps - 1) +
                # stay at current position
                dfs(pos, steps - 1) +
                # move to the right
                dfs(pos + 1, steps - 1) 
            ) % M
        return dfs(0, steps)"
number of ways to stay in the same place after some steps,"class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        MOD = (10**9)+7
        @cache
        def dfs(steps,index):
            if steps == 0 and index == 0:
                return 1

            if steps == 0:
                return 0

            goLeft = 0
            goRight = 0
            goStay = 0

            if index > 0:
                goLeft = dfs(steps-1,index-1)

            if index < arrLen-1:
                goRight = dfs(steps-1,index+1)

            goStay = dfs(steps-1,index)

            return goLeft+goStay+goRight

        return dfs(steps,0) % MOD"
find winner on a tic tac toe game,"class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        # keep track of the ""net score"" of each row/col/diagonal
        # player A adds 1 to the ""net score"" of each row/col/diagonal they play in,
        # player B subtracts 1
        # scores[0], scores[1] and scores[2] are for rows 0, 1 and 2
        # scores[3], scores[4] and scores[5] are for cols 0, 1 and 2
        # scores[6] and scores[7] are for the forward and backward diagonal
        scores = [0] * 8
        
        for i, (row, col) in enumerate(moves):
            if i % 2 == 0:  # if player A is playing
                x = 1
            else:  # if player B is playing
                x = -1
            
            scores[row] += x
            scores[col + 3] += x
            if row == col:
                scores[6] += x
            if 2 - row == col:
                scores[7] += x
            
        for score in scores:
            if score == 3:
                return 'A'
            elif score == -3:
                return 'B'
        
        return 'Draw' if len(moves) == 9 else 'Pending'"
find winner on a tic tac toe game,"class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        score = [[0]*8 for _ in range(2)]
        
        for p, (i, j) in enumerate(moves):
            p %= 2
            score[p][i] += 1
            score[p][3+j] += 1
            if i == j: score[p][6] += 1
            if i+j == 2: score[p][7] += 1
            if any(x == 3 for x in score[p]): return ""AB""[p]
            
        return ""Pending"" if len(moves) < 9 else ""Draw"""
number of burgers with no waste of ingredients,"class Solution:
    def numOfBurgers(self, tomatoSlices, cheeseSlices):
		# on the basis of the matrix solution
        ans = [0.5 * tomatoSlices - cheeseSlices, -0.5 * tomatoSlices + 2 * cheeseSlices]
		
		# using the constraints to see if solution satisfies it
        if 0 <= int(ans[0]) == ans[0] and 0 <= int(ans[1]) == ans[1]:
            return [int(ans[0]), int(ans[1])]
        else:
            return []"
number of burgers with no waste of ingredients,"class Solution:
    def numOfBurgers(self, T: int, C: int) -> List[int]:
        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]
		
		
- Junaid Mansuri
- Chicago, IL"
count square submatrices with all ones,"class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        
        count=matrix.count(1)
        count=0
        for r in range(len(matrix)):
            for c in range(len(matrix[0])):
                if matrix[r][c]==1:
                    count+=1
                if r==0 or c==0: continue
                
                old_val=matrix[r][c]
                matrix[r][c]=min(matrix[r-1][c-1], matrix[r][c-1],matrix[r-1][c]) + 1 if matrix[r][c]==1 else 0
                count= count+ matrix[r][c]- old_val  
        return count"
count square submatrices with all ones,"class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        count = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 1 and (i != 0 and j != 0):
                    matrix[i][j] = min(matrix[i-1][j-1], matrix[i-1][j], matrix[i][j-1])+1
            count += sum(matrix[i])
        return count"
palindrome partitioning iii,"class Solution:
    def palindromePartition(self, s: str, k: int) -> int:
        
        
		#This is the cost function 
        
        def Cost(s):
            i,j,c=0,len(s)-1,0
            
            while i<j:
                if s[i]!=s[j]:c+=1
                j-=1
                i+=1
            return c
        
        dp={}
        
		# Recursion
		
        def A(s,k):
			# Memoization
            if (s,k) in dp:
                return dp[(s,k)]
			# if k==1 then we want the whole string there is no other way 
            if k==1:
                return Cost(s)
            
			#intial value to max
            f=float('inf')
            
            #start checking whole string 
            for x in range(1,len(s)+1):
                #check wheather if both the strings exist.
                if len(s[:x]) and len(s[x:]):
				
                    #if exist we find the cost recursively assign min value 
                    f=min(f,Cost(s[:x])+A(s[x:],k-1))
             #store the min value       
            dp[(s,k)]=f
			
            return dp[(s,k)]
        return A(s,k)
                
                    
            
            ```"
palindrome partitioning iii,"class Solution:
    def palindromePartition(self, S, K):
        N = len(S)
        dp = [[N] * (N + 1) for _ in range(K + 1)]
        dp[0][0] = 0
        for i in range(2 * N - 1):
            c = 0
            l = i // 2
            r = l + (i &amp; 1)
            while 0 <= l and r < N:
                if S[l] != S[r]: c += 1
                for i in range(K):
                    dp[i + 1][r + 1] = min(dp[i + 1][r + 1], dp[i][l] + c)
                l -= 1
                r += 1
        return dp[-1][-1]"
subtract the product and sum of digits of an integer,"class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        p,s=1,0
        while n!=0:
            p*=(n%10)
            s+=(n%10)
            n//=10
        return p-s"
subtract the product and sum of digits of an integer,"class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        return prod(list(map(int, str(n))))-sum(list(map(int, str(n))))"
group the people given the group size they belong to,"class Solution:
    # Time: O(n)
    # Space: O(n)
    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:
        res, dic = [], {}
        for idx, group in enumerate(groupSizes):
            if group not in dic:
                dic[group] = [idx]
            else:
                dic[group].append(idx)
            
            if len(dic[group]) == group:
                res.append(dic[group])
                del dic[group]
        return res"
group the people given the group size they belong to,"class Solution:
    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:
        # Step 1 : Categorise using hashmap
		h = {}
        for index,value in enumerate(groupSizes): 
            h[value] = h.get(value,[]) + [index]
        ans = []
		
		# Step 2 : Prepare the groups
        for size in h.keys():
            num_grps = len(h[size])//size # // means integer division
            for x in range(num_grps):
                temp = []
                for j in range(size):
                    temp.append(h[size].pop(0))
                ans.append(temp)
		# Return the answer
        return ans"
find the smallest divisor given a threshold,"class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        left, right = 1, max(nums)
        while left + 1 < right:
            mid = (left + right) // 2
            div_sum =  self.get_sum(mid, nums)
            if div_sum > threshold:
                left = mid
            else:
                right = mid
        
        div_sum = self.get_sum(left, nums)
        if div_sum <= threshold:
            return left
        return right
        
    
    def get_sum(self, divisor, nums):
        res = 0
        for n in nums:
            tmp = n // divisor
            if tmp * divisor < n:
                tmp += 1
            
            res += tmp
        
        return res"
find the smallest divisor given a threshold,"class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        def ok(mid):
            ans = 0
            for num in nums:
                ans += math.ceil(num / mid)
                if ans > threshold: return False
            return True    
        l, r = 1, int(1e6)
        while l <= r:
            mid = (l+r) // 2
            if ok(mid): r = mid - 1
            else: l = mid + 1
        return l"
minimum number of flips to convert binary matrix to zero matrix,"class Solution:
    def minFlips(self, G: List[List[int]]) -> int:
        M, N = len(G), len(G[0])
        P = [(i,j) for i,j in itertools.product(range(M),range(N))]
        for n in range(M*N+1):
            for p in itertools.permutations(P,n):
                H = list(map(list,G))
                for (x,y) in p:
                    for (i,j) in (x,y-1),(x,y),(x,y+1),(x-1,y),(x+1,y):
                        if 0 <= i < M and 0 <= j < N: H[i][j] = 1 - H[i][j]
                if max(max(H)) == 0: return n
        return -1
		
		
- Junaid Mansuri
- Chicago, IL"
element appearing more than 25 percent in sorted array,"class Solution:
    def findSpecialInteger(self, A: List[int]) -> int:
        return collections.Counter(A).most_common(1)[0][0]
		

from statistics import mode

class Solution:
    def findSpecialInteger(self, A: List[int]) -> int:
        return mode(A)


class Solution:
    def findSpecialInteger(self, A: List[int]) -> int:
        return max(set(A), key = A.count)
		
		
class Solution:
    def findSpecialInteger(self, A: List[int]) -> int:
        return (lambda C: max(C.keys(), key = lambda x: C[x]))(collections.Counter(A))
		
		
- Junaid Mansuri
- Chicago, IL"
element appearing more than 25 percent in sorted array,"class Solution:
    def findSpecialInteger(self, arr: List[int]) -> int:
        per = len(arr)//4
        for i in arr:
            occ = arr.count(i)
            if occ > per:
                return i"
remove covered intervals,"class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        res, longest = len(intervals), 0
        srtd = sorted(intervals, key = lambda i: (i[0], -i[1]))
        
        for _, end in srtd:
            if end <= longest:
                res -= 1
            else:
                longest = end
                
        return res"
remove covered intervals,"class Solution:
	def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:

		intervals=sorted(intervals)

		i=0
		while i<len(intervals)-1:

				a,b = intervals[i]
				p,q = intervals[i+1]

				if a <= p and q <= b:
					intervals.remove(intervals[i+1])
					i=i-1

				elif p <= a and b <= q:
					intervals.remove(intervals[i])
					i=i-1

				i=i+1
		return len(intervals)"
minimum falling path sum ii,"class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        min1 = min11 = float('inf')                     # min1 -> minimum , min11 -> second minimum in even indexed row
        min2 = min22 = float('inf')                     # min2 -> minimum , min22 -> second minimum in odd indexed row
        for i in range(rows):
            for j in range(cols):
                if i==0:
                    if grid[i][j]<=min1:                # Logic to find minimum and second minimum
                        min11 = min1
                        min1 = grid[i][j]
                    elif grid[i][j]<min11:
                        min11 = grid[i][j]    
                else:
                    if i%2:
                        if grid[i-1][j]==min1:          # If adjacent -> then add the second minimum value
                            grid[i][j] += min11
                        else:                           # Else -> add the minimum value
                            grid[i][j] += min1
                        if grid[i][j]<min2:             # Logic to find minimum and second minimum
                            min22 = min2
                            min2 = grid[i][j]
                        elif grid[i][j]<min22:
                            min22 = grid[i][j]
                    else:
                        if grid[i-1][j]==min2:
                            grid[i][j] += min22
                        else:
                            grid[i][j] += min2
                        if grid[i][j]<min1:             # Logic to find minimum and second minimum
                            min11 = min1
                            min1 = grid[i][j]
                        elif grid[i][j]<min11:
                            min11 = grid[i][j]    
            if i%2:                                     # Reset the minimum and second minimum values accordingly
                min1 = min11 = float('inf')
            else:
                min2 = min22 = float('inf')
        return min(grid[-1])                            # Return the minimum element in last row"
minimum falling path sum ii,"class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        
        # Time : O(N^2) 
        # Space : O(N)
        
        rows = len(grid)
        cols = len(grid[0])
        
        if cols == 1:
            return grid[0][0]
        
        dp = [float('inf') for i in range(cols + 2) ]
        min_in_left = [float('inf') if i in {0, cols +1} else 0 for i in range(cols + 2) ]
        min_in_right = [float('inf') if i in {0, cols +1} else 0 for i in range(cols + 2) ]
        
        for i in range(rows-1,-1,-1):
            for j in range(1,cols+1):
                dp[j] = grid[i][j-1] + min(min_in_left[j-1], min_in_right[j+1])
            
            for j in range(1, cols+1):
                min_in_left[j] = min(dp[j], min_in_left[j-1])
                
            for j in range(cols, 0, -1):
                min_in_right[j] = min(dp[j], min_in_right[j+1])
    
        return min(dp)"
convert binary number in a linked list to integer,"class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        answer = 0
        while head: 
            answer = 2*answer + head.val 
            head = head.next 
        return answer"
convert binary number in a linked list to integer,"class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        ans = 0
        while head: 
            ans = 2*ans + head.val 
            head = head.next 
        return ans"
sequential digits,"class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        l=len(str(low))
        h=len(str(high))
        ans=[]
        a=[12,23,34,45,56,67,78,89]
        t=0
        while l<=h:
            for i in a:
                for j in range(0,l-2):
                    t=i%10
                    if i==9:
                        break
                    i=int(str(i)+str(t+1))
                if i%10==0:
                    break
                if i>=low and i<=high:
                    ans.append(i)
            l+=1
        return ans"
sequential digits,"class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        ans = []
        def dfs(cur, digit):
            if digit <= 10 and low <= cur <= high: ans.append(cur) # add number satisfy the condition
            elif cur < low: pass                                   # continue check larger values
            else: return                                           # stop condition
            cur = cur * 10 + digit                                 # generating number with sequential digits
            dfs(cur, digit+1)                                      # backtracking
        for i in range(1, 10): dfs(0, i)                           # start with each digit from 1 to 9, inclusive
        return sorted(ans)                                         # sort the result and return"
maximum side length of a square with sum less than or equal to threshold,"class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        ans = 0            
        m = len(mat)
        n = len(mat[0])
        presum = [[0] * (n+1) for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                presum[i][j] = mat[i-1][j-1] + presum[i][j-1] + presum[i-1][j] - presum[i-1][j-1] 
                lo, hi = 1, min(i, j) + 1
                while lo < hi:
                    mid = (lo + hi)//2
                    cursum = presum[i][j] - presum[i-mid][j] - presum[i][j-mid] + presum[i-mid][j-mid]
                    if cursum > threshold:
                        hi = mid
                    else:
                        lo = mid + 1
                ans = max(ans, lo-1)
        return ans"
maximum side length of a square with sum less than or equal to threshold,"class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        m = len(mat)
        n = len(mat[0])
        presum = [[0] * (n+1) for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                presum[i][j] = mat[i-1][j-1] + presum[i][j-1] + presum[i-1][j] - presum[i-1][j-1] 
        ans = 0            
        for i in range(m+1):
            for j in range(n+1):
                length = ans + 1
                while (i + length <= m and j + length <= n and
                       presum[i+length][j+length] - presum[i+length][j] - presum[i][j+length] + presum[i][j] <= threshold):
                    ans = length
                    length += 1
        return ans"
shortest path in a grid with obstacles elimination,"class Solution:
    def shortestPath(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        
        # x, y, obstacles, steps
        q = deque([(0,0,k,0)])
        seen = set()
        
        while q:
            x, y, left, steps = q.popleft()
            if (x,y,left) in seen or left<0:
                continue
            if (x, y) == (m-1, n-1):
                return steps
            seen.add((x,y,left))
            if grid[x][y] == 1:
                left-=1
            for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
                new_x, new_y = x+dx, y+dy
                if 0<=new_x<m and 0<=new_y<n:
                    q.append((new_x, new_y, left, steps+1))
        return -1"
shortest path in a grid with obstacles elimination,"class Solution:
    def shortestPath(self, grid: List[List[int]], k: int) -> int:
        if len(grid) == 1 and len(grid[0]) == 1:
            return 0
        q = deque([(0,0,k,0)])
        visited = set([(0,0,k)])
        
        if (len(grid)-1) + (len(grid[0])-1) < k:
            return (len(grid)-1) + (len(grid[0])-1)
        
        while q:
            r, c, e, steps = q.popleft()
            for new_r,new_c in [(r-1,c), (r+1,c), (r,c-1), (r,c+1)]:
                if (new_r >= 0 and
                    new_r < len(grid) and 
                    new_c >= 0 and
                    new_c < len(grid[0])):
                    if grid[new_r][new_c] == 1 and e > 0 and (new_r,new_c,e-1) not in visited:
                        visited.add((new_r,new_c,e-1))
                        q.append((new_r,new_c,e-1,steps+1))
                    if grid[new_r][new_c] == 0 and (new_r,new_c,e) not in visited:
                        if new_r == len(grid) - 1 and new_c == len(grid[0]) - 1:
                            return steps + 1
                        visited.add((new_r,new_c,e))
                        q.append((new_r,new_c,e,steps+1))
        return -1"
find numbers with even number of digits,"class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        return len([x for x in nums if len(str(x)) % 2 == 0])"
find numbers with even number of digits,"class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        
        counter = 0
        
        for number in nums:
            
            if len( str(number) ) % 2 == 0:
                
                counter += 1
                
        return counter"
divide array in sets of k consecutive numbers,"class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        hand = nums
        W = k
        if not hand and W > 0:
            return False
        if W > len(hand):
            return False
        if W == 0 or W == 1: 
            return True
        expectation_map = {}
        # self.count keep track of the numbers of cards that have been successfully counted as a straight,
        # when self.count == len(hand) => All cards are part of a valid straight 
        self.count = 0
        handLength = len(hand)

        #Sort the hand.
        sortedHand = sorted(hand)

        
        """"""
        This method updates the expectation map in the following way:
            a) If the len(l) == W
                    => We've completed a straight of length W, add it towards the final count
            b) if the next expected number (num+1) is already in the map 
                    => add the list to a queue of hands waiting to make a straight
            c) if expected number (num+1) not in the map 
                    => Add a new expectation key with value as a new queue with this list 
        """"""
        def update_expectation_with_list(expectation_map, num, l, W):
            # If we have W consecutive numbers, we're done with this set, count towards final count
            if len(l) == W:
                self.count += W
            # we need more numbers to make this straight, add back with next expected num 
            else:
                exp = num + 1
                # Some other list is already expecting this number, add to the queue
                if exp in expectation_map:
                    expectation_map[exp].append(l)

                # New expected number, create new key and set [l] as value
                else:
                    expectation_map[exp] = [l]
        
        """"""
        Very similar to update_expectation_with_list. The difference here is we have the first card of the straight and thus we need to handle it correctly (set the value as a list of lists)
        """"""
        def update_expectation_with_integer(expectation_map, num):
            exp = num + 1
            # Some other list is already expecting this number, add to the queue
            if exp in expectation_map:
                expectation_map[exp].append([num])
            # New expected number, create new key and set [num] as value
            else:
                expectation_map[exp] = [[num]]
        
        for idx,num in enumerate(sortedHand):
            # A possible straight can be formed with this number
            if num in expectation_map:
                # there are multiple hands waiting for this number
                if len(expectation_map[num]) > 1:
                    # pop the first hand
                    l = expectation_map[num].pop(0)
                    # add num to this hand
                    l.append(num)
                    # Update the expectation map
                    update_expectation_with_list(expectation_map, num, l, W)
                
                # there's only one hand expecting this number
                else:
                    # pop the first hand
                    l = expectation_map[num].pop(0)
                    l.append(num)

                    # Important : del the key! There's no other hand expecting this number
                    expectation_map.pop(num) 
                    update_expectation_with_list(expectation_map, num, l, W)
                    
            # Nothing is expecting this number, add new expectation to the map
            else:
                update_expectation_with_integer(expectation_map, num)
                
        return self.count == handLength"
divide array in sets of k consecutive numbers,"class Solution:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        if len(nums) % k != 0:
            return False


        count = collections.Counter(nums)
        count = dict(sorted(count.items()))
        print(count)
        while count:
            start_key = list(count.keys())[0]
            count[start_key] -=1
            if count[start_key] == 0:
                count.pop(start_key)
            for i in range(1, k):
                if start_key + i not in count:
                    return False
                count[start_key+i] -=1
                if count[start_key+i] == 0:
                    count.pop(start_key+i)
        return True"
maximum number of occurrences of a substring,"class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        s1 = []
        count ={}
        while minSize <= maxSize:
            for i in range(0,len(s)):
                if (i+ minSize) <=len(s) and len(set(s[i: i+ minSize])) <= maxLetters:
                    s1.append(s[i: i+ minSize])
            minSize += 1         
        for i in s1:
            count[i] = count[i] + 1 if i in count  else 1      
        return max(count.values()) if count else 0"
maximum number of occurrences of a substring,"class Solution:
    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
        freq = {}
        temp = {}
        for i in range(len(s)): 
            temp[s[i]] =  1 + temp.get(s[i], 0)
            if i >= minSize: 
                temp[s[i-minSize]] -= 1 
                if temp[s[i-minSize]] == 0: temp.pop(s[i-minSize])
            
            if i >= minSize-1 and len(temp) <= maxLetters: 
                key = s[i-minSize+1: i+1]
                freq[key] = 1 + freq.get(key, 0)
        return max(freq.values(), default=0)"
maximum candies you can get from boxes,"class Solution:
    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:
        myKeys = set()
        canVisit = set(initialBoxes)
        q = initialBoxes[:]
        # Check [all keys we can get] and [all boxes we can visit]
        while q:
            box = q.pop(0)
            myKeys.update(set((keys[box]))) # Add the keys in box into ""myKeys""
            canVisit.add(box) # Add current box into ""canVisit""
            newBoxes = containedBoxes[box] # Add next boxes to the queue
            for nb in newBoxes:
                q.append(nb)
                
        ans = 0
        # Visit all boxes we can visit 
        for i in canVisit:
            # We can open the box only if we have the key or box's status is open(1)
            if i in myKeys or status[i] == 1:
                ans += candies[i]
        return ans"
maximum candies you can get from boxes,"class Solution:
    def maxCandies(self, S: List[int], C: List[int], K: List[List[int]], CB: List[List[int]], I: List[int]) -> int:
        t, I, S, B = 0, set(I), set([i for i,v in enumerate(S) if v]), 1
        while B:
            B = 0
            for b in I &amp; S: t, I, S, B = t + C[b], I.union(set(CB[b]))-{b}, S.union(set(K[b])), 1
        return t
            
            
            
- Junaid Mansuri
- Chicago, IL"
replace elements with greatest element on right side,"class Solution:
    def replaceElements(self, arr: List[int]) -> List[int]:
        mx = arr[-1]
        arr[-1] = -1
        for i in range(len(arr) - 2, -1, -1):
            temp = arr[i]
            arr[i] = mx
            if mx < temp: mx = temp
        return arr"
replace elements with greatest element on right side,"class Solution:
    def replaceElements(self, A: List[int]) -> List[int]:
        for i in range(len(A)-2,-1,-1): A[i] = max(A[i],A[i+1])
        return  A[1:]+[-1]
		
- Junaid Mansuri
- Chicago, IL"
sum of mutated array closest to target,"class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:
        arr.sort()
        s, n = 0, len(arr)
        
        for i in range(n):
            ans = round((target - s)/n)
            if ans <= arr[i]: return ans 
            s += arr[i]
            n -= 1
            
        return arr[-1]"
sum of mutated array closest to target,"class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:
        arr.sort()
        length = len(arr)
        
        for x in range(length):
            sol = round(target / length)
            if arr[x] >= sol:
                return sol
            target -= arr[x]
            length -= 1
        
        return arr[-1]"
number of paths with max score,"class Solution:
    def pathsWithMaxScore(self, board: List[str]) -> List[int]:
        """"""bottom-up dp""""""
        n = len(board) #dimension

        #count > 0 also indicates state is reachable
        dp = [[0, 0] for _ in range(n+1)] #score-count (augment by 1 for convenience)
        
        for i in reversed(range(n)):
            #not assuming reachability while updating state
            copy = [[0, 0] for _ in range(n+1)] #to be updated to new dp
            for j in reversed(range(n)): 
                if board[i][j] == ""X"": continue #skip obstacle
                if board[i][j] == ""S"": #initialize ""S""
                    copy[j] = [0, 1]
                    continue 
                #find max score from neighbors
                for candidate in (copy[j+1], dp[j], dp[j+1]): #right/below/right-below
                    if not candidate[1]: continue #not reachable
                    if copy[j][0] < candidate[0]: copy[j] = candidate[:]
                    elif copy[j][0] == candidate[0]: copy[j][1] = (copy[j][1] + candidate[1])%(10**9+7)
                #update with board number 
                if board[i][j] != ""E"": copy[j][0] += int(board[i][j])
            dp = copy
        return dp[0]"
number of paths with max score,"class Solution:
    def pathsWithMaxScore(self, board: List[str]) -> List[int]:
        n = len(board)-1
        self.board = [[int(_) if _.isdigit() else _ for _ in x] for x in board]
        self.board[n][n] = 0
        self.board[0][0] = 0
        self.scores = [[0 for _ in range(n+2)] for x in range(n+2)]
        self.counts = [[0 for _ in range(n+2)] for x in range(n+2)]
        self.counts[n][n] = 1
        for i in range(n, -1, -1):
            for j in range(n, -1, -1):
                if self.board[i][j] == 'X':
                    continue
                highest_score = max(self.scores[i+1][j],
                            self.scores[i+1][j+1],
                            self.scores[i][j+1])
                score = highest_score + self.board[i][j]
                self.scores[i][j] = score
                
                for i_x, j_x in [[i+1, j], [i+1, j+1], [i, j+1]]:
                    if self.scores[i_x][j_x] == highest_score:
                        self.counts[i][j] += self.counts[i_x][j_x]
        
        if self.counts[0][0] == 0:
            return [0, 0]
        else:
            return [self.scores[0][0], self.counts[0][0] % (10**9+7)]"
deepest leaves sum,"class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        q = [(root, 0)]
        ans = 0
        curr_level = 0 # Maintains the current level we are at
        while len(q) != 0: # Do a simple Level Order Traversal
            current, max_level = q.pop(0)
            if max_level > curr_level: # Update the ans as curr_level gets outdated
                curr_level = max_level # Update curr_level
                ans = 0 # Ans needs to be constructed for the new level i.e. max_level
            ans += current.val
            if current.left is not None:
                q.append((current.left, max_level + 1))
            if current.right is not None:
                q.append((current.right, max_level + 1))
        return ans"
deepest leaves sum,"class Solution:
    def deepestLeavesSum(self, root: TreeNode) -> int:
        queue = [root]
        while queue:
            front = []
            ans = 0
            for node in queue: 
                ans += node.val
                if node.left: front.append(node.left)
                if node.right: front.append(node.right)
            queue = front
        return ans"
find n unique integers sum up to zero,"class Solution:
    def sumZero(self, n: int) -> List[int]:
        return list(range(1,n))+[-n*(n-1)//2]"
find n unique integers sum up to zero,"class Solution:
    def sumZero(self, n: int) -> List[int]:
        return list(range(-(n//2), 0)) + [0]*(n % 2) + list(range(1, n//2 + 1))

 
- Junaid Mansuri
- Chicago, IL"
all elements in two binary search trees,"class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        h = lambda r:  h(r.left) + [r.val] + h(r.right) if r else []
        return sorted( h(root1) + h(root2) )"
all elements in two binary search trees,"class Solution:
    # Time: O(n)
    # Space: O(n)
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        l1 = self.dfs(root1, [])
        l2 = self.dfs(root2, [])
        res = []
        while l1 or l2:
            if not l1:
                res.append(l2.pop(0))
            elif not l2:
                res.append(l1.pop(0))
            else:
                res.append(l1.pop(0) if l1[0] < l2[0] else l2.pop(0))
        return res
        
    def dfs(self, node, vals):
        if not node:
            return
        self.dfs(node.left, vals)
        vals.append(node.val)
        self.dfs(node.right, vals)
        return vals"
jump game iii,"class Solution:
    def canReach(self, arr: List[int], i: int) -> bool:
        if i < 0 or i >= len(arr) or arr[i] < 0: return False
        arr[i] *= -1 # Mark visited
        return arr[i] == 0 or self.canReach(arr, i - arr[i]) or self.canReach(arr, i + arr[i])"
jump game iii,"class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        n=len(arr)
        visited=[0]*n
        lst=[start]
        visited[start]=1
        while lst:
            x=lst.pop(0)
            if arr[x]==0:
                return True
            if x+arr[x]<n and visited[x+arr[x]]==0:
                lst.append(x+arr[x])
                visited[x+arr[x]]=1
            if x-arr[x]>=0 and visited[x-arr[x]]==0:
                lst.append(x-arr[x])
                visited[x-arr[x]]=1
        return False"
verbal arithmetic puzzle,"class Solution:
    def isSolvable(self, words: List[str], result: str) -> bool:
        if max(map(len, words)) > len(result): return False # edge case 
        
        words.append(result)
        digits = [0]*10 
        mp = {} # mapping from letter to digit 
        
        def fn(i, j, val): 
            """"""Find proper mapping for words[i][~j] and result[~j] via backtracking.""""""
            if j == len(result): return val == 0 # base condition 
            if i == len(words): return val % 10 == 0 and fn(0, j+1, val//10)
            
            if j >= len(words[i]): return fn(i+1, j, val)
            if words[i][~j] in mp: 
                if j and j+1 == len(words[i]) and mp[words[i][~j]] == 0: return # backtrack (no leading 0)
                if i+1 == len(words): return fn(i+1, j, val - mp[words[i][~j]])
                else: return fn(i+1, j, val + mp[words[i][~j]])
            else: 
                for k, x in enumerate(digits): 
                    if not x and (k or j == 0 or j+1 < len(words[i])): 
                        mp[words[i][~j]] = k
                        digits[k] = 1
                        if i+1 == len(words) and fn(i+1, j, val-k): return True 
                        if i+1 < len(words) and fn(i+1, j, val+k): return True 
                        digits[k] = 0
                        mp.pop(words[i][~j])
        
        return fn(0, 0, 0)"
verbal arithmetic puzzle,"class Solution:
    def isSolvable(self, words: List[str], result: str) -> bool:
        
        # reverse words
        words = [i[::-1] for i in words]
        result = result[::-1]
        allWords = words + [result]
        
        # chars that can not be 0
        nonZero = set()
        for word in allWords:
            if len(word) > 1:
                nonZero.add(word[-1])
        
        # numbers selected in backtracking
        selected = set()
        # char to Int map
        charToInt = dict()
        mxLen = max([len(i) for i in allWords])
        
        def res(i = 0, c = 0, sm = 0):
            if c == mxLen:
                return 1 if sm == 0 else 0
            elif i == len(words):
                num = sm % 10
                carry = sm // 10
                if c >= len(result):
                    if num == 0:
                        return res(0, c+1, carry)
                    else:
                        return 0
                # result[c] should be mapped to num if a mapping exists
                if result[c] in charToInt:
                    if charToInt[result[c]] != num:
                        return 0
                    else:
                        return res(0, c+1, carry)
                elif num in selected:
                    return 0
                # if mapping does not exist, create a mapping
                elif (num == 0 and result[c] not in nonZero) or num > 0:
                    selected.add(num)
                    charToInt[result[c]] = num
                    ret = res(0, c + 1, carry)
                    del charToInt[result[c]]
                    selected.remove(num)
                    return ret
                else:
                    return 0
            else:
                word = words[i]
                if c >= len(word):
                    return res(i+1, c, sm)
                elif word[c] in charToInt:
                    return res(i+1, c, sm + charToInt[word[c]])
                else:
                    ret = 0
                    # possibilities for word[c]
                    for j in range(10):
                        if (j == 0 and word[c] not in nonZero) or j > 0:
                            if j not in selected:
                                selected.add(j)
                                charToInt[word[c]] = j
                                ret += res(i + 1, c, sm + j)
                                del charToInt[word[c]]
                                selected.remove(j)
                    return ret
        
        return res() > 0"
decrypt string from alphabet to integer mapping,"class Solution:
    def freqAlphabets(self, s: str) -> str:
        for i in range(26,0,-1): s = s.replace(str(i)+'#'*(i>9),chr(96+i))
        return s
            
		
		
- Junaid Mansuri
- Chicago, IL"
decrypt string from alphabet to integer mapping,"class Solution:
    def freqAlphabets(self, s: str) -> str:
        
        fn = lambda i: chr(96+int(i)) #convert number to char
        
        ans = []
        i = len(s)-1
        while i >= 0:
            if s[i] == ""#"": 
                ans.append(fn(s[i-2:i]))
                i -= 3
            else: 
                ans.append(fn(s[i]))
                i -= 1
        
        return """".join(reversed(ans))"
xor queries of a subarray,"class Solution:
    def xorQueries(self, A: List[int], Q: List[List[int]]) -> List[int]:
        B = [A[0]]
        for a in A[1:]: B.append(B[-1]^a)
        B.append(0)
        return [B[L-1]^B[R] for L,R in Q]"
xor queries of a subarray,"class Solution:
    def xorQueries(self, A: List[int], Q: List[List[int]]) -> List[int]:
        B = list(itertools.accumulate(A, func = operator.xor)) + [0]
        return [B[L-1]^B[R] for L,R in Q]
		
		
		
- Junaid Mansuri
- Chicago, IL"
get watched videos by your friends,"class Solution:
    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
        queue = [id]
        count = 0
        seen = set(queue)
        while queue and count < level: #bfs
            count += 1
            temp = set()
            for i in queue: 
                for j in friends[i]:
                    if j not in seen: 
                        temp.add(j)
                        seen.add(j)
            queue = temp
        
        movies = dict()
        for i in queue: 
            for m in watchedVideos[i]: 
                movies[m] = movies.get(m, 0) + 1
        return [k for _, k in sorted((v, k) for k, v in movies.items())]"
get watched videos by your friends,"class Solution:
    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
        friends = [set(lst) for lst in friends]
        row = friends[id]
        previous_friends = {id}
        for _ in range(1, level):
            previous_friends.update(row)
            new_row = set()
            for friend in row:
                new_row.update(friends[friend])
            row = new_row - previous_friends
        videos = defaultdict(int)
        for friend in row:
            for video in watchedVideos[friend]:
                videos[video] += 1
        return [v for _, v in sorted((freq, v) for v, freq in videos.items())]"
minimum insertion steps to make a string palindrome,"class Solution:
    def minInsertions(self, S: str) -> int:
        L = len(S)
        DP = [[0 for _ in range(L+1)] for _ in range(L+1)]
        for i,j in itertools.product(range(L),range(L)): DP[i+1][j+1] = DP[i][j] + 1 if S[i] == S[L-1-j] else max(DP[i][j+1],DP[i+1][j])
        return L - DP[-1][-1]
		
		
- Junaid Mansuri
- Chicago, IL"
minimum insertion steps to make a string palindrome,"class Solution:
    def minInsertions(self, s: str) -> int:
        
        if s == s[::-1]:
            return 0
        
        return len(s) - self.lps(s)
    
    
    def lps(self,s):
        
        revs = s[::-1]
        
        return self.lcs(s,revs)
    
    
    def lcs(self,a,b):
        
        n = len(a)
        m = len(b)
        
        if n==0 or m==0:
            return 0
        
        dp = [[0]*(m+1) for i in range(n+1)]
        
        for i in range(1,n+1):
            for j in range(1,m+1):
                
                if a[i-1] == b[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                    
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                    
                    
        return dp[n][m]"
decompress run length encoded list,"class Solution:
    def decompressRLElist(self, N: List[int]) -> List[int]:
        L, A = len(N), []
        for i in range(0,L,2):
            A.extend(N[i]*[N[i+1]])
        return A"
decompress run length encoded list,"class Solution:
    def decompressRLElist(self, N: List[int]) -> List[int]:
        return sum([N[i]*[N[i+1]] for i in range(0,len(N),2)],[])
		
		
- Junaid Mansuri
- Chicago, IL"
matrix block sum,"class Solution:
    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        mat[:] = [[0] * (n + 1)] + [[0] + row for row in mat]
        res = [[0] * n for i in range(m)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1]
                
        for i in range(m):
            for j in range(n):
                r1, r2 = max(i - K, 0), min(i + K + 1, m)
                c1, c2 = max(j - K, 0), min(j + K + 1, n)
                res[i][j] = mat[r2][c2] - mat[r2][c1] - mat[r1][c2] + mat[r1][c1]

        return res"
matrix block sum,"class Solution:
    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        result = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(m):
            for j in range(n):
                result[i][j] = sum(sum(mat[x][max(0, j-k):min(n, j+k+1)])
                                   for x in range(max(0, i-k), min(m, i+k+1)))
        return result"
sum of nodes with even valued grandparent,"class Solution:
    def __init__(self):
        self.summary = 0

    def sumEvenGrandparent(self, root: TreeNode) -> int:
        self.walk(root, False, False)
        return self.summary

    def walk(self, node: TreeNode, parent_even: bool, grand_parent_even: bool):
        if node is None:
            return
        if grand_parent_even:
            self.summary += node.val
        next_parent_even = True if node.val % 2 == 0 else False
        self.walk(node.left, next_parent_even, parent_even)
        self.walk(node.right, next_parent_even, parent_even)
        return"
sum of nodes with even valued grandparent,"class Solution:
    def sumEvenGrandparent(self, root: TreeNode) -> int:
        root.parent = None
        root.grandparent = None
        result = 0
        stack = [root]
        
        while len(stack):
            node = stack.pop()
            if node.left:
                node.left.parent = node
                node.left.grandparent = node.parent
                stack.append(node.left)
            if node.right:
                node.right.parent = node
                node.right.grandparent = node.parent
                stack.append(node.right)
            
            if node.grandparent and node.grandparent.val % 2 == 0:
                result += node.val
        
        return result"
distinct echo substrings,"class Solution:
    def distinctEchoSubstrings(self, text: str) -> int:
        n = len(text)
		
        def helper(size):
            base = 1 << 5
            M = 10 ** 9 + 7
            a = pow(base, size, M)
            t = 0
            vis = defaultdict(set)
            vis_pattern = set()
            ans = 0
            for i in range(n):
                t = (base * t + ord(text[i]) - ord('a')) % M
                if i >= size:
                    t -= a * (ord(text[i - size]) - ord('a'))
                    t %= M
                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:
                        ans += 1
                        vis_pattern.add(t)
                if i >= size - 1:
                    vis[t].add(i - size + 1)
            return ans

        return sum(helper(size) for size in range(1, n//2+1))"
distinct echo substrings,"class Solution(object):
    def distinctEchoSubstrings(self, text):
        n=len(text)
        ans=0
        s=set()
        for i in range(1,n):
            for j in range(i//2+1,i+1):
                l=i+1-j
                temp=text[j-l:j]
                if temp==text[j:i+1]:
                    s.add(temp)
        return len(s)"
convert integer to the sum of two no zero integers,"class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        left = 0
        right = n
        ans = []
        while True:
            if str(left).count(""0"")==0 and str(right).count(""0"")==0:
                ans.append(left)
                ans.append(right)
                break
            left+=1
            right-=1
        return ans"
convert integer to the sum of two no zero integers,"class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        def check(num):
            while num>0:
                if num%10==0:
                    return False
                num//=10
            return True
        for i in range(1,n):
            t=n-i
            if check(t) and check(i):
                return [i,t]"
minimum flips to make a or b equal to c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:   
        count = 0
        while a or b or c:
            if (a &amp; 1) | (b &amp; 1) != (c &amp; 1):
                if (c &amp; 1): count += 1
                else: count += (a &amp; 1) + (b &amp; 1)
            a, b, c = a >> 1, b >> 1, c >> 1
        return count"
minimum flips to make a or b equal to c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        a, b, c, t, D = bin(a)[2:], bin(b)[2:], bin(c)[2:], 0, {'010':1, '100':1, '001':1, '110':2}
        M = max(len(a),len(b),len(c))
        a, b, c = a.zfill(M), b.zfill(M), c.zfill(M)
        for i in range(M): t += D.get(a[i]+b[i]+c[i],0)
        return t
		
		
- Junaid Mansuri
- Chicago, IL"
number of operations to make network connected,"class Solution:
    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        self.components = n
        # We need atleast n-1 connections to connect n networks
        if(len(connections) < n-1):
            return -1
        # If we have n-1 connections, we only need to count to number of components
        # Union-Find 
        
        parent = [i for i in range(0, n)]
        rank = [0] * n
        for x, y in connections:
            self.union(x, y, parent, rank)
        # we require no. of components - 1 edge to connect n components
        return self.components - 1             
        
    def find(self, x, parent):
        if(parent[x] != x):
            parent[x] = self.find(parent[x], parent)
        return parent[x]
    
    def union(self, x, y, parent, rank):
        parent_x = self.find(x, parent)
        parent_y = self.find(y, parent)
        
        if(parent_x == parent_y):
            return
        rank_x = rank[parent_x]
        rank_y = rank[parent_y]
        
        if(rank_x > rank_y):
            parent[parent_y] = parent_x
        elif(rank_x < rank_y):
            parent[parent_x] = parent_y
        else:
            parent[parent_y] = parent_x
            rank[parent_x] += 1
        self.components -= 1"
number of operations to make network connected,"class Solution:
    def makeConnected(self, n: int, a: List[List[int]]) -> int:
        length = len(a)
        if length < n - 1:
            return -1
        nodes = set()
        connections = defaultdict(list)
        
        for src,dest in a:
            connections[src].append(dest)
            connections[dest].append(src)
        
        def dfs(src):
            if src in nodes:
                return
            nodes.add(src)
            for node in connections[src]:
                dfs(node)
            
        
        result = 0
        for i in range(n):
            if i not in nodes:
                dfs(i)
                result+=1
        
        return result - 1"
minimum distance to type a word using two fingers,"class Solution:
def minimumDistance(self, word: str) -> int:
    def dist(pre,cur):
        if pre==None:
            return 0
        x1,y1 = divmod(ord(pre)-ord('A'),6)
        x2,y2 = divmod(ord(cur)-ord('A'),6)
        return abs(x1-x2) + abs(y1-y2)
    
    @lru_cache(None)
    def fingers(i,l,r):
        if i == len(word):
            return 0
        n1 = dist(l,word[i]) + fingers(i+1,word[i],r)
        n2 = dist(r,word[i]) + fingers(i+1,l,word[i])
        return min(n1,n2)
    
    return fingers(0,None,None)"
minimum distance to type a word using two fingers,"class Solution:
    def minimumDistance(self, word: str) -> int:
        locations = {}
        x, y = 0, 0
        for i in range(65, 91):
            locations[chr(i)] = (x, y)
            y += 1
            if y > 5:
                x += 1
                y = 0
        
        #print(locations)
        @lru_cache(None)
        def func(idx, f1, f2):
            if idx == len(word):
                return 0
            
            # use f1
            if f1 == '':
                x1, y1 = locations[word[idx]]
            else:
                x1, y1 = locations[f1]
                
            x, y = locations[word[idx]]
            dist1 = abs(x1 - x) + abs(y1 - y)
            useF1 = dist1 + func(idx + 1, word[idx], f2)
            
            if f2 == '':
                x2, y2 = locations[word[idx]]
            else:
                x2, y2 = locations[f2]
                
            dist2 = abs(x2 - x) + abs(y2 - y)
            useF2 = dist2 + func(idx + 1, f1, word[idx])
            
            return min(useF1, useF2)
        
        return func(0, '', '')"
maximum 69 number,"class Solution:
    def maximum69Number (self, nums: int) -> int:
        nums = str(nums)                          #changing integer to string
        j = 1                                     #maximum number you can change atmost
        for i in range(len(nums)):
            if nums[i] == ""6"" and (j == 1):       #checking if the element is ""6"" and we are change only once
                bef = nums[:i]                    #stored element before the element 6 using slicing
                aft = nums[i+1:]                  #stored element after the element 6 using slicing
                nums = bef + ""9""+aft              #adding element in place of 6
                j-=1                              # we will reduct 1. so that above condition cant satisfy again.
        nums = int(nums)
        return nums"
maximum 69 number,"class Solution:
    def maximum69Number (self, num: int) -> int:
        num = list(str(num))
        
        for i, n in enumerate(num):
            if n == '6':
                num[i] = '9'
                break
        
        return int(''.join(num))"
print words vertically,"class Solution:
    def printVertically(self, s: str) -> List[str]:
        
        
        st=0 # track of index to take element from each word 
        s=s.split()
        ans=[]
        y=0
        for i in s:
            y=max(y,len(i))
   
        while st<y:
            u=[]
            for i in s:
                if st<len(i):
                    u.append(i[st])
                else:
                    u.append(' ')# adding spaces if word length is less
                    
            
            while u[-1]==' ': # using stack operation to remove trailing spaces
                u.pop()
            ans.append(''.join(u))
            st+=1# increasing index at each iteration 
        return ans"
print words vertically,"class Solution:
    def printVertically(self, s: str) -> List[str]:
        t = s.split(' ')
        
        l = 0
        for i in t:
            if l < len(i):
                l = len(i)
        
        final = []
        i = 0
        for j in range(l):
            st = ''
            for word in t:
                if i < len(word) and word[i]:
                    st += word[i]
                else:
                    st = st + ' '
            
            while len(st) >= 0:
                if st[-1] == ' ':
                    st = st[:-1]
                else:
                    break
                    
            i += 1
            final.append(st)
        
        return final"
delete leaves with a given value,"class Solution:
    def removeLeafNodes(self, R: TreeNode, t: int) -> TreeNode:
        def RLN(R):
            if R == None: return None
            R.left, R.right = RLN(R.left), RLN(R.right)
            return None if R.val == t and R.left == R.right else R
        return RLN(R)
		
		
- Junaid Mansuri
- Chicago, IL"
delete leaves with a given value,"class Solution:
    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
        def helper(root):
            if root is None:
                return True
            left, right = helper(root.left), helper(root.right)
            if left:
                root.left = None
            if right:
                root.right = None
            
            return left and right and root.val == target
        
        return root if not helper(root) else None"
minimum number of taps to open to water a garden,"class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        jumps = [0]*(n+1)
        for i in range(n+1):
            l, r = max(0,i-ranges[i]),  min(n,i+ranges[i])
            jumps[l] = max(jumps[l],r-l)
        step = start = end = 0
        while end < n:
            start, end = end+1, max(i+jumps[i] for i in range(start, end+1))
            if start > end:
                return -1
            step += 1
        return step"
minimum number of taps to open to water a garden,"class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        taps = [0] * len(ranges) 
        for i,r in enumerate(ranges):
            left = max(0, i - r)
            taps[left] = max(taps[left], i + r)

        total = reach = nextReach = 0
        for i, r in enumerate(taps):
            nextReach = max(nextReach, r)
            
            if i == reach:
                if nextReach == reach: return -1
                
                total += 1
                reach = nextReach
                if (nextReach >= n): break
        
        return total"
break a palindrome,"class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        if n == 1: return ''
        for i, c in enumerate(palindrome):
            if c != 'a' and ((i != n // 2 and n % 2) or not n % 2): return palindrome[:i] + 'a' + palindrome[i+1:]                
        else: return palindrome[:-1] + 'b'"
break a palindrome,"class Solution:
    def breakPalindrome(self, s: str) -> str:
        n = len(s)
        if n == 1:
            return ''
        for i in range(n//2):
            if s[i] != 'a':
                return s[:i] + 'a' + s[i+1:]
        return s[:-1] + 'b'"
sort the matrix diagonally,"class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        
        
        d = defaultdict(list)
        
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                d[i-j].append(mat[i][j])
        
        for k in d.keys():
            d[k].sort()
        
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                mat[i][j] = d[i-j].pop(0)
        return mat"
sort the matrix diagonally,"class Solution:
	""""""
	Time:   O(n*m*log(max(n,m))
	Memory: O(n*m)
	""""""

	def diagonalSort(self, matrix: List[List[int]]) -> List[List[int]]:
		n, m = len(matrix), len(matrix[0])
		diags = defaultdict(list)

		for i in range(n):
			for j in range(m):
				diags[i - j].append(matrix[i][j])

		for k in diags:
			diags[k].sort(reverse=True)

		for i in range(n):
			for j in range(m):
				matrix[i][j] = diags[i - j].pop()

		return matrix"
reverse subarray to maximize array value,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        maxi, mini = -math.inf, math.inf
        
        for a, b in zip(nums, nums[1:]):
            maxi = max(min(a, b), maxi)
            mini = min(max(a, b), mini)
        change = max(0, (maxi - mini) * 2)
        
        # solving the boundary situation
        for a, b in zip(nums, nums[1:]):
            tmp1 = - abs(a - b) + abs(nums[0] - b)
            tmp2 = - abs(a - b) + abs(nums[-1] - a)
            change = max([tmp1, tmp2, change])
			
        original_value = sum(abs(a - b) for a, b in zip(nums, nums[1:]))
        return  original_value + change"
rank transform of an array,"class Solution:
	""""""
	Time:   O(n*log(n))
	Memory: O(n)
	""""""

	def arrayRankTransform(self, arr: List[int]) -> List[int]:
		ranks = {num: r for r, num in enumerate(sorted(set(arr)), start=1)}
		return [ranks[num] for num in arr]"
rank transform of an array,"class Solution:
    def arrayRankTransform(self, arr):
        ranks = {}
        for rank, num in enumerate(sorted(set(arr))):
            ranks[num] = rank+1
        return [ranks[num] for num in arr]"
remove palindromic subsequences,"class Solution:
    def removePalindromeSub(self, s: str) -> int:
        return 1 if s == s[::-1] else 2"
remove palindromic subsequences,"class Solution:
    def removePalindromeSub(self, s: str) -> int:
        return int(s==s[::-1]) or 2"
"filter restaurants by vegan friendly, price and distance","class Solution:
    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:
        def f(x):
            if (veganFriendly == 1 and x[2] == 1 and x[3] <= maxPrice and x[4] <= maxDistance) or (veganFriendly == 0 and x[3] <= maxPrice and x[4] <= maxDistance):
                return True
            else:
                return False
        y = list(filter(f,restaurants))
        y.sort(key=lambda a:a[0],reverse=True)
        y.sort(key=lambda a:a[1],reverse=True)
        return [i[0] for i in y]"
"filter restaurants by vegan friendly, price and distance","class Solution:
    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:
        fn = lambda x: (x[2] >= veganFriendly and x[3] <= maxPrice and x[4] <= maxDistance)
        return [x[0] for x in sorted(filter(fn, restaurants), key=lambda x:(-x[1], -x[0]))]"
find the city with the smallest number of neighbors at a threshold distance,"class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        """"""Floyd-Warshall algorithm""""""
        dist = [[float(""inf"")]*n for _ in range(n)]
        for i in range(n): dist[i][i] = 0
        for i, j, w in edges: dist[i][j] = dist[j][i] = w
            
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
        
        ans = {sum(d <= distanceThreshold for d in dist[i]): i for i in range(n)}
        return ans[min(ans)]"
find the city with the smallest number of neighbors at a threshold distance,"class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        graph = {i:dict() for i in range(n)}
        for u,v,w in edges:
            graph[u][v] = w
            graph[v][u] = w
        
        neighbors = [0]*n
        
        for k in range(n):
            dist = [float('inf')]*n
            dist[k] = 0
            visited = [False]*n
            
            queue = [(0, k)]
            heapify(queue)
            
            count = -1

            while len(queue):
                minVal, minNode = heappop(queue)
                if minVal > distanceThreshold: break
                if visited[minNode]: continue
                visited[minNode] = True
                count += 1
                for node in graph[minNode]:
                    if not visited[node] and dist[minNode] + graph[minNode][node] < dist[node]:
                        dist[node] = dist[minNode] + graph[minNode][node]
                        heappush(queue, (dist[node], node))

            neighbors[k] = count
            
        curMin = neighbors[0]
        ans = 0
        for i in range(n):
            if neighbors[i] <= curMin:
                ans = i
                curMin = neighbors[i]

        return ans"
minimum difficulty of a job schedule,"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
        jobCount = len(jobDifficulty)    
        if jobCount < d:
            return -1

        @lru_cache(None)
        def topDown(jobIndex: int, remainDayCount: int) -> int:
            remainJobCount = jobCount - jobIndex
            if remainDayCount == 1:
                return max(jobDifficulty[jobIndex:])
            
            if remainJobCount == remainDayCount:
                return sum(jobDifficulty[jobIndex:])

            minDiff = float('inf')
            maxToday = 0
            for i in range(jobIndex, jobCount - remainDayCount + 1):
                maxToday = max(maxToday, jobDifficulty[i])
                minDiff = min(minDiff, maxToday + topDown(i+1, remainDayCount-1))
            return minDiff

        return topDown(0, d)"
minimum difficulty of a job schedule,"class Solution1: # Memoized Solution
    def minDifficulty(self, arr: List[int], d: int) -> int:
        if d>len(arr): return -1
        n = len(arr)
        dp = [[-1 for i in range(d+1)] for j in range(n)]
        def f(ind,d):
            if ind==n: return float('inf')
            if d==1:   # if we have only one day then we just take max of all remaining jobs
                return max(arr[ind:])
            if dp[ind][d]!=-1: return dp[ind][d]
            ans = float('inf')
            mx = float('-inf')
            s = 0
            for i in range(ind,n):
                mx = max(mx,arr[i])
                s=mx+f(i+1,d-1)
                ans = min(ans,s)
            dp[ind][d] = ans
            return dp[ind][d]
        return f(0,d)
class Solution:  # Tabulation version
    def minDifficulty(self, arr: List[int], d: int) -> int:
        if d>len(arr): return -1
        n = len(arr)
        dp = [[0 for i in range(d+1)] for j in range(n+1)]
        for i in range(d+1):                   # Base Cases
            dp[n][i] = float('inf')
        for i in range(n):                       # Base Case
            dp[i][1]=max(arr[i:])
        for ind in range(n-1,-1,-1):
            for days in range(2,d+1):
                ans = float('inf')
                mx = float('-inf')
                s = 0
                for i in range(ind,n):
                    mx = max(mx,arr[i])
                    s=mx+dp[i+1][days-1]
                    ans = min(ans,s)
                dp[ind][days] = ans
        return dp[0][d]"
the k weakest rows in a matrix,"class Solution:
	def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
		m = len(mat)
		rows = sorted(range(m), key=lambda i: (mat[i], i))
		del rows[k:]
		return rows"
the k weakest rows in a matrix,"class Solution:
    def kWeakestRows(self, G: List[List[int]], k: int) -> List[int]:
        S = [[sum(g),i] for i,g in enumerate(G)]
        R = sorted(S)
        return [r[1] for r in R[:k]]"
reduce array size to the half,"class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        freq = Counter(arr);
        f = [];
        for val in freq.values():
            f.append(val);
        f.sort(reverse=True)
        ans = 0;
        n = 0;
        while(len(arr)//2>n):
            n += f[ans];
            ans += 1;
        return ans;"
reduce array size to the half,"class Solution(object):
    def minSetSize(self, arr):
        d = {}
        for x in arr:
            if x not in d:
                d[x] = 1
            else:
                d[x] += 1
                  
        l = sorted(d.values())
        N = len(arr) // 2
        idx = 0
        
        while N > 0:
            N -= l[-idx-1]
            idx += 1
            
        return idx"
maximum product of splitted binary tree,"class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        vals = []
        
        def fn(node): 
            """"""Return sum of sub-tree.""""""
            if not node: return 0 
            ans = node.val + fn(node.left) + fn(node.right)
            vals.append(ans)
            return ans
        
        total = fn(root)
        return max((total-x)*x for x in vals) % 1_000_000_007"
maximum product of splitted binary tree,"class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        stack, vals = [], []
        node, prev = root, None
        mp = defaultdict(int)
        while node or stack:
            if node: 
                stack.append(node)
                node = node.left 
            else: 
                node = stack[-1] 
                if node.right and node.right != prev: node = node.right 
                else: 
                    mp[node] = node.val + mp[node.left] + mp[node.right]
                    vals.append(mp[node]) 
                    stack.pop() 
                    prev = node 
                    node = None
        return max(x*(vals[-1] - x) for x in vals) % 1_000_000_007"
jump game v,"class Solution:
	def maxJumps(self, arr: List[int], d: int) -> int:

		dp = defaultdict(int)
		def dfs(i):
			if i in dp: return dp[i]
			m_path = 0
			for j in range(i+1,i+d+1):
				if j>=len(arr) or arr[j]>=arr[i]: break
				m_path = max(m_path,dfs(j))

			for j in range(i-1,i-d-1,-1):
				if j<0 or arr[j]>=arr[i]: break
				m_path = max(m_path,dfs(j))
			dp[i] = m_path+1
			return m_path+1

		res = 0
		for i in range(len(arr)):
			res = max(res,dfs(i))
		return res"
jump game v,"class Solution:
    def maxJumps(self, nums: List[int], d: int) -> int:
        N = len(nums)
        seen = set() # seen for lookup, to memoize
        dp = [1]*N   # stores the values of jump we can make from Ith index in DP.                                    #  minimum being 1 jump (i.e its self)
        
        def recursion(indx):
            # if we have indx in seen return its value  dp[indx].
            if indx in seen:
                return dp[indx]
            # base case if indx is out of range we cant jump. return 0
            if indx<0 or indx >= N:
                return 0
            
        # tempR : all the jumps we can make to the right side of indx
        # tempL : all the jumps we can make to the left side of indx
            tempR,tempL= 0,0
            curr = nums[indx] # height of current indx so we only jump allowed jump 
                    # i.e nums[i] < curr <- allowed  if curr =< nums[i] break(jump not allowed)
            
            #max jump we can make to the right Side are stored in tempR, 
            for i in range(indx+1, min(indx+d+1,N) ):
                if nums[i] < curr:
                    tempR = max(tempR, recursion(i)) # store max jumps in right
                else:
                    break
            for i in range(indx-1, max(-1,indx-d-1) , -1): 
                if nums[i] < curr:
                    tempL = max(tempL, recursion(i)) # store max jumps in  left
                else:
                    break
            # update dp[indx] by (1 + maxjumps( right, left))   ( 1 becoz it can jump on itself)
            dp[indx] = max(tempR,tempL) + 1 
            seen.add(indx) # as Indx calculated, can use its value next time, so added to seen
            return dp[indx]
        
        
        # for all indices we check how many jumps we can make
        for i in range(N): 
            if i not in seen: # if ith index is not in seen then we have comupted its jumps.
                recursion(i)
        return max(dp)  # returns the max jumps"
number of steps to reduce a number to zero,"class Solution:
    """"""
    Time:   O(log(n))
    Memory: O(log(n))
    """"""

    def numberOfSteps(self, num: int) -> int:
        if num == 0:
            return 0
        return 1 + self.numberOfSteps(num - 1 if num &amp; 1 else num >> 1)"
number of steps to reduce a number to zero,"class Solution:
    """"""
    Time:   O(log(n))
    Memory: O(1)
    """"""

    def numberOfSteps(self, num: int) -> int:
        steps = 0

        while num != 0:
            steps += 1
            if num &amp; 1:
                num -= 1
            else:
                num >>= 1

        return steps"
number of sub arrays of size k and average greater than or equal to threshold,"class Solution:
    def numOfSubarrays(self, arr, k, threshold):
        windowStart = 0
        max_avg = 0
        avg = 0
        c=0
        result = []
        windowSum = 0
        for windowEnd in range(len(arr)):
            windowSum += arr[windowEnd]
            if((windowEnd)>=k-1):
                avg = windowSum//k
                result.append(avg)
                windowSum -= arr[windowStart]
                windowStart += 1
        for i in range(len(result)):
            if(result[i]>=threshold):
                c=c+1
        return c"
number of sub arrays of size k and average greater than or equal to threshold,"class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        c,j,n=0,0,len(arr)
        s=sum(arr[:k])
        if s>=k*threshold:
            c=1
        for i in range(k,n):
            s+=arr[i]-arr[j]
            if s>=k*threshold:
                c+=1
            j+=1
        return c"
angle between hands of a clock,"class Solution:
    def angleClock(self, hour: int, minutes: int) -> float:
        return min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))"
angle between hands of a clock,"class Solution:
    def angleClock(self, h, m):
        # Convert the hour hand to another minute hand
        m2 = (h%12 + m/60)*5
        
        # Calculate the difference between the two minute hands
        diff = abs(m-m2)
        
        # Convert the difference to an angle
        ang = diff*(360/60)
        
        # Return the smallest angle
        return min(360-ang, ang)"
jump game iv,"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        N, groups = len(arr), defaultdict(list)

        for i, el in enumerate(arr): 
            groups[el].append(i)

        vis, vis_groups = set(), set()
        
        def bfs(lvl, dist):
            nextLvl = set()
            
            for i in lvl:
                if i in vis: continue
                if i == N-1: return dist
                
                vis.add(i)
                
                if i: nextLvl.add(i-1)
                if i+1 < N: nextLvl.add(i+1)
                
                if not arr[i] in vis_groups:
                    vis_groups.add(arr[i])
                    nextLvl.update(groups[arr[i]])
            
            return bfs(nextLvl, dist + 1)
            
        return bfs(set([0]), 0)"
jump game iv,"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        h={}
        for i,e in enumerate(arr):
            if e not in h:
                h[e] = []
            h[e].append(i)
        q = [(0,0)]
        while q:
            n,d = q.pop(0)
            if n == len(arr)-1:
                return d
            if n+1 == len(arr)-1:
                return d+1
            if n+1 < len(arr) and h.get(arr[n+1]):
                q.append((n+1,d+1))
            if n-1 >= 0 and h.get(arr[n-1]):
                q.append((n-1,d+1))
            for i in h[arr[n]]:
                if i != n:
                    q.append((i,d+1))
                if i == len(arr)-1:
                    return d+1
            h[arr[n]] = []"
check if n and its double exist,"class Solution:
    def checkIfExist(self, A: List[int]) -> bool:
        if A.count(0) > 1: return True
        S = set(A) - {0}
        for a in A:
            if 2*a in S: return True
        return False
		
		
- Junaid Mansuri
- Chicago, IL"
check if n and its double exist,"class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        hashMap = {}
        for i in arr:
            if(hashMap.get(i+i)):
                return True
            if(i%2 == 0 and hashMap.get(i//2)):
                return True
            hashMap[i] = True
        return False"
minimum number of steps to make two strings anagram,"class Solution:
    def minSteps(self, S: str, T: str) -> int:
        D = collections.Counter(S) - collections.Counter(T)
        return sum(max(0, D[s]) for s in set(S))
		
		
- Junaid Mansuri
- Chicago, IL"
minimum number of steps to make two strings anagram,"class Solution:
	def minSteps(self, s: str, t: str) -> int:

		common = Counter(s) &amp; Counter(t)
		count = sum(common.values())

		return len(s) - count"
maximum students taking exam,"class Solution:
    def maxStudents(self, seats: list[list[str]]) -> int:
        def count_bits(num: int) -> int:
            # Count how many bits having value 1 in num.
            cnt = 0
            while num:
                cnt += 1
                num &amp;= num - 1

            return cnt

        R, C = len(seats), len(seats[0])
        validSeats = []

        # Calculate valid seats mask for each row.
        for row in seats:
            curr = 0
            for seat in row:
                curr = (curr << 1) + (seat == '.')

            validSeats.append(curr)

        # dp[i][mask] stands for the maximum students on ith row with students
        # following the mask.
        dp = [[-1] * (1 << C) for _ in range(R + 1)]
        dp[0][0] = 0
        for r in range(1, R + 1):
            seatMask = validSeats[r - 1]
            for studentMask in range(1 << C):
                validBits = count_bits(studentMask)

                # 1. Check if a student mask is a subset of seatMask so that
                #   the target student could sit on a seat.
                # 2. The student should not sit next to each other.
                if (
                    studentMask &amp; seatMask == studentMask and
                    studentMask &amp; (studentMask >> 1) == 0
                ):
                    # Then check the upper student mask and make sure that
                    # 1. no student is on the upper left.
                    # 2. no student is on the upper right.
                    # Then the upper mask is a valid candidate for the current
                    # student mask.
                    for upperStudentMask in range(1 << C):
                        if (
                            studentMask &amp; (upperStudentMask >> 1) == 0 and
                            studentMask &amp; (upperStudentMask << 1) == 0 and
                            dp[r - 1][upperStudentMask] != -1
                        ):
                            dp[r][studentMask] = max(
                                dp[r][studentMask],
                                dp[r - 1][upperStudentMask] + validBits
                            )

        return max(dp[-1])"
maximum students taking exam,"class Solution:
    def maxStudents(self, seats: List[List[str]]) -> int:
        m, n = len(seats), len(seats[0]) # dimensions 
        
        valid = []
        for i in range(m): 
            val = 0
            for j in range(n): 
                if seats[i][j] == ""."": val |= 1 << j 
            valid.append(val)
        
        @cache
        def fn(i, mask): 
            """"""Return max students taking seats[i:] given previous row as mask.""""""
            if i == len(seats): return 0 
            ans = fn(i+1, 0)
            for x in range(1 << n): 
                if x &amp; valid[i] == x and (x >> 1) &amp; x == 0 and (mask >> 1) &amp; x == 0 and (mask << 1) &amp; x == 0: 
                    ans = max(ans, bin(x).count(""1"") + fn(i+1, x))
            return ans 
        
        return fn(0, 0)"
count negative numbers in a sorted matrix,"class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        result = 0
        rows = len(grid)
        cols = len(grid[0])
        
        i = 0
        j = cols - 1
        while i < rows and j>=0:
            curr = grid[i][j]
            if(curr < 0):
                j-=1
            else:
                result+=((cols-1) - j) #capture the no.of negative number in this row and jump to next row
                i+=1
        
		#left out negative rows
        while i < rows:
            result+=cols
            i+=1
        
        return result"
count negative numbers in a sorted matrix,"# Approach 1: Brute Force Solution
# Time: O(mn)
# Space: O(n+m)
class Solution:
	def countNegatives(self, grid: List[List[int]]) -> int:
		return sum([1 for i in grid for j in i if j < 0])

# Approach 2: Optimal Solution
# Time: O(n + m)
# Space: O(1)
class Solution:
	def countNegatives(self, grid: List[List[int]]) -> int:
		n = len(grid[0])  # O(n)
		row = len(grid)-1  # O(m)
		clmn = 0
		cnt_neg = 0
		while row >= 0 and clmn < n:  # O(n) + O(m)
			if grid[row][clmn] < 0:
				cnt_neg += n-clmn
				row -= 1
			else:
				clmn += 1
		return cnt_neg"
maximum number of events that can be attended,"# Solution 1
def maxEvents(self, events: List[List[int]]) -> int:
        events = sorted(events, key=lambda x: x[1])
        visited = set()
        for s, e in events:
            for t in range(s, e+1):
                if t not in visited:
                    visited.add(t)
                    break
        return len(visited)"
maximum number of events that can be attended,"# Solution 2: it use `import heapq`
import heapq
class Solution(object):
    def maxEvents(self, events):
        events = sorted(events, key = lambda x:x[0]) #1
        total_days = max(event[1] for event in events) #2
        min_heap = [] #3
        day, cnt, event_id = 1, 0, 0 #4
        
        
        while day <= total_days: #5
		    # if no events are available to attend today, let time flies to the next available event.
            if event_id < len(events) and not min_heap: #6
                day = events[event_id][0] #7
			
			# all events starting from today are newly available. add them to the heap.
            while event_id < len(events) and events[event_id][0] <= day: #8
                heapq.heappush(min_heap, events[event_id][1]) #9
                event_id += 1 #10

			# if the event at heap top already ended, then discard it.
            while min_heap and min_heap[0] < day: #11
                heapq.heappop(min_heap) #12

			# attend the event that will end the earliest
            if min_heap: #13
                heapq.heappop(min_heap) #14 
                cnt += 1 #15
            elif event_id >= len(events): #16
                break  # no more events to attend. so stop early to save time.
            day += 1 #17
        return cnt #18"
construct target array with multiple sums,"class Solution:
	def isPossible(self, target: List[int]) -> bool:

		heapq._heapify_max(target)
		s = sum(target)

		while target[0] != 1:
			sub = s - target[0]
			if sub == 0: return False
			n = max((target[0] - 1) // sub, 1)
			s -= n * sub
			target0 = target[0] - n * sub
			if target0 < 1: return False
			heapq._heapreplace_max(target, target0)

		return True
	```"
construct target array with multiple sums,"class Solution:
    def isPossible(self, target: List[int]) -> bool:
        if len(target) == 1: return target[0] == 1 # edge case 
        
        total = sum(target)
        pq = [-x for x in target] # max heap 
        heapify(pq)
        
        while -pq[0] > 1: 
            x = -heappop(pq)
            total -= x
            if x <= total: return False 
            x = (x-1) % total + 1
            heappush(pq, -x)
            total += x
        return True"
sort integers by the number of 1 bits,"class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        return sorted(arr, key = lambda item: (str(bin(item))[2:].count(""1""), item))"
sort integers by the number of 1 bits,"class Solution:
	def sortByBits(self, array: List[int]) -> List[int]:

		array = sorted(array)

		d = {}

		for i in array:

			total_one = bin(i)[2:].count('1')

			if total_one not in d:
				d[total_one] = [i]
			else:
				d[total_one].append(i)

		d = dict(sorted(d.items() , key = lambda x:x[0]))

		result = []

		for key in d:
			result = result + d[key]

		return result"
number of substrings containing all three characters,"class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        a = b = c = 0                        # counter for letter a/b/c
        ans, i, n = 0, 0, len(s)             # i: slow pointer
        for j, letter in enumerate(s):       # j: fast pointer
            if letter == 'a': a += 1         # increment a/b/c accordingly
            elif letter == 'b': b += 1
            else: c += 1
            while a > 0 and b > 0 and c > 0: # if all of a/b/c are contained, move slow pointer
                ans += n-j                   # count possible substr, if a substr ends at j, then there are n-j substrs to the right that are containing all a/b/c
                if s[i] == 'a': a -= 1       # decrement counter accordingly
                elif s[i] == 'b': b -= 1
                else: c -= 1
                i += 1                       # move slow pointer
        return ans"
number of substrings containing all three characters,"class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        a, b, c = 0, 0, 0
        start, ans, n = 0, 0, len(s)
        i = 0
        
        while i < n:
            if s[i] == 'a':
                a += 1
            elif s[i] == 'b':
                b += 1
            else:
                c += 1
            while a > 0 and b > 0 and c > 0:
                ans += (n-i)
                if s[start] == 'a':
                    a -= 1
                elif s[start] == 'b':
                    b -= 1
                else:
                    c -= 1
                start += 1
            i += 1
        
        return ans"
count all valid pickup and delivery options,"class Solution:
    def countOrders(self, n: int) -> int:
        n=2*n
        ans=1
        while n>=2:
            ans = ans *((n*(n-1))//2)
            n-=2
            ans=ans%1000000007
        return ans"
count all valid pickup and delivery options,"class Solution:
    def countOrders(self, n: int) -> int:
        return (math.factorial(n * 2) >> n) % (10**9 + 7)"
number of days between two dates,"class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        
        def f_date(date): # calculates days passed since '1900-01-01'
            year0 = '1900'
            year1, month1, day1 = date.split('-')
                        
            days = 0
            for y in range(int(year0), int(year1)):
                days += 365
                if y%100 == 0:
                    if y%400 == 0:
                        days += 1
                else:
                    if y%4 == 0:
                        days += 1
                        
            for m in range(int(month1)):
                if m in [1, 3, 5, 7, 8, 10, 12]:
                    days += 31
                if m in [4, 6, 9, 11]:
                    days += 30
                if m == 2:
                    days += 28
                    if int(year1)%100 == 0:
                        if int(year1)%400 == 0:
                            days += 1
                    else:
                        if int(year1)%4 ==0:
                            days += 1
            days += int(day1)
            return days
			
        return abs(f_date(date1) - f_date(date2))"
number of days between two dates,"class Solution:
    
    def leap_year(self,year):
        
        return not(year % 400) or year % 100 and not(year % 4) # Leap year Condition
    
    def count_years_days(self,year):
        
        year_days = 0
        
        for i in range(1971,year): # We need some reference 1971 is reference here lowest possible year in constairnts. You can take anything which will be lesser than given two dates.
            
            # To find distance between a and b. We are taking some reference which is smaller than both a and b. like if we need to find 100 - 200 we can take 0 as reference and find  0 - 100 and 0- 200 then find 100 - 200 which is -100 easily.
            
            # Directly if we try to find a - b many conditions will be there and it will end up having an headache
            
            if self.leap_year(i):
                
                year_days += 366
                
            else:
                
                year_days +=  365
        
        return year_days
    
    def count_month_days(self,m,year):
        
        month = [0,31,28,31,30,31,30,31,31,30,31,30,31]
        
        month_days = 0
        
        for i in range(1,m):
            
            if i==2: # i is number of month like 1 for Jan and 2 for feb
                
                # for leap year feb will have 29 days i.e. x will be 1
                
                month_days += month[i] + int(self.leap_year(year))
                
            else:
                
                month_days += month[i]
        
        return month_days
        
        
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        
        
        year1,month1,date1 = map(int,date1.split(""-""))
        
        year2,month2,date2 = map(int,date2.split(""-""))
        
        return abs ((self.count_years_days(year1) + self.count_month_days(month1,year1) + date1) - (self.count_years_days(year2) + self.count_month_days(month2,year2) + date2))"
validate binary tree nodes,"class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:
        n = len(leftChild)
        
        # tree has 2 requirements
        # 1. every node has a single parent
        # 2. single root (only one node has NO parent)
        # 3. no cycle
        # 4. all nodes connected to each other (single component)
        
        parent = [-1] * n
        
        # checking condition (1. and 2.)
        for idx, (left, right) in enumerate(zip(leftChild, rightChild)):
            
            if left != -1:
                # FAILED: condition (1.)
                if parent[left] != -1: return False
                parent[left] = idx
                
            if right != -1:
                # FAILED: condition (1.)
                if parent[right] != -1: return False
                parent[right] = idx
        
        # FAILED condition (2.)
        if parent.count(-1) != 1: return False
            
        # checking condition (3. and 4.)
        vis = set()
        def dfs_has_cycle(u):
            if u in vis:
                return True
            else:
                vis.add(u)
            
            for kid in [leftChild[u], rightChild[u]]:
                if kid != -1:
                    if dfs_has_cycle(kid): return True
            
        # FAILED condition (3.) - found a cycle
        if dfs_has_cycle(parent.index(-1)): return False
        
        # FAILED condition (4.) - DFS did not visit all nodes!
        if len(vis) != n: return False
        
        # did not FAIL any condition, success ;)
        return True

""""""
Tricky test case (cycle and not connected):
4
[1,-1,3,-1]
[2,-1,-1,-1]

"""""""
validate binary tree nodes,"class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:
	    parent = {}
        for p, children in enumerate(zip(leftChild, rightChild)):
            for c in children:
                if c == -1:
                    continue
                if c in parent:
                    return False
                if p in parent and parent[p] == c:
                    return False
                parent[c] = p
        root = set(range(n)) - set(parent.keys())
        if len(root) != 1:
            return False
        def count(root):
            if root == -1:
                return 0
            return 1 + count(leftChild[root]) + count(rightChild[root])
        return count(root.pop()) == n"
closest divisors,"class Solution:
    def closestDivisors(self, num: int) -> List[int]:
        for i in range(int((num+2)**0.5), 0, -1):
            if not (num+1)%i: return (i, (num+1)//i)
            if not (num+2)%i: return (i, (num+2)//i)"
closest divisors,"class Solution:
    def closestDivisors(self, num: int) -> List[int]:
		# Using Sort
        lis=[]  # lis in the format of [divisor1,divisor2,difference of divisor] Note** product of divisor=dividend
        for i in range(1,int(sqrt(num+1))+1):
            if (num+1)%i==0:
                lis.append((i,(num+1)//i,((num+1)//i)-i))
        
        for i in range(1,int(sqrt(num+2))+1):
            if (num+2)%i==0:
                lis.append((i,(num+2)//i,((num+2)//i)-i))
		lis=sorted(lis,key=lambda x:x[2])
        #print(lis)
        return [lis[0][0],lis[0][1]]"
largest multiple of three,"class Solution:
    def largestMultipleOfThree(self, digits: List[int]) -> str:
        def dump(r: int) -> str:
            if r:
                for i in range(3):
                    idx = 3 * i + r
                    if counts[idx]:
                        counts[idx] -= 1
                        break
                else:
                    rest = 2
                    for j in range(3):
                        idx = 3 * j + (-r % 3)
                        while rest and counts[idx]:
                            counts[idx] -= 1
                            rest -= 1
                        if not rest: break
                    if rest: return ''
            if any(counts):
                result = ''
                for i in reversed(range(10)):
                    result += str(i) * counts[i]
                return str(int(result))
            return ''

        total, counts = 0, [0] * 10
        for digit in digits:
            counts[digit] += 1
            total += digit
        return dump(total % 3)"
largest multiple of three,"class Solution:
  def largestMultipleOfThree(self, digits: List[int]) -> str:

    digits.sort()
    rem = [d % 3 for d in digits]
    s = sum(rem) % 3

    def remove_smallest_with_rem(x): 
      idx = rem.index(x)
      del digits[idx]
      del rem[idx]

    if s != 0:
      try:
        remove_smallest_with_rem(s)
      except ValueError:
        remove_smallest_with_rem(3-s)
        remove_smallest_with_rem(3-s)

    if len(digits) == 0: return """" 
    if digits[-1] == 0: return ""0""
    return ("""".join(str(d) for d in reversed(digits)))"
how many numbers are smaller than the current number,"class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        a=[]
        numi = sorted(nums)
        for i in range(0,len(nums)):
            a.append(numi.index(nums[i]))
        return a"
how many numbers are smaller than the current number,"class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        sort_nums = sorted(nums)
        res = []
        for i in nums:
            res.append(sort_nums.index(i))
        return res"
rank teams by votes,"class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        teamVotes = collections.defaultdict(lambda: [0] * 26)
        for vote in votes:
            for pos, team in enumerate(vote):
                teamVotes[team][pos] += 1
        
        return ''.join(sorted(teamVotes.keys(), reverse=True,
                              key=lambda team: (teamVotes[team], -ord(team))))"
rank teams by votes,"class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        ranking = dict()
        for vote in votes: 
            for i, x in enumerate(vote): 
                ranking.setdefault(x, [0]*len(vote))[i] += 1
        return """".join(sorted(sorted(vote), key=ranking.get, reverse=True))"
linked list in binary tree,"class Solution:
    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        #build longest prefix-suffix array
        pattern, lps = [head.val], [0] #longest prefix-suffix array
        j = 0
        while head.next: 
            head = head.next 
            pattern.append(head.val)
            
            while j and head.val != pattern[j]: j = lps[j-1]
            if head.val == pattern[j]: j += 1
            lps.append(j)
            
        def dfs(root, i): 
            """"""Return True of tree rooted at ""root"" match pattern""""""
            if i == len(pattern): return True
            if not root: return False 
            
            while i > 0 and root.val != pattern[i]: i = lps[i-1]
            if root.val == pattern[i]: i += 1
            return dfs(root.left, i) or dfs(root.right, i)
        
        return dfs(root, 0)"
linked list in binary tree,"class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
        def dfs(hd,node):
            if not hd.next :
                return hd.val==node.val
            if hd.val==node.val:
                if node.left and node.right:
                    return dfs(hd.next,node.left) or dfs(hd.next,node.right)
                elif node.left:
                    return dfs(hd.next,node.left) 
                elif node.right :
                    return dfs(hd.next,node.right)
                else:
                    return False
            else:
                return False
        stk=[root]
        while stk:
            temp=stk.pop()
            if dfs(head,temp):
                return True
            if temp.left:
                stk.append(temp.left)
            if temp.right:
                stk.append(temp.right)
        return False"
minimum cost to make at least one valid path in a grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        graph = {}
        m, n = len(grid), len(grid[0])
        
        def addEdges(i, j):
            graph[(i, j)] = {}
            neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]
            for each in neighbors:
                x, y = each
                if x < 0 or y < 0 or x > m - 1 or y > n - 1:
                    continue
                else:
                    graph[(i, j)][(x, y)] = 1
            
            if grid[i][j] == 1:
                if j != n - 1:
                    graph[(i, j)][(i, j + 1)] = 0
            
            elif grid[i][j] == 2:
                if j != 0:
                    graph[(i, j)][(i, j - 1)] = 0
            
            elif grid[i][j] == 3:
                if i != m - 1:
                    graph[(i, j)][(i + 1, j)] = 0
            
            else:
                if i != 0:
                    graph[(i, j)][(i - 1, j)] = 0
                    
        
        for i in range(m):
            for j in range(n):
                addEdges(i, j)
        
		# convert row, col to index value in distances array
        def convert(x, y):
            return x * n + y
        
        def BFS(graph):
            q = deque()
            q.append([0, 0, 0])
            distances = [float(inf)] * (m * n)
            
            while q:
                cost, x, y = q.popleft()
                if (x, y) == (m - 1, n - 1):
                    return cost
                
                idx = convert(x, y)
                if distances[idx] < cost:
                    continue
                
                distances[idx] = cost
                for node, nxtCost in graph[(x, y)].items():
                    nxtIndex = convert(node[0], node[1])
                    if distances[nxtIndex] <= cost + nxtCost:
                        continue
                    
                    distances[nxtIndex] = cost + nxtCost
                    if nxtCost == 0:
                        q.appendleft([cost, node[0], node[1]])
                    else:
                        q.append([cost + 1, node[0], node[1]])
                        
        
        def dijkstra(graph):
            distances = [float(inf)] * (m * n)
            myheap = [[0, 0, 0]]
            #distances[0] = 0
            
            while myheap:
                cost, x, y = heappop(myheap)
                if (x, y) == (m - 1, n - 1):
                    return cost
                
                idx = convert(x, y)
                if distances[idx] < cost:
                    continue
                else:
                    distances[idx] = cost
                    for node, nxtCost in graph[(x, y)].items():
                        total = cost + nxtCost
                        nxtIndex = convert(node[0], node[1])
                        if distances[nxtIndex] <= total:
                            continue
                        else:
                            distances[nxtIndex] = total
                            heappush(myheap, [total, node[0], node[1]])
            
            return distances[-1]
        
        #return dijkstra(graph)
        return BFS(graph)"
minimum cost to make at least one valid path in a grid,"class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        i_curr, j_curr = 0, 0
        cost = 0
        frontier = []
        visited = [[False for _ in range(n)] for _ in range(m)]
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while 0 <= i_curr < m and 0 <= j_curr < n and not visited[i_curr][j_curr]:
            if i_curr == m - 1 and j_curr == n - 1:
                return cost
            visited[i_curr][j_curr] = True
            frontier.append((i_curr, j_curr))
            di, dj = dirs[grid[i_curr][j_curr] - 1]
            i_curr += di
            j_curr += dj
        while frontier:
            cost += 1
            next_layer = []
            for i, j in frontier:
                for di, dj in dirs:
                    i_next, j_next = i + di, j + dj
                    while 0 <= i_next < m and 0 <= j_next < n and not visited[i_next][j_next]:
                        if i_next == m - 1 and j_next == n - 1:
                            return cost
                        visited[i_next][j_next] = True
                        next_layer.append((i_next, j_next))
                        di, dj = dirs[grid[i_next][j_next] - 1]
                        i_next += di
                        j_next += dj
            frontier = next_layer"
increasing decreasing string,"class Solution:
    def sortString(self, s: str) -> str:
        s = list(s)
        # Big S: O(n)
        result = []
        
        # Logic is capture distinct char with set
        # Remove found char from initial string
        
        # Big O: O(n)
        while len(s) > 0:

            # Big O: O(n log n) Space: O(n)
            smallest = sorted(set(s))
            # Big O: O(s) - reduced set
            for small in smallest:
                result.append(small)
                s.remove(small)
                
            # Big O: O(n log n) Space: O(n)
            largest = sorted(set(s), reverse = True)
            # Big O: O(s) - reduced set
            for large in largest:
                result.append(large)
                s.remove(large)
        
        return ''.join(result)
    
        # Summary:  Big O(n)^2 Space: O(n)"
increasing decreasing string,"class Solution:
    def sortString(self, s: str) -> str:
        
        res = ''
        counter = dict(collections.Counter(s))
        chars = sorted(list(set(s)))
        
        while(counter):
            for char in chars:
                if char in counter:
                    res += char
                    counter[char] -= 1
                    if counter[char] == 0:
                        del counter[char]
            for char in reversed(chars):
                if char in counter:
                    res += char
                    counter[char] -= 1
                    if counter[char] == 0:
                        del counter[char]
                        
        return res"
find the longest substring containing vowels in even counts,"class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        ans = mask = 0 
        seen = {0: -1}
        for i, c in enumerate(s):
            if c in ""aeiou"": 
                mask ^= 1 << (""aeiou"".find(c))
            if mask in seen: ans = max(ans, i - seen[mask])
            seen.setdefault(mask, i)
        return ans"
find the longest substring containing vowels in even counts,"class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        d = collections.defaultdict(lambda: sys.maxsize)
        cur = (0, 0, 0, 0, 0)                            # current mask
        ans = d[cur] = -1                                # initialize result
        vowel = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4} # index mapping
        for i, c in enumerate(s):
            if c in vowel:                               # if `c` is a vowel, update the `cur` (mask)
                idx = vowel[c]
                cur = cur[:idx] + (1-cur[idx],) + cur[idx+1:]
            if d[cur] == sys.maxsize: 
                d[cur] = i                               # if mask is never recorded, recorded it since it's the lowest index of this current mask
            ans = max(ans, i - d[cur])                   # update `ans` by calculating `i - lower_idx_of_mask`
        return ans"
longest zigzag path in a binary tree,"class Solution:
    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        
        LEFT = 0
        RIGHT = 1
            
        stack = []
        if root.left:
            stack.append((root.left, LEFT, 1))
        if root.right:
            stack.append((root.right, RIGHT, 1))
            
        longest = 0
        while stack:
            node, direction, count = stack.pop()
            
            longest = max(longest, count)
            if direction == LEFT:
                if node.left:
                    stack.append((node.left, LEFT, 1))
                if node.right:
                    stack.append((node.right, RIGHT, count+1))
            else:
                if node.right:
                    stack.append((node.right, RIGHT, 1))
                if node.left:
                    stack.append((node.left, LEFT, count+1))
        return longest"
longest zigzag path in a binary tree,"class Solution:
    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        
        # initialize a instance variable in order to
        # save the maximum path length
        self.max_path = 0
        
        # make the DFS
        self.dfs(root, -1, 0)
        
        # return path length
        return self.max_path
    
    def dfs(self, node, prev_direction, path_length):
        # end condition for dfs
        if node is None:
            return
        
        # add current length to max path
        # print(path_length)
        self.max_path = max(path_length, self.max_path)
        
        if prev_direction == 1:
            self.dfs(node.left, 1, 1)
            self.dfs(node.right, 2, path_length+1)
        else:
            self.dfs(node.left, 1, path_length+1)
            self.dfs(node.right, 2, 1)"
maximum sum bst in binary tree,"class Solution:
    def maxSumBST(self, root: TreeNode) -> int:
        tot = -math.inf

        def dfs(node):
            nonlocal tot
            if not node:
                return 0, math.inf, -math.inf 
            l_res, l_min, l_max = dfs(node.left)
            r_res, r_min, r_max = dfs(node.right)
			# if maintains BST property
            if l_max<node.val<r_min:
                res = node.val + l_res + r_res
                tot = max(tot, res)
				# keep track the min and max values of the subtree
                return res, min(l_min,node.val), max(r_max, node.val)
            else:
                return 0, -math.inf, math.inf
        
        return max(dfs(root)[0], tot)"
maximum sum bst in binary tree,"class Solution:
    def maxSumBST(self, root: TreeNode) -> int:
        
        def fn(node): 
            """"""Collect info while traversing the tree in post-order.""""""
            if not node: return True, inf, -inf, 0, 0 # bst flag | min | max | sum
            ltf, lmn, lmx, lsm, lval = fn(node.left)
            rtf, rmn, rmx, rsm, rval = fn(node.right)
            lmn = min(lmn, node.val)
            rmx = max(rmx, node.val)
            sm = lsm + rsm + node.val 
            if ltf and rtf and lmx < node.val < rmn: 
                return True, lmn, rmx, sm, max(lval, rval, sm)
            return False, lmn, rmx, sm, max(lval, rval)
        
        return fn(root)[-1]"
generate a string with characters that have odd counts,"class Solution:
    def generateTheString(self, n: int) -> str:
        a=""a""
        b=""b""
        if n%2==0:
            return (((n-1)*a)+b)
        return (n*a)"
generate a string with characters that have odd counts,"class Solution:
    def generateTheString(self, n: int) -> str:
        return ""a""*n if n%2 == 1 else ""a""*(n-1)+""b"""
number of times binary string is prefix aligned,"class Solution:
    def numTimesAllBlue(self, light: List[int]) -> int:
        max = count = 0
        for i in range(len(light)):
            if max < light[i]:
                max = light[i]
            if max == i + 1:
                count += 1
        return count"
number of times binary string is prefix aligned,"class Solution:
    def numTimesAllBlue(self, light: List[int]) -> int:
        res = 0
        curr_sum = 0
        object_sum = 0
        for i, bulb in enumerate(light):
            object_sum += i + 1
            curr_sum += bulb
            if curr_sum == object_sum:
                res += 1
        return res"
time needed to inform all employees,"class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        def find(i):
            if manager[i] != -1:
                informTime[i] += find(manager[i])
                manager[i] = -1
            return informTime[i]
        return max(map(find, range(n)))"
time needed to inform all employees,"class Solution:
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:        
        def calculateTime(n: int) -> int:
            if manager[n] != -1:
                informTime[n] += calculateTime(manager[n])
                manager[n] = -1
            return informTime[n]
        
        for idx in range(len(manager)):
            calculateTime(idx)
            
        return max(informTime)"
frog position after t seconds,"class Solution:

	def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
		if target==1:
			if t>=1 and len(edges)>=1:
				return 0
		adj = collections.defaultdict(list)
		for i in edges:
			adj[min(i[0],i[1])].append(max(i[1],i[0]))

		def traversal(curr, target,t):
			if curr==target:
				if t==0 or len(adj[curr])==0:
					return 1
				return 0
			if t==0:
				return 0
			for child in adj[curr]:
				prob = traversal(child, target, t-1)/len(adj[curr])
				if prob>0: 
					return prob
			return 0
		return traversal(1,target,t)"
frog position after t seconds,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        tree = dict()
        for i, j in edges: 
            if i > j: i, j = j, i
            tree.setdefault(i-1, []).append(j-1)
        
        queue, time = [(0, 1)], 0 #node-prob
        while queue and time <= t: #bfs 
            tmp = []
            for node, prob in queue: 
                if node == target-1: return 0 if time < t and node in tree else prob
                for n in tree.get(node, []): tmp.append((n, prob/len(tree[node])))
            queue, time = tmp, time+1
        return 0"
find a corresponding node of a binary tree in a clone of that tree,"class Solution:    
    def getTargetCopy(self, node1: TreeNode, node2: TreeNode, target: TreeNode) -> TreeNode:        
        if not node1 or target == node1:  # if node1 is null, node2 will also be null
            return node2
        
        return self.getTargetCopy(node1.left, node2.left, target) or self.getTargetCopy(node1.right, node2.right, target)"
find a corresponding node of a binary tree in a clone of that tree,"class Solution:    
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
        
        curr1=original
        curr2=cloned
        
        found = None
        while curr1:
            if not curr1.left:
                if curr1==target:
                    found=curr2
                curr1=curr1.right
                curr2=curr2.right
            else:
                temp1 = curr1.left
                temp2 = curr2.left
                
                while temp1.right and temp1.right!=curr1:
                    temp1=temp1.right
                    temp2=temp2.right
                
                if temp1.right==curr1:
                    temp1.right=None
                    temp2.right=None
                    if curr1 == target:
                        found=curr2
                    curr1=curr1.right
                    curr2=curr2.right
                else:
                    temp1.right=curr1
                    temp2.right=curr2
                    curr1=curr1.left
                    curr2=curr2.left
        return found"
lucky numbers in a matrix,"class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        rmin = [min(x) for x in matrix]
        cmax = [max(x) for x in zip(*matrix)]
        return [matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) if rmin[i] == cmax[j]]"
lucky numbers in a matrix,"class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        return set(map(min, matrix)) &amp; set(map(max, zip(*matrix)))"
balance a binary search tree,"class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        
        def dfs(node):
            """"""inorder depth-first traverse bst""""""
            if not node: return 
            dfs(node.left)
            value.append(node.val)
            dfs(node.right)
        
        value = [] #collect values
        dfs(root)
        
        def tree(lo, hi): 
            if lo > hi: return None
            mid = (lo + hi)//2
            ans = TreeNode(value[mid])
            ans.left = tree(lo, mid-1)
            ans.right = tree(mid+1, hi)
            return ans
        
        return tree(0, len(value)-1)"
balance a binary search tree,"class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        def inorder(root):
            if root is None: return None
            inorder(root.left); lst.append(root); inorder(root.right)
        
        lst = []
        inorder(root)
        
        def bst(arr):
            if len(arr) == 0:return 
            mid = len(arr)//2;   root = arr[mid]
            root.left = bst(arr[:mid]);   root.right = bst(arr[mid+1:])
            return root
        
        return bst(lst)"
maximum performance of a team,"class Solution:
    def maxPerformance_simple(self, n, speed, efficiency):
        
        people = sorted(zip(speed, efficiency), key=lambda x: -x[1])
        
        result, sum_speed = 0, 0
        
        for s, e in people:
            sum_speed += s
            result = max(result, sum_speed * e)
        
        return result # % 1000000007"
maximum performance of a team,"class Solution:
    def maxPerformance(self, n, speed, efficiency, k):
        
        people = sorted(zip(speed, efficiency), key=lambda x: -x[1])
        
        result, sum_speed = 0, 0
        min_heap = []
		
        for i, (s, e) in enumerate(people):
            if i < k:
                sum_speed += s
                heapq.heappush(min_heap, s)
            elif s > min_heap[0]:
                sum_speed += s - heapq.heappushpop(min_heap, s)
            else:
                continue # don't have to update result since top k speeds are not changed and efficiency goes down
                
            result = max(result, sum_speed * e)
        
        return result # % 1000000007"
find the distance value between two arrays,"class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        n = len(arr2)
        arr2.sort()
        res = 0
        
        for num in arr1:
            low, high = 0, n - 1
            while low <= high:
                mid = (low + high) // 2
                if abs(num - arr2[mid]) <= d:
                    break
                elif num < arr2[mid]:
                    high = mid - 1
                else:
                    low = mid + 1
            else:
                res += 1
        
        return res"
find the distance value between two arrays,"class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        res = len(arr1)
        for i in arr1:
            for j in arr2:
                if(abs(i-j)>d):
                    continue
                else:
                    res-=1
                    break
        return res"
cinema seat allocation,"class Solution:
    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
        seats = {}
        for i, j in reservedSeats: 
            if i not in seats: seats[i] = 0
            seats[i] |= 1 << j-1
        
        ans = 2 * (n - len(seats))
        for v in seats.values(): 
            if not int(""0111111110"", 2) &amp; v: ans += 2
            elif not int(""0111100000"", 2) &amp; v: ans += 1
            elif not int(""0001111000"", 2) &amp; v: ans += 1
            elif not int(""0000011110"", 2) &amp; v: ans += 1
        return ans"
cinema seat allocation,"class Solution:
    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
        alloc = collections.defaultdict(set)
        ct = n*2
        while reservedSeats:
            x = reservedSeats.pop()
            if 1 < x[1] < 6:
                alloc[x[0]].add(1)
            elif 5 < x[1] < 10:
                alloc[x[0]].add(3)
            if 3 < x[1] < 8:
                alloc[x[0]].add(2)
        ct = 2*n
        for key, val in alloc.items():
            if val=={1,2,3}:
                ct-=2
            else:
                ct-=1
        return ct"
sort integers by the power value,"class Solution:
    def getpower(self,num):
        p=0
        while(num!=1):
            if num%2==0:
                num=num//2
                
            else:
                num=(3*num)+1
            p+=1
            
        return p
             
    def getKth(self, lo: int, hi: int, k: int) -> int:
        
        temp=sorted(range(lo,hi+1),key=lambda x:self.getpower(x))
        return temp[k-1]
		```"
sort integers by the power value,"class Solution:
    def po(self,x):
        if(x==1):
            return(0)
        a=0
        if(x%2==0):
            a=self.po(x//2)
        else:
            a=self.po(x*3+1)
        return(a+1)
    def getKth(self, lo: int, hi: int, k: int) -> int:
        ot=[]
        for i in range(lo,hi+1):
            ot.append([i,self.po(i)])
        newara=sorted(ot, key = lambda x:x[1])
        return(newara[k-1][0])"
pizza with 3n slices,"class Solution:
    def maxSizeSlices(self, slices: List[int]) -> int:
        
        @cache
        def fn(i, k, first): 
            """"""Return max sum of k pieces from slices[i:].""""""
            if k == 0: return 0 
            if i >= len(slices) or first and i == len(slices)-1: return -inf 
            if i == 0: return max(fn(i+1, k, False), slices[i] + fn(i+2, k-1, True))
            return max(fn(i+1, k, first), slices[i] + fn(i+2, k-1, first))
        
        return fn(0, len(slices)//3, None)"
pizza with 3n slices,"class Solution:
    def maxSizeSlices(self, slices: List[int]) -> int:
        m=len(slices)//3
        def solve(slices,m):
            n=len(slices)
            dp=[[0 for i in range(m+1)] for j in range(n+1)]
            for i in range(1,n+1):
                for j in range(1,m+1):
                    if i==1:
                        dp[i][j]=slices[0]
                    else:
                        dp[i][j]=max(dp[i-1][j],dp[i-2][j-1]+slices[i-1])
            return dp[n][m]
        return max(solve(slices[:-1],m),solve(slices[1:],m))"
create target array in the given order,"class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        ans = []
        
        for i in range(len(nums)):
            ans.insert(index[i] , nums[i])
        
        return ans"
create target array in the given order,"class Solution:
	def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
		target = []

		for num, idx in zip(nums, index):
			target.insert(idx, num)

		return target"
four divisors,"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            divisor = set() 
            for i in range(1, floor(sqrt(num)) + 1):
                if num % i == 0:
                    divisor.add(num//i)
                    divisor.add(i)
                if len(divisor) > 4:    
                    break
                    
            if len(divisor) == 4:
                res += sum(divisor)
        return res"
four divisors,"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        
        def fn(x):
            c = s = 0
            for i in range(1, int(x**0.5)+1):
                if x % i == 0: 
                    c += 1 + (0 if x//i == i else 1)
                    s += i + (0 if x//i == i else x//i)
            return s if c == 4 else 0
        
        return sum(fn(x) for x in nums)"
check if there is a valid path in a grid,"class Solution:
    directions = [[-1, 0], [0, 1], [1, 0], [0, -1]]
    streetDirections = {
       1: [1, 3],
       2: [0, 2],
       3: [2, 3],
       4: [1, 2],
       5: [0, 3],
       6: [0, 1]
    }
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        def dfs(i: int, j: int, oppositeDirection: int) -> None:
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] < 0:
                return
            v = grid[i][j]
            sd = Solution.streetDirections[v]
            direction = (oppositeDirection + 2) % 4
            if direction not in sd:
                return
            grid[i][j] = -v
            for d in sd:
                delta = Solution.directions[d]
                dfs(i+delta[0], j+delta[1], d)
        dfs(0, 0, 0)
        dfs(0, 0, 3)
        return grid[m-1][n-1] < 0"
check if there is a valid path in a grid,"class Solution:
    # define direction identifiers
    left, right, up, down = 0, 1, 2, 3
    
    # define possible directions to move from a given street
    moves = {
        1: {left, right},
        2: {up,   down},
        3: {left, down},
        4: {down, right},
        5: {left, up},
        6: {up,   right}
    }
    
    # defind offsets x, y offsets for each direction
    offsets = {
        left:  ( 0, -1, right), # y offset, x offset, move to return to previous position
        right: ( 0,  1, left),
        up:    (-1,  0, down),
        down:  ( 1,  0, up)
    }
        
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        if len(grid) == 1 and len(grid[0]) == 1:
            return True
        
        # on the start we can possibly move only to right and down
        # so there are only two possible paths which can lead as to the final position
        for direction in [Solution.right, Solution.down]:
            cur_x, cur_y = 0, 0
            while 1:
                y_offset, x_offset, reverse_move = Solution.offsets[direction]
                cur_x += x_offset
                cur_y += y_offset
                
                # break if current road leads us to out of grid
                if not (0 <= cur_x < len(grid[0]) and 0 <= cur_y < len(grid)):
                    break
                # break if current road leads us to incompatible road
                if not reverse_move in Solution.moves[grid[cur_y][cur_x]]:
                    break
                
                # we are in the infinite loop
                if (cur_x, cur_y) == (0, 0):
                    break
                
                # define next direction
                direction = [i for i in Solution.moves[grid[cur_y][cur_x]] if i != reverse_move][0]
                if (cur_x, cur_y) == (len(grid[0]) - 1, len(grid) - 1):
                    return True
        return False"
longest happy prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n = [0] + [None] * (len(s) - 1)

        for i in range(1, len(s)):
            k = n[i - 1] # trying length k + 1
            while (k > 0) and (s[i] != s[k]):
                k = n[k - 1]
            if s[i] == s[k]:
                k += 1
            n[i] = k
        happy_border = n[-1]
        return s[:happy_border]"
longest happy prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        n = len(s)
        z = [0] * n
        l, r = 0, 0
        for i in range(1, n):
            if i < r:
                z[i] = min(r - i, z[i - l])
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
            if i + z[i] == n:
                return s[i:]
            if i + z[i] > r:
                l, r = i, i + z[i]
        return ''"
find lucky integer in an array,"class Solution:
    def findLucky(self, arr: List[int]) -> int:
        
        charMap = {}
        
        for i in arr:
            charMap[i] = 1 + charMap.get(i, 0)
            
        res = []
        
        for i in charMap:
            if charMap[i] == i:
                res.append(i)
                
        res = sorted(res)    
        
        if len(res) > 0:
            return res[-1]
            
        return -1"
find lucky integer in an array,"class Solution:
    def findLucky(self, arr: List[int]) -> int:
        ans=[]
        d={}
        for ar in arr:
            if ar in d:
                d[ar]+=1
            else:
                d[ar]=1
        for key in d:
            if key ==d[key]:
                ans.append(key)
        if len(ans)==0:
            return -1
        return max(ans)"
count number of teams,"class Solution:
    def numTeams(self, rating: List[int]) -> int:
        
        dp = [[1, 0, 0] for i in range(len(rating))]
        
        for i in range(1, len(rating)):
            for j in range(i):
                if rating[i] > rating[j]:
                    dp[i][1] += dp[j][0]
                    dp[i][2] += dp[j][1]
        
        a = sum(dp[i][2] for i in range(len(dp)))
        #print(a)

        dp = [[1, 0, 0] for i in range(len(rating))]
        
        for i in range(1, len(rating)):
            for j in range(i):
                if rating[i] < rating[j]:
                    dp[i][1] += dp[j][0]
                    dp[i][2] += dp[j][1]
        
        b = sum(dp[i][2] for i in range(len(dp)))
        
        return a + b"
count number of teams,"class Solution:
    def numTeams(self, rating: List[int]) -> int:
        r, size = rating, len( rating )
        
		# compute statistics of sliding range
        left_smaller = [ sum( r[i] < r[j] for i in range(0,j) ) for j in range(size) ]
        right_bigger = [ sum( r[j] < r[k] for k in range(j+1, size) ) for j in range(size)]
        
        num_of_teams = 0
		
		# j slides from 0 to ( n-1 ), and j stands for the index of middle element
        for j in range( 0, size):
		
            num_of_ascending_team = left_smaller[j] * right_bigger[j]
			
            num_of_descending_team = ( j - left_smaller[j] ) * ( size-1 - j - right_bigger[j] )
            
            num_of_teams += ( num_of_ascending_team + num_of_descending_team )
            
        return num_of_teams"
find all good strings,"class Solution:
    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
        lps = [0]
        k = 0 
        for i in range(1, len(evil)): 
            while k and evil[k] != evil[i]: k = lps[k-1]
            if evil[k] == evil[i]: k += 1
            lps.append(k)
        
        @cache
        def fn(i, k, lower, upper): 
            """"""Return number of good strings at position i and k prefix match.""""""
            if k == len(evil): return 0 # boundary condition 
            if i == n: return 1 
            lo = ascii_lowercase.index(s1[i]) if lower else 0
            hi = ascii_lowercase.index(s2[i]) if upper else 25
            
            ans = 0
            for x in range(lo, hi+1): 
                kk = k 
                while kk and evil[kk] != ascii_lowercase[x]: 
                    kk = lps[kk-1]
                if evil[kk] == ascii_lowercase[x]: kk += 1
                ans += fn(i+1, kk, lower and x == lo, upper and x == hi)
            return ans 
        
        return fn(0, 0, True, True) % 1_000_000_007"
find all good strings,"class Solution:
    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
        p=10**9+7
        ord_a=ord('a')
        l=len(evil)
        dup=[]
        for i in range(1, l):
            if evil[i:]==evil[:l-i]:
                dup.append(i)
        lend=len(dup)
        def count(s):
            tmp_ct=0
            bd=1
            ind=n
            without_s=[]
            for i in range(n):
                tmp_ct*=26
                if bd:
                    tmp_ct+=ord(s[i])-ord_a
                if i>=l-1 and ind>i-l and evil<s[i-l+1:i+1]:
                    tmp_ct-=1
                if i>=l:
                    tmp_ct-=without_s[i-l]
                if i>=l-1:
                    if s[i-l+1:i+1]==evil:
                        bd=0
                        ind=i
                tmp_ct%=p
                tmp_with_s=0
                for j in range(lend):
                    d=dup[j]
                    if i>=d:
                        tmp_with_s+=without_s[i-d]
                    if i>=d-1 and ind>i-d and evil[:d]<s[i-d+1:i+1]:
                        tmp_with_s+=1
                without_s.append(tmp_ct-tmp_with_s)
            return tmp_ct, bd
        str_ct1, bd1=count(s1)
        str_ct2, bd2=count(s2)
        return (str_ct2-str_ct1+bd2)%p"
count largest group,"class Solution:

    def countLargestGroup(self, n: int) -> int:
        dp = {0: 0}
        counts = [0] * (4 * 9)
        for i in range(1, n + 1):
            quotient, reminder = divmod(i, 10)
            dp[i] = reminder + dp[quotient]
            counts[dp[i] - 1] += 1

        return counts.count(max(counts))"
count largest group,"class Solution(object):
    def countLargestGroup(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        res = []
        for i in range(1, n+1):
            res.append(sum(int(x) for x in str(i)))
                   
        c = collections.Counter(res)
        x = [i for i in c.values() if i == max(c.values())]
        return len(x)"
construct k palindrome strings,"class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        if k > len(s):
            return False
        dic = {}
        
        for i in s:
            if i not in dic:
                dic[i] = 1
            else:
                dic[i] += 1
        c = 0        
        for i in dic.values():
            if i % 2 == 1:
                c += 1
        
        if c > k:
            return False
        return True"
construct k palindrome strings,"class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        freq = {}
        for c in s: 
		    freq[c] = 1 + freq.get(c, 0)
        return sum(freq[c]&amp;1 for c in freq) <= k <= len(s)"
circle and rectangle overlapping,"class Solution:
    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        x = 0 if x1 <= x_center <= x2 else min(abs(x1-x_center), abs(x2-x_center))
        y = 0 if y1 <= y_center <= y2 else min(abs(y1-y_center), abs(y2-y_center))
        return x**2 + y**2 <= radius**2"
circle and rectangle overlapping,"class Solution:
    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        
        def pointInCircle(p, center):
            nonlocal radius
            xr, yr = center
            x, y = p
            return  abs(x-xr)**2 + abs(y-yr)**2 <= radius**2
        
        def segmentOverlaps(s1, s2):
            return max(s1[0], s2[0]) <= min(s1[1], s2[1])
        
        if any(pointInCircle(p, (x_center, y_center))
               for p in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]):
            return True
        
        if (not segmentOverlaps([x_center - radius, x_center + radius], sorted([x1, x2])) or
            not segmentOverlaps([y_center - radius, y_center + radius], sorted([y1, y2]))):
            return False
        
        return x1 <= x_center <= x2 or y1 <= y_center <= y2"
reducing dishes,"class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort(reverse=True)
        maxSatisfaction = dishSum = 0

        for dish in satisfaction:
            dishSum += dish
            if dishSum <= 0:
                break
            maxSatisfaction += dishSum
        
        return maxSatisfaction"
reducing dishes,"class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort() # ascending order 
        
        @cache
        def fn(i, k): 
            """"""Return max sum of like-time coefficient of satisfation[i:].""""""
            if i == len(satisfaction): return 0 
            return max(satisfaction[i]*k + fn(i+1, k+1), fn(i+1, k))
        
        return fn(0, 1)"
minimum subsequence in non increasing order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        nums.sort()
        l = []
        while sum(l) <= sum(nums):
            l.append(nums.pop())
        return l"
minimum subsequence in non increasing order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        if (len(nums) == 1):
            return nums
        nums.sort()
        count = 0
        num = []
        l = len(nums)
        for i in range(1,l+1):
            count += nums[-i]
            num.append(nums[-i])
            if count > sum(nums[:l-i]):
                return (num)"
number of steps to reduce a number in binary representation to one,"class Solution:
    def numSteps(self, s):
        return len(s) + s.rstrip('0').count('0') + 2 * (s.count('1') != 1) - 1"
number of steps to reduce a number in binary representation to one,"class Solution:
    def numSteps(self, s: str) -> int:          
        found_one = False
        increments = 0
        for num in s[1:][::-1]:
            if num == '1':
                found_one |= True
            elif found_one:
                increments += 1
        
        if found_one:
			increments += 1
            return len(s) + increments
        else:
			return len(s) - 1"
longest happy string,"class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        count = collections.Counter({'a':a, 'b':b, 'c':c})
        res = ['#']
        while True:
            (a1, _), (a2, _) = count.most_common(2)
            
            if a1 == res[-1] == res[-2]:
                a1 = a2
                
            if not count[a1]:
                break
                
            res.append(a1)
            count[a1] -= 1            
        
        return ''.join(res[1:])"
longest happy string,"class Solution(object):
    def longestDiverseString(self, a, b, c):
        """"""
        :type a: int
        :type b: int
        :type c: int
        :rtype: str
        """"""
        r = ''
        d = {'a':a, 'b':b, 'c':c}
        sign = [-1, 1]
        for i in range(a+b+c):
           
		    # exclude the last character 
            cmp_key = lambda x: d[x]* sign[x!=r[i-1]]
               
            # if r is good
            if i<2 or r[i-1]!=r[i-2]:
                cmp_key = d.get
              
            c = max(d, key=cmp_key)
            if d[c] == 0:
                break
            r += c
            d[c] -=1
                
            
        return r"
stone game iii,"class Solution(object):
    def stoneGameIII(self, stoneValue):
        """"""
        :type stoneValue: List[int]
        :rtype: str
        """"""
        
        dp = [0 for _ in range(len(stoneValue))]
        if len(dp) >= 1:
            dp[-1] = stoneValue[-1]
        if len(dp) >= 2:
            dp[-2] = max(stoneValue[-1] + stoneValue[-2], stoneValue[-2] - dp[-1])
        if len(dp) >= 3:
            dp[-3] = max(stoneValue[-3] + stoneValue[-1] + stoneValue[-2], stoneValue[-3] - dp[-2], stoneValue[-3] + stoneValue[-2] - dp[-1])
        
        for i in range(len(stoneValue) - 4, -1, -1):
            
            dp[i] = max([sum(stoneValue[i: i + j]) - dp[i + j] for j in range(1, 4)])
        
        if dp[0] > 0:
            return ""Alice""
        if dp[0] == 0:
            return ""Tie""
        return ""Bob"""
stone game iii,"class Solution:
    def stoneGameIII(self, stoneValue: List[int]) -> str:
        
        @cache
        def fn(i): 
            """"""Return max value obtained from stoneValue[i:].""""""
            if i >= len(stoneValue): return 0 
            ans = -inf
            for ii in range(i, i+3): 
                ans = max(ans, sum(stoneValue[i:ii+1]) - fn(ii+1))
            return ans 
        
        ans = fn(0)
        if ans > 0: return ""Alice""
        if ans == 0: return ""Tie""
        return ""Bob"""
string matching in an array,"class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        def add(word: str):
            node = trie
            for c in word:
                node = node.setdefault(c, {})

        def get(word: str) -> bool:
            node = trie
            for c in word:
                if (node := node.get(c)) is None: return False
            return True

        words.sort(key=len, reverse=True)
        trie, result = {}, []
        for word in words:
            if get(word): result.append(word)
            for i in range(len(word)):
                add(word[i:])
        return result"
string matching in an array,"class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        def add(word: str):
            node = trie
            for c in word:
                node = node.setdefault(c, {})
                node['#'] = node.get('#', 0) + 1

        def get(word: str) -> bool:
            node = trie
            for c in word:
                if (node := node.get(c)) is None: return False
            return node['#'] > 1

        trie = {}
        for word in words:
            for i in range(len(word)):
                add(word[i:])
        return [word for word in words if get(word)]"
queries on a permutation with key,"class Solution:
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        permuteArr=[i for i in range(1,m+1)]
        query_len=len(queries)
        answer=[]
        left,right=[],[]
        for query in range(query_len):
            index=permuteArr.index(queries[query])
            answer.append(index)
            left=permuteArr[:index]
            right=permuteArr[index+1:]
            permuteArr=[permuteArr[index]]+left+right
        return answer"
queries on a permutation with key,"class Solution:
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        l = [i+1 for i in range(m)]
        x = []
        for i in queries:
            n = l.index(i)
            x.append(n)
            l.insert(0,l.pop(n))
        return x"
html entity parser,"class Solution:
    def entityParser(self, text: str) -> str:
        
        html_symbol = [ '&amp;quot;', '&amp;apos;', '&amp;gt;', '&amp;lt;', '&amp;frasl;', '&amp;amp;']
        formal_symbol = [ '""', ""'"", '>', '<', '/', '&amp;']
                
        for html_sym, formal_sym in zip(html_symbol, formal_symbol):
            text = text.replace( html_sym , formal_sym )
        
        return text"
html entity parser,"class Solution:
    def entityParser(self, text: str) -> str:
        def add(entity: str, symbol: str):
            node = trie
            for c in entity:
                node = node.setdefault(c, {})
            node['#'] = symbol

        def check(idx: int) -> tuple:
            node = trie
            while text[idx] in node:
                node = node[text[idx]]
                idx += 1
                if '#' in node: return node['#'], idx
            return False, idx

        def parse():
            i = 0
            while i < len(text):
                if text[i] in trie:
                    symbol, j = check(i)
                    yield symbol or text[i:j]
                    i = j
                else:
                    yield text[i]
                    i += 1

        trie = {}
        entities = [('&amp;quot;', '""'), ('&amp;apos;', ""'""), ('&amp;amp;', '&amp;'), ('&amp;gt;', '>'), ('&amp;lt;', '<'), ('&amp;frasl;', '/')]
        for entity, symbol in entities:
            add(entity, symbol)
        return ''.join(parse())"
number of ways to paint n  3 grid,"class Solution:
    def numOfWays(self, n: int) -> int:
        mod = 10 ** 9 + 7
        two_color, three_color = 6, 6
        for _ in range(n - 1):
            two_color, three_color = (two_color * 3 + three_color * 2) % mod, (two_color * 2 + three_color * 2) % mod
        return (two_color + three_color) % mod"
number of ways to paint n  3 grid,"class Solution:
    def numOfWays(self, n: int) -> int:
        mod = 10 ** 9 + 7
        
        @lru_cache(None)
        def func(idx, c1, c2, c3):
            if idx == n:
                return 1
            
            nc1, nc2, nc3 = 0, 0, 0
            this = 0
            for i in range(1, 4):
                if i != c1:
                    nc1 = i
                    for j in range(1, 4):
                        if j != c2 and j != nc1:
                            nc2 = j
                            for k in range(1, 4):
                                if k != c3 and k != nc2:
                                    nc3 = k
                                    
                                    this += func(idx + 1, nc1, nc2, nc3)
                                    
                                    
            return this % mod
        
        return func(0, 0, 0, 0)"
minimum value to get positive step by step sum,"class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        
        for i in range(1, len(nums)): nums[i] = nums[i] + nums[i - 1]
        
        return 1 if min(nums) >= 1 else abs(min(nums)) + 1"
minimum value to get positive step by step sum,"class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        #Take starting value as first elemet of the array
        startValue = 0
        
        #This will store the minimum step sum for all iterations
        minimum_num = 0
        
        #Iterate
        for i in nums:
            #StepSum
            startValue += i
            
            #Storing minimum possible step sum
            minimum_num = min(minimum_num, startValue)
        
        #Now if we add a number abs(minimum_num)+1, at each iteration stepsum will increase by this number and hence every stepsum is greater than 1    
        return 1-minimum_num"
find the minimum number of fibonacci numbers whose sum is k,"class Solution:
    def findMinFibonacciNumbers(self, n: int) -> int:
        def check(z):
            key = [1,1]
            while key[-1] + key[-2] <= z:
                key.append(key[-1]+key[-2])
            print(key,z)
            if z in key:
                return 1
            return 1 + check(z-key[-1])
        return check(n)"
find the minimum number of fibonacci numbers whose sum is k,"class Solution:
    def findMinFibonacciNumbers(self, k: int) -> int:
        l=[1,1]
        a=0

        while l[len(l)-1] <= k:
            a += l[len(l)-1]+l[len(l)-2]
            if a > k:
                break
            l.append(a)
            a=0
        b = l[::-1]
        ans = 0
        for i in b:
            if i<=k:
                ans = ans + 1
                k -= i
            if k == 0:
                break
        return ans"
the k th lexicographical string of all happy strings of length n,"class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        
        char = [""a"", ""b"", ""c""]  
        
        # Edge case, n = 1
        if n == 1: return char[k - 1] if k <= 3 else """"
        
        # There will be $part$ number of strings starting with each character (a, b, c)
        part = 2 ** (n - 1)
        
        # If k is too large
        if k > part * 3: return """"
        
        res = []
        
        # Edge case is k = n * i, where i is an integer in range [1, 3]
        res.append(char[k // part if k % part != 0 else k // part - 1])
        k = k % part if k % part != 0 else part
        
        for i in range(n - 2, -1, -1):
            char = [""a"", ""b"", ""c""]  
            char.remove(res[-1])        # Make sure the adjacent characters will be different
            
            if len(res) + 1 == n:       # Edge case, assigning the last element
                if k == 1: res.append(char[0])
                elif k == 2: res.append(char[-1])
            elif k > 2 ** i:            # Go to the right side
                res.append(char[-1])
                k -= 2 ** i       
            else: res.append(char[0])   # Go to the left side
        
        return """".join(res)"
the k th lexicographical string of all happy strings of length n,"class Solution:
    def helper(self,s , l , letters , n ):
        if(len(s) == n):
            l.append(s)
            return 0
        for i in letters :
            if(s[-1] != i ):
                self.helper(s + i , l , letters , n)
            
        
            
    def getHappyString(self, n: int, k: int) -> str:
        letters = [""a"" , ""b"" , ""c""]
        l = []
        for i in letters :
            self.helper(i,l,letters , n)
            if(len(l) >= k):
                return l[k-1]
        return """""
restore the array,"class Solution(object):
    def numberOfArrays(self, s, k):
        n=len(s)
        new=[0]*n
        new[0]=1
        m=len(str(k))
        for i in range(1,n):
            for j in range(max(0,i-m+1),i+1):
                if s[j]!=""0"" and int(s[j:i+1])<=k:
                    if j==0:
                        new[i]=1
                    else:
                        new[i]+=new[j-1]
                #print(new)
        
        return new[-1]%(10**9+7)"
restore the array,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        dp = [0]*(len(s)+1)
        dp[-1] = sm = 1 
        
        ii = len(s)
        for i in reversed(range(len(s))): 
            if s[i] != ""0"": 
                while ii - i - 1 > log10(k) or int(s[i:ii]) > k: 
                    sm = (sm - dp[ii]) % 1_000_000_007
                    ii -= 1
                dp[i] = sm
                sm = (sm + dp[i]) % 1_000_000_007
        return dp[0]"
reformat the string,"class Solution:
    def reformat(self, s: str) -> str:
        nums, chars = [], []
        [(chars, nums)[char.isdigit()].append(str(char)) for char in s]
        nums_len, chars_len = len(nums), len(chars)
        if 2 > nums_len - chars_len > -2:
            a, b = ((chars, nums), (nums, chars))[nums_len > chars_len]
            return reduce(lambda x, y: x + y[0] + y[1], itertools.zip_longest(a, b, fillvalue=''), '')
        return ''"
reformat the string,"class Solution:
    def reformat(self, s: str) -> str:
        nums = [c for c in s if c.isnumeric()]
        alph = [c for c in s if c.isalpha()]
                
        if abs(len(nums) - len(alph)) > 1:
            return ''
        
        a, b = (nums, alph) if len(nums) <= len(alph) else (alph, nums)
        return ''.join(c for pair in itertools.zip_longest(b, a) for c in pair if c)"
display table of food orders in a restaurant,"class Solution:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
                        
        order = defaultdict(lambda : {})
                
        foods = set()
        
        ids = []
        
        for i , t , name in orders:
            t = int(t)
            if(name in order[t]):
                order[t][name] += 1
            else:
                order[t][name] = 1
            if(int(t) not in ids):
                ids.append(int(t))
                
            foods.add(name)
        
        ids.sort()
                        
        foods = list(foods)
        
        foods.sort()
        
        tables = [['Table'] + foods]
        
        k = 0
                
        order = dict(sorted(order.items() , key=lambda x: x[0]))
                
        for _ , j in order.items():
            ans = [str(ids[k])]
            for i in foods:
                if(i in j):
                    ans.append(str(j[i]))
                else:
                    ans.append(""0"")
            
            tables.append(ans)
            
            k += 1
        
        return tables"
display table of food orders in a restaurant,"class Solution:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        freq = {} 
        foods = set()
        
        for _, table, food in orders: 
            freq.setdefault(table, defaultdict(int))[food] += 1
            foods.add(food)
        
        foods = sorted(foods)
        ans = [[""Table""] + foods]
        for k in sorted(freq, key=int): 
            row = [k]
            for food in foods: 
                row.append(str(freq[k][food]))
            ans.append(row)
        return ans"
minimum number of frogs croaking,"class Solution:
    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        cnt, s = collections.defaultdict(int), 'croak'     
        ans, cur, d = 0, 0, {c:i for i, c in enumerate(s)}  # d: mapping for letter &amp; its index
        for letter in croakOfFrogs:                         # iterate over the string
            if letter not in s: return -1                   # if any letter other than ""croak"" is met, then invalid
            cnt[letter] += 1                                # increase cnt for letter
            if letter == 'c': cur += 1                      # 'c' is met, increase current ongoing croak `cur`
            elif cnt[s[d[letter]-1]] <= 0: return -1        # if previous character fall below to 0, return -1
            else: cnt[s[d[letter]-1]] -= 1                  # otherwise, decrease cnt for previous character
            ans = max(ans, cur)                             # update answer using `cur`
            if letter == 'k':                               # when 'k' is met, decrease cnt and cur
                cnt[letter] -= 1
                cur -= 1
        return ans if not cur else -1                       # return ans if current ongoing ""croak"" is 0"
minimum number of frogs croaking,"class Solution:
    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        ans = 0
        freq = [0]*5 # freq array 
        for c in croakOfFrogs: 
            i = ""croak"".index(c)
            freq[i] += 1 
            if i and freq[i-1] < freq[i]: return -1 
            if c == ""k"": 
                ans = max(ans, freq[0])
                for i in range(5): freq[i] -= 1
        if max(freq) == 0: return ans
        return -1"
build array where you can find the maximum exactly k comparisons,"class Solution:
    def numOfArrays(self, n: int, m: int, K: int) -> int:
        MOD = 10 ** 9 + 7
        # f[i][j][k] cumulative sum, first i elements, current max less than or equal to j, k more maximum to fill
        f = [[[0 for _ in range(K + 1)] for _ in range(m + 1)] for _ in range(n + 1)]
        for j in range(m + 1):
            f[0][j][K] = 1

        for i in range(n + 1):
            for j in range(1, m + 1):
                for k in range(K):
                    #             prev value       a[i] <= pref high                            a[i] = j refresh high
                    f[i][j][k] = (f[i][j - 1][k] + j * (f[i - 1][j][k] - f[i - 1][j - 1][k]) + f[i - 1][j - 1][k + 1]) % MOD
        
        return f[n][m][0]"
build array where you can find the maximum exactly k comparisons,"class Solution:
    def numOfArrays(self, n: int, m: int, k: int) -> int:
        @lru_cache(None)
        def solve(size,maxNum,lis):
            val=0
            if size==1:
                return lis==1
            for mx in range(1,m+1):
                if mx<maxNum:
                    val+=solve(size-1,mx,lis-1)
                else:
                    val+=solve(size-1,maxNum,lis)
            return val%1000000007
            
        ans=0
        ans=solve(n+1,m+1,k+1)
        return ans"
maximum score after splitting a string,"class Solution:
    def maxScore(self, s: str) -> int:
        zeros = ones = 0
        ans = float(""-inf"")
        
        for i in range(len(s)-1):
            if s[i] == ""0"": zeros += 1
            else: ones -= 1
            ans = max(ans, zeros + ones)
        
        return ans - ones + (1 if s[-1] == ""1"" else 0)"
maximum score after splitting a string,"class Solution:
    def maxScore(self, s: str) -> int:
        
        return max([s[:i].count('0')+s[i:].count('1') for i in range(1, len(s))])"
maximum points you can obtain from cards,"class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        n = len(cardPoints)
        total = sum(cardPoints)
        
        remaining_length = n - k
        subarray_sum = sum(cardPoints[:remaining_length])
        
        min_sum = subarray_sum
        for i in range(remaining_length, n):
            # Update the sliding window sum to the subarray ending at index i
            subarray_sum += cardPoints[i]
            subarray_sum -= cardPoints[i - remaining_length]
            # Update min_sum to track the overall minimum sum so far
            min_sum = min(min_sum, subarray_sum)
        return total - min_sum"
maximum points you can obtain from cards,"class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        length = len(cardPoints)
        s = sum(cardPoints[-k:])
        maximum = s
        j = length-k
        i=0
        while i!=j and j<length:
            s+=cardPoints[i]
            s-=cardPoints[j]
            i+=1
            j+=1
            maximum = max(s,maximum)
        return maximum"
diagonal traverse ii,"class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        d = collections.defaultdict(list)
        
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                d[(i+j)].append(nums[i][j])
        
        
        ans = []
        for key in d:
            ans += d[key][::-1]
        
        return ans"
diagonal traverse ii,"class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        idx, val = [], []
        for i, row in enumerate(nums):
            for j, num in enumerate(row): 
                idx.append((i+j, -i))
                val.append(num)
        _, ans = zip(*sorted(zip(idx, val)))
        return ans"
constrained subsequence sum,"class Solution:
    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [0]*n
        q = deque()

        for i, num in enumerate(nums):
            if i > k and q[0] == dp[i-k-1]:
                q.popleft()
            dp[i] = max(q[0] if q else 0, 0)+num

            while q and q[-1] < dp[i]:
                q.pop()
            q.append(dp[i])
        return max(dp)"
constrained subsequence sum,"class Solution:
    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp, mono_dec_q, res = [nums[0]] * n, deque([0]), nums[0]
        for i in range(1, n):
            dp[i] = nums[i] + max(0, dp[mono_dec_q[0]])
            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]:
                mono_dec_q.pop()
            if mono_dec_q and i - mono_dec_q[0] == k:
                mono_dec_q.popleft()
            mono_dec_q.append(i)
            res = max(res, dp[i])
        return res"
kids with the greatest number of candies,"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        return [x+extraCandies >= max(candies) for x in candies]"
kids with the greatest number of candies,"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        
        result, maximum = [], max( candies )
        
        for candy in candies:
            
            # check whether current kid can achieve maximum by adding extra candies
            if (candy + extraCandies) >= maximum:
                result.append( True )
            
            else:
                result.append( False )
                
        return result"
max difference you can get from changing an integer,"class Solution:
    def maxDiff(self, num: int) -> int:
        num = str(num)
        
        i = next((i for i in range(len(num)) if num[i] != ""9""), -1) #first non-9 digit
        hi = int(num.replace(num[i], ""9""))
        
        if num[0] != ""1"": lo = int(num.replace(num[0], ""1""))
        else: 
            i = next((i for i in range(len(num)) if num[i] not in ""01""), -1)
            lo = int(num.replace(num[i], ""0"") if i > 0 else num)
            
        return hi - lo"
max difference you can get from changing an integer,"class Solution:
    def maxDiff(self, num: int) -> int:
        a = b = 0
        n = len(str(num))
        nums = str(num)
        if nums[0]!= ""1"" and nums[0]!= ""9"":
            a = int(nums.replace(nums[0],""9""))
            b = int(nums.replace(nums[0],""1""))
            return a-b
        elif nums[0]==""1"": 
            a = int(nums.replace(""1"",""9""))
            b = num
            for i in range(0,n-1):
                if nums[i]!=""1"" and nums[i]!=""0"":
                    b = int(nums.replace(nums[i],""0""))
                    break 
            return a-b
        else: 
            a = num
            b = int(nums.replace(""9"",""1""))
            for i in range(0,n-1):
                if nums[i]!=nums[i+1]:
                    a = int(nums.replace(nums[i+1],""9""))
                    break
            return a-b"
check if a string can break another string,"class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        return all(a<=b for a,b in zip(min(sorted(s1),sorted(s2)),max(sorted(s1),sorted(s2))))```"
check if a string can break another string,"class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        s1 = list(s1)
        s2 = list(s2)
        s1.sort()
        s2.sort()
        i = 0

        while i<len(s1):
            if s1[i]>=s2[i]:
                i+=1
            else:
                break
        if i==len(s1):
            return True
            
        i = 0
        while i<len(s2):
            if s2[i]>=s1[i]:
                i+=1
            else:
                break
        if i==len(s2):
            return True
        return False"
number of ways to wear different hats to each other,"class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        n = len(hats)
        h2p = collections.defaultdict(list)
        for p, hs in enumerate(hats):
            for h in hs:
                h2p[h].append(p)
        full_mask = (1 << n) - 1
        mod = 10**9 + 7
        @functools.lru_cache(maxsize=None)
        def count(h, mask):
		    # everyone wears a hat
            if mask == full_mask:
                return 1
			# ran out of hats
            if h == 41:
                return 0
			# skip the current hat h
            ans = count(h + 1, mask)
            for p in h2p[h]:
			    # if person p already has a hat
                if mask &amp; (1 << p):
                    continue
				# let person p wear hat h
                ans += count(h + 1, mask | (1 << p))
                ans %= mod
            return ans
		# start from the first hat and no one wearing any hat
        return count(1, 0)"
number of ways to wear different hats to each other,"class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        # use hat masks in bottom up dp
        n_hats, n_persons = 40, len(hats)                
        
        dp = [collections.defaultdict(int) for i in range(n_persons + 1)]
        # dp[i] = dict hat_mask -> count using [:i] persons

        curr = dp[0]
        curr[0] = 1
        prev = curr

        for i in range(n_persons):
            curr = dp[i + 1]
            for key in prev:
                curr[key] += prev[key]
            for h in hats[i]:
                bit = 1 << (h - 1)
                for hat_mask in prev:
                    if bit &amp; hat_mask == 0:
                        curr[bit | hat_mask] += prev[hat_mask]
            prev = curr
        
        # answer is sum over all masks with n_persons 1 bits
        masks = []
        for m in dp[n_persons]:
            count, mm = 0, m
            while mm:
                count += 1
                mm = mm &amp; (mm - 1)
            if count == n_persons:
                masks.append(m)                
        return sum(dp[n_persons][m] for m in masks) % 1000000007"
destination city,"class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        lst=[]
        arr=[]
        for i in paths:
            lst.append(i[0])
            arr.append(i[1])
        ptr=set(lst)
        ptr2=set(arr)
        return list(ptr2-ptr)[0]"
destination city,"class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        d = dict(paths)
        for i in d.values():
            if i not in d.keys():
                return i"
check if all 1s are at least length k places away,"class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        indices = [i for i, x in enumerate(nums) if x == 1]
        if not indices:
            return True
        for i in range(1, len(indices)):
            if indices[i] - indices[i-1] < k + 1:
                return False
        return True"
check if all 1s are at least length k places away,"class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        indices = [i for i,x in enumerate(nums) if x==1]
        return all([indices[i+1]-indices[i]>k for i in range(len(indices)-1)])"
longest continuous subarray with absolute diff less than or equal to limit,"class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        #[8,2,4,3,6,11] limit = 5

        #if the new number is greater than max this becomes new max,
        #if new number is less than min this becomes new min
        #if max - min exceeds limit, pop the left most element -> if the left most element was max or min, recompute max - min and see if it goes limit

        q = []
        min_heap = []
        max_heap = []
        max_ans = 1
        popped_index = set()

        for i,v in enumerate(nums):

            q.append((v,i))
            # max_ans = max(max_ans,len(q))
            heapq.heappush(min_heap,(v,i))
            heapq.heappush(max_heap,(v*-1,i))
            while(max_heap[0][0]*-1 - min_heap[0][0] > limit):
                temp = q.pop(0)
                popped_ele = temp[0]
                popped_index.add(temp[1])

                while(min_heap[0][1] in popped_index):
                    heapq.heappop(min_heap)
                
                while(max_heap[0][1] in popped_index):
                    heapq.heappop(max_heap)

            if len(q) > max_ans:
                max_ans = len(q)

        return max_ans"
longest continuous subarray with absolute diff less than or equal to limit,"class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        incq = deque()
        decq = deque()
        ans = 0
        s = e = 0
        while e < len(nums):
            curr = nums[e]

            while incq and incq[-1] < curr:
                incq.pop()
            incq.append(curr)

            while decq and decq[-1] > curr:
                decq.pop()
            decq.append(curr)

            while incq[0] - decq[0] > limit:
                if incq[0] == nums[s]:
                    incq.popleft()

                if decq[0] == nums[s]:
                    decq.popleft()
                s += 1
            ans = max(ans, e-s+1)
            e += 1
        return ans"
find the kth smallest sum of a matrix with sorted rows,"class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        row=len(mat)
        col=len(mat[0])
        temp=[i for i in mat[0]]
        for i in range(1,row):
            currSum=[]
            for j in range(col):
                for it in range(len(temp)):
                    currSum.append(temp[it]+mat[i][j])
            currSum.sort()
            temp.clear()
            maxSize=min(k,len(currSum))
            for size in range(maxSize):
                temp.append(currSum[size])
        return temp[k-1]"
build an array with stack operations,"class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        stack=[]
        for i in range(1,n+1):
            if(i in target):
                stack.append(""Push"")
            else:
                stack.append(""Push"")
                stack.append(""Pop"")
            if(i==(target[-1])):
                break
        return stack"
build an array with stack operations,"class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        output = []
        new_target = []
        l = [i for i in range(1,n+1)]
        for i in l:
            if new_target == target:
                return output
            output.append(""Push"")
            new_target.append(i)
            if i not in target:
                output.append(""Pop"")
                new_target.pop()
        return output"
count triplets that can form two arrays of equal xor,"class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        import collections
        if len(arr) < 2:
            return 0
        xors = arr[0]
        cnt = collections.Counter()
        cnt_sums = collections.Counter()        
        result = 0
        cnt[xors] = 1
        cnt_sums[xors] = 0
        for k in range(1, len(arr)):
            xors ^= arr[k]
            if xors == 0:
                result += k
            result += (k - 1)*cnt[xors] - cnt_sums[xors]
            cnt_sums[xors] += k
            cnt[xors] += 1
            
        return result"
count triplets that can form two arrays of equal xor,"class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        d={0:[0,1]}
        s=0
        ans=0
        for i in range(len(arr)):
            s^=arr[i]
            if(s in d):
                j=d[s]
                ans+=(i*j[1])-j[0]
                d[s][0]+=(i+1)
                d[s][1]+=1
            else:
                d[s]=[(i+1),1]
        return ans"
minimum time to collect all apples in a tree,"class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        self.res = 0
        d = collections.defaultdict(list)
        
        for e in edges: # construct the graph
            d[e[0]].append(e[1])
            d[e[1]].append(e[0])
            
        seen = set() # initialise seen set for visited nodes
        seen.add(0) # add root to visited
        
        def dfs(key):
            # we initialize the go_thru state as 0, meaning we do not go through this node from root
            # there are two cases where we would set go_thru == 1: 
            #(1) when this is the apple node, so we must visit it and go back up
            #(2) when this node has apple nodes as descendants below, we must go down and come back
            go_thru = 0 
            if hasApple[key]: # case 1
                go_thru = 1
    
            for i in d[key]:
                if i not in seen:
                    seen.add(i)
                    a = dfs(i)    
                    if a: # case 2, note that having just one path with an apple node below would require us to go through our current node, 
						  # i.e we don't need both the paths to have apples
                        go_thru = 1
            
            if key != 0: # since 0 is already the root, there is no way we can go through 0 to a node above
                self.res += 2 * go_thru # passing one node means forward and backward, so 1 * 2 for going through, 0 * 2 for not
            return go_thru
        
        dfs(0)
        return self.res"
minimum time to collect all apples in a tree,"class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        graph, visited = defaultdict(list), defaultdict(bool)

        for src, dst in edges:
            graph[src].append(dst)
            graph[dst].append(src)

        visited[0] = True
        def dfs(src: int) -> int:
            time = 0
            for dst in graph[src]:
                if not visited[dst]:
                    visited[dst] = True
                    time += dfs(dst)
            if time or hasApple[src]:
                return time + 2
            return 0
        return max(dfs(0) -2, 0)"
number of ways of cutting a pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        rows, cols = len(pizza), len(pizza[0])
        
        # first, need way to query if a section contains an apple given a top left (r1, c1) and bottom right (r2, c2)
        # we can do this in constant time by keeping track of the number of apples above and to the left of any given cell
        apples = [[0] * cols for _ in range(rows)]
        for row in range(rows):
            apples_left = 0
            for col in range(cols):
                if pizza[row][col] == 'A':
                    apples_left += 1
                apples[row][col] = apples[row-1][col] + apples_left
              
        # query if there is an apple in this rectangle using the prefix sums
        def has_apple(r1, c1, r2 = rows-1, c2 = cols-1) -> bool:
            if r1 > r2 or c1 > c2:
                return False
            tot = apples[r2][c2]
            left_sub = apples[r2][c1-1] if c1 > 0 else 0
            up_sub = apples[r1-1][c2] if r1 > 0 else 0
            upleft_sub = apples[r1-1][c1-1] if r1 > 0 < c1 else 0
            in_rect = tot - left_sub - up_sub + upleft_sub
            return in_rect > 0
        
        # memory optimized dp, keep track of only one matrix of rows x cols
        # bc we only need to access the values at the previous number of cuts
        dp = [[1 if has_apple(r, c) else 0 for c in range(cols + 1)] for r in range(rows + 1)]
        
        for cuts in range(1, k):
            new_dp = [[0] * (cols + 1) for _ in range(rows + 1)]
            for row in range(rows-1, -1, -1):
                for col in range(cols-1, -1, -1):
                    
                    for r2 in range(row, rows):
                        if has_apple(row, col, r2):
                            new_dp[row][col] += dp[r2+1][col]
                            
                    for c2 in range(col, cols):
                        if has_apple(row, col, rows-1, c2):
                            new_dp[row][col] += dp[row][c2+1]
            dp = new_dp
                            
        return dp[0][0] % (10**9 + 7)"
number of ways of cutting a pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        M = 10**9+7
        m, n = len(pizza), len(pizza[0])
        
        arr = [[0] * n for _ in range(m)]
        # keep track of total apples from left top corner to right down corner
        for i in range(m):
            for j in range(n):
                arr[i][j] = ''.join(x[j:] for x in pizza[i:]).count('A')


        @lru_cache(None)
        def dp(r, c, k, cnt):
            # base case
            if k == 1:
                return 1
            ans = 0
            for i in range(m):
                # cuts must be either right or down
                if i <= r: continue
                # rest apples should have at least one but less than previous sum
                if 0 < arr[i][c] < cnt:
                    ans += dp(i, c, k-1, arr[i][c])
            for j in range(n):
                if j <= c: continue
                if 0 < arr[r][j] < cnt:
                    ans += dp(r, j, k-1, arr[r][j])
            return ans % M
                
        
        return dp(0, 0, k, arr[0][0])"
consecutive characters,"class Solution:
    def maxPower(self, s: str) -> int:
        
        # the minimum value for consecutive is 1
        local_max, global_max = 1, 1
        
        # dummy char for initialization
        prev = '#'
        for char in s:
            
            if char == prev:
                
                # keeps consecutive, update local max
                local_max += 1
                
                # update global max length with latest one
                global_max = max( global_max, local_max )
                
            else:
                
                # lastest consective chars stops, reset local max
                local_max = 1
            
                # update previous char as current char for next iteration
                prev = char
        
        
        return global_max"
consecutive characters,"class Solution:
    def maxPower(self, s: str) -> int:
        res = 1
        curr = 1
        
        for i in range(1, len(s)):
            if s[i] == s[i-1]:
                curr += 1
                res = max(res, curr)
            else:
                curr = 1
        
        return res"
simplified fractions,"class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        if n == 1:
            return []
        else:
            numerator = list(range(1,n))
            denominator = list(range(2,n+1))
            res = set()
            values = set()
            for i in numerator:
                for j in denominator:
                    if i < j and i/j not in values:
                        res.add(f'{i}/{j}')
                        values.add(i/j)
            return res"
simplified fractions,"class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        ans = []
        for d in range(2, n+1): 
            for x in range(1, d):
                if gcd(x, d) == 1: ans.append(f""{x}/{d}"")
        return ans"
count good nodes in binary tree,"class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        def solve(root,val):
            if root:
                k = solve(root.left, max(val,root.val)) + solve(root.right, max(val,root.val))
                if root.val >= val:
                    k+=1
                return k
            return 0
        return solve(root,root.val)"
count good nodes in binary tree,"class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        # Our counter for the good nodes.
        count = 0
        
        def helper(node, m):
            nonlocal count
			# If we run out of nodes return.
            if not node:
                return
			# If the current node val is >= the largest observed in the path thus far.
            if node.val >= m:
			    # Add 1 to the count and update the max observed value.
                count += 1
                m = max(m, node.val)
			# Traverse l and r subtrees.
            helper(node.left, m)
            helper(node.right, m)
                
        helper(root, root.val)
        return count"
form largest integer with digits that add up to target,"class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        
        @cache
        def fn(x): 
            """"""Return max integer given target x.""""""
            if x == 0: return 0
            if x < 0: return -inf 
            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))
        
        return str(max(0, fn(target)))"
number of students doing homework at a given time,"class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        count = 0 # If a value meets the criteria, one will be added here.

        for x, y in zip(startTime, endTime): # Zipping the two lists to allow us to iterate over them using x,y as our variables.
            if x <= queryTime <= y: # Checking if the queryTime number is between startTime and endTime, adding one to count if it is.
                    count += 1
        return count # Returning the value in count"
number of students doing homework at a given time,"class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        ans = 0
        for i,j in enumerate(range(len(startTime))):
            if queryTime in range(startTime[i], endTime[j]+1):
                    ans += 1
        
        return ans"
rearrange words in a sentence,"class Solution:
    def arrangeWords(self, text: str) -> str:
        return "" "".join(sorted(text.split(), key=len)).capitalize()"
rearrange words in a sentence,"class Solution:
    def arrangeWords(self, text: str) -> str:
        a = []
        for x in text.split("" ""):
            a.append(x.lower())
        return "" "".join(sorted(a, key=len)).capitalize()"
people whose list of favorite companies is not a subset of another list,"class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:

        n = len(favoriteCompanies)
        comp = []
        for f in favoriteCompanies:
            comp += f
        comp = list(set(comp))
  
        dictBit = {comp[i] : 1 << i for i in range(len(comp))}

        def getBit(cList):
            output = 0
            for c in cList:
                output |= dictBit[c]
            return output
        bitFav = [getBit(favoriteCompanies[i]) for i in range(n)]

        output = []
        for i in range(n):
            isGood = True
            for j in range(n):
                if(i != j and bitFav[i] &amp; bitFav[j] == bitFav[i]):
                    isGood = False
                    break
            if(isGood):
                output.append(i)
    
        return output"
people whose list of favorite companies is not a subset of another list,"class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
        
        # convert to list of sets and keep track of the index
        favoriteCompanies = [(idx, set(ele)) for idx, ele in enumerate(favoriteCompanies)]
        
        
        # we sort the lists by length for early stopping
        favoriteCompanies = sorted(favoriteCompanies, key=lambda x: len(x[1]), reverse=True)
        
        # go through all subsets
        result = []
        for index, (idx, companies) in enumerate(favoriteCompanies):
            
            # get the length
            companies_length = len(companies)
            add_to_list = True
            
            for other_index, (other_idx, other_companies) in enumerate(favoriteCompanies):
                
                # check whether we look at the same set
                if index == other_index:
                    continue
                
                # if we are subset we set add_to_list to false and break
                if companies.issubset(other_companies):
                    add_to_list = False
                    break
                    
                # once we hit sets that are shorter we can break
                if len(other_companies) < companies_length:
                    break
                
            # add if we want to
            if add_to_list:
                result.append(idx)
                
        return sorted(result)"
maximum number of darts inside of a circular dartboard,"class Solution:
    def numPoints(self, points: List[List[int]], r: int) -> int:
        ans = 1
        for x, y in points: 
            angles = []
            for x1, y1 in points: 
                if (x1 != x or y1 != y) and (d:=sqrt((x1-x)**2 + (y1-y)**2)) <= 2*r: 
                    angle = atan2(y1-y, x1-x)
                    delta = acos(d/(2*r))
                    angles.append((angle-delta, +1)) #entry
                    angles.append((angle+delta, -1)) #exit
            angles.sort(key=lambda x: (x[0], -x[1]))
            val = 1
            for _, entry in angles: 
                ans = max(ans, val := val+entry)
        return ans"
maximum number of darts inside of a circular dartboard,"class Solution:
    def numPoints(self, points: List[List[int]], r: int) -> int:
        
        def getPointsInside(i, r, n):
            # This vector stores alpha and beta and flag
            # is marked true for alpha and false for beta
            angles = []

            for j in range(n):
                
                if i != j and distance[i][j] <= 2 * r:
                    # acos returns the arc cosine of the complex
                    # used for cosine inverse
                    B = math.acos(distance[i][j] / (2 * r))

                    # arg returns the phase angle of the complex
                    x1, y1 = points[i]
                    x2, y2 = points[j]
                    
                    A = math.atan2(y1 - y2, x1 - x2)
                    
                    alpha = A - B
                    
                    beta = A + B
                    
                    angles.append((alpha, False))
                    
                    angles.append((beta, True))

            # angles vector is sorted and traversed
            angles.sort()
            # count maintains the number of points inside
            # the circle at certain value of theta
            # res maintains the maximum of all count
            cnt, res = 1, 1
            for angle in angles:
                # entry angle
                if angle[1] == False: 
                    cnt += 1
                # exit angle
                else: 
                    cnt -= 1

                res = max(cnt, res)

            return res

        # Returns count of maximum points that can lie
        # in a circle of radius r.
        #a dis array stores the distance between every
        # pair of points
        n = len(points)
        max_pts = n
        distance = [[0 for _ in range(max_pts)] for _ in range(max_pts)]
        for i in range(n - 1):
            for j in range(i + 1, n):
                # abs gives the magnitude of the complex
                # number and hence the distance between
                # i and j
                x1, y1 = points[i]
                x2, y2 = points[j]
                distance[i][j] = distance[j][i] = sqrt((x1 - x2)**2 + (y1 - y2)**2)

        # This loop picks a point p
        ans = 0
        # maximum number of points for point arr[i]
        for i in range(n):
            ans = max(ans, getPointsInside(i, r, n))

        return ans"
check if a word occurs as a prefix of any word in a sentence,"class Solution:
    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        for i , j in enumerate(sentence.split()):
            if(j.startswith(searchWord)):
                return i + 1
        
        return -1"
check if a word occurs as a prefix of any word in a sentence,"class Solution:
    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        l=sentence.split()
        for i in range(len(l)):
            if l[i].startswith(searchWord):
                return i+1
        return -1"
maximum number of vowels in a substring of given length,"class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        x = 0
        for i in range(k):
            if s[i] in ('a', 'e', 'i', 'o', 'u'):
                x += 1
        ans = x
        for i in range(k,len(s)):
            if s[i] in ('a', 'e', 'i', 'o', 'u'):
                x += 1
            if s[i-k] in ('a', 'e', 'i', 'o', 'u'):
                x -= 1
            ans = max(ans,x)
        return ans"
maximum number of vowels in a substring of given length,"class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        
        n = len(s)
       
        #STEP 1
        arr = []
        for i in range(0, n):
                arr.append(s[i : i + k])
        
        vowels = [""a"", ""e"", ""i"", ""o"", ""u""]
        arr1 = []
        
		#STEP 2
        for i in arr:
            count = 0 
            if len(i) == k:
                for j in i:
                    if j in vowels:
                        count += 1 
                arr1.append(count)
        
		#STEP 3
        if len(arr1) != 0:
            value = max(arr1)
            return value
        else:
            return 0"
pseudo palindromic paths in a binary tree,"class Solution:
    def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:
        if not root: return 0
        cnt ^= 1 << (root.val - 1)
        if root.left is None and root.right is None:
            return 1 if cnt &amp; (cnt - 1) == 0 else 0
        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)"
pseudo palindromic paths in a binary tree,"class Solution:
    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:
                
        ## Function to check if current path has a permutation that's a palindrome
        def isPalindromicPath(palinArr: [int]) -> bool:
            hasSeenFirstOdd: bool = False
            for i in range(0, len(palinArr)):
                if(palinArr[i] % 2 == 1):
                    if hasSeenFirstOdd: return False
                    hasSeenFirstOdd = True
            return True
    
        ## Wrapper for function that calculates the number of pseudo palindromic paths
        def calcPalindromicPaths(root: Optional[TreeNode], arr: [int]) -> int:
            
            count: int = 0
            if root == None: return 0
            arr[root.val] += 1
            
            ## Leaf Node: No children
            if(root.left == None and root.right == None):
                if(isPalindromicPath(arr)): count = 1
            
            if(root.left != None): count += calcPalindromicPaths(root.left, arr)
            if(root.right != None): count += calcPalindromicPaths(root.right, arr)
                
            arr[root.val] -= 1
            return count; 
        
        
        dparr: [int] = [0] * 10
        return calcPalindromicPaths(root, dparr)"
max dot product of two subsequences,"class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        m=len(nums2)
        
        dp=[[0]*(m+1) for i in range(n+1)]
        for i in range(m+1):
            dp[0][i]=-1e9
        for i in range(n+1):
            dp[i][0]=-1e9
        
        for i in range(1, n+1):
            for j in range(1, m+1):
                val=nums1[i-1]*nums2[j-1]+max(0, dp[i-1][j-1])
                dp[i][j]=max(val, max(dp[i-1][j], dp[i][j-1]))
        return dp[n][m]"
max dot product of two subsequences,"class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def fn(i, j): 
            """"""Return max dot product of nums1[i:] and nums2[j:].""""""
            if i == len(nums1) or j == len(nums2): return -inf
            return max(nums1[i]*nums2[j] + fn(i+1, j+1), nums1[i]*nums2[j], fn(i+1, j), fn(i, j+1))
        
        return fn(0, 0)"
make two arrays equal by reversing subarrays,"class Solution:
    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        n, m = len(target), len(arr)
        if m > n:
            return False
        t = Counter(target)
        a = Counter(arr)
        for k, v in a.items():
            if k in t and v == t[k]:
                continue
            else:
                return False
        return True"
make two arrays equal by reversing subarrays,"class Solution:
    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        
        return Counter(arr) == Counter(target)"
check if a string contains all binary codes of size k,"class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:                
        return len({s[i:i+k] for i in range(len(s)-k+1)}) == 2 ** k"
check if a string contains all binary codes of size k,"class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:     
        n=len(s)
        required_count=2 ** k        
        seen=set()
        for i in range(n-k+1):
            tmp=s[i:i+k]
            if tmp not in seen:
                seen.add(tmp)
                required_count-=1
                if required_count==0: # kill the loop once the condition is met
                    return True
        return False"
course schedule iv,"class Solution:
    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        #Let m = len(prereqs) and z = len(queries)
        #Time: O(m + n + n*n + z) -> O(n^2)
        #Space: O(n*n + n + n*n + n + z) -> O(n^2)
        
        
        #process the prerequisites and build an adjacency list graph
        #where edges go from prerequisite to the course that depends on the prereq!
        n = numCourses
        #Adjacency List graph!
        adj = [set() for _ in range(n)]
        #indegrees array!
        indegrees = [0] * n
        #tell us every ith node's set of ancestors or all prereqs to take ith course!
        ancestors = [set() for _ in range(n)]
        #iterate through prereqs and update indegrees array as well as the adj list!
        for i in range(len(prerequisites)):
            prereq, main = prerequisites[i][0], prerequisites[i][1]
            adj[prereq].add(main)
            indegrees[main] += 1
        
        queue = deque()
        #iterate through the indegrees array and add all courses that have no 
        #ancestors(no prerequisites to take it!)
        for a in range(len(indegrees)):
            #ath course can be taken without any prereqs -> first to be processed in
            #the Kahn's BFS algo!
            if(indegrees[a] == 0):
                queue.append(a)
        #proceed with Kahn's algo!
        while queue:
            cur_course = queue.pop()
            neighbors = adj[cur_course]
            for neighbor in neighbors:
                #neighbor has one less incoming edge!
                indegrees[neighbor] -= 1
                #current course is a prerequisite to every neighboring node!
                ancestors[neighbor].add(cur_course)
                #but also, all prereqs of cur_course is also indirectly a prereq
                #to each and every neighboring courses!
                ancestors[neighbor].update(ancestors[cur_course])
                #if neighboring node suddenly becomes can take with no prereqs,
                #add it to the queue!
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        #once the algorithm ends, our ancestors array will have info regarding
        #prerequisites in order to take every course from 0 to n-1!
        output = []
        for query in queries:
            prereq2, main2 = query[0], query[1]
            all_prereqs = ancestors[main2]
            #check if prereq2 is an ancestor or required prereq course to take main2!
            if(prereq2 in all_prereqs):
                output.append(True)
                continue
            else:
                output.append(False)
                
        
        return output"
course schedule iv,"class Solution:
    def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        if not prerequisites:
            return [False]*len(queries)
        graph = collections.defaultdict(list)
        
        for i,j in prerequisites:
            graph[i].append(j)
    
        def dfs(source,distance,visited):
            visited[source] = 1
            if source == distance:
                return True
            for i in graph[source]:
                if(visited.get(i) is None):
                    if(dfs(i,distance,visited)):
                        return True
            return False
        ans = []
        for i,j in queries:
            if j in graph[i]:
                ans.append(True)
            else:
                visited = {}
                ans.append(dfs(i,j,visited))
        return ans"
cherry pickup ii,"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        
        dp = [[[0]*(cols + 2) for _ in range(cols + 2)] for _ in range(rows + 1)]
        
        def get_next_max(row, col_r1, col_r2):
            res = 0
            for next_col_r1 in (col_r1 - 1, col_r1, col_r1 + 1):
                for next_col_r2 in (col_r2 - 1, col_r2, col_r2 + 1):
                    res = max(res, dp[row + 1][next_col_r1 + 1][next_col_r2 + 1])

            return res
        
        for row in reversed(range(rows)):
            for col_r1 in range(min(cols, row + 2)):
                for col_r2 in range(max(0, cols - row - 1), cols):

                    reward = grid[row][col_r1] + grid[row][col_r2]
                    if col_r1 == col_r2:
                        reward /= 2
                    
                    dp[row][col_r1 + 1][col_r2 + 1] = reward + get_next_max(row, col_r1, col_r2)
                    
        return dp[0][1][cols]"
cherry pickup ii,"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        
        @lru_cache(None)
        def fn(i, j, jj): 
            """"""Return max cherries picked so far when two robots are at (i, j) and (i, jj)""""""
            if not (0 <= i < m and 0 <= j < n and 0 <= jj < n) or j > i or jj < n-1-i or jj < j: return 0
            if i == 0: return grid[0][0] + grid[0][n-1]
            return grid[i][j] + (jj != j) * grid[i][jj] + max(fn(i-1, k, kk) for k in range(j-1, j+2) for kk in range(jj-1, jj+2))
                    
        return max(fn(m-1, j, jj) for j in range(n) for jj in range(n))"
maximum product of two elements in an array,"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        # approach 1: find 2 max numbers in 2 loops. T = O(n). S = O(1)
		# approach 2: sort and then get the last 2 max elements. T = O(n lg n). S = O(1)
		# approach 3: build min heap of size 2. T = O(n lg n). S = O(1)
		# python gives only min heap feature. heaq.heappush(list, item). heapq.heappop(list)
        
        heap = [-1]
        for num in nums:
            if num > heap[0]:
                if len(heap) == 2:
                    heapq.heappop(heap)
                heapq.heappush(heap, num)
                
        return (heap[0]-1) * (heap[1]-1)"
maximum product of two elements in an array,"class Solution(object):
    def maxProduct(self, nums):
        nums.sort()
        return (nums[-1] -1) * (nums[-2]-1)
        """"""
        :type nums: List[int]
        :rtype: int
        """""""
maximum area of a piece of cake after horizontal and vertical cuts,"class Solution:
    def maxArea(self, h: int, w: int, hc: List[int], vc: List[int]) -> int:
        
        hc.sort()
        vc.sort()
        
        maxh = hc[0]
        maxv = vc[0]
        
        for i in range(1, len(hc)):
            maxh = max(maxh, hc[i] - hc[i-1])
        maxh = max(maxh, h - hc[-1])
        
        for i in range(1, len(vc)):
            maxv = max(maxv, vc[i] - vc[i-1])
        maxv = max(maxv, w - vc[-1])
        
        return maxh*maxv % (10**9 + 7)"
maximum area of a piece of cake after horizontal and vertical cuts,"class Solution:
    def getMaxConsecutiveDifference(self,distances,lenTotal):
        #Appending first boundary
        distances.append(0)
        #Appending last boundary
        distances.append(lenTotal)
        #Sorting
        distances.sort()
        maxDistancesDiff = 0 
        #Looping to calculate max consecutive distance
        for i in range(1,len(distances)):
            #Getting the difference of two consecutive elements
            currDiff = distances[i] - distances[i-1]
            #Updating max difference value
            maxDistancesDiff = max(maxDistancesDiff,currDiff)       
        return maxDistancesDiff
    
    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:
        #Getting max consecutive distance from horizontal distance
        horizontalMaxDiff = self.getMaxConsecutiveDifference(horizontalCuts,h) 
        #Getting max consecutive distance from vertical distance
        verticalMaxDiff = self.getMaxConsecutiveDifference(verticalCuts,w) 
        #Returning the result after performing the modulo operation
        return ((horizontalMaxDiff*verticalMaxDiff)%(10**9+7))"
reorder routes to make all paths lead to the city zero,"class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        cmap = {0}
        count = 0
        dq = deque(connections)
        while dq:
            u, v = dq.popleft()
            if v in cmap:
                cmap.add(u)
            elif u in cmap:
                cmap.add(v)
                count += 1
            else:
                dq.append([u, v])
        return count"
reorder routes to make all paths lead to the city zero,"class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        visited=[0]*n
        indegree=[[] for _ in range(n)]
        outdegree=[[] for _ in range(n)]
        for frm,to in connections:
            indegree[to].append(frm)
            outdegree[frm].append(to)
        lst=[0]
        visited[0]=1
        ct=0
        while lst:
            x=lst.pop(0)
            for i in indegree[x]:
                if visited[i]==0:
                    lst.append(i)
                    visited[i]=1
            for i in outdegree[x]:
                if visited[i]==0:
                    lst.append(i)
                    visited[i]=1
                    # here we have to change the direction of edge
                    ct+=1
        return ct"
probability of a two boxes having the same number of distinct balls,"class Solution:
    def getProbability(self, balls: List[int]) -> float:
        n = sum(balls)//2
        
        @cache 
        def fn(i, s0, s1, c0, c1):
            """"""Return number of ways to distribute boxes successfully (w/o considering relative order).""""""
            if s0 > n or s1 > n: return 0 # impossible 
            if i == len(balls): return int(c0 == c1)
            ans = 0 
            for x in range(balls[i]+1): 
                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)
            return ans
        
        return fn(0, 0, 0, 0, 0) / comb(2*n, n)"
shuffle the array,"class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        l=[]
        for i in range(n):
            l.append(nums[i])
			l.append(nums[n+i])
        return l"
shuffle the array,"class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        l=[]
        for i in range(n):
            l.extend([nums[i],nums[i+1]])
        return l"
the k strongest values in an array,"class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        new_arr = []
        arr.sort()
        med = arr[int((len(arr) - 1)//2)]
        for num in arr : 
            new_arr.append([int(abs(num - med)), num])
            
        new_arr = sorted(new_arr, key = lambda x : (x[0], x[1]))
        
        output, counter = [], 0
        for i in reversed(range(len(new_arr))) : 
            output.append(new_arr[i][1])
            counter += 1 
            if counter == k : 
                return output 
            
        return output"
the k strongest values in an array,"class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        arr.sort()
        n = len(arr)
        median = arr[(n - 1) // 2]
        res = []
        left, right = 0, n - 1

        for _ in range(k):
            if median - arr[left] > arr[right] - median:
                res.append(arr[left])
                left += 1
            else:
                res.append(arr[right])
                right -= 1
        
        return res"
paint house iii,"class Solution:
    def minCost1(self, houses: List[int], cost: List[List[int]], R: int, C: int, target: int) -> int:
        # think as if we are traveling downward
        # at any point, if switch our column then (target--)
        
        @functools.cache
        def dp(x,y,k): # O(100*20*100) time space
            if x == R:
                return 0 if k == 0 else math.inf
            elif k <= 0: 
                return math.inf
            
            # if this house is already colored, dont recolor!!
            if houses[x] > 0 and houses[x] != y+1: return math.inf
            
            cur_cost = 0 if houses[x] == y+1 else cost[x][y] 
            
            # now try all columns! O(20) time
            res = math.inf
            for c in range(C):
                if c == y:
                    res = min(res, cur_cost + dp(x+1,c,k))
                else:
                    res = min(res, cur_cost + dp(x+1,c,k-1))
            # print('dp',x,y,k,'=',res)
            return res
        
        ans = min(dp(0,y,target) for y in range(C))
        
        return -1 if ans == math.inf else ans"
paint house iii,"class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:        
        # dp_values[i][j][k] records the min costs that we have k+1 neighbors 
        # in the first i houses and the ith house is painted with j
        dp_values = [[[float('inf')]*target for _ in range(n)] for _ in range(m)]
		# initial values
        if houses[0] != 0:
            dp_values[0][houses[0]-1][0] = 0
        else:
            for i in range(n):
                dp_values[0][i][0] = cost[0][i]
        for i in range(1, m):
            for j in range(n):
                # houses[i] is painted. we only consider when j == houses[i]
                if houses[i] != 0 and j != houses[i]-1:
                    continue
                for k in range(target):
                    # for i houses, we can't have more than i neighbors 
                    if k > i:
                        break
                    if houses[i-1] != 0:
                        if j == houses[i-1]-1:
                            dp_values[i][j][k] = dp_values[i-1][j][k]
                        else:
                            # if k == 0, it makes no sense to consider the case that current 
                            # house color is different from the previous house's color.
                            if k > 0:
                                dp_values[i][j][k] = dp_values[i-1][houses[i-1]-1][k-1]
                    else:
                        min_with_diff_color = float('inf')
                        if k > 0:
                            for w in range(n):
                                if w == j:
                                    continue
                                min_with_diff_color = min(min_with_diff_color, dp_values[i-1][w][k-1])
                        dp_values[i][j][k] = min(min_with_diff_color, dp_values[i-1][j][k])
                    # if the house is not painted, we need extra cost
                    if houses[i] == 0:
                        dp_values[i][j][k] += cost[i][j]
        costs = float('inf')
        for j in range(n):
            costs = min(costs, dp_values[m-1][j][target-1])
        return costs if costs != float('inf') else -1"
final prices with a special discount in a shop,"class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        len_prices = len(prices)
        i = 0
        while i <= len_prices-2:
            for j in range(i+1, len(prices)):
                if prices[i] >= prices[j] and j > i:
                    prices[i] = prices[i] - prices[j]
                    break
            
            i += 1
        
        return prices"
final prices with a special discount in a shop,"class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
        stack = [] # taking a empty stack. 
        for i in range(len(prices)): # traversing through the provided prices list. 
            while stack and (prices[stack[-1]] >= prices[i]): # comparing the previous element with current element as descibed in the question to calculate the discount. 
                prices[stack.pop()] -= prices[i] # reducing the price of the current elem from previous. 
            stack.append(i) # In stack we`ll just stores the index of the prices. Using those indexes will make changes in the prices list itself. 
        return prices # returing the updated prices as we made changes in the provided list itself."
find two non overlapping sub arrays each with target sum,"class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        l, windowSum, res = 0, 0, float('inf')
        min_till = [float('inf')] * len(arr) # records smallest lenth of subarry with target sum up till index i.
        for r, num in enumerate(arr): # r:right pointer and index of num in arr
            windowSum += num
            while windowSum > target: 
			# when the sum of current window is larger then target, shrink the left end of the window one by one until windowSum <= target
                windowSum -= arr[l]
                l += 1
			# the case when we found a new target sub-array, i.e. current window
            if windowSum == target:
			   # length of current window
                curLen = r - l + 1
				# min_till[l - 1]: the subarray with min len up till the previous position of left end of the current window: 
				# avoid overlap with cur window
				# new_sum_of_two_subarray = length of current window + the previous min length of target subarray without overlapping
				# , if < res, update res.
                res = min(res, curLen + min_till[l - 1])
				# Everytime we found a target window, update the min_till of current right end of the window, 
				# for future use when sum up to new length of sum_of_two_subarray and update the res.
                min_till[r] = min(curLen, min_till[r - 1])
            else:
			# If windowSum < target: window with current arr[r] as right end does not have any target subarry, 
			# the min_till[r] doesn't get any new minimum update, i.e it equals to previous min_till at index r - 1. 
                min_till[r] = min_till[r - 1]
        return res if res < float('inf') else -1
	
Time = O(n): when sliding the window, left and right pointers traverse the array once.
Space = O(n): we use one additional list min_till[] to record min length of target subarray till index i."
find two non overlapping sub arrays each with target sum,"class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        n = len(arr)
        heap = []
        prefix_sum = {}
        prefix_sum[0] = -1
        curr_sum = 0
        for i in range(n): 
            curr_sum += arr[i]
            if prefix_sum.get(curr_sum - target):
                heapq.heappush(heap,(i - prefix_sum.get(curr_sum - target), i))
            prefix_sum[curr_sum] = i
                
        while len(heap) > 1:
            len1, end1 = heapq.heappop(heap)
            len2, end2 = heapq.heappop(heap)
            if end1 <= end2 - len2 or end2 <= end1 - len1:    
                return len1 + len2
            else:    # overlap
                heapq.heappush(heap, (len1, end1))
                
        return -1"
allocate mailboxes,"class Solution:
def minDistance(self, houses: List[int], k: int) -> int:
    
    n = len(houses)
    houses.sort()
    cost = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(i+1,n):
            mid_house = houses[(i+j)//2]
            for t in range(i,j+1):
                cost[i][j]+= abs(mid_house-houses[t])
    
    @lru_cache(None)
    def dp(k,ind):
        if k==0 and ind==n: return 0
        if k==0 or ind==n: return float('inf')
        res = float('inf')
        for j in range(ind,n):
            c = cost[ind][j]
            res = min(res, c + dp(k-1,j+1))
        
        return res
    
    return dp(k,0)"
allocate mailboxes,"class Solution:
    def minDistance(self, houses: List[int], k: int) -> int:
        houses.sort() # ascending order 
        n = len(houses)
        
        mdist = [[0]*n for _ in range(n)] # mdist[i][j] median distance of houses[i:j+1]
        for i in range(n):
            for j in range(i+1, n): 
                mdist[i][j] = mdist[i][j-1] + houses[j] - houses[i+j >> 1]
        
        @cache
        def fn(n, k):
            """"""Return min distance of allocating k mailboxes to n houses.""""""
            if n <= k: return 0 # one mailbox for each house
            if k == 1: return mdist[0][n-1]
            ans = inf 
            for nn in range(k-1, n): 
                ans = min(ans, fn(nn, k-1) + mdist[nn][n-1])
            return ans 
        
        return fn(n, k)"
running sum of 1d array,"class Solution(object):
    def runningSum(self, nums):
        result = []
        current_sum = 0
        for i in range(0, len(nums)):
            result.append(current_sum + nums[i])
            current_sum = result[i]
        return result"
running sum of 1d array,"class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        for i in range(1, len(nums)):
            nums[i] = nums[i] + nums[i-1]
        return nums"
least number of unique integers after k removals,"class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:

        count = Counter(arr)
        ans = len(count)
        for i in sorted(count.values()):
            k -= i
            if k < 0:
                break
            ans -= 1
        return ans"
least number of unique integers after k removals,"class Solution:
def findLeastNumOfUniqueInts(self, arr: List[int], m: int) -> int:
    
    dic = Counter(arr)
    heap = []
    for k in dic:
        heapq.heappush(heap,(dic[k],k))
    
    while heap and m>0:
        f,k = heapq.heappop(heap)
        mi = min(m,f)
        m-=mi
        f-=mi
        
        if f!=0:
            heapq.heappush(heap,(f,k))
    
    return len(heap)"
minimum number of days to make m bouquets,"class Solution:
    def checker(self,arr, d, m, k) -> bool:
        '''
        d -> days
        m -> bouquets
        k -> adjacent flowers
        
        return bool
        '''
        arr = [10**9] + arr + [10**9] #appending array with maximum values
        idx = []
        for i in range(len(arr)):
            if arr[i] > d:
                idx.append(i)
        cnt = 0
        for i in range(len(idx)-1):
            # how many bouquet can we make out of an interval of valid flowers 
            cnt += (idx[i+1] - idx[i] - 1) // k
        
        # return if count >= m
        return cnt >= m

    def minDays(self, arr: List[int], m: int, k: int) -> int:
        if m*k > len(arr):
            return -1
        lo, hi = 1, max(arr)
        
        while(hi >= lo):
            mid = (hi+lo)//2
            if(self.checker(arr, mid, m, k) == True):
                hi = mid
            else:
                lo = mid+1
            if(hi == lo): break
    
        if self.checker(arr, lo, m, k):
            return lo
        else:
            return hi"
minimum number of days to make m bouquets,"class Solution:
    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
        if len(bloomDay) < m*k: return -1 # edge case 
        
        def fn(d):
            """"""Return True if it is possible to make m bouquets on given day.""""""
            mm, kk = m, k
            for x in bloomDay: 
                kk = kk-1 if x <= d else k
                if not kk: mm, kk = mm-1, k
                if not mm: return True
            return False 
        
        # ""first true"" binary search
        lo, hi = 0, max(bloomDay)
        while lo < hi:
            mid = lo + hi >> 1
            if fn(mid): hi = mid
            else: lo = mid + 1
        return lo"
xor operation in an array,"class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        ans=0
        for i in range(n):
            ans^=start+(2*i)
        return ans"
xor operation in an array,"class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        return reduce(operator.xor,[start+(2*i) for i in range(n)])"
making file names unique,"class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        # names : array of names
        # n : size of names
        
        # create folders at the i'th minute for each name = names[i]
        # If name was used previously, append a suffix ""(k)"" - note parenthesis - where k is the smallest pos int
        
        # return an array of strings where ans[i] is the actual saved variant of names[i]
        
        n = len(names)
        
        dictNames = {}
        ans = ['']*n
        
        # enumerate to grab index so we can return ans list in order
        for idx, name in enumerate(names):
            # check if we have seen this name before
            if name in dictNames:
                # if we have grab the next k using last successful low (k) suffix
                k = dictNames[name]
                # track the name we started so we can update the dict
                namestart = name
                # cycle through values of increasing k until we are not in a previously used name
                while name in dictNames:
                    name = namestart + f""({k})""
                    k += 1
                # update the name we started with to the new lowest value of k
                dictNames[namestart] = k
                # add the new name with k = 1 so if we see this name with the suffix
                dictNames[name] = 1
            else:
                # we havent seen this name so lets start with 1
                dictNames[name] = 1
            # build the solution
            ans[idx] = name
        return ans"
making file names unique,"class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        seen = {}
        for name in names: 
            if name not in seen: seen[name] = 1
            else: 
                k = seen[name]
                while (suffix := f""{name}({k})"") in seen: k += 1
                seen[name] = k+1
                seen[suffix] = 1
        return seen.keys()"
avoid flood in the city,"class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        pq = []
        fill = set()
        d = collections.defaultdict(list)
        ans = []
        
        for i, rain in enumerate(rains):
            d[rain].append(i)
        
        for rain in rains:
            if rain > 0:
                if rain in fill:
                    return []
                fill.add(rain)
                d[rain].pop(0)
                if d[rain]:
                    heapq.heappush(pq, d[rain][0])
                ans.append(-1)
            else:
                if pq:
                    ind = heapq.heappop(pq)
                    ans.append(rains[ind])
                    fill.remove(rains[ind])
                else:
                    ans.append(1)
        
        return ans"
avoid flood in the city,"class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        days = dict() #days of raining for a given lake 
        for d, lake in enumerate(rains): 
            if lake: days.setdefault(lake, deque()).append(d)
            
        ans, hp = [], [] #min-heap 
        full = set() #full lakes
        for d, lake in enumerate(rains): 
            if lake: 
                if lake in full: return []
                full.add(lake)
                days[lake].popleft()
                if days[lake]: heappush(hp, (days[lake][0], lake))
                ans.append(-1)
            else: 
                if hp: 
                    _, lake = heappop(hp)
                    full.remove(lake)
                    ans.append(lake)
                else: 
                    ans.append(1)
        return ans"
find critical and pseudo critical edges in minimum spanning tree,"class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = dict()
        for u, v, w in edges: 
            graph.setdefault(u, []).append((v, w))
            graph.setdefault(v, []).append((u, w))
            
        ref = self.mst(n, graph)
        critical, pseudo = [], []
        for i in range(len(edges)):
            if self.mst(n, graph, exclude=edges[i][:2]) > ref: critical.append(i)
            elif self.mst(n, graph, init=edges[i]) == ref: pseudo.append(i)
        return [critical, pseudo]
            
        
    def mst(self, n, graph, init=None, exclude=None):
        """"""Return weight of MST of given graph using Prim's algo""""""

        def visit(u): 
            """"""Mark node and put its edges to priority queue""""""
            marked[u] = True
            for v, w in graph.get(u, []):
                if exclude and u in exclude and v in exclude: continue
                if not marked[v]: heappush(pq, (w, u, v))
                    
        ans = 0
        marked = [False]*n
        pq = [] #min prioirty queue
        
        if init: 
            u, v, w = init
            ans += w
            marked[u] = marked[v] = True
            visit(u) or visit(v)
        else:
            visit(0)

        while pq: 
            w, u, v = heappop(pq)
            if marked[u] and marked[v]: continue
            ans += w
            if not marked[u]: visit(u)
            if not marked[v]: visit(v)
                
        return ans if all(marked) else inf"
average salary excluding the minimum and maximum salary,"class Solution:
    def average(self, salary: List[int]) -> float:
        minimum = float(""inf"")
        maximum = float(""-inf"")
        
        i = 0
        sums = 0
        while i<len(salary):
            minimum = min(minimum, salary[i])
            maximum = max(maximum, salary[i])
            sums+=salary[i]
            i+=1
        
        return (sums - (maximum+minimum))/(i-2)"
average salary excluding the minimum and maximum salary,"class Solution:
    def average(self, salary: List[int]) -> float:
        salary = sorted(salary)[1:len(salary)-1]
        return sum(salary) / len(salary)"
the kth factor of n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        factors = []
        for i in range(1,n+1):
            if n % i == 0:
                factors.append(i)
        if k > len(factors):
            return -1
        else:
            return factors[k-1]"
the kth factor of n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        
        
        u=[]
        
        for i in range(1,int(n**(0.5))+1):
            
            if n%i==0:
                u.append(i)
                
                if n//i != i:
                    u.append(n//i)
        u.sort() 
        if k<=len(u):
            return u[k-1]
        return -1"
longest subarray of 1s after deleting one element,"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        m=0
        l=len(nums)
        one=True
        for i in range(0,l):
            if nums[i]==0:
                one=False
                left=i-1
                right=i+1
                ones=0
                while left>=0:
                    if nums[left]==1:
                        ones=ones+1
                        left=left-1
                    else:
                        break
                while right<l:
                    if nums[right]==1:
                        ones=ones+1
                        right=right+1
                    else:
                        break
                if ones>m:
                    m=ones
        if one:
            return l-1
        return m"
longest subarray of 1s after deleting one element,"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        groups = [[k, len(list(g))] for k, g in itertools.groupby(nums)]
        if len(groups) == 1:
            return groups[0][1] - 1 if groups[0][0] else 0
        ans = 0
        for i in range(len(groups)):
            k, klen = groups[i]
            if k:
                ans = max(ans, klen)
            elif i not in [0, len(groups)-1] and klen == 1:
                ans = max(ans, groups[i-1][1] + groups[i+1][1])
        return ans"
parallel courses ii,"class Solution:
    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:
        pre = [0]*n # prerequisites 
        for u, v in dependencies: 
            pre[v-1] |= 1 << (u-1) 
            
        @cache
        def fn(mask): 
            """"""Return min semesters to take remaining courses.""""""
            if mask == (1 << n) - 1: return 0 # all courses taken 
            can = [] # available courses 
            for i in range(n): 
                if not mask &amp; 1 << i and mask &amp; pre[i] == pre[i]: 
                    can.append(i)
            
            ans = inf
            for courses in combinations(can, min(k, len(can))): 
                temp = mask | reduce(lambda x, y: x | 1 << y, courses, 0)
                ans = min(ans, 1 + fn(temp))
            return ans 
        
        return fn(0)"
parallel courses ii,"class Solution:
    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:
        graph = [0] * n
        out_degree = [0] * n
        # -1 to fix 1-based indexing offset from prompt.
        for pre_req, course in relations:
            graph[course-1] += 1 << (pre_req-1)
            out_degree[pre_req-1] += 1
        # Just converts course to its shifted value
        c2shift = [1<<course for course in range(n)]
        start = 0
        goal = 2**n-1  # will eq course_total once all have been taken.
        queue = collections.deque([(start,0)])
        seen = [0] * (2 ** n)

        # Similar to Bellman-Ford
        while queue:
            # course_total is state. Each bit representing a taken course.
            course_total, steps = queue.popleft()
            available = []
            for course_num in range(n):
                if (course_total &amp; graph[course_num] == graph[course_num]) \
                            and (course_total &amp; c2shift[course_num] == 0):
                    available.append(course_num)

            # pre_req courses can unlock others.
            pre_reqs = [c2shift[course_num] for course_num in available if out_degree[course_num]]
            leaves = [c2shift[course_num] for course_num in available if out_degree[course_num] == 0] 
            
            # We only include leaf courses when we have extra space
            if len(pre_reqs) <= k:
                course_total += sum(pre_reqs) + sum(leaves[:k-len(pre_reqs)])
                if course_total == goal:
                    return steps + 1
                if not seen[course_total]:
                    queue.append((course_total,steps+1))
                    seen[course_total] = 1
            else:
                # Trying every combination of the pre_reqs.
                # comb is required here because we can't simply take them all (len(pre_reqs) > k)
                for batch in itertools.combinations(pre_reqs, k):
                    diff = sum(batch)
                    t = course_total + diff
                    if t == goal:
                        return steps + 1
                    if not seen[t]:
                        queue.append((t, steps+1))
                        seen[t] = 1![Uploading file...]()"
path crossing,"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        l = [(0,0)]
        x,y = 0,0
        for i in path:
            if i == 'N':
                y += 1
            if i == 'S':
                y -= 1
            if i == 'E':
                x += 1
            if i == 'W':
                x -= 1
            if (x,y) in l:
                return True
            else:
                l.append((x,y))
        return False"
path crossing,"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        x, y = 0, 0
        seen = {(x, y)}
        for move in path: 
            if   move == ""N"": y += 1
            elif move == ""S"": y -= 1
            elif move == ""E"": x += 1
            else: x -= 1
            if (x, y) in seen: return True
            seen.add((x, y))
        return False"
check if array pairs are divisible by k,"class Solution:
    def canArrange(self, arr: List[int], k: int) -> bool:
        freq = dict()
        for x in arr: freq[x%k] = 1 + freq.get(x%k, 0)
        return all(freq[x] == freq.get(xx:=(k-x)%k, 0) and (x != xx or freq[x]%2 == 0) for x in freq)"
check if array pairs are divisible by k,"class Solution:
    def canArrange(self, arr: List[int], k: int) -> bool:
        h = {}
        for i in arr:
            r = i % k
            if r not in h:
                h[r] = 0
            h[r]+=1

        if h.get(0,0) %2 !=0:
            return False

        for r1 in h:
            r2 = k - r1
            if r1 == 0:
                continue
            if h[r1] != h.get(r2,0):
                return False
        return True
# Please upvote if you understand the solution"
number of subsequences that satisfy the given sum condition,"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        n = len(nums)
        
        nums.sort()
        i, j = 0, n-1
        
        
        res = 0 
        NUM = 10**9+7
        while i <= j:
            if nums[i] + nums[j] > target:
                j -= 1
            elif nums[i] + nums[j] <= target:
                res += pow(2, j-i, NUM)
                i += 1
            #else: # nums[i] + nums[j] == target
                
            
            
        return res % NUM"
number of subsequences that satisfy the given sum condition,"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        mod = 10 ** 9 + 7
        ans = 0
        nums.sort()
        for i, n in enumerate(nums):
            if 2 * n > target:
                break
            j = bisect.bisect(nums, target - n, lo=i)
            ans += pow(2, j - i - 1, mod)
        return ans % mod"
max value of equation,"class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        ans = -inf
        hp = [] 
        for xj, yj in points:
            while hp and xj - hp[0][1] > k: heappop(hp)
            if hp: 
                ans = max(ans, xj + yj - hp[0][0])
            heappush(hp, (xj-yj, xj))
        return ans"
max value of equation,"class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        deque = collections.deque()
        res = -math.inf

        for point in points:
            x, y = point[0], point[1]
            
            while deque and x - deque[0][0] > k:
                deque.popleft()
            
            if deque:
                res = max(res, (y + deque[0][1]) + (x - deque[0][0]))
            
            # while deque AND any equation including (x, y) will always yield a greater
			# (or ==) result than any equation including (deque[-1][0], deque[-1][1])
            while deque and (deque[-1][0] - x) + (y - deque[-1][1]) >= 0:
                deque.pop()
            
            deque.append(point)
        
        return res"
can make arithmetic progression from sequence,"class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        return len(set(arr[i-1] - arr[i] for i in range(1, len(arr)))) == 1"
can make arithmetic progression from sequence,"class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        return len(set(a - b for a, b in zip(arr, arr[1:]))) == 1"
last moment before all ants fall out of a plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        if left and not right:
            return max(left)
        if not left and right:
            return n - min(right)
        if not left and not right:
            return 0
        if left and right:
            return max(max(left), n - min(right))"
last moment before all ants fall out of a plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left,default=0), n - min(right, default=n))"
count submatrices with all ones,"class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        
        #precipitate mat to histogram 
        for i in range(m):
            for j in range(n):
                if mat[i][j] and i > 0: 
                    mat[i][j] += mat[i-1][j] #histogram 
        
        ans = 0
        for i in range(m):
            stack = [] #mono-stack of indices of non-decreasing height
            cnt = 0
            for j in range(n):
                while stack and mat[i][stack[-1]] > mat[i][j]: 
                    jj = stack.pop()                          #start
                    kk = stack[-1] if stack else -1           #end
                    cnt -= (mat[i][jj] - mat[i][j])*(jj - kk) #adjust to reflect lower height

                cnt += mat[i][j] #count submatrices bottom-right at (i, j)
                ans += cnt
                stack.append(j)

        return ans"
count submatrices with all ones,"class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        rows, cols = len(mat), len(mat[0])
        for r in range(1, rows):
            for c, (a, b) in enumerate(zip(mat[r], mat[r - 1])):
                if a and b:
                    mat[r][c] += b
        ans = 0
        for row in mat:
            for c in range(cols):
                min_val = row[c]
                for val in row[c:]:
                    if val == 0:
                        break
                    elif val < min_val:
                        min_val = val
                    ans += min_val
        return ans"
minimum possible integer after at most k adjacent swaps on digits,"class Solution:
    def minInteger(self, num: str, k: int) -> str:
        n = len(num)
        if k >= n*(n-1)//2: return """".join(sorted(num)) #special case
        
        #find smallest elements within k swaps 
        #and swap it to current position 
        num = list(num)
        for i in range(n):
            if not k: break 
            #find minimum within k swaps
            ii = i
            for j in range(i+1, min(n, i+k+1)): 
                if num[ii] > num[j]: ii = j 
            #swap the min to current position 
            if ii != i: 
                k -= ii-i
                for j in range(ii, i, -1):
                    num[j-1], num[j] = num[j], num[j-1]
        return """".join(num)"
reformat date,"class Solution:
    def reformatDate(self, date: str) -> str:
        s = date.split() # Divides the elements into 3 individual parts
        
        monthDict = {'Jan': '01', 'Feb': '02', 
                     'Mar': '03', 'Apr': '04', 
                     'May': '05', 'Jun': '06', 
                     'Jul': '07', 'Aug': '08', 
                     'Sep': '09', 'Oct': '10', 
                     'Nov': '11', 'Dec': '12'}
        
        day = s[0][:-2] # Removes the last 2 elements of the day
        month = s[1] 
        year = s[2]
        
        if int(day) < 10: # Adds 0 to the front of day if day < 10
            day = '0' + day
        
        return ''.join(f'{year}-{monthDict[month]}-{day}') # Joins it all together. Month is used to draw out the corresponding number from the dict."
reformat date,"class Solution:
    def reformatDate(self, date: str) -> str:
        months = {
            'Jan' : '01',
            'Feb' : '02',
            'Mar' : '03',
            'Apr' : '04',
            'May' : '05',
            'Jun' : '06',
            'Jul' : '07',
            'Aug' : '08',
            'Sep' : '09',
            'Oct' : '10',
            'Nov' : '11',
            'Dec' : '12',
        }

        day, month, year = date.split()

        day = day[ : -2 ] # remove st or nd or rd or th
        day = '0' + day if len( day ) == 1 else day # needs to be 2 digits

        return year + '-' + months[ month ] + '-' + day"
range sum of sorted subarray sums,"class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        ans = []
        for i in range(len(nums)):
            prefix = 0
            for ii in range(i, len(nums)):
                prefix += nums[ii]
                ans.append(prefix)
        ans.sort()
        return sum(ans[left-1:right]) % 1_000_000_007"
range sum of sorted subarray sums,"class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        h = [(x, i) for i, x in enumerate(nums)] #min-heap 
        heapify(h)
        
        ans = 0
        for k in range(1, right+1): #1-indexed
            x, i = heappop(h)
            if k >= left: ans += x
            if i+1 < len(nums): 
                heappush(h, (x + nums[i+1], i+1))
                
        return ans % 1_000_000_007"
minimum difference between largest and smallest value in three moves,"class Solution:
    
    def minDifference(self, nums: List[int]) -> int:
        
        n = len(nums)
        # If nums are less than 3 all can be replace,
        # so min diff will be 0, which is default condition
        if n > 3:
            
            # Init min difference
            min_diff = float(""inf"")
            
            # sort the array
            nums = sorted(nums)
            
            # Get the window size, this indicates, if we
            # remove 3 element in an array how many element
            # are left, consider 0 as the index, window
            # size should be (n-3), but for array starting
            # with 0 it should be ((n-1)-3)
            window = (n-1)-3
            
            # Run through the entire array slinding the
            # window and calculating minimum difference
            # between the first and the last element of
            # that window
            for i in range(n):
                if i+window >= n:
                    break
                else:
                    min_diff = min(nums[i+window]-nums[i], min_diff)
                    
            # return calculated minimum difference
            return min_diff
        
        return 0 # default condition"
minimum difference between largest and smallest value in three moves,"class Solution:
    def minDifference(self, nums: List[int]) -> int:
        return min(x-y for x, y in zip(nlargest(4, nums), reversed(nsmallest(4, nums))))"
stone game iv,"class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n + 1)
        squares = []
        curSquare = 1
        for i in range(1, n + 1):
            if i == curSquare * curSquare:
                squares.append(i)
                curSquare += 1
                dp[i] = True
            else:
                for square in squares:
                    if not dp[i - square]:
                        dp[i] = True
                        break
        return dp[n]"
stone game iv,"class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n+1)
        for x in range(1, n+1): 
            for k in range(1, int(sqrt(x))+1):
                if not dp[x-k*k]: 
                    dp[x] = True
                    break 
        return dp[-1]"
number of good pairs,"class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        hashMap = {}
        res = 0
        for number in nums:            
            if number in hashMap:
                res += hashMap[number]
                hashMap[number] += 1
            else:
                hashMap[number] = 1
        return res"
number of good pairs,"class Solution:
	def numIdenticalPairs(self, nums: List[int]) -> int:
		nums, memo = sorted(nums), {} # sort to get the total number of digits that have duplicates
		for i in range(len(nums)-1): # lets say nums = [1,1,1,1,2,2,2,3] the total digits with duplicates is 7
			if nums[i] == nums[i+1]: # because nums has 4 ones and 3 twos so it adds up to 7
				if nums[i] not in memo: # 3 is not counted because there are no duplicates of it
					memo[nums[i]] = 1
				memo[nums[i]] = memo[nums[i]] + 1 
		# nums = [1,1,1,1,2,2,2,3]
		# so now memo = {1 : 4, 2: 3} which means we have 4 ones and 3 twos
		answer = 0
		for n in memo.values(): # this is the hard part, please refer to my beautiful drawing to understand this
			answer += (n**2 - n)//2 # after looking at the drawing, we repeat with each n value in memo

		return answer"
number of substrings with only 1s,"class Solution:
    def numSub(self, s: str) -> int: 
            res = 0
            s = s.split(""0"")

            for one in s:
                if one == """":
                    continue
                    
                n = len(one)
                temp = (n / 2)*(2*n + (n-1)*-1)
                    
                if temp >= 1000000007:
                    res += temp % 1000000007
                else:
                    res += temp
            return int(res)"
number of substrings with only 1s,"class Solution:
    def numSub(self, s: str) -> int:
        ans = n = 0
        for c in s:
            if c == ""0"": 
                ans = (ans + n*(n+1)//2) % 1_000_000_007
                n = 0
            else: n += 1
        return (ans + n*(n+1)//2) % 1_000_000_007"
path with maximum probability,"class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        graph, prob = dict(), dict() #graph with prob
        for i, (u, v) in enumerate(edges):
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
            prob[u, v] = prob[v, u] = succProb[i]
        
        h = [(-1, start)] #Dijkstra's algo
        seen = set()
        while h: 
            p, n = heappop(h)
            if n == end: return -p
            seen.add(n)
            for nn in graph.get(n, []):
                if nn in seen: continue 
                heappush(h, (p * prob.get((n, nn), 0), nn))
        return 0"
path with maximum probability,"class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        # construct the graph
        graph = collections.defaultdict(list)
        prob = collections.defaultdict(dict)
        for i,(p,[a,b]) in enumerate(zip(succProb,edges)):
            graph[a].append(b)
            graph[b].append(a)
            prob[a][b] = prob[b][a] = p
        # apply dijkstra
        dis = {start:1}
        for i in range(n):
            dis[i] = 0
        visited = set([])
        # note that Python only supports min-heap
        # so some tricks here to get a max-heap
        pq = [(-1,start)]
        while pq:
            _p, node = heapq.heappop(pq)
            visited.add(node)
            for child in graph[node]:
                if child not in visited:
                    if dis[child] < -1 * _p * prob[node][child]:
                        heapq.heappush(pq,(_p * prob[node][child],child))
                        dis[child] = -1 * _p * prob[node][child]

        return dis[end]"
best position for a service centre,"class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        #euclidean distance 
        fn = lambda x, y: sum(sqrt((x-xx)**2 + (y-yy)**2) for xx, yy in positions)
        #centroid as starting point
        x = sum(x for x, _ in positions)/len(positions)
        y = sum(y for _, y in positions)/len(positions)
        
        ans = fn(x, y)
        chg = 100 #change since 0 <= positions[i][0], positions[i][1] <= 100
        while chg > 1e-6: #accuracy within 1e-5
            zoom = True
            for dx, dy in (-1, 0), (0, -1), (0, 1), (1, 0):
                xx = x + chg * dx
                yy = y + chg * dy
                dd = fn(xx, yy)
                if dd < ans: 
                    ans = dd 
                    x, y = xx, yy
                    zoom = False 
                    break 
            if zoom: chg /= 2
        return ans"
water bottles,"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        ans = r = 0
        while numBottles:
            ans += numBottles
            numBottles, r = divmod(numBottles + r, numExchange)
        return ans"
water bottles,"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        drank , left = [numBottles] * 2
        
        while left >= numExchange:
            left -= numExchange - 1
            drank += 1
        
        return drank"
number of nodes in the sub tree with the same label,"class Solution:
    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:
        ans = [0] * n
        tree = collections.defaultdict(list)
        for a, b in edges:                             # build tree
            tree[a].append(b)
            tree[b].append(a)
        def dfs(node):                                 # dfs
            nonlocal visited, ans, tree
            c = collections.Counter(labels[node])
            for nei in tree[node]:
                if nei in visited: continue            # avoid revisit
                visited.add(nei)
                c += dfs(nei)                          # add counter (essentially adding a 26 elements dictionary)
            ans[node] = c.get(labels[node])            # assign count of label to this node
            return c
        visited = set([0])
        dfs(0)
        return ans"
number of nodes in the sub tree with the same label,"class Solution:
    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:
        #tree as adjacency list 
        tree = dict()
        for u, v in edges:
            tree.setdefault(u, []).append(v)
            tree.setdefault(v, []).append(u)
            
        def fn(k):
            """"""Return frequency table of tree rooted at given node""""""
            seen.add(k) #mark as visited 
            freq = [0]*26
            freq[ord(labels[k])-97] = 1
            for kk in tree[k]: 
                if kk not in seen: freq = [x+y for x, y in zip(freq, fn(kk))]
            ans[k] = freq[ord(labels[k])-97] #populate table 
            return freq
        
        ans = [0]*n
        seen = set()
        fn(0)
        return ans"
maximum number of non overlapping substrings,"class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        locs = {}
        for i, x in enumerate(s): 
            locs.setdefault(x, []).append(i)
        
        def fn(lo, hi): 
            """"""Return expanded range covering all chars in s[lo:hi+1].""""""
            for xx in locs: 
                k0 = bisect_left(locs[xx], lo)
                k1 = bisect_left(locs[xx], hi)
                if k0 < k1 and (locs[xx][0] < lo or hi < locs[xx][-1]): 
                    lo = min(lo, locs[xx][0])
                    hi = max(hi, locs[xx][-1])
                    lo, hi = fn(lo, hi)
            return lo, hi
        
        group = set()
        for x in locs: 
            group.add(fn(locs[x][0], locs[x][-1]))
        
        ans = [] # ISMP (interval scheduling maximization problem)
        prev = -1 
        for lo, hi in sorted(group, key=lambda x: x[1]): 
            if prev < lo: 
                ans.append(s[lo:hi+1])
                prev = hi 
        return ans"
maximum number of non overlapping substrings,"class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        
        # record last index(+1) and interval relations
        last, interval = {}, {}
        for i, c in enumerate(s):
            last[c] = i + 1
            if c not in interval:
                interval[c] = set(''.join(s.split(c)[1:-1]))
        
        # union-find
        parent = {c: c for c in s}
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            parent[find(x)] = find(y)
            return
        
        for c in interval:
            for n in interval[c]:
                if c in interval[n]:
                    union(c, n)
        
        # cut and remove redundant character
        splits, max_splits = [(s, 0)], []
        
        while splits:
            
            # cut
            splits_cut = []
            for string, start in splits:
                left = right = 0 
                for i, c in enumerate(string):
                    right = max(right, last[c] - start)
                    if i == right - 1:
                        splits_cut.append((string[left:right], start + left))
                        left = right
            
            # remove redundant
            splits_rem = []
            for string, start in splits_cut:
                len_splits_rem = len(splits_rem)
                redundant = find(string[0])
                
                left = 0
                while left < len(string):
                    if find(string[left]) == redundant:
                        left += 1
                    else:
                        right = left
                        while right < len(string) and find(string[right]) != redundant:
                            right += 1
                        splits_rem.append((string[left:right], start + left))
                        left = right

                if len_splits_rem == len(splits_rem):
                    max_splits.append(string)

            splits = splits_rem
        
        return max_splits"
find a value of a mysterious function closest to target,"class Solution:
    def closestToTarget(self, arr: List[int], target: int) -> int:
        ans, seen = inf, set()
        for x in arr: 
            seen = {ss &amp; x for ss in seen} | {x}
            ans = min(ans, min(abs(ss - target) for ss in seen))
        return ans"
find a value of a mysterious function closest to target,"class Solution:
    def closestToTarget(self, arr: List[int], target: int) -> int:
        ans, seen = inf, set()
        for x in arr: 
            tmp = set() #new set 
            seen.add(0xffffffff)
            for ss in seen:
                ss &amp;= x
                ans = min(ans, abs(ss - target))
                if ss > target: tmp.add(ss) #fine tuning 
            seen = tmp
        return ans"
count odd numbers in an interval range,"class Solution:
  def countOdds(self, low: int, high: int) -> int:
    if low % 2 == 0:
      return (high-low+1)//2
    return (high-low)//2 + 1"
count odd numbers in an interval range,"class Solution:
    def countOdds(self, low: int, high: int) -> int:
        val=(high-low+1)//2
        return val+1 if(low&amp;1 and high&amp;1) else val"
number of sub arrays with odd sum,"class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        cumSum = odd = even = 0
        for num in arr:
            cumSum += num
            if cumSum % 2:
                odd += 1
            else:
                even += 1
        return odd * (even + 1) % (pow(10, 9) + 7)"
number of sub arrays with odd sum,"class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        cur = total = 0
        for i in range(len(arr)):
            if arr[i] &amp; 1: cur = i+1 - cur
            total += cur
        return total % 1000000007"
number of good ways to split a string,"class Solution:
    def numSplits(self, s: str) -> int:
		# this is not neccessary, but speeds things up
        length = len(s)
        if length == 1:  # never splittable
            return 0
        elif length == 2:  # always splittable
            return 1
		
		# we are recording the first and last occurence of each included letter
        first = {}  # max size = 26
        last = {}  # max size = 26
		
        for index, character in enumerate(s):  # O(n)
            if character not in first:
                first[character] = index
            last[character] = index
			
		# we are concatenating the collected indices into a list and sort them
        indices = list(first.values()) + list(last.values())  # max length 26 + 26 = 52
        indices.sort()  # sorting is constant O(1) because of the length limit above
		
		# all possible splits will be in the middle of this list
        middle = len(indices)//2  # always an integer because indices has an even length
		
		# there are this many possible splits between the two 'median' numbers
        return indices[middle] - indices[middle-1]"
number of good ways to split a string,"class Solution:
    def numSplits(self, s: str) -> int:
        ans = 0
        leftSet, leftCount = set(), []
        for idx, ch in enumerate(s):
            leftSet.add(ch)
            leftCount.append(len(leftSet))
        
        rightSet = set()
        for idx in range(len(s)-1, 0, -1):
            rightSet.add(s[idx])
            if len(rightSet) == leftCount[idx-1]:
                ans += 1
        return ans"
minimum number of increments on subarrays to form a target array,"class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        res = target[0]
        
        for i in range(1, len(target)):
            if target[i] >= target[i - 1]:
                res -= target[i - 1]
                res += target[i]
        
        return res"
minimum number of increments on subarrays to form a target array,"class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        return target[0] + sum([max(0, target[i + 1] - target[i]) for i in range(len(target) - 1)])"
shuffle string,"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        res = [''] * len(s)
        for i in range(len(s)):
            res[indices[i]] = s[i]
        return ''.join(i for i in res)"
shuffle string,"class Solution:
	def restoreString(self, s: str, indices: List[int]) -> str:
		result = [""""] * len(s)

		for i, letter in enumerate(s):
			result[indices[i]] = letter

		return """".join(result)"
minimum suffix flips,"class Solution:
    def minFlips(self, target: str) -> int:
        return len(list(groupby(""0"" + target)))-1"
minimum suffix flips,"class Solution:
    def minFlips(self, target: str) -> int:
        ans = flip = 0
        for bulb in target: 
            if flip ^ int(bulb): 
                flip ^= 1
                ans += 1
        return ans"
number of good leaf nodes pairs,"class Solution:
    def countPairs(self, root: TreeNode, distance: int) -> int:
        
        def dfs(node):
            """"""Return (a list of) distances to leaves of sub-tree rooted at node.""""""
            nonlocal ans
            if not node: return []
            if node.left is node.right is None: return [0]
            left,right = dfs(node.left), dfs(node.right)
            ans += sum(2 + x + y <= distance for x in left for y in right)
            return [1 + x for x in left + right]
        
        ans = 0
        dfs(root)
        return ans"
number of good leaf nodes pairs,"class Solution:
    def countPairs(self, root: TreeNode, distance: int) -> int:
        ans = 0
        
        def fn(node): 
            """"""Return distances of leaves of sub-tree rooted at node.""""""
            nonlocal ans 
            if not node: return []
            if node.left is node.right is None: return [0]
            left, right = fn(node.left), fn(node.right)
            for x in right: 
                k = bisect_right(left, distance - x - 2) # binary search 
                ans += k
            # merge 
            out = []
            i = j = 0 
            while i < len(left) or j < len(right): 
                if j == len(right) or i < len(left) and left[i] < right[j]: 
                    out.append(1 + left[i])
                    i += 1
                else:
                    out.append(1 + right[j])
                    j += 1
            return out
        
        fn(root)
        return ans"
string compression ii,"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        rle = lambda x: x if x <= 1 else int(log10(x)) + 2 # rle length of a char repeated x times
        
        @cache 
        def fn(i, k, prev, cnt):
            """"""Return length of rle of s[i:] with k chars to be deleted.""""""
            if k < 0: return inf 
            if i == len(s): return 0 
            ans = fn(i+1, k-1, prev, cnt) # delete current character 
            if prev == s[i]: 
                ans = min(ans, fn(i+1, k, s[i], cnt+1) + rle(cnt+1) - rle(cnt))
            else: 
                ans = min(ans, fn(i+1, k, s[i], 1) + 1)
            return ans 
        
        return fn(0, k, """", 0)"
string compression ii,"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        #traverse the string
        #keep track of the status of delete or not delete current character
        #the status includes current index, number of delete, the previous character, and the runing length of previous character
        #return the minium length of compresed between delete or not delete
		#O(n^2*26*k) = O(n^2*k) time and space
        
        memo = {}
        return self.dfs(s, 0, k, None, 0, memo)
    
    def dfs(self, s, i, k, prev, l, memo):
        if i == len(s):
            return 0
        if (i, k, prev, l) in memo:
            return memo[(i, k, prev, l)]
        
        if k > 0:
            delete = self.dfs(s, i + 1, k - 1, prev, l, memo)
        else:
			#in this case, we cannot delete, set it as INF to choose skip in the end
            delete = float(""inf"")
        
        if s[i] == prev:
		    #need one more digit for the count
            carry = 1 if l == 1 or len(str(l + 1)) > len(str(l)) else 0
            skip = carry + self.dfs(s, i + 1, k, s[i], l + 1, memo)
        else:
            skip = 1 + self.dfs(s, i + 1, k, s[i], 1, memo)
        
        memo[(i, k, prev, l)] = min(delete, skip)
        
        return memo[(i, k, prev, l)]"
count good triplets,"class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        return sum(abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c for i in range(len(arr)) for j in range(i+1, len(arr)) for k in range(j+1, len(arr)))"
count good triplets,"class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        ans = 0
        for i in range(len(arr)):
            for j in range(i+1, len(arr)):
                for k in range(j+1, len(arr)):
                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c: ans += 1
        return ans"
find the winner of an array game,"class Solution:
    def getWinner(self, arr: List[int], k: int) -> int:
        win = cnt = 0 #winner &amp; count 
        for i, x in enumerate(arr): 
            if win < x: win, cnt = x, 0 #new winner in town 
            if i: cnt += 1 #when initializing (i.e. i == 0) count is 0
            if cnt == k: break #early break 
        return win"
find the winner of an array game,"class Solution:
    def getWinner(self, arr: List[int], k: int) -> int:
        if k == 1:
            return max(arr[0], arr[1])
        
        i = wins = 0
        for j in range(1, len(arr)):
            if arr[i] > arr[j]:
                wins += 1
                if wins == k:
                    return arr[i]
            else:
                i = j
                wins = 1
        
        return max(arr)"
minimum swaps to arrange a binary grid,"class Solution:
    def minSwaps(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        #summarizing row into number 
        row = [0]*m 
        for i in range(m):
            row[i] = next((j for j in reversed(range(n)) if grid[i][j]), 0)
        
        ans = 0
        #sequentially looking for row to fill in 
        for k in range(m): 
            for i, v in enumerate(row): 
                if v <= k: #enough trailing zeros 
                    ans += i
                    row.pop(i) #value used 
                    break 
            else: return -1 #cannot find such row 
        return ans"
minimum swaps to arrange a binary grid,"class Solution:
    def minSwaps(self, grid: List[List[int]]) -> int:
        A = [sum(int(x == 0) for x in accumulate(row[::-1])) for row in grid]
        n = len(grid)

        res = 0
        for i in range(n):
            for j in range(i, n):
                if A[j] >= n - 1 - i:
                    A = A[:i] + A[j:j+1] + A[i:j] + A[j+1:]
                    res += j - i
                    break
            else:
                return -1
        
        return res"
get the maximum score,"class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        ans = i = ii = s = ss = 0
        while i < len(nums1) and ii < len(nums2): 
            #update range sum &amp; move pointer 
            if nums1[i] < nums2[ii]: 
                s += nums1[i] 
                i += 1
            elif nums1[i] > nums2[ii]:
                ss += nums2[ii]
                ii += 1
            #add larger range sum to ans
            #add common value &amp; move pointers
            else: 
                ans += max(s, ss) + nums1[i]
                s = ss = 0
                i, ii = i+1, ii+1
        #complete the range sum &amp; update ans 
        ans += max(s + sum(nums1[i:]), ss + sum(nums2[ii:])) 
        return ans % 1_000_000_007"
get the maximum score,"class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        scores = defaultdict(int)
        i, j = 0, 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] < nums2[j]:
                scores[nums1[i]] = nums1[i] if i == 0 else scores[nums1[i-1]] + nums1[i]
                i += 1
            elif nums1[i] > nums2[j]:
                scores[nums2[j]] = nums2[j] if j == 0 else scores[nums2[j-1]] + nums2[j]
                j += 1
            else:
                scores[nums1[i]] = max(0 if i == 0 else scores[nums1[i-1]], 
                                       0 if j == 0 else scores[nums2[j-1]]) + nums1[i]
                i, j = i + 1, j + 1                
        while i < len(nums1):
            scores[nums1[i]] = nums1[i] if i == 0 else scores[nums1[i-1]] + nums1[i]
            i += 1
        while j < len(nums2):
            scores[nums2[j]] = nums2[j] if j == 0 else scores[nums2[j-1]] + nums2[j]
            j += 1
        return max(scores[nums1[-1]], scores[nums2[-1]]) % 1000000007"
kth missing positive number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        ss, x = set(arr), 1
        while True: 
            if x not in ss: k -= 1
            if not k: return x
            x += 1"
kth missing positive number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        lo, hi = 0, len(arr)
        while lo < hi:
            mid = (lo + hi)//2
            if arr[mid] - (mid + 1) < k: lo = mid + 1
            else: hi = mid
        return lo + k"
can convert string in k moves,"class Solution:
    def canConvertString(self, s: str, t: str, k: int) -> bool:
        if len(s) != len(t):
            return False
        
        cycles, extra = divmod(k, 26)
        shifts = [cycles + (shift <= extra) for shift in range(26)]

        for cs, ct in zip(s, t):
            shift = (ord(ct) - ord(cs)) % 26
            if shift == 0:
                continue
            if not shifts[shift]:
                return False
            shifts[shift] -= 1
        
        return True"
can convert string in k moves,"class Solution:
    def canConvertString(self, s: str, t: str, k: int) -> bool:
        
        #If length of strings are different return False
        if len(s) != len(t):
            return False
        
        check = [0]*26  #List which stores counts of t[i] - s[i]
        
        #Storing counts of t[i] - s[i] for 0 <= i < len(s)
        for i in range(len(s)):
            if s[i] != t[i]:
                temp = ( ord(t[i]) - ord(s[i]) ) % 26
                big = temp + 26*check[temp]
                check[temp] += 1
                if big > k:
                    return False
        return True"
minimum insertions to balance a parentheses string,"class Solution:
    def minInsertions(self, s: str) -> int:
        """"""
        (
        """"""
        res = need = 0

        for i in range(len(s)):
            if s[i] == '(':
                need += 2
                if need % 2 == 1:
                    res += 1
                    need -= 1
            if s[i] == ')':
                need -= 1
                if need == -1:
                    res += 1
                    need = 1
        return res + need"
minimum insertions to balance a parentheses string,"class Solution:
    def minInsertions(self, s):
        res = right = 0
        for c in s:
            if c == '(':
                if right % 2:
                    right -= 1
                    res += 1
                right += 2
            if c == ')':
                right -= 1
                if right < 0:
                    right += 2
                    res += 1
        return right + res"
find longest awesome substring,"class Solution:
    def longestAwesome(self, s: str) -> int:
        # li = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
        li = [2**i for i in range(10)]
        # checker = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512}
        checker = set(li)
        checker.add(0)
        # di: k = prefix xor, v = the first idx I got a new prefix_xor_value.
        di = collections.OrderedDict({0: -1})
        maxLength = prefix_xor = 0
        
        for i in range(len(s)):
            prefix_xor ^= li[int(s[i])]
            # Found a new prefix_xor_value
            if prefix_xor not in di:
                di[prefix_xor] = i
            
            # XOR operation with previous prefix_xor_value
            for key in di.keys():
                if i - di[key] <= maxLength:
                    break
				# s[di[key] : i] is Awesome Substring
                if key ^ prefix_xor in checker:
                    maxLength = i - di[key]
        return maxLength"
find longest awesome substring,"class Solution:
    def longestAwesome(self, s: str) -> int:
        ans = prefix = 0
        seen = {0: -1}
        for i, c in enumerate(s):
            prefix ^= 1 << int(c) #toggle bit 
            ans = max(ans, i - seen.get(prefix, inf))
            for k in range(10): 
                x = prefix ^ (1 << k) #toggle kth bit 
                ans = max(ans, i - seen.get(x, inf))
            seen.setdefault(prefix, i)
        return ans"
make the string great,"class Solution:
    def makeGood(self, s: str) -> str:
        stack = []
        for c in s: 
            if stack and abs(ord(stack[-1]) - ord(c)) == 32: stack.pop() #pop ""bad""
            else: stack.append(c) #push ""good""
        return """".join(stack)"
make the string great,"class Solution:
    def makeGood(self, s: str) -> str:
        stack = []
        for c in s: 
            if stack and ord(stack[-1]) ^ ord(c) == 32: stack.pop() #pop ""bad""
            else: stack.append(c) #push ""good""
        return """".join(stack)"
find kth bit in nth binary string,"class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        if k == 1: return ""0""
        if k == 2**(n-1): return ""1""
        if k < 2**(n-1): return self.findKthBit(n-1, k)
        return ""0"" if self.findKthBit(n-1, 2**n-k) == ""1"" else ""1"""
find kth bit in nth binary string,"class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        i, s, hash_map = 1, '0', {'1': '0', '0': '1'}
        for i in range(1, n):
            s = s + '1' + ''.join((hash_map[i] for i in s))[::-1]
        return s[k-1]"
maximum number of non overlapping subarrays with sum equals target,"class Solution:
    def maxNonOverlapping(self, nums: List[int], target: int) -> int:
        ans = prefix = 0
        seen = set([0]) #prefix sum seen so far ()
        for i, x in enumerate(nums): 
            prefix += x
            if prefix - target in seen:
                ans += 1
                seen.clear() #reset seen
            seen.add(prefix)
        return ans"
maximum number of non overlapping subarrays with sum equals target,"class Solution:
    def maxNonOverlapping(self, nums: List[int], target: int) -> int:
        d = {0:0}
        rangeListF = []
        sm = 0
        for i in range(len(nums)):
            sm += nums[i]
            if sm - target in d:
                if len(rangeListF) == 0 or d[sm - target] > rangeListF[-1][1]:
                    rangeListF.append([d[sm - target], i])
                else:
                    pass
            d[sm] = i+1
        return len(rangeListF)"
minimum cost to cut a stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        @lru_cache(None)
        def fn(lo, hi): 
            """"""Return cost of cutting [lo, hi].""""""
            cc = [c for c in cuts if lo < c < hi] #collect cuts within this region 
            if not cc: return 0
            ans = inf
            for mid in cc: ans = min(ans, fn(lo, mid) + fn(mid, hi))
            return ans + hi - lo
        
        return fn(0, n)"
minimum cost to cut a stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        cuts.extend([0, n])
        cuts.sort()
        
        @lru_cache(None)
        def fn(i, j): 
            """"""Return cost of cutting from cuts[i] to cuts[j].""""""
            if i+1 == j: return 0 #no cut in (i, j)
            return cuts[j] - cuts[i] + min(fn(i, k) + fn(k, j) for k in range(i+1, j))
        
        return fn(0, len(cuts)-1)"
three consecutive odds,"class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        count = 0
        
        for i in range(0, len(arr)):
            if arr[i] %2 != 0:
                count += 1
                if count == 3:
                    return True
            else:
                count = 0
        return False"
three consecutive odds,"class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        c=0
        for i in arr:
            if i%2==0:
                c=0
            else:
                c+=1
                if c==3:
                    return True
        return False"
minimum operations to make array equal,"class Solution:
    def minOperations(self, n: int) -> int:
        if(n%2!=0):
            n=n//2
            return n*(n+1)
        else:
            n=n//2
            return n**2"
minimum operations to make array equal,"class Solution:
    def minOperations(self, n: int) -> int:
        return (n*n)//4"
magnetic force between two balls,"class Solution:
    def maxDistance(self, position: List[int], m: int) -> int:
        position.sort()
        
        def fn(d):
            """"""Return True if d is a feasible distance.""""""
            ans, prev = 0, -inf # where previous ball is put
            for x in position:
                if x - prev >= d: 
                    ans += 1
                    if ans == m: return True
                    prev = x
            return False 
        
		# ""last True"" binary search (in contrast to ""first True"" binary search)
        lo, hi = 1, position[-1] - position[0]
        while lo < hi: 
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return lo"
magnetic force between two balls,"class Solution:
    def maxDistance(self, position: List[int], m: int) -> int:
        def verify(x):
            '''
            Returns true if we can put m balls in the buskets
            while maintining at least x distance between them
            '''
            count, prev = 1, position[0]
            for i in range(1, len(position)):
                if position[i]-prev >= x:
                    prev = position[i]
                    count += 1
            return count >= m
    
        position.sort()
        low, high, ret = 1, (position[-1]-position[0])//(m-1)+1, -1
        while low <= high:
            mid = low+(high-low)//2
            if verify(mid):
                # this is a solution but we are looking for the maximum
                # update ret and continue looking for a even larger one
                ret = mid
                low = mid+1
            else:
                high = mid-1
        return ret"
minimum number of days to eat n oranges,"class Solution:
    def minDays(self, n: int) -> int:
        ans = 0
        queue = [n]
        seen = set()
        while queue: #bfs 
            newq = []
            for x in queue: 
                if x == 0: return ans 
                seen.add(x)
                if x-1 not in seen: newq.append(x-1)
                if x % 2 == 0 and x//2 not in seen: newq.append(x//2)
                if x % 3 == 0 and x//3 not in seen: newq.append(x//3)
            ans += 1
            queue = newq"
minimum number of days to eat n oranges,"class Solution:
    def minDays(self, n: int) -> int:
        
        @lru_cache(None)
        def fn(n):
            if n <= 1: return n
            return 1 + min(n%2 + fn(n//2), n%3 + fn(n//3))
        
        return fn(n)"
thousand separator,"class Solution:
    def thousandSeparator(self, n: int) -> str:
        return f""{n:,}"".replace("","", ""."")"
thousand separator,"class Solution:
    def thousandSeparator(self, n: int) -> str:
        ans = deque()
        while n: 
            n, d = divmod(n, 1000)
            ans.appendleft(f""{d:03}"" if n else str(d))
        return ""."".join(ans) or ""0"""
minimum number of vertices to reach all nodes,"class Solution:
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        if not edges:
            return []
        
        incoming_degrees = {i: 0 for i in range(n)}
        
        for x, y in edges:
            incoming_degrees[y] += 1
            
        result = [k for k, v in incoming_degrees.items() if v == 0]
        return result"
minimum number of vertices to reach all nodes,"class Solution:
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        indegree=[0]*n
        for i,j in edges:
            indegree[j]+=1
        lst=[]
        for i in range(n):
            if indegree[i]==0:
                lst.append(i)
        return lst"
minimum numbers of function calls to make target array,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 2 - 1"
minimum numbers of function calls to make target array,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        x = sum(nums)
        count = 0
        while x != 0:
            for i in range(len(nums)):
                if nums[i] % 2 != 0:
                    count += 1
                    x -= 1
            if x != 0:
                for i in range(len(nums)):
                    if nums[i] != 0:
                        nums[i] //= 2
                        x -= nums[i]
                count += 1
        return count"
detect cycles in 2d grid,"class Solution:
    def containsCycle(self, grid: List[List[str]]) -> bool:
        m, n = len(grid), len(grid[0])
        
        @lru_cache(None)
        def fn(i, j, d): 
            """"""Traverse the grid to find cycle via backtracking.""""""
            if grid[i][j] != ""BLACK"": 
                val = grid[i][j]
                grid[i][j] = ""GRAY"" # mark visited in this trial
                for ii, jj, dd in ((i-1, j, -2), (i, j-1, -1), (i, j+1, 1), (i+1, j, 2)):
                    if 0 <= ii < m and 0 <= jj < n and d + dd != 0: # in range &amp; not going back 
                        if grid[ii][jj] == ""GRAY"": return True #cycle found 
                        if grid[ii][jj] == val: fn(ii, jj, dd)
                grid[i][j] = val 
        
        for i in range(m):
            for j in range(n):
                if fn(i, j, 0): return True
                grid[i][j] = ""BLACK"" # mark ""no cycle""
        return False"
detect cycles in 2d grid,"class Solution:
    def containsCycle(self, grid: List[List[str]]) -> bool:
        
        visited, visited_cur = set(), set()
        stack = deque()

        row_n = len(grid)
        col_n = len(grid[0])

        for row, row_g in enumerate(grid):
            for col, val in enumerate(row_g):
                if (row, col) not in visited:   # if new cell
                    
                    # add to stack current cell and previous cell
                    # we don't have previous cell, so replace it to -1, -1
                    stack.append([row, col, -1, -1]) 
                    visited_cur.clear()              
                    while stack:
                        
                        r, c, r_prv, c_prv = stack.pop()
                        if (r, c) in visited_cur:   return True   # we saw this cell before -> cycle
                        visited_cur.add((r, c))

                        for d_r, d_c in [[-1, 0], [0, -1], [1, 0], [0, 1]]:
                            # we exclude previous cell from addition to stack
                            if 0 <= r + d_r < row_n   and (r + d_r, c + d_c) != (r_prv, c_prv)  and   \
                               0 <= c + d_c < col_n   and grid[r + d_r][c + d_c] == val:
                                    stack.append([r + d_r, c + d_c, r, c])

                    visited.update(visited_cur) # add current set to general set

        return False"
most visited sector in a circular track,"class Solution:
    def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
        x, xx = rounds[0], rounds[-1]
        return list(range(x, xx+1)) if x <= xx else list(range(1, xx+1)) + list(range(x, n+1))"
most visited sector in a circular track,"class Solution:
    def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
        # count the length of distance starting from rounds[0]:
		distance = 1
        for i in range(1, len(rounds)):
            if rounds[i - 1] < rounds[i]:
                distance += rounds[i] - rounds[i - 1]
            
            else:
                distance += n - (rounds[i - 1] - rounds[i])
        
		# mapping= {number: frequency}
        mapping = collections.defaultdict(int)
        # be careful that the iteration should start from rounds[0]
        for i in range(rounds[0], rounds[0] + distance):
            if i % n != 0:
                mapping[i % n] += 1
            
            else:
                mapping[n] += 1
         
		 # find out the most frequent numbers
        maxFreq = max(mapping.values())

        res = []
        
        for key in mapping:
            if mapping[key] == maxFreq:
                res.append(key)
        
        # sort the result list and retur
        return sorted(res)"
maximum number of coins you can get,"class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        piles.sort(reverse=True)
        sum = 0
        for i in range(1,len(piles)-int(len(piles)/3),2):
            sum += piles[i]
            print(sum)
        return sum"
maximum number of coins you can get,"class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        piles.sort()
        n = len(piles)
        k = n // 3
        i, j = 0, 2
        ans = 0
        while i < k:
            ans += piles[n-j]
            j += 2
            i +=1
        return ans"
find latest group of size m,"class Solution:
    def findLatestStep(self, arr: List[int], m: int) -> int:
        span = [0]*(len(arr)+2)
        freq = [0]*(len(arr)+1)
        ans = -1
        for i, x in enumerate(arr, 1): 
            freq[span[x-1]] -= 1
            freq[span[x+1]] -= 1
            span[x] = span[x-span[x-1]] = span[x+span[x+1]] = 1 + span[x-1] + span[x+1]
            freq[span[x]] += 1
            
            if freq[m]: ans = i
        return ans"
stone game v,"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        length = len(stoneValue)
        if length == 1:
            return 0
        
		# Calculate sum
        s = [0 for _ in range(length)]
        s[0] = stoneValue[0]
        for i in range(1, length):
            s[i] = s[i-1] + stoneValue[i]
		
		# dp for best value, best_cut for where is the cut in (i, j), i, j inclusive
        dp = [[0 for _ in range(length)] for _ in range(length)]
        best_cut = [[0 for _ in range(length)] for _ in range(length)]
        
        for i in range(0, length-1):
            dp[i][i+1] = min(stoneValue[i], stoneValue[i+1])
            best_cut[i][i+1] = i
            
        for t in range(2, length):
            for i in range(0, length-t):
                tmp_dp = 0
                tmp_cut = 0
                left_bound = best_cut[i][i+t-1]
                if left_bound > i:
                    left_bound -= 1
                right_bound = best_cut[i+1][i+t]
                if right_bound < i+t-1:
                    right_bound += 1
                    
                for k in range(left_bound, 1+right_bound):
                    s1 = s[k] - s[i-1] if i > 0 else s[k]
                    s2 = s[i+t] - s[k]
                    if s1 < s2:
                        tmp = s1 + dp[i][k]
                        if tmp > tmp_dp:
                            tmp_dp = tmp
                            tmp_cut = k
                    elif s1 > s2:
                        tmp = s2 + dp[k+1][i+t]
                        if tmp > tmp_dp:
                            tmp_dp = tmp
                            tmp_cut = k
                    else:
                        tmp1 = s1 + dp[i][k]
                        tmp2 = s2 + dp[k+1][i+t]
                        if tmp1 > tmp_dp:
                            tmp_dp = tmp1
                            tmp_cut = k
                        if tmp2 > tmp_dp:
                            tmp_dp = tmp2
                            tmp_cut = k
        
                dp[i][i+t] = tmp_dp
                best_cut[i][i+t] = tmp_cut
                
        return dp[0][length-1]"
stone game v,"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        def dfs(start, end):
            if start >= end:
                return 0
            max_score = 0
            # divides the array into [start,cut] and 
            # [cur+1, end]
            for cut in range(start, end):
                sum1 = partial_sum[start][cut]
                sum2 = partial_sum[cut+1][end]
                # remaing part is [cut+1, end]
                if sum1 > sum2:
                    score = sum2+dfs(cut+1, end)
                # remaining part is [start, cut]
                elif sum1 < sum2:
                    score = sum1+dfs(start, cut)
                # two rows are equal
                else:
                    score = sum1+max(dfs(start, cut), dfs(cut+1, end))
                max_score = max(score, max_score)
            return max_score
                
        
        def getPartialSum():
            for i in range(n):
                partial_sum[i][i] = stoneValue[i]
            for i in range(n):
                for j in range(i+1, n):
                    partial_sum[i][j] = partial_sum[i][j-1]+stoneValue[j]
                               
            
        n = len(stoneValue)
        partial_sum = [[0]*n for _ in range(n)]
        getPartialSum()
        return dfs(0, n-1)"
detect pattern of length m repeated k or more times,"class Solution:
    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
        for i in range(len(arr)-m+1):
            count = 1
            x = arr[i:i+m]
            res = 1
            for j in range(i+m,len(arr)-m+1,m):
                if x == arr[j:j+m]:
                    count += 1
                else:
                    res = max(res,count)
                    count = 1
                    x = arr[j:j+m]
            res = max(res,count)
            if res >= k:
                return True
        return False"
detect pattern of length m repeated k or more times,"class Solution:
    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
        if len(arr) < k*m: return False
        arr = ''.join([str(x) for x in arr])
        return any([ a==a[0:m]*k for a in [arr[i:i+m*k] for i in range(len(arr))] ])"
maximum length of subarray with positive product,"class Solution:
    def getMaxLen(self, nums: List[int]) -> int:
        ans = pos = neg = 0
        for x in nums: 
            if x > 0: pos, neg = 1 + pos, 1 + neg if neg else 0
            elif x < 0: pos, neg = 1 + neg if neg else 0, 1 + pos
            else: pos = neg = 0 # reset 
            ans = max(ans, pos)
        return ans"
maximum length of subarray with positive product,"class Solution:
    def getMaxLen(self, nums: List[int]) -> int:
        max_len = pos = neg = 0
        for i in nums:
            if i == 0: # Case 1 -> Reset the subarrays
                pos = neg = 0
            elif i > 0: # Case 2 -> +ve subarray remains +ve and -ve remains -ve after adding the new value
                pos += 1 # increment pos
                neg = 0 if neg == 0 else neg + 1 # neg remains 0 if it is already 0 otherwise increment it.
            else: # Case 3 -> +ve subarray becomes -ve and -ve becomes +ve after adding the new value due to sign reversal.
                old_pos = pos
                pos = 0 if neg == 0 else neg + 1 # pos becomes 0 if it is neg is 0 otherwise it is neg+1
                neg = old_pos + 1 # neg becomes old pos + 1
            max_len = max(max_len, pos) # Update the max_len 
        return max_len"
minimum number of days to disconnect island,"class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension 
        grid = """".join("""".join(map(str, x)) for x in grid)
        
        @lru_cache(None)
        def fn(s): 
            """"""Return True if grid is disconnected.""""""
            row, grid = [], []
            for i, c in enumerate(s, 1):
                row.append(int(c))
                if i%n == 0: 
                    grid.append(row)
                    row = []
                    
            def dfs(i, j): 
                """"""""""""
                grid[i][j] = 0
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: dfs(ii, jj)
                return 1
            return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j])
        
        #bfs 
        queue = [grid]
        level = 0 
        seen = {grid}
        while queue: 
            tmp = []
            for node in queue: 
                if fn(node) == 0 or fn(node) >= 2: return level 
                for i in range(m*n):
                    if node[i] == ""1"": 
                        nn = node[:i] + ""0"" + node[i+1:]
                        if nn not in seen: 
                            seen.add(nn)
                            tmp.append(nn)
            queue = tmp
            level += 1"
number of ways to reorder array to get same bst,"class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        
        def fn(nums): 
            """"""Post-order traversal.""""""
            if len(nums) <= 1: return len(nums) # boundary condition 
            ll = [x for x in nums if x < nums[0]]
            rr = [x for x in nums if x > nums[0]]
            left, right = fn(ll), fn(rr)
            if not left or not right: return left or right
            ans = comb(len(rr)+len(ll), len(rr))
            return ans*left*right
            
        return (fn(nums)-1) % 1_000_000_007"
number of ways to reorder array to get same bst,"class Solution:
      

    def numOfWays(self, nums: List[int]) -> int:
        FACT = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063, 72847302, 602640637, 860734560, 657629300, 440732388, 459042011, 394134213, 35757887, 36978716, 109361473, 390205642, 486580460, 57155068, 943272305, 14530444, 523095984, 354551275, 472948359, 444985875, 799434881, 776829897, 626855450, 954784168, 10503098, 472639410, 741412713, 846397273, 627068824, 726372166, 318608048, 249010336, 948537388, 272481214, 713985458, 269199917, 75195247, 286129051, 595484846, 133605669, 16340084, 996745124, 798197261, 286427093, 331333826, 536698543, 422103593, 280940535, 103956247, 172980994, 108669496, 715534167, 518459667, 847555432, 719101534, 932614679, 878715114, 661063309, 562937745, 472081547, 766523501, 88403147, 249058005, 671814275, 432398708, 753889928, 834533360, 604401816, 187359437, 674989781, 749079870, 166267694, 296627743, 586379910, 119711155, 372559648, 765725963, 275417893, 990953332, 104379182, 437918130, 229730822, 432543683, 551999041, 407899865, 829485531, 925465677, 24826746, 681288554, 260451868, 649705284, 117286020, 136034149, 371858732, 391895154, 67942395, 881317771, 114178486, 473061257, 294289191, 314702675, 79023409, 640855835, 825267159, 333127002, 640874963, 750244778, 281086141, 979025803, 294327705, 262601384, 400781066, 903100348, 112345444, 54289391, 329067736, 753211788, 190014235, 221964248, 853030262, 424235847, 817254014, 50069176, 159892119, 24464975, 547421354, 923517131, 757017312, 38561392, 745647373, 847105173, 912880234, 757794602, 942573301, 156287339, 224537377, 27830567, 369398991, 365040172, 41386942, 621910678, 127618458, 674190056, 892978365, 448450838, 994387759, 68366839, 417262036, 100021558, 903643190, 619341229, 907349424, 64099836, 89271551, 533249769, 318708924, 92770232, 420330952, 818908938, 584698880, 245797665, 489377057, 66623751, 192146349, 354927971, 661674180, 71396619, 351167662, 19519994, 689278845, 962979640, 929109959, 389110882, 98399701, 89541861, 460662776, 289903466, 110982403, 974515647, 928612402, 722479105, 218299090, 96415872, 572421883, 774063320, 682979494, 693774784, 611379287, 166890807, 880178425, 837467962, 705738750, 616613957, 338771924, 497191232, 896114138, 560652457, 661582322, 224945188, 262995829, 859081981, 857116478, 279856786, 408062844, 406076419, 367193638, 985761614, 767884817, 77737051, 801784560, 410447512, 813374614, 702909132, 777826615, 11426636, 685259446, 721228129, 931065383, 593559607, 860745086, 578819198, 495425745, 893029457, 6156532, 502193801, 37480384, 220174401, 383076669, 3013247, 750298503, 574624441, 230733683, 144887710, 656590378, 773954850, 358485371, 772254339, 469363737, 95843299, 823414273, 87709482, 892174648, 749756145, 185864756, 68295241, 98238739, 131504392, 111672419, 928208089, 687974198, 753032165, 71715287, 506557931, 290314197, 546089425, 174590825, 187067364, 817659471, 309331349, 303445769, 964814732, 112937795, 848457973, 113604679, 263728612, 162653895, 519013648, 956915940, 591788795, 26960558, 818561771, 201473695, 830318534, 283328761, 298655153, 103269519, 567777414, 629890782, 707451727, 528064896, 419467694, 259775012, 452053078, 972081682, 512829263, 412924123, 354780756, 917691336, 648929514, 519218426, 957710940, 848100261, 607279584, 78508462, 651656900, 271922065, 927371945, 976904514, 655633282, 147015495, 44958071, 431540693, 956102180, 821001984, 4640954, 508310043, 709072863, 866824584, 318461564, 773853828, 371761455, 53040744, 609526889, 972452623, 799173814, 723225821, 3874155, 305590228, 289496343, 139259591, 348260611, 756867525, 848691744, 101266155, 835557082, 267191274, 448180160, 518514435, 443022120, 614718802, 151579195, 204297074, 912569551, 137049249, 515433810, 979001276, 524451820, 229298431, 88837724, 892742699, 387369393, 840349900, 206661672, 18186411, 619853562, 246548548, 236767938, 893832644, 930410696, 321544423, 971435684, 402636244, 780681725, 194281388, 661238608, 964476271, 643075362, 439409780, 96895678, 723461710, 915447882, 785640606, 114709392, 933696835, 539582134, 739120141, 300372431, 244129985, 722433522, 26638091, 388855420, 42468156, 647517040, 474194942, 832805846, 958306874, 489519451, 339220689, 9833277, 923477502, 390998217, 790283925, 694135631, 736657340, 609563281, 873127083, 489593220, 264439147, 891171227, 489029295, 502009550, 325923608, 280525558, 857054649, 820622208, 558213940, 216997416, 487921842, 951328535, 606653379, 794417402, 449723904, 783486165, 414645478, 809681447, 114612567, 824953206, 255016498, 147060381, 88903008, 228293174, 394357308, 362355866, 900088886, 638573794, 779598451, 904922263, 451026166, 549459329, 212643744, 563246709, 391796933, 174243175, 189725986, 238337196, 60051478, 782959006, 982673239, 237607992, 685987666, 694447544, 195840153, 519748540, 446086975, 523485236, 185780714, 716004996, 214280883, 140643728, 555470704, 516522055, 116665689, 899547947, 490696549, 683197147, 686671136, 988747143, 744912554, 619072836, 345158054, 224284246, 637879131, 78947725, 342273666, 237716550, 915360466, 711578771, 423071394, 228124918, 271834959, 480779410, 254894593, 859192972, 990202578, 258044399, 151532640, 644862529, 48049425, 448119239, 130306338, 850105179, 401639970, 606863861, 183881380, 837401090, 513536652, 714177614, 946271680, 243293343, 403377310, 688653593, 15447678, 754734307, 631353768, 202296846, 159906516, 912696536, 737140518, 467380526, 896686075, 309895051, 356369955, 461415686, 706245266, 10064183, 183054210, 455971702, 737368289, 956771035, 564163693, 365118309, 226637659, 304857172, 440299843, 717116122, 485961418, 615704083, 476049473, 354119987, 329471814, 620060202, 251964959, 45357250, 175414082, 671119137, 48735782, 122378970, 717506435, 18459328, 949577729, 771970076, 635808197, 608040366, 165916428, 258536202, 902229110, 617090616, 548564593, 613394864, 753777984, 577888302, 416452176, 881599549, 524547188, 599140122, 522765386, 657552586, 256787840, 287613719, 776067801, 597965522, 458655497, 764387515, 350167935, 494713961, 513386012, 576480762, 864589772, 86987059, 495636228, 512647986, 721997962, 982831380, 162376799, 204281975, 462134806, 189646394, 425968575, 209834628, 494248765, 664281698, 947663843, 540352769, 25662122, 986679150, 207298711, 477043799, 24708053, 528335066, 189351697, 717500453, 42764755, 316734785, 823726196, 293357001, 547414377, 258966410, 602945692, 561521296, 351253952, 752369730, 174204566, 871148004, 302242737, 554611874, 540181425, 349941261, 414343943, 921115587, 959388563, 227019335, 708812719, 793380997, 342547759, 324322556, 458370547, 356254978, 809319893, 159690374, 848340820, 971304725, 180230004, 103061704, 207441144, 443272953, 45593686, 541647240, 612817107, 849140508, 109375794, 906749744, 159084460, 541378020, 692284266, 908221578, 720697998, 363923522, 819281897, 701846632, 479994712, 196613531, 29272489, 792937812, 859009553, 202148261, 385627435, 115321267, 612859231, 132778909, 173511339, 782369566, 322583903, 324703286, 31244274, 433755056, 109559692, 871157455, 350443931, 592104988, 197184362, 141678010, 649163959, 746537855, 954594407, 850681817, 703404350, 467293824, 684978431, 565588709, 378843675, 825260479, 749777538, 850502015, 387852091, 412307507, 307565279, 914127155, 864079609, 845970807, 414173935, 638273833, 664477235, 173471099, 480759791, 839694748, 190898355, 956270620, 957911348, 43002811, 628936576, 966234409, 667971950, 236586166, 954211897, 223051884, 21058295, 656573222, 631532535, 809706350, 984734695, 314281677, 311454037, 640732448, 434907794, 175084834, 434807109, 973816812, 488481268, 844735329, 917344075, 314288693, 459259162, 992521062, 667512257, 603748166, 679935673, 833938466, 933875943, 522922384, 981191471, 457854178, 112860028, 484939649, 611363777, 627371454, 844300972, 962501388, 738504183, 631041465, 29224765, 334078303, 211237785, 626057542, 900175080, 728504100, 450509755, 575177363, 905713570, 416609984, 874776027, 334255451, 683287462, 999293262, 474888472, 317020697, 180417613, 591538360, 879151833, 605566485, 569294094, 970567518, 896200922, 943088633, 145735679, 884701203, 949403596, 749113557, 78958680, 850679027, 665376978, 686499745, 426302291, 842343474, 708066168, 962548572, 349652428, 833757979, 492365420, 136639914, 76093131, 591710464, 208764552, 166233017, 498121245, 545840935, 26721664, 736011124, 880639351, 137410283, 42609708, 235572009, 981737748, 718913567, 909319027, 906112184, 298059463, 274736280, 217450848, 351267027, 149682364, 249066734, 11785215, 333890217, 774940233, 302540697, 519852435, 802535369, 620684620, 306323295, 752310997, 848793393, 883503040, 569433124, 254795373, 855478464, 660158704, 87911700, 944741410, 351053939, 2634663, 134077016, 736459220, 4882454, 969435081, 120150411, 922584286, 828772112, 106810765, 371205161, 17024731, 960279329, 389323593, 23991206, 744762405, 684217429, 479374977, 963728237, 3246420, 688035746, 381629444, 752436308, 274567573, 440219140, 702541058, 919238277, 563955926, 467150839, 5249506, 399086000, 833151662, 847391187, 655983283, 337920422, 866913758, 675206635, 549602585, 963783662, 324756002, 393087771, 731515248, 787956453, 550936813, 398161393, 631665856, 442637251, 454846959, 348994181, 88011024, 513458067, 60476466, 9760396, 403700900, 990173371, 519613195, 945797344, 114696834, 327457551, 905694736, 143025346, 289024806, 451579463, 325709522, 18701196, 326143996, 49850509, 619195074, 414881030, 850660769, 880149960, 651809429, 592293509, 810577782, 929598726, 835669318, 731671946, 529667681, 285562083, 293565850, 686472980, 274474950, 282703792, 889076915, 56602629, 546147347, 255724802, 873696194, 831784350, 110556728, 279941051, 667003092, 302778600, 803516696, 772054724, 165410893, 531446229, 958833885, 703493734, 68812272, 481542542, 722167619, 172528691, 173636402, 356397518, 390931659, 311533827, 53449710, 959934024, 259493848, 215350798, 907381983, 791418522, 896453666, 530274270, 443147787, 468552325, 410897594, 491169384, 314015783, 406644587, 772818684, 721371094, 596483817, 922913559, 78344520, 173781169, 485391881, 326797438, 209197264, 227032260, 183290649, 293208856, 909531571, 778733890, 346053132, 674154326, 75833611, 738595509, 449942130, 545136258, 334305223, 589959631, 51605154, 128106265, 85269691, 347284647, 656835568, 934798619, 602272125, 976691718, 647351010, 456965253, 143605060, 148066754, 588283108, 104912143, 240217288, 49898584, 251930392, 868617755, 690598708, 880742077, 200550782, 935358746, 104053488, 348096605, 394187502, 726999264, 278275958, 153885020, 653433530, 364854920, 922674021, 65882280, 762280792, 84294078, 29666249, 250921311, 659332228, 420236707, 614100318, 959310571, 676769211, 355052615, 567244231, 840761673, 557858783, 627343983, 461946676, 22779421, 756641425, 641419708]

        MMI = [0, 1, 500000004, 333333336, 250000002, 400000003, 166666668, 142857144, 125000001, 111111112, 700000005, 818181824, 83333334, 153846155, 71428572, 466666670, 562500004, 352941179, 55555556, 157894738, 850000006, 47619048, 409090912, 739130440, 41666667, 280000002, 576923081, 370370373, 35714286, 758620695, 233333335, 129032259, 281250002, 939393946, 676470593, 628571433, 27777778, 621621626, 78947369, 717948723, 425000003, 658536590, 23809524, 395348840, 204545456, 822222228, 369565220, 404255322, 520833337, 448979595, 140000001, 784313731, 788461544, 56603774, 685185190, 763636369, 17857143, 385964915, 879310351, 50847458, 616666671, 688524595, 564516133, 15873016, 140625001, 30769231, 469696973, 686567169, 838235300, 579710149, 814285720, 98591550, 13888889, 410958907, 310810813, 93333334, 539473688, 831168837, 858974365, 202531647, 712500005, 123456791, 329268295, 84337350, 11904762, 670588240, 197674420, 252873565, 102272728, 415730340, 411111114, 164835166, 184782610, 43010753, 202127661, 231578949, 760416672, 268041239, 724489801, 646464651, 570000004, 940594066, 892156869, 572815538, 394230772, 209523811, 28301887, 224299067, 342592595, 9174312, 881818188, 873873880, 508928575, 893805316, 692982461, 147826088, 939655179, 239316241, 25423729, 478991600, 808333339, 438016532, 844262301, 886178868, 782258070, 856000006, 7936508, 480314964, 570312504, 798449618, 515384619, 190839696, 734848490, 165413535, 843283588, 274074076, 419117650, 58394161, 789855078, 604316551, 407142860, 134751774, 49295775, 832167838, 506944448, 151724139, 705479457, 149659865, 655405410, 530201346, 46666667, 483443712, 269736844, 594771246, 915584422, 625806456, 929487186, 343949047, 601265827, 685534596, 856250006, 962732926, 561728399, 116564418, 664634151, 587878792, 42168675, 5988024, 5952381, 242603552, 335294120, 795321643, 98837210, 791907520, 626436786, 325714288, 51136364, 683615824, 207865170, 435754193, 205555557, 933701664, 82417583, 562841534, 92391305, 524324328, 521505380, 577540111, 601063834, 338624341, 615789478, 439790579, 380208336, 694300523, 634020623, 343589746, 862244904, 969543154, 823232329, 507537692, 285000002, 228855723, 470297033, 108374385, 946078438, 131707318, 286407769, 526570052, 197115386, 832535891, 604761909, 90047394, 514150947, 32863850, 612149537, 79069768, 671296301, 875576043, 4587156, 470319638, 440909094, 950226251, 436936940, 125560539, 754464291, 364444447, 446902658, 35242291, 846491234, 711790398, 73913044, 277056279, 969827593, 90128756, 619658124, 880851070, 512711868, 67510549, 239495800, 280334730, 904166673, 406639007, 219008266, 707818935, 922131154, 89795919, 443089434, 165991904, 391129035, 28112450, 428000003, 912350604, 3968254, 339920951, 240157482, 556862749, 285156252, 70038911, 399224809, 517374521, 757692313, 417624524, 95419848, 836501907, 367424245, 611320759, 582706771, 138576780, 421641794, 743494429, 137037038, 450184505, 209558825, 388278391, 529197084, 752727278, 394927539, 252707583, 802158279, 681003589, 203571430, 718861215, 67375887, 650176683, 524647891, 77192983, 416083919, 808362375, 253472224, 961937723, 575862073, 756013751, 852739732, 522184304, 574829936, 210169493, 327702705, 215488217, 265100673, 441471575, 523333337, 770764125, 241721856, 646864691, 134868422, 137704919, 297385623, 749185673, 457792211, 857605184, 312903228, 787781356, 464743593, 492012783, 671974527, 403174606, 800632917, 652996850, 342767298, 614420067, 428125003, 741433027, 481366463, 597523224, 780864203, 406153849, 58282209, 3058104, 832317079, 343465048, 293939396, 631419944, 521084341, 624624629, 2994012, 737313438, 502976194, 41543027, 121301776, 631268441, 167647060, 284457480, 897660825, 206997086, 49418605, 715942034, 395953760, 985590785, 313218393, 521489975, 162857144, 413105416, 25568182, 175637395, 341807912, 19718310, 103932585, 826330538, 717877100, 713091927, 602777782, 113573408, 466850832, 812672182, 541208795, 882191787, 281420767, 376021801, 546195656, 295392956, 262162164, 436657685, 260752690, 16085791, 788770059, 618666671, 300531917, 212201593, 669312174, 195250661, 307894739, 160104988, 719895293, 172323761, 190104168, 966233773, 847150265, 932816544, 817010315, 951156819, 171794873, 102301791, 431122452, 63613232, 484771577, 840506335, 911616168, 760705295, 253768846, 55137845, 142500001, 855361602, 614427865, 779156333, 735148520, 424691361, 554187196, 238329240, 473039219, 188264060, 65853659, 352798056, 643203888, 578692498, 263285026, 16867470, 98557693, 534772186, 916267949, 844868741, 802380958, 966745850, 45023697, 44917258, 757075477, 134117648, 16431925, 526932088, 806074772, 610722615, 39534884, 761020887, 835648154, 614318711, 937788025, 50574713, 2293578, 354691078, 235159819, 642369025, 220454547, 716553293, 975113129, 88036118, 218468470, 83146068, 562780273, 176733782, 877232149, 285077953, 682222227, 605321512, 223451329, 161147904, 517621149, 432967036, 423245617, 172866522, 355895199, 198257082, 36956522, 321041217, 638528143, 820734347, 984913800, 208602152, 45064378, 775160605, 309829062, 240938168, 440425535, 447983018, 256355934, 763213536, 533755278, 646315794, 119747900, 228511532, 140167365, 206680586, 952083340, 355509358, 703319507, 654244311, 109504133, 653608252, 853909471, 607802879, 461065577, 38854806, 544897963, 641547866, 221544717, 632860045, 82995952, 529292933, 695564521, 156941651, 14056225, 266533068, 714000005, 1996008, 456175302, 282306165, 1984127, 588118816, 669960479, 747534522, 120078741, 491159139, 778431378, 344422703, 142578126, 598440550, 535019459, 314563109, 699612408, 400386850, 758687264, 597302509, 878846160, 191938581, 208812262, 921606125, 47709924, 441904765, 918250957, 301707782, 683712126, 510396979, 805660383, 561205277, 791353389, 589118203, 69288390, 844859819, 210820897, 811918069, 871747218, 404452693, 68518519, 60998152, 725092256, 311233888, 604779416, 801834868, 694139199, 541133459, 264598542, 854280516, 376363639, 39927405, 697463773, 457504524, 626353795, 174774776, 901079143, 457809698, 840501798, 491949914, 101785715, 525846706, 859430611, 433392543, 533687947, 578761066, 825088345, 446208116, 762323949, 732864680, 538596495, 334500878, 708041963, 813263531, 904181191, 229565219, 126736112, 771230508, 980968865, 898100179, 787931040, 869191056, 878006879, 732418530, 426369866, 447863251, 261092152, 724020448, 287414968, 585738544, 605084750, 656514387, 663851356, 160202362, 607744112, 95798320, 632550340, 835845902, 720735791, 410684477, 761666672, 296173047, 885382066, 76285241, 120860928, 887603312, 823432349, 729818786, 67434211, 36124795, 568852463, 492635028, 648692815, 696574230, 874592840, 377235775, 728896109, 716369535, 428802592, 953150249, 156451614, 842190022, 393890678, 630818624, 732371800, 571200004, 746006395, 944178635, 835987267, 36565978, 201587303, 438985740, 900316462, 30015798, 326498425, 696062997, 171383649, 880690744, 807210037, 677621288, 714062505, 720748835, 870716517, 43545879, 740683235, 359689925, 298761612, 119010820, 890432105, 640986137, 703076928, 291858681, 529141108, 29096478, 1529052, 438167942, 916158543, 823439884, 171732524, 698027319, 146969698, 216338882, 315709972, 983408755, 760542174, 33082707, 812312318, 163418292, 1497006, 41853513, 368656719, 62593145, 251488097, 493313525, 520771517, 454814818, 60650888, 320531760, 815634224, 609720181, 83823530, 345080766, 142228740, 530014645, 948830416, 411678835, 103498543, 237263466, 524709306, 927431066, 357971017, 444283650, 197976880, 92352093, 992795396, 520863313, 656609200, 862266864, 760744991, 696709590, 81428572, 489301002, 206552708, 85348507, 12784091, 626950359, 587818701, 991513444, 170903956, 385049368, 9859155, 355836852, 551966296, 701262277, 413165269, 366433569, 358938550, 93444910, 856545967, 318497916, 301388891, 224687935, 56786704, 802213007, 233425416, 630344832, 406336091, 696011009, 770604401, 235939645, 941095897, 729138172, 640710387, 66848568, 688010904, 29931973, 273097828, 698778838, 147696478, 538565633, 131081082, 721997306, 718328846, 590847918, 130376345, 506040272, 508042899, 676037488, 894385033, 889185587, 809333339, 215712385, 650265962, 304116868, 606100800, 896688748, 334656087, 952443864, 597625334, 779973655, 653947373, 582128782, 80052494, 1310616, 859947650, 518954252, 586161884, 850065195, 95052084, 855656703, 983116890, 690012975, 923575136, 648124196, 466408272, 525161294, 908505161, 839124845, 975578413, 613607193, 585897440, 645326509, 551150899, 805874846, 215561226, 868789815, 31806616, 419313853, 742385792, 278833969, 920253171, 841972193, 455808084, 822194205, 880352651, 537106922, 126884423, 877038902, 527568926, 964956202, 571250004, 46192260, 427680801, 764632633, 807213936, 592546588, 889578170, 581164812, 367574260, 102595798, 712345684, 755856972, 277093598, 816728173, 119164620, 223312885, 736519613, 73439413, 94132030, 462759466, 532926833, 618757617, 176399028, 52247874, 321601944, 917575764, 289346249, 617896014, 131642513, 712907122, 8433735, 84235861, 549278850, 496998803, 267386093, 601197609, 958133978, 560334532, 922434374, 696066751, 401190479, 853745547, 483372925, 239620405, 522511852, 848520716, 22458629, 348288078, 878537742, 216725561, 67058824, 722679206, 508215966, 690504108, 263466044, 359064330, 403037386, 792298722, 805361311, 67520373, 19767442, 269454125, 880510447, 718424107, 417824077, 158381504, 807159359, 987312579, 968894016, 200230151, 525287360, 360505169, 1146789, 918671255, 177345539, 265142859, 617579913, 891676175, 821184516, 840728106, 610227277, 759364364, 858276650, 612684036, 987556568, 736723169, 44018059, 559188279, 109234235, 497187855, 41573034, 738496077, 781390140, 705487127, 88366891, 287150840, 938616078, 813823863, 642538980, 314794218, 841111117, 591564932, 302660756, 256921375, 611725668, 786740337, 80573952, 324145537, 758810578, 882288235, 216483518, 963776077, 711622812, 371303398, 86433261, 712568311, 677947603, 741548533, 99128541, 41349293, 18478261, 916395229, 660520612, 776814740, 819264075, 304864867, 910367177, 952535066, 492456900, 252960174, 104301076, 23630505, 22532189, 595927121, 887580306, 515508025, 154914531, 16008538, 120469084, 164004261, 720212771, 568544106, 223991509, 115588548, 128177967, 467724871, 381606768, 551214365, 266877639, 262381456, 323157897, 884332288, 59873950, 383001052, 114255766, 687958120, 570083686, 204806689, 103340293, 8342023, 476041670, 746097820, 177754679, 580477678, 851659757, 338860106, 827122159, 260599795, 554752070, 199174408, 326804126, 669412981, 926954739, 943473799, 803901443, 468717952, 730532792, 584442174, 19427403, 492339125, 772448985, 1019368, 320773933, 399796544, 610772362, 793908635, 816430026, 447821685, 41497976, 17189080, 764646470, 172552978, 847782264, 877139986, 578470829, 901507544, 507028116, 911735212, 133266534, 874874881, 857000006]
        n = len(nums)
        lis = [0] * n
        def count(subnums):
            nonlocal lis
            if subnums:
                low = [num for num in subnums if num < subnums[0]]
                high = [num for num in subnums if num > subnums[0]]
                lis[subnums[0]-1] = len(subnums)
                count(low)
                count(high)
        
        count(nums)




        M = 10 ** 9 + 7
        denum = 1
        for k in range(1,n+1):
            denum = (denum * MMI[lis[k-1]]) % M
        return (FACT[n] * denum) % M - 1"
matrix diagonal sum,"class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        """"""
        The primary diagonal is formed by the elements A00, A11, A22, A33.
        Condition for Primary Diagonal:
            The row-column condition is row = column.

        The secondary diagonal is formed by the elements A03, A12, A21, A30. 
        Condition for Secondary Diagonal:
            The row-column condition is row = numberOfRows - column -1.
        """"""
        s = 0
        l , mid = len(mat), len(mat)//2
        for i in range(l):
            s += mat[i][i] # primary diagonal
            s += mat[len(mat)-i-1][i] # secondary diagonal
        
        # If the mat is odd, then diagonal will coincide, so subtract the middle element
        if l%2 != 0:
            s -= mat[mid][mid]
        
        return s"
matrix diagonal sum,"class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        total = 0 
        for i, x in enumerate(mat):
            if i == len(mat)-i-1:
                total += x[i]
            else: 
                total += x[i] + x[len(mat)-i-1]
        return total"
number of ways to split a string,"class Solution:
    def numWays(self, s: str) -> int:
        total = s.count('1')
        if total % 3: return 0
        n = len(s)
        if not total: return (1+n-2) * (n-2) // 2 % 1000000007
        avg, ans = total // 3, 0
        cnt = first_part_right_zeros = last_part_left_zeros = 0
        for i in range(n):
            if s[i] == '1': cnt += 1
            elif cnt == avg: first_part_right_zeros += 1
            elif cnt > avg: break    
        cnt = 0
        for i in range(n-1, -1, -1):
            if s[i] == '1': cnt += 1
            elif cnt == avg: last_part_left_zeros += 1
            elif cnt > avg: break    
        return (first_part_right_zeros+1) * (last_part_left_zeros+1) % 1000000007"
number of ways to split a string,"class Solution:
    def numWays(self, s: str) -> int:
        total = s.count('1')
        if total % 3: return 0
        avg = total // 3
        n, ans = len(s), 0
        @lru_cache(maxsize=None)
        def dfs(s, idx, part):
            nonlocal avg, n
            if part == 4 and idx == n: return 1
            cnt = cur = 0
            for i in range(idx, n):
                if s[i] == '1': cnt += 1
                if cnt == avg: cur += dfs(s, i+1, part+1)    
                elif cnt > avg: break 
            return cur
        return dfs(s, 0, 1) % 1000000007"
shortest subarray to be removed to make array sorted,"class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        
        def lowerbound(left, right, target):
            while left < right:
                mid = left + (right - left) // 2
                
                if arr[mid] == target:
                    right = mid
                elif arr[mid] < target:
                    left = mid + 1
                else:
                    right = mid
                
            return left
        
        
        N = len(arr)
        
        # find the longest ascending array on the left side
        i = 0
        while i + 1 < N and arr[i] <= arr[i+1]:
            i += 1
        
        if i == N - 1:
            # it is already in ascending order
            return 0
        
        # find the longest ascending array on the right side
        j = N - 1
        while j - 1 >= 0 and arr[j] >= arr[j-1]:
            j -= 1
        
        if j == 0:
            # the entire array is in decending order
            return N - 1
        
        # keep ascending array on right side or left side
        result = min(N - (N - j), N - i -1)
        
        
        # find the shortest unordered subarray in the middle 
        for k in range(i+1):
            l = lowerbound(j, len(arr), arr[k])
            result = min(result, l - (k + 1))
        
        
        return result"
shortest subarray to be removed to make array sorted,"class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        st = 0
        end = len(arr) - 1
        prev = None
        
        st = Solution.find_end_subarray(arr=arr, st=0, inc_flag=True)
        end = Solution.find_end_subarray(arr=arr, st=len(arr)-1, inc_flag=False)

        merge_length = Solution.merge(st-1, end+1, arr)
        take_first = len(arr) - st
        take_end = end + 1
        take_merged = len(arr) - merge_length
        return min(take_first, min(take_end, take_merged))
        
    @staticmethod
    def find_end_subarray(arr, st, inc_flag, prev=None):
        while(st < len(arr) if inc_flag else st >= 0):
            if prev is None or (arr[st] >= prev if inc_flag else arr[st] <= prev):
                prev = arr[st]
                st = st + 1 if inc_flag else st - 1
            else:
                break
        return st
    
    @staticmethod
    def merge(first_arr_end, second_arr_st, arr):
        ans = 0
        first_arr_st = 0
        while(first_arr_st <= first_arr_end and second_arr_st < len(arr)):
            if arr[first_arr_st] <= arr[second_arr_st]:
                if first_arr_st >= second_arr_st:
                    ans = max(ans, len(arr) - 1)
                    break
                else:
                    ans = max(ans, first_arr_st + len(arr) - second_arr_st + 1)
                first_arr_st += 1
            else:
                second_arr_st += 1
        return ans"
count all possible routes,"class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        
        @lru_cache(None)
        def fn(n, x): 
            """"""Return all possible routes from n to finish with x fuel.""""""
            if x < 0: return 0 # not going anywhere without fuel 
            ans = 0
            if n == finish: ans += 1
            for nn in range(len(locations)): 
                if nn != n: ans += fn(nn, x-abs(locations[n] - locations[nn]))
            return ans 
        
        return fn(start, fuel) % 1_000_000_007"
count all possible routes,"class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        # start = initial index
        # end = destination index     

        MOD = (10**9)+7 
        lenLocations = len(locations)

        @cache
        def dfs(index, fuel):
            # If you have no more fuel and you're at destination:
            # You cannot try another other routes, return 1 because you're at destination
            if fuel == 0 and index == finish:
                return 1

            # If no more fuel and not at route:
            # You cannot try another other routes, return 1 because you're not at destination
            if fuel <= 0:
                return 0
            
            # If your current index is destination index, you found an existing route
            countWays = 1 if index == finish else 0

            # Try every location index (dfs), but you cannot stay at your current index
            for nextIndex in range(len(locations)):
                if index != nextIndex:
                    cost = abs(locations[index]-locations[nextIndex])
                    countWays += dfs(nextIndex,fuel-cost)

            return countWays

        return dfs(start,fuel) % MOD"
replace all s to avoid consecutive repeating characters,"class Solution:
    def modifyString(self, s: str) -> str:
        s = list(s)
        for i in range(len(s)):
            if s[i] == ""?"": 
                for c in ""abc"": 
                    if (i == 0 or s[i-1] != c) and (i+1 == len(s) or s[i+1] != c): 
                        s[i] = c
                        break 
        return """".join(s)"
replace all s to avoid consecutive repeating characters,"class Solution:
    def modifyString(self, s: str) -> str:
        if len(s)==1:  #if input contains only a '?'
            if s[0]=='?':
                return 'a'
        s=list(s)
        for i in range(len(s)):
            if s[i]=='?':
                for c in 'abc':
                    if i==0 and s[i+1]!=c: #if i=0 means it is first letter so there is no s[ i-1]
                        s[i]=c
                        break
                    if i==len(s)-1 and s[i-1]!=c: #if i=len(s) means it is last letter so there is no s[i+1]
                        s[i]=c
                        break
                    if (i>0 and i<len(s)-1) and s[i-1]!=c and s[i+1]!=c: 
                        s[i]=c
                        break
        return ''.join(s)
	```"
number of ways where square of number is equal to product of two numbers,"class Solution:
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        sqr1, sqr2 = defaultdict(int), defaultdict(int)
        m, n = len(nums1), len(nums2)
        for i in range(m):
            sqr1[nums1[i]**2] += 1
        for j in range(n):
            sqr2[nums2[j]**2] += 1
            
        res = 0 
        for i in range(m-1):
            for j in range(i+1, m):
                if nums1[i]*nums1[j] in sqr2:
                    res += sqr2[nums1[i]*nums1[j]]
                    
        for i in range(n-1):
            for j in range(i+1, n):
                if nums2[i]*nums2[j] in sqr1:
                    res += sqr1[nums2[i]*nums2[j]]
        return res"
number of ways where square of number is equal to product of two numbers,"class Solution:
    
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        """"""
        O(n^2)
        """"""
        
        def check(nums1, nums2):
            
            # Initialize a dict: value->(value^2, count)
            a = {}
            for i in nums1:
                if i not in a:
                    a[i] = [i**2, 1]
                else:
                    a[i][-1] += 1
                               
            # Initialize a dict: nums2[i] * nums[j] -> count
            b = collections.defaultdict(int)
            for i in range(len(nums2)):
                for j in range(i+1, len(nums2)):
                    b[nums2[i]*nums2[j]] += 1
                    
            # Calculate the result
            # result += i^2 count * j*k count for each combination
            result = 0            
            for (i, amount) in a.values():                
                result += b[i]*amount
            
            return result
        
                                
        # Call above function twice
        return check(nums1, nums2) + check(nums2, nums1)"
minimum time to make rope colorful,"class Solution:
    def minCost(self, s: str, cost: List[int]) -> int:
        ans = prev = 0 # index of previously retained letter 
        for i in range(1, len(s)): 
            if s[prev] != s[i]: prev = i
            else: 
                ans += min(cost[prev], cost[i])
                if cost[prev] < cost[i]: prev = i
        return ans"
minimum time to make rope colorful,"class Solution:
    def minCost(self, s: str, cost: List[int]) -> int:
        ans = 0
        prev = 0
        for i in range(1, len(s)):
            if s[i] == s[prev]:
                if cost[prev] < cost[i]:
                    ans += cost[prev]
                    prev = i
                else:
                    ans += cost[i]
            else:
                prev = i
        return ans &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
special positions in a binary matrix,"class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        onesx = []
        onesy = []
        for ri, rv in enumerate(mat):
            for ci, cv in enumerate(rv):
                if cv == 1:
                    onesx.append(ri)
                    onesy.append(ci)
        
        count = 0
        for idx in range(len(onesx)):
            if onesx.count(onesx[idx]) == 1:
                if onesy.count(onesy[idx]) == 1:
                    count += 1
        return count"
special positions in a binary matrix,"class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        
        M, N, result = len(mat), len(mat[0]), 0
                
        mat_t = list(zip(*mat)) # transpose
        
        for i in range(M):
            for j in range(N):
                if mat[i][j] == 1 and \
                sum(mat[i]) == 1 and \
                sum(mat_t[j]) == 1:
                    result += 1
                            
        return result"
count unhappy friends,"class Solution:
    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:

        def find_preferred_friends(x: int) -> List[int]:
            """"""
            Returns friends of x that have a higher preference than partner.
            """"""
			partner = partners[x]  # Find the partner of x.
            x_friends = friend_prefs[x]  # Find all the friends of x.
            partner_ranking = x_friends[partner]  # Get the partner's ranking amongst those friends.
            return list(x_friends)[:partner_ranking]  # Return all friends with a preferred lower ranking.

        def is_unhappy(x: int) -> bool:
            """"""
            Returns True if person x is unhappy, otherwise False.
            """"""
            # Find the partner for person x.
            partner = partners[x]  
            # Find the friends that person x prefers more than this partner.
            preferred_friends = find_preferred_friends(x)  
            # A friend is unhappy with their partner if there is another friend with a higher preference 
            # and that friend prefers them over their partner.
            return any(friend_prefs[friend][x] <= friend_prefs[friend][partners[friend]] 
                       for friend in preferred_friends)

        # Create dictionary to lookup friend preference for any person.
        friend_prefs = {
            person: {friend: pref for pref, friend in enumerate(friends)}
            for person, friends in enumerate(preferences)
        }
		# Example:
		# {0: {1: 0, 3: 1, 2: 2},
	    #  1: {2: 0, 3: 1, 0: 2},
	    #  2: {1: 0, 3: 1, 0: 2},
	    #  3: {0: 0, 2: 1, 1: 2}}
 
        # Create dictionary to find anyone's partner.
        partners = {}
        for x, y in pairs:
            partners[x] = y
            partners[y] = x
        
		# Count and return the number of unhappy people.
        return sum(is_unhappy(person) for person in range(n))"
count unhappy friends,"class Solution:
    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:
        dd = {}
        
        for i,x in pairs:
            dd[i] = preferences[i][:preferences[i].index(x)]
            dd[x] = preferences[x][:preferences[x].index(i)]
        
        ans = 0
            
        for i in dd:
            for x in dd[i]:
                if i in dd[x]:
                    ans += 1
                    break
        
        return ans"
min cost to connect all points,"class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])
        n, c = len(points), collections.defaultdict(list)
        for i in range(n):
            for j in range(i+1, n):
                d = manhattan(points[i], points[j])
                c[i].append((d, j))
                c[j].append((d, i))
        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]
        visited[0] = 1
        heapq.heapify(heap)
        while heap:
            d, j = heapq.heappop(heap)
            if not visited[j]:
                visited[j], cnt, ans = 1, cnt+1, ans+d
                for record in c[j]: heapq.heappush(heap, record)
            if cnt >= n: break        
        return ans"
min cost to connect all points,"class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        d, res = {(x, y): float('inf') if i else 0 for i, (x, y) in enumerate(points)}, 0
        while d:
            x, y = min(d, key=d.get)  # obtain the current minimum edge
            res += d.pop((x, y))      # and remove the corresponding point
            for x1, y1 in d:          # for the rest of the points, update the minimum manhattan distance
                d[(x1, y1)] = min(d[(x1, y1)], abs(x-x1)+abs(y-y1))
        return res"
check if string is transformable with substring sort operations,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if sorted(s) != sorted(t): return False # edge case 
        
        pos = [deque() for _ in range(10)]
        for i, ss in enumerate(s): pos[int(ss)].append(i)
            
        for tt in t: 
            i = pos[int(tt)].popleft()
            for ii in range(int(tt)): 
                if pos[ii] and pos[ii][0] < i: return False # cannot swap 
        return True"
sum of all odd length subarrays,"class Solution:
    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        s=0
        for i in range(len(arr)):
            for j in range(i,len(arr),2):
                s+=sum(arr[i:j+1])
        return s"
sum of all odd length subarrays,"class Solution(object):
    def sumOddLengthSubarrays(self, arr):
        """"""
        :type arr: List[int]
        :rtype: int
        """"""
		#We declare our output variable with the initial value as the sum of all elements as this is the 1st iteration of the sum of all individual elements.
        result = sum(arr)
		#Saving length of the input array beforehand for ease of writing
        length = len(arr)
		#As we already summed up the individual elements, now its time to start groups starting from 3,5,7 and so onnn
        for j in range(3,length+1,2):
		#Now we need to create pairs for each element with the previous loop sizes
            for i in range(length):
			#This condition is to make we dont search for indexes outside our list
                if (i+j) > length:
                    break
					#We continously add the sum of each sublist to our output variable
                result += sum(arr[i:i+j])
        return result"
maximum sum obtained of any permutation,"class Solution:
    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:
        chg = [0]*len(nums) # change 
        for i, j in requests: 
            chg[i] += 1
            if j+1 < len(nums): chg[j+1] -= 1
        for i in range(1, len(nums)): chg[i] += chg[i-1] # cumulated change
        return sum(n*c for n, c in zip(sorted(nums), sorted(chg))) % 1_000_000_007"
make sum divisible by p,"class Solution:
def minSubarray(self, nums: List[int], p: int) -> int:
    dp = defaultdict(int)
    dp[0] = -1
    target = sum(nums) % p
    curSum = 0
    result = len(nums)
    
    if sum(nums) % p == 0: return 0
    
    for i in range(len(nums)):
        curSum += nums[i]
        
        curMod = curSum % p
        
        temp = (curSum - target) % p
        
        if temp in dp:
            if i - dp[temp] < result:
                result = i - dp[temp]
        
        dp[curMod] = i
    
    return result if result < len(nums) else -1"
make sum divisible by p,"class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        s = sum(nums)
        if s % p == 0: return 0 
   

        moddict = {}
        minv = float('inf')
        t = 0 

        moddict[0] = 0 
        cnt = 1
        for num in nums:
            t = (t + num) % p 
            if (t-s) % p in moddict:
                minv = min(minv, cnt - moddict[(t-s)%p])
            moddict[t] = cnt
            cnt += 1
            
        if minv == float('inf') or minv == len(nums):
            return -1
        else:
            return minv"
strange printer ii,"class Solution:
    def isPrintable(self, targetGrid: List[List[int]]) -> bool:
        visited = [0] * 61
        graph = collections.defaultdict(set)
        m, n = len(targetGrid), len(targetGrid[0])
        for c in range(1, 61):
            l,r,t,b = n,-1,m,-1
			#to specify the covered range of color c
            for i in range(m):
                for j in range(n):
                    if targetGrid[i][j] == c:
                        l = min(l, j)
                        r = max(r, j)
                        t = min(t, i)
                        b = max(b, i)
			#to find the contained colors
            for i in range(t, b + 1):
                for j in range(l, r + 1):
                    if targetGrid[i][j] != c:
                        graph[targetGrid[i][j]].add(c)
        
		# to find if there is a cycle 
        def dfs(graph,i):
            if visited[i] == -1:
                return False
            if visited[i] == 1:
                return True 
            visited[i] = -1
            for j in graph[i]:
                if not dfs(graph,j):
                    return False
            visited[i] = 1
            return True
        
        for c in range(61):
            if not dfs(graph,c):
                return False
        return True"
strange printer ii,"class Solution(object):
    def isPrintable(self, targetGrid):
        """"""
        :type targetGrid: List[List[int]]
        :rtype: bool
        """"""
#doing reverse engineering like toposort concept find that reactangle which is completely independent,and remove and process futher
        m,n=len(targetGrid),len(targetGrid[0])
        # strore upper,left,right,bottom most for every color
        colors={}
        for i in range(m):
            for j in range(n):
                c=targetGrid[i][j]
                if c not in colors:
                    colors[c]=[sys.maxsize,sys.maxsize,-1*sys.maxsize,-1*sys.maxsize]
                colors[c][0]=min(colors[c][0],i)
                colors[c][1]=min(colors[c][1],j)
                colors[c][2]=max(colors[c][2],j)
                colors[c][3]=max(colors[c][3],i)
        # print(colors)
        # this is for check is it possible to fill with this color or not
        def isPossibleTofill(color):
            upper,left,right,bottom=colors[color]
            for i in range(upper,bottom+1):
                for j in range(left,right+1):
                    if targetGrid[i][j]>0 and targetGrid[i][j]!=color:return False
            for i in range(upper,bottom+1):
                for j in range(left,right+1):
                    targetGrid[i][j]=0
            return True
                                 
        c1=colors.keys()
        while c1:
            c2=set()
            for col in c1:
                if isPossibleTofill(col)==False:
                    c2.add(col)
            if len(c2)==len(c1):return False
            c1=c2
        if len(c1)==0:return True
        return False"
rearrange spaces between words,"class Solution(object):
    def reorderSpaces(self, text):
        word_list = text.split()
        words, spaces = len(word_list), text.count("" "")
        
        if words > 1:
            q, r = spaces//(words-1), spaces%(words-1)
            return ("" "" * q).join(word_list) + "" "" * r
        else:
            return """".join(word_list) + "" "" * spaces"
rearrange spaces between words,"class Solution(object):
    def reorderSpaces(self, text):
        word_list = text.split()
        words, spaces = len(word_list), text.count("" "")
        
        if words > 1:
            q, r = spaces//(words-1), spaces%(words-1)
        else:
            q, r = 0, spaces
        
        return ("" "" * q).join(word_list) + "" "" * r"
split a string into the max number of unique substrings,"class Solution:
    def maxUniqueSplit(self, s: str) -> int:
        ans, n = 0, len(s)
        def dfs(i, cnt, visited):
            nonlocal ans, n
            if i == n: ans = max(ans, cnt); return  # stop condition
            for j in range(i+1, n+1):    
                if s[i:j] in visited: continue      # avoid re-visit/duplicates
                visited.add(s[i:j])                 # update visited set
                dfs(j, cnt+1, visited)              # backtracking
                visited.remove(s[i:j])              # recover visited set for next possibility
        dfs(0, 0, set())                            # function call
        return ans"
split a string into the max number of unique substrings,"class Solution:
    def maxUniqueSplit(self, s: str) -> int:
        
        def fn(i):
            """"""Find max length via backtracking.""""""
            nonlocal ans 
            if i == len(s): return (ans := max(ans, len(tabu)))
            for ii in range(i+1, len(s)+1): 
                if s[i:ii] not in tabu: 
                    tabu.add(s[i:ii])
                    fn(ii)
                    tabu.remove(s[i:ii])
            
        ans = 1
        tabu = set()
        fn(0)
        return ans"
maximum non negative product in a matrix,"class Solution:
    def maxProductPath(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        
        @lru_cache(None)
        def fn(i, j): 
            """"""Return maximum &amp; minimum products ending at (i, j).""""""
            if i == 0 and j == 0: return grid[0][0], grid[0][0]
            if i < 0 or j < 0: return -inf, inf
            if grid[i][j] == 0: return 0, 0
            mx1, mn1 = fn(i-1, j) # from top
            mx2, mn2 = fn(i, j-1) # from left 
            mx, mn = max(mx1, mx2)*grid[i][j], min(mn1, mn2)*grid[i][j]
            return (mx, mn) if grid[i][j] > 0 else (mn, mx)
        
        mx, _ = fn(m-1, n-1)
        return -1 if mx < 0 else mx % 1_000_000_007"
maximum non negative product in a matrix,"class Solution:
    def maxProductPath(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        grid[0][0] = grid[0][0], grid[0][0]                                      # (small, large) for starting point
        for j in range(1, n):
            grid[0][j] = grid[0][j-1][0]*grid[0][j], grid[0][j-1][1]*grid[0][j]  # special handling first row
        for i in range(1, m):
            grid[i][0] = grid[i-1][0][0]*grid[i][0], grid[i-1][0][1]*grid[i][0]  # special handling first col
        for i in range(1, m):
            for j in range(1, n):
                nums = [grid[i-1][j][0]*grid[i][j], grid[i][j-1][0]*grid[i][j], grid[i-1][j][1]*grid[i][j], grid[i][j-1][1]*grid[i][j]]
                small, large = min(nums), max(nums)
                grid[i][j] = (small, large)                                      # update all other points
        return (grid[-1][-1][1] % 1000000007) if grid[-1][-1][1] >= 0 else -1"
minimum cost to connect two groups of points,"class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        mn = [min(x) for x in zip(*cost)] # min cost of connecting points in 2nd group 
        
        @lru_cache(None)
        def fn(i, mask):
            """"""Return min cost of connecting group1[i:] and group2 represented as mask.""""""
            if i == m: return sum(mn[j] for j in range(n) if not (mask &amp; (1<<j)))
            return min(cost[i][j] + fn(i+1, mask | 1<<j) for j in range(n))
                
        return fn(0, 0)"
minimum cost to connect two groups of points,"class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        mn = [min(x) for x in cost] # min cost of connecting points in 1st group 
        
        @lru_cache(None)
        def fn(j, mask):
            """"""Return min cost of connecting group1[i:] and group2 represented as mask.""""""
            if j == n: return sum(mn[i] for i in range(m) if not (mask &amp; (1<<i)))
            return min(cost[i][j] + fn(j+1, mask | 1<<i) for i in range(m))
                
        return fn(0, 0)"
crawler log folder,"class Solution:
    def minOperations(self, logs: List[str]) -> int:
        ans = 0
        for log in logs: 
            if log == ""./"": continue
            elif log == ""../"": ans = max(0, ans-1) # parent directory
            else: ans += 1 # child directory 
        return ans"
crawler log folder,"class Solution:
    def minOperations(self, logs: List[str]) -> int:
        res = 0
        
        for i in logs:
            if i == '../' and res > 0:
                res -= 1
            elif i != './' and i != '../':
                res += 1
                
        return res"
maximum profit of operating a centennial wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        ans = -1
        most = pnl = waiting = 0
        for i, x in enumerate(customers): 
            waiting += x # more people waiting in line 
            waiting -= (chg := min(4, waiting)) # boarding 
            pnl += chg * boardingCost - runningCost 
            if most < pnl: ans, most = i+1, pnl
        q, r = divmod(waiting, 4)
        if 4*boardingCost > runningCost: ans += q
        if r*boardingCost > runningCost: ans += 1
        return ans"
maximum profit of operating a centennial wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        
         
        n=len(customers)
        dp=[]
        reserved=0
        on_board=0
        rotation=0
        for i in range(n):
            if reserved!=0:
                if reserved>=4:
                    on_board+=4
                    reserved += customers[i]-4
                else:
                    new_customers=4-reserved
                    if customers[i]>=new_customers:
                        on_board+=4
                        reserved=customers[i]-new_customers
                    else:
                        on_board+=reserved+customers[i]
                        reserved=0
            else:
                if customers[i]>=4:
                    on_board+=4
                    reserved+=customers[i]-4
                else:
                    on_board+=customers[i]
            rotation+=1
            
            dp.append(on_board*boardingCost - rotation*runningCost)
        
        for i in range(reserved//4 + 1):
            if reserved>=4:
                on_board+=4
                reserved-=4
            else:
                on_board+=reserved
                reserved=0
            rotation+=1
            dp.append(on_board*boardingCost - rotation*runningCost)
        
        maxim=max(dp)
        return dp.index(maxim)+1 if maxim>=0 else -1"
maximum number of achievable transfer requests,"class Solution:
    def maximumRequests(self, n: int, req: List[List[int]]) -> int:
        tot = len(req)
        for i in range(tot, 0, -1):
            comb = list(itertools.combinations([j for j in range(tot)], i))
            for c in comb:
                net = [0 for j in range(n)]
                for idx in c:
                    net[req[idx][0]] -= 1
                    net[req[idx][1]] += 1
                if net == [0 for j in range(n)]:
                    return i
        return 0"
maximum number of achievable transfer requests,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        
        def fn(k, mask): 
            """"""Return maximum number of achievable transfer requests.""""""
            if k == len(requests): 
                net = [0]*n
                for i, (u, v) in enumerate(requests): 
                    if mask &amp; 1 << i: 
                        net[u] -= 1
                        net[v] += 1
                return 0 if any(net) else bin(mask).count(""1"")
            return max(fn(k+1, mask), fn(k+1, mask | 1 << k))
        
        return fn(0, 0)"
alert using same key card three or more times in a one hour period,"class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        key_time = {}
        for index, name in enumerate(keyName):
            key_time[name] = key_time.get(name, [])
            key_time[name].append(int(keyTime[index].replace("":"", """")))
        ans = []
        for name, time_list in key_time.items():
            time_list.sort()
            n = len(time_list)
            for i in range(n-2):
                if time_list[i+2] - time_list[i] <= 100:
                    ans.append(name)
                    break
        return sorted(ans)"
alert using same key card three or more times in a one hour period,"class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        mapp = {}
        for i in range(len(keyName)):
            name = keyName[i]
            if(name not in mapp):
                mapp[name] = [keyTime[i]]
            else:
                mapp[name].append(keyTime[i])
        res = []
        for name, arr in mapp.items():
            arr.sort()
            for i in range(len(arr)-2):
                time= arr[i]
                t2 = arr[i+1]
                t3 = arr[i+2]
                if(time[0:2]==""23""):
                    endTime = ""24:00""
                    if(t2<=endTime and t3<=endTime and t2>time and t3>time):
                        res.append(name)
                        break
                else:
                    start = int(time[0:2])
                    endTime = str(start+1)+time[2:]
                    if(start<9):
                        endTime = ""0""+endTime
                    if(t2<=endTime and t3<=endTime):
                        res.append(name)
                        break
                
        return sorted(res)"
find valid matrix given row and column sums,"class Solution:
    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        def backtrack(y, x):
            choice = min(rowSum[y], colSum[x])
            result[y][x] = choice
            rowSum[y] -= choice
            colSum[x] -= choice
            if y == 0 and x == 0:
                return

            elif not rowSum[y]:
                backtrack(y - 1, x)
            elif not colSum[x]:
                backtrack(y, x - 1)

        Y, X = len(rowSum), len(colSum)
        result = [[0 for _ in range(X)] for _ in range(Y)]
        backtrack(Y-1, X-1)
        return result"
find valid matrix given row and column sums,"class Solution:
    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        n,m=len(rowSum),len(colSum)
        matrix = [[0 for i in range(m)] for j in range(n)]
        total = 0
        for i in range(n):
            matrix[i][0] = rowSum[i]
            total += rowSum[i]
        for c in range(m):
            if total == colSum[c]:
                break
            else:
                nextTotal = total - colSum[c]
                total = nextTotal
                for r in range(n):
                    curr = min(matrix[r][c],total)
                    matrix[r][c] -= curr
                    total -= curr
                    if c+1 < m:
                        matrix[r][c+1] = curr
                total = nextTotal
        return matrix"
find servers that handled most number of requests,"class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        busy = [] # min-heap
        free = list(range(k)) # min-heap 
        freq = [0]*k
        
        for i, (ta, tl) in enumerate(zip(arrival, load)): 
            while busy and busy[0][0] <= ta: 
                _, ii = heappop(busy)
                heappush(free, i + (ii - i) % k) # circularly relocate it
            if free: 
                ii = heappop(free) % k 
                freq[ii] += 1
                heappush(busy, (ta+tl, ii))
        
        mx = max(freq)
        return [i for i, x in enumerate(freq) if x == mx]"
special array with x elements greater than or equal x,"class Solution:
    def specialArray(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)

        if n<=nums[0]:
            return n
        
        for i in range(1,n):
            count = n-i       #counts number of elements in nums greater than equal i
            if nums[i]>=(count) and (count)>nums[i-1]:
                return count 
        return -1"
special array with x elements greater than or equal x,"class Solution:
    def specialArray(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)

        if n<=nums[0]:
            return n
        
        #binary search
        start,end = 0,n
                
        while(start<=end):
            mid = (start+end)//2
            #index of middle element
            count = 0
            for i in range(0,n):
                if nums[i]>=mid:
                    count = n-i
                    #count+=1 could use this but will take more iterations then.
                    break
        
            if count==mid:
                return count
            elif count<mid:
                end = mid-1
            else:
                start=mid+1            
        
        return -1"
even odd tree,"class Solution:
    def isEvenOddTree(self, root: TreeNode) -> bool:
        even = 1 # even level 
        queue = deque([root])
        while queue: 
            newq = []
            prev = -inf if even else inf
            for _ in range(len(queue)): 
                node = queue.popleft()
                if even and (node.val&amp;1 == 0 or prev >= node.val) or not even and (node.val&amp;1 or prev <= node.val): return False 
                prev = node.val 
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            even ^= 1
        return True"
even odd tree,"class Solution:
		def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
			if root is None:
				return False

			level_order = self.level_order(root)

			# check level 0
			if level_order[0][0] % 2 == 0:
				return False

			# check level 1 ~ end
			for i, level in enumerate(level_order[1:], 2):
				if i % 2 == 0:
					# even and decreasing order
					previous_element = level[0]
					if previous_element % 2 != 0:
						return False

					for element in level[1:]:
						if element % 2 != 0 or previous_element < element:
							return False
						previous_element = element

				else:
					# odd and increasing order
					previous_element = level[0]
					if previous_element % 2 == 0:
						return False

					for element in level[1:]:
						if element % 2 == 0 or element < previous_element:
							return False
						previous_element = level

			return True

		def level_order(self, root: Optional[TreeNode]) -> List[List[int]]:
				queue = [root]
				level_order = []
				while queue:
					size = len(queue)
					level = []
					for _ in range(size):
						node = queue.pop(0)

						if node.left:
							queue.append(node.left)

						if node.right:
							queue.append(node.right)

						level.append(node.val)

					level_order.append(level)

				return level_order"
maximum number of visible points,"class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:
        
        array = []
        nloc = 0
        for p in points:
            if p == l:
                nloc += 1
            else:
                array.append(math.degrees(atan2(p[1]-l[1], p[0]-l[0])))
        array.sort()
        angles = array + [a+360 for a in array]
        left, maxm = 0, 0
        for right, a in enumerate(angles):
            if a-angles[left] > angle:
                left += 1
            maxm = max(right-left+1, maxm)
        
        return maxm + nloc"
minimum one bit operations to make integers zero,"class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        """"""
        to flip the bits to turn the number to zero
        
        Interpretation of Rules:
        - recursive:
            to turn a leading one of i bits to zero, the only way is to turn the i-1 bits to a leading one pattern
            and to turn the i-1 bits leading zero to zero, the only way is to turn the i-2 bits to a leading one pattern
            and so on, which is a recursive process
            
            (10000.. -> 11000.. -> 01000..), (01000.. -> 01100.. -> 00100), ..., (..010 -> ..011 -> ..001 -> ..000)
            
        - reversable:
        
            Let's make some observations to check if there's any pattern:

            - 2: 10 -> 11 -> 01 -> 00
            - 4: 100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000
            - 8: 1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 1100 -> 0100 -> (reversing 100 to 000) -> 0000
            ...
            
            based on the observation, turning every i bits leading one to zero, is turning the i-1 bits from 00.. to 10..
            and then back to 00.., which is a reverable process, and with the recursive process we can conclude that
            turning any length of 00..M-> 10.. is a reversable process
        
        - all unique states:
            since it is recursive and reversable, and we are flipping every bit between 1 and 0 programtically 10.. <-> 00..
            we can conclude that every intermediate state in a process is unique (2**i unique states, so we need 2**i - 1 steps)
        
                for i bits 10.. <-> 00.. - numer of operations f(i) = 2**i - 1
            
            this also aligns with the observation above that f(i) = 2*f(i-1) - 1 (-1 for no operation needed to achieve the initial 000)
        
        Process:
        to turn any binary to 0, we can turning the 1s to 0s one by one from lower bit to higher bit
        and because turning a higher bit 1 to 0, would passing the unique state including the lower bit 1s
        we can reverse those operations needed for the higher bit 100.. to the unique state including the lower bit 1s
        
        e.g. turning 1010100 to 0
        - 1010(100) -> 1010(000), we will need 2**3 - 1 operations
        - 10(10000) -> 10(00000), we will need (2**5 - 1) - (2**3 - 1) operations
        we will be passing the state 10(10100), which is ready available from the last state
        so we can save/reverse/deduct the operations needed for 1010(000) <-> 1010(100)
        - ...
        
            so for any binary, f(binary) would tell us how many operations we need for binary <-> 000..
            and for any more 1s, 100{binary} we can regard it as a process of 100.. <-> 100{binary} <-> 000{000..}
            which is 100.. <-> 000.. (2**i - 1) saving the operations 100{000..} <-> 100{binary} (f(binary))
            = (2**i - 1) - f(last_binary)
            
        """"""
        binary = format(n, ""b"")

        N, res = len(binary), 0
        
        for i in range(1, N+1):
            if binary[-i] == ""1"": res = 2**i-1 - res
                
        return res"
minimum one bit operations to make integers zero,"class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        x = '{0:b}'.format(n)
        y = list(x)
        r = 0
        s = True
        for k in range(len(y)):
            if x[k]=='1' and s:
                r+=(2**(len(y)-k))-1
                s=False
            elif x[k]=='1':
                r-=(2**(len(y)-k))-1
                s=True
        return r"
maximum nesting depth of the parentheses,"class Solution:
    def maxDepth(self, s: str) -> int:
        depths = [0]
        
        count = 0
        for i in s:
            if(i == '('):
                count += 1
            elif(i == ')'):
                count -= 1
            depths.append(count)
        
        return max(depths)"
maximum nesting depth of the parentheses,"class Solution:
    def maxDepth(self, s: str) -> int:
        r = cnt = 0
        for c in s:
            if c == "")"":
                if cnt:
                    cnt -= 1
                    r = max(r, cnt + 1)
            elif c == ""("":
                cnt += 1
                
        return r"
maximal network rank,"class Solution:
    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:
        graph = {}
        for u, v in roads:
            graph.setdefault(u, set()).add(v)
            graph.setdefault(v, set()).add(u)
        
        ans = 0
        for i in range(n): 
            for j in range(i+1, n):
                val = len(graph.get(i, set())) + len(graph.get(j, set())) - (j in graph.get(i, set()))
                ans = max(ans, val)
        return ans"
maximal network rank,"class Solution:
	def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:
		if roads == []: #egde case check
			return 0

		node_degrees = defaultdict(int)
		for i in roads:
			node_degrees[i[0]]+=1
			node_degrees[i[1]]+=1

		maxx1, maxx2 = 0, 0
		ans = 0
		for i, k in node_degrees.items():      #O(N)
			if k >= maxx1:
				maxx1 = k
				maxx2 = 0
				for j, l in node_degrees.items():       #O(N)
					if l >= maxx2 and j!=i:
						maxx2 = l
						if [i, j] in roads or [j, i] in roads:           #O(N)
							ans = max(ans, maxx1 + maxx2 - 1)
						else:
							ans = max(ans, maxx1 + maxx2 )
		return ans"
split two strings to make palindrome,"class Solution:
    def checkPalindromeFormation(self, a: str, b: str) -> bool:
        
        fn = lambda x: x == x[::-1] # check for palindrome 
        
        i = 0
        while i < len(a) and a[i] == b[~i]: i += 1
        if fn(a[:i] + b[i:]) or fn(a[:-i] + b[-i:]): return True 
        
        i = 0
        while i < len(a) and a[~i] == b[i]: i += 1
        if fn(b[:i] + a[i:]) or fn(b[:-i] + a[-i:]): return True 
        
        return False"
split two strings to make palindrome,"class Solution:
    def checkPalindromeFormation(self, a: str, b: str) -> bool:
        return self.solve(a, b) or self.solve(b, a)
    
    def solve(self, a, b):
        i = 0
        j = len(a) - 1
        while i < j and a[i] == b[j]:
            i += 1
            j -= 1
        
        return self.isPalindrome(a[:i] + b[i:]) or self.isPalindrome(a[:j + 1] + b[j + 1:])
        
    
    def isPalindrome(self, s):
        i = 0
        j = len(s) - 1
        
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True"
count subtrees with max distance between cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        # Create Tree as adjacency list
        neigh: List[List[int]] = [[] for _ in range(n)]
        for u, v in edges:
            neigh[u - 1].append(v - 1)
            neigh[v - 1].append(u - 1)

        distance_array: List[int] = [0] * n

        def find_tree_center(vertices: List[int], adj_list: List[List[int]]) -> int:
            """"""Given a tree, return a central vertex (minimum radius vertex) with BFS""""""

            num_neighbors: List[int] = list(map(len, adj_list))
            leaf_nodes: Deque[int] = collections.deque((x for x in range(len(vertices)) if num_neighbors[x] == 1))
            while len(leaf_nodes) > 1:
                leaf = leaf_nodes.popleft()
                for neighbor in adj_list[leaf]:
                    num_neighbors[neighbor] -= 1
                    if num_neighbors[neighbor] == 1:
                        leaf_nodes.append(neighbor)
            return leaf_nodes[0]

        def merge_into_parent(parent_subtrees: Dict[Tuple[int, int], int],
                              child_subtrees: Dict[Tuple[int, int], int]) -> None:

            """""" Helper function to merge two disjoint rooted trees T_parent and T_child rooted at 'parent' and 'child',
               into one tree rooted at 'parent', by adding an edge from 'parent' to 'child'.
               Called once for each edge in our tree. parent_subtrees[i, j] is the count of rooted subtrees
               of T_parent that contain 'parent', have diameter i, and height j.
               Worst case complexity: O(n^4) per call
            """"""

            for (diam_for_parent, height_for_parent), count_from_parent in list(parent_subtrees.items()):

                for (diam_for_child, height_for_child), count_from_child in child_subtrees.items():

                    new_diameter = max(diam_for_parent, diam_for_child, height_for_parent + height_for_child + 1)
                    new_height = max(height_for_parent, height_for_child + 1)
                    parent_subtrees[new_diameter, new_height] = parent_subtrees.get((new_diameter, new_height), 0) + count_from_child * count_from_parent

            return None

        def compute_subtree_counts(current_vertex: int,
                                   last_vertex: int = -1) -> Dict[Tuple[int, int], int]:
            """"""Recursively counts subtrees rooted at current_vertex using DFS,
            with edge from current_vertex to 'last_vertex' (parent node) cut off""""""
            subtree_counts: Dict[Tuple[int, int], int] = {(0, 0): 1}

            for child_vertex in neigh[current_vertex]:
                if child_vertex == last_vertex:
                    continue

                merge_into_parent(parent_subtrees=subtree_counts,
                                  child_subtrees=compute_subtree_counts(current_vertex=child_vertex,
                                                                        last_vertex=current_vertex))

            for (diameter, height), subtree_count in subtree_counts.items():
                distance_array[diameter] += subtree_count

            return subtree_counts

        # Optimization: Use a max-degree vertex as our root to minimize recursion depth
        max_degree_vertex: int = find_tree_center(vertices=list(range(n)),
                                                  adj_list=neigh)

        compute_subtree_counts(current_vertex=max_degree_vertex)

        return distance_array[1:]"
count subtrees with max distance between cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        
        def fn(edges): 
            """""" """"""
            graph = {} # graph as adjacency list 
            for u, v in edges:
                graph.setdefault(u-1, []).append(v-1) # 0-indexed 
                graph.setdefault(v-1, []).append(u-1)
            group = [None]*n
            dist = [0]*n
            
            def dfs(x, d=0): 
                """""" """"""
                seen.add(x) # mark visited 
                for xx in graph.get(x, []): 
                    dist[x] = max(dist[x], d)
                    if group[xx] is None: group[xx] = group[x]
                    if xx not in seen: dfs(xx, d+1)
                
            for i in range(n): 
                seen = set()
                if group[i] is None: group[i] = i
                dfs(i)
            return group, dist 
        
        ans = {} # answer 
        for r in range(1, len(edges)+1):
            for x in combinations(edges, r): 
                temp = {}
                d = {}
                seen, dist = fn(x)
                for i in range(n): 
                    temp.setdefault(seen[i], []).append(i)
                    if seen[i] not in d: d[seen[i]] = dist[i]
                    else: d[seen[i]] = max(d[seen[i]], dist[i])
                for k, v in temp.items(): 
                    if len(v) > 1: 
                        ans.setdefault(d[k], set()).add(tuple(sorted(v)))
        return [len(ans.get(x, set())) for x in range(1, n)]"
mean of array after removing some elements,"class Solution:
    def trimMean(self, arr: List[int]) -> float:
        arr.sort()

        return statistics.mean(arr[int(len(arr)*5/100):len(arr)-int(len(arr)*5/100)])"
mean of array after removing some elements,"class Solution:
    def trimMean(self, arr: List[int]) -> float:
        arr.sort()
        
        n = len(arr)
        per = int(n*5/100)
        l2 = arr[per:len(arr)-per]
		
        x = sum(l2)/len(l2)

        return x"
coordinate with maximum network quality,"class Solution:
    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:
        mx = -inf
        for x in range(51):
            for y in range(51): 
                val = 0
                for xi, yi, qi in towers: 
                    d = sqrt((x-xi)**2 + (y-yi)**2)
                    if d <= radius: val += int(qi/(1 + d))
                if val > mx: 
                    ans = [x, y]
                    mx = val
        return ans"
coordinate with maximum network quality,"class Solution:
    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:
        return max(
            (
                (sum(qi // (1 + dist) for xi, yi, qi in towers if (dist := sqrt((xi - x) ** 2 + (yi - y) ** 2)) <= radius),
                 [x, y]) for x in range(51) for y in range(51)
            ),
            key=lambda x: (x[0], -x[1][0], -x[1][1])
        )[1]"
number of sets of k non overlapping line segments,"class Solution:
    def numberOfSets(self, n: int, k: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return number of sets.""""""
            if n <= k: return 0 
            if k == 0: return 1
            return 2*fn(n-1, k) + fn(n-1, k-1) - fn(n-2, k)
        
        return fn(n, k) % 1_000_000_007"
largest substring between two equal characters,"class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        ans = -1
        seen = {}
        for i, c in enumerate(s): 
            if c in seen: ans = max(ans, i - seen[c] - 1)
            seen.setdefault(c, i)
        return ans"
largest substring between two equal characters,"class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        ans = [-1]
        
        for i in set(s):
            if(s.count(i) >= 2):
                ans.append(s.rindex(i) - s.index(i) - 1 )
        
        return max(ans)"
lexicographically smallest string after applying operations,"class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        op1 = lambda s: """".join(str((int(c)+a)%10) if i&amp;1 else c for i, c in enumerate(s))
        op2 = lambda s: s[-b:] + s[:-b]
        
        seen = set()
        stack = [s]
        while stack: 
            s = stack.pop()
            seen.add(s)
            if (ss := op1(s)) not in seen: stack.append(ss)
            if (ss := op2(s)) not in seen: stack.append(ss)
        return min(seen)"
lexicographically smallest string after applying operations,"class Solution:
    def __init__(self):
        self.smallest = float(""inf"")
        self.seen = {}
    
    def rotate(self, s, b):
        s = [char for char in s]
        def reverse_segment(start, end):
            end -= 1
            while start < end:
                s[start], s[end] = s[end], s[start]
                start += 1
                end -= 1
        rotations = b % len(s)
        reverse_segment(0, len(s))
        reverse_segment(0, rotations)
        reverse_segment(rotations, len(s))
        return """".join(s) 
    
    def add_one(self, char, a):
        return str((int(char)+a) % 10)
    
    def add(self, s, a):
        s = [char for char in s]
        for idx in range(len(s)):
            if idx % 2 != 0:
                s[idx] = self.add_one(s[idx], a)
        return """".join(s)
    
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        if self.smallest == float(""inf""):
            self.smallest = s        
        if int(s) < int(self.smallest):
            self.smallest = s
        if s in self.seen:
            return
        self.seen[s] = True
        self.findLexSmallestString(self.rotate(s,b), a, b)
        self.findLexSmallestString(self.add(s,a), a, b)
        return self.smallest"
best team with no conflicts,"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        '''
        Using example scores = [1,2,3,5] and ages = [8,9,10,1]
        
        data is   [(1, 5), (8, 1), (9, 2), (10, 3)]
        and dp is [5, 1, 2, 3]
        
        when curr player is (1, 5)
            there are no prev players -> so leave dp of curr as-is
            
        when curr player is (8, 1)
            prev player's score is not less than curr player score
            nor is previous player's age same as curr player age -> so leave dp of curr as-is
        
        when curr player is (9, 2)
            prev player (1, 5) has score NOT less than, and age NOT equal to ... skipping
            prev player (8, 1) has score YES less than ... so we do something!
                since the accumulated dp of prev player + curr's score is GREATER than curr's accumulated dp value:
                    we update curr's accumulated dp value to be instead sum of prev player's dp value and curr's score
                    
        when curr player is (10, 3)
            prev player (1, 5) has score NOT less, and age NTO equal to ... skipping
            prev player (8, 1) has score YES less, so update curr's dp value from 3 -> 3+1 = 4
            prev player (9, 2) has score YES less, so update curr's dp value from 4 -> 4+2 = 6
            
        finally we return the max of all dp values for the dream team.
        '''
        # Sort by age and score ASC
        data = sorted(zip(ages, scores), key=lambda x:(x[0], x[1]))
        # Initialize dp with scores for each player
        dp = [score for age, score in data]
        N = len(data)
        
        # For every current player
        for curr in range(N):
            # Compare every previous player
            for prev in range(0, curr):
                # And if previous player score is less OR previous player is same age
                if (data[prev][1] <= data[curr][1] or data[curr][0] == data[prev][0]):
                    # Then update dp value for current player to be the max of either
                    #  -> the current score as it is OR
                    #  -> the current score PLUS the dp value of previous player
                    dp[curr] = max(dp[curr], data[curr][1] + dp[prev])

        return max(dp)"
best team with no conflicts,"class Solution:
    def bestTeamScore(self, scores, ages):
        ans = sorted(zip(ages,scores))
        dp = [i[1] for i in ans]

        for i in range(1,len(ans)):
            for j in range(i):
                if ans[i][1] >= ans[j][1]:
                    dp[i] = max(dp[i],dp[j]+ans[i][1])

        return max(dp)"
slowest key,"class Solution:
    def slowestKey(self, r: List[int], k: str) -> str:
        times = {r[0]: [k[0]]}
        
        for i in range(1 , len(r)):
            t = r[i] - r[i - 1]
            if(t in times):
                times[t].append(k[i])
            else:
                times[t] = [k[i]]
        
        keys = times[max(times.keys())]
        
        return max(keys)"
slowest key,"class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        for i in range(len(releaseTimes)-1, 0, -1):
            releaseTimes[i] = releaseTimes[i] - releaseTimes[i-1]
        return max(zip(releaseTimes,list(keysPressed)))[1]"
arithmetic subarrays,"class Solution:
    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
        ans = []
        
        def find_diffs(arr):
            
            arr.sort()

            dif = []
            
            for i in range(len(arr) - 1):
                dif.append(arr[i] - arr[i + 1])
            
            return len(set(dif)) == 1
        
        for i , j in zip(l , r):
            ans.append(find_diffs(nums[i:j + 1]))
        
        return ans"
arithmetic subarrays,"class Solution:
    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
        out=[]
        for i, j in zip(l, r):
            out.append(self.canMakeArithmeticProgression(nums[i:j+1]))
        return out
        
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        minArr = min(arr)
        maxArr = max(arr)
		
		# if difference between minArr and maxArr cannot be divided into equal differences, then return false
        if (maxArr-minArr)%(len(arr)-1)!=0:
            return False
			
		# consecutive difference in arithmetic progression
        diff = int((maxArr-minArr)/(len(arr)-1))
        if diff == 0:
            if arr != [arr[0]]*len(arr):
                return False
            return True
		
		# array to check all numbers in A.P. are present in input array.
		# A.P.[minArr, minArr+d, minArr+2d, . . . . . . . maxArr]
        check = [1]*len(arr)
        for num in arr:
            if (num-minArr)%diff != 0:
                return False
            check[(num-minArr)//diff]=0
		
		# if 1 is still in check array it means at least one number from A.P. is missing from input array.
        if 1 in check:
            return False
        return True"
path with minimum effort,"class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        
        queue = {(0, 0): 0} # (0, 0) maximum height so far 
        seen = {(0, 0): 0} # (i, j) -> heights 
        ans = inf 
        
        while queue: 
            newq = {} # new dictionary 
            for (i, j), h in queue.items(): 
                if i == m-1 and j == n-1: ans = min(ans, h)
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                    if 0 <= ii < m and 0 <= jj < n: 
                        hh = max(h, abs(heights[i][j] - heights[ii][jj]))
                        if hh < seen.get((ii, jj), inf): 
                            seen[(ii, jj)] = hh 
                            newq[(ii, jj)] = hh
            queue = newq 
        return ans"
path with minimum effort,"class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0]) # dimensions 
        seen = {(0, 0): 0}
        pq = [(0, 0, 0)]
        while pq: 
            h, i, j = heappop(pq)
            if i == m-1 and j == n-1: return h
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 <= ii < m and 0 <= jj < n: 
                    hh = max(h, abs(heights[ii][jj] - heights[i][j]))
                    if (ii, jj) not in seen or hh < seen[ii, jj]: 
                        heappush(pq, (hh, ii, jj))
                        seen[ii, jj] = hh"
rank transform of a matrix,"class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0]) # dimension 
        # mapping from value to index 
        mp = {} 
        for i in range(m):
            for j in range(n): 
                mp.setdefault(matrix[i][j], []).append((i, j))
        
        def find(p):
            """"""Find root of p.""""""
            if p != parent[p]:
                parent[p] = find(parent[p])
            return parent[p]
        
        rank = [0]*(m+n)
        ans = [[0]*n for _ in range(m)]
        
        for k in sorted(mp): # from minimum to maximum 
            parent = list(range(m+n))
            for i, j in mp[k]: 
                ii, jj = find(i), find(m+j) # find 
                parent[ii] = jj # union 
                rank[jj] = max(rank[ii], rank[jj]) # max rank 
            
            seen = set()
            for i, j in mp[k]:
                ii = find(i)
                if ii not in seen: rank[ii] += 1
                seen.add(ii)
                rank[i] = rank[m+j] = ans[i][j] = rank[ii]
        return ans"
rank transform of a matrix,"class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])
        
        def find_root(x: int, y: int):
            if parent[x][y] == (x, y):
                return (x, y)
            else:
                r = find_root(parent[x][y][0], parent[x][y][1])
                parent[x][y] = r
                return r
        
        def union(x1, y1, x2, y2):
            root_a = find_root(x1, y1)
            root_b = find_root(x2, y2)
            parent[root_b[0]][root_b[1]] = root_a
            
        ########################################################
        
		# *parent* records the parent of each point in matrix form
		# points with same value in the same row/column should have the same parent
        parent = [[(j, i) for i in range(n)] for j in range(m)]
        
		# sort each row, if there are points with same value, union them
        for i in range(m):
            value = []
            for j in range(n):
                v = tuple([matrix[i][j], i, j])
                value.append(v)
            value.sort()
            for k in range(n - 1):
                if value[k][0] == value[k + 1][0]:
                    union(value[k][1], value[k][2], value[k + 1][1], value[k + 1][2])
					
        # sort each column, if there are points with same value, union them            
        for i in range(n):
            value = []
            for j in range(m):
                v = tuple([matrix[j][i], j, i])
                value.append(v)
            value.sort()
            for k in range(m - 1):
                if value[k][0] == value[k + 1][0]:
                    union(value[k][1], value[k][2], value[k + 1][1], value[k + 1][2])
        
        ########################################################
        
        dic = {} # point index : point that it directs ->
        in_degree = {} # point index : number of incoming arrows <-
		
		# Ex. [20, -21, 14]
		# sort: -21 (0, 1) -> 14 (0, 2) -> 20 (0, 0)
		# dic = { (0, 0) : [], (0, 1) : [(0, 2)], (0, 2) : [(0, 0)] }
		# in_degree = { (0, 0) : 1, (0, 1) : 0, (0, 2) : 1 }
		
		# only select ""root"" points that parent[point] = point itself
        for i in range(m):
            for j in range(n):
                if parent[i][j] == (i, j):
                    dic[(i, j)] = []
                    in_degree[(i, j)] = 0
                    
		# if there are points that parent[point] = its parent but not the ""root"" ancestor
		# make parent[point] = the ""root"" ancestor
		
		# Ex. before: parent[4][4] = (4, 4), parent[8][0] = (4, 4), parent[8][4] = (8, 0)
		# after: parent[4][4] = (4, 4), parent[8][0] = (4, 4), parent[8][4] = (4, 4)
		
        for i in range(m):
            for j in range(n):
                while parent[i][j] not in dic:
                    parent[i][j] = parent[parent[i][j][0]][parent[i][j][1]]
        
		# continue to construct *dic* and *in_degree*
		# make connections in each row
        for i in range(m):
            row = []
            for j in range(n):
                r = tuple([matrix[i][j], parent[i][j][0], parent[i][j][1]])
                row.append(r)
            row.sort()
            for k in range(n - 1):
                if row[k][0] < row[k + 1][0]:
                    if (row[k][1], row[k][2]) in dic and (row[k + 1][1], row[k + 1][2]) in dic:
                        if (row[k + 1][1], row[k + 1][2]) not in dic[(row[k][1], row[k][2])]:
                            dic[(row[k][1], row[k][2])].append((row[k + 1][1], row[k + 1][2]))
                            in_degree[(row[k + 1][1], row[k + 1][2])] += 1
        
		# and make connections in each column
        for i in range(n):
            col = []
            for j in range(m):
                c = tuple([matrix[j][i], parent[j][i][0], parent[j][i][1]])
                col.append(c)
            col.sort()
            for k in range(m - 1):
                if col[k][0] < col[k + 1][0]:
                    if (col[k][1], col[k][2]) in dic and (col[k + 1][1], col[k + 1][2]) in dic:
                        if (col[k + 1][1], col[k + 1][2]) not in dic[(col[k][1], col[k][2])]:
                            dic[(col[k][1], col[k][2])].append((col[k + 1][1], col[k + 1][2]))
                            in_degree[(col[k + 1][1], col[k + 1][2])] += 1
        
        #######################################################################
        
		# *distance* records the rank of the ""root"" points (just my naming habit)
        distance = {} # point index : rank
        for i in range(m):
            for j in range(n):
                if parent[i][j] == (i, j):
                    distance[(i, j)] = 0
        
		# first put ""root"" points that have 0 in_degree (meaning they are the smallest) in queue
        queue = []
        for i in in_degree:
            if in_degree[i] == 0:
                queue.append(i)
                distance[i] = 1
        
        head = 0
        tail = len(queue) - 1
        while head <= tail:
            h = queue[head]

            for p in dic[h]:
                in_degree[p] -= 1
                if in_degree[p] == 0:
                    queue.append(p)
                    distance[p] = distance[h] + 1

            head += 1
            tail = len(queue) - 1
        
        #######################################################################
        
		# *rank* records the final result in matrix form
        rank = [[0 for i in range(n)] for j in range(m)]
        
		# now we already got the rank of those ""root"" points recorded in *distance*
		# let's put them in *rank*, also their descendants'
        for i in range(m):
            for j in range(n):
                rank[i][j] = distance[parent[i][j]]
        
        return rank"
sort array by increasing frequency,"class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        return sorted(sorted(nums,reverse=1),key=nums.count)"
sort array by increasing frequency,"class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        lst = sorted([(key, freq) for key, freq in Counter(nums).items()],
                     key=lambda tpl: (tpl[1], -tpl[0]))
        ans = []
        for key, freq in lst:
            ans += [key] * freq
        return ans"
widest vertical area between two points containing no points,"class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        l = []
        for i in points:
            l.append(i[0])
        a = 0
        l.sort()
        for i in range(len(l)-1):
            if l[i+1] - l[i] > a:
                a = l[i+1] - l[i]
        return a"
widest vertical area between two points containing no points,"class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        return max([t - s for s, t in zip(sorted([r[0] for r in points]), sorted([r[0] for r in points])[1:])])"
count substrings that differ by one character,"class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        m, n = len(s), len(t) 
        
        @cache
        def fn(i, j, k): 
            """"""Return number of substrings ending at s[i] and t[j] with k=0/1 difference.""""""
            if i < 0 or j < 0: return 0 
            if s[i] == t[j]: return fn(i-1, j-1, k) + (k==0)
            else: return 0 if k == 0 else 1 + fn(i-1, j-1, 0)
        
        return sum(fn(i, j, 1) for i in range(m) for j in range(n))"
count substrings that differ by one character,"class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp0 = [[0]*(n+1) for _ in range(m+1)] # 0-mismatch
        dp1 = [[0]*(n+1) for _ in range(m+1)] # 1-mismatch
        
        ans = 0
        for i in range(m):
            for j in range(n):
                if s[i] == t[j]: 
                    dp0[i+1][j+1] = 1 + dp0[i][j]
                    dp1[i+1][j+1] = dp1[i][j]
                else: 
                    dp0[i+1][j+1] = 0
                    dp1[i+1][j+1] = 1 + dp0[i][j]
                ans += dp1[i+1][j+1]
        return ans"
number of ways to form a target string given a dictionary,"class Solution:
    def numWays(self, words: List[str], target: str) -> int:
        freq = [defaultdict(int) for _ in range(len(words[0]))]
        for word in words: 
            for i, c in enumerate(word): 
                freq[i][c] += 1
        
        @cache
        def fn(i, k): 
            """"""Return number of ways to form target[i:] w/ col k.""""""
            if i == len(target): return 1
            if k == len(words[0]): return 0 
            return freq[k][target[i]]*fn(i+1, k+1) + fn(i, k+1)
        
        return fn(0, 0) % 1_000_000_007"
number of ways to form a target string given a dictionary,"class Solution:
    def numWays(self, words: List[str], target: str) -> int:
        MOD = 10**9+7
        n,m = len(target),len(words[0])
        
        def dfs(i,j):
            if j == n: return 1
            if i == m: return 0
            if n-j > m-i: return 0

            res = 0
            for word in words:
                for k in range(i,m):
                    if word[k] == target[j]:
                        res += dfs(k+1,j+1)

            return res

        return dfs(0,0)%MOD"
check array formation through concatenation,"class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        mp = {x[0]: x for x in pieces}
        i = 0
        while i < len(arr): 
            if (x := arr[i]) not in mp or mp[x] != arr[i:i+len(mp[x])]: return False 
            i += len(mp[x])
        return True"
check array formation through concatenation,"class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        mp = {x[0]: x for x in pieces}
        return sum((mp.get(x, []) for x in arr), []) == arr"
count sorted vowel strings,"class Solution:
    def countVowelStrings(self, n: int) -> int:        
        dp = [[0] * 6 for _ in range(n+1)]
        for i in range(1, 6):
            dp[1][i] = i
        
        for i in range(2, n+1):
            dp[i][1]=1
            for j in range(2, 6):
                dp[i][j] = dp[i][j-1] + dp[i-1][j]
        
        return dp[n][5]"
count sorted vowel strings,"class Solution:
    def countVowelStrings(self, n: int) -> int:        
        dp = [1] * 5
        
        for i in range(2, n+1):
            for j in range(4, -1, -1):
                dp[j] += sum(dp[:j])            
        
        return sum(dp)"
furthest building you can reach,"class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        # prepare: use a min heap to store each difference(climb) between two contiguous buildings
        # strategy: use the ladders for the longest climbs and the bricks for the shortest climbs
        
        min_heap = []
        n = len(heights)
        
        for i in range(n-1):
            climb = heights[i+1] - heights[i]
            
            if climb <= 0:
                continue
            
            # we need to use a ladder or some bricks, always take the ladder at first
            if climb > 0:
                heapq.heappush(min_heap, climb)
            
            # ladders are all in used, find the current shortest climb to use bricks instead!
            if len(min_heap) > ladders:
                # find the current shortest climb to use bricks
                brick_need = heapq.heappop(min_heap)
                bricks -= brick_need
            
            if bricks < 0:
                return i
        
        return n-1"
furthest building you can reach,"class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        pq = []
        n = len(heights)
        
        for i in range(n-1):
            diff = heights[i+1] - heights[i]
            if diff > 0:
                heapq.heappush(pq, diff)
            if len(pq) > ladders:
                bricks = bricks-heapq.heappop(pq)
            if bricks < 0:
                return i
        
        return n-1"
kth smallest instructions,"class Solution:
    def kthSmallestPath(self, destination: List[int], k: int) -> str:
        m, n = destination # m ""V"" &amp; n ""H"" in total 
        ans = """"
        while n: 
            kk = comb(m+n-1, n-1) # (m+n-1 choose n-1) instructions starting with ""H""  
            if kk >= k: 
                ans += ""H""
                n -= 1
            else: 
                ans += ""V""
                m -= 1
                k -= kk 
        return ans + m*""V"""
kth smallest instructions,"class Solution:
    def kthSmallestPath(self, destination: List[int], k: int) -> str:
        x,y=destination
        arr=[[0 for i in range(y+1)] for j in range(x+1)]
        arr[x][y]=1

        for i in range(x,-1,-1):
            for j in range(y,-1,-1):
                if i+1<=x:
                    arr[i][j]+=arr[i+1][j]
                if j+1<=y:
                    arr[i][j]+=arr[i][j+1]
       
        i,j=0,0
        r=''
        for _ in range(x+y):
            if i<=x and j+1<=y and arr[i][j+1]>=k:
                r+='H'
                j+=1
            else:
                r+='V'
                k-=arr[i][j+1] if i<=x and j+1<=y else 0
                i+=1
        
        return r"
get maximum in generated array,"class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        max_nums = [0, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 11, 11, 11, 11, 11, 11, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21]
        return max_nums[n]"
get maximum in generated array,"class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        if n == 0:
            return 0
        elif n == 1:
            return 1
        else:
            nums = [0,1]
            for i in range(2,n+1):
                if i%2 == 0:
                    nums.append(nums[i//2])
                else:
                    nums.append(nums[i//2]+nums[(i//2)+1])
            return max(nums)"
minimum deletions to make character frequencies unique,"class Solution:
    def minDeletions(self, s: str) -> int:
        freq = {} # frequency table 
        for c in s: freq[c] = 1 + freq.get(c, 0)
        
        ans = 0
        seen = set()
        for k in sorted(freq.values(), reverse=True): 
            while k in seen: 
                k -= 1 
                ans += 1
            if k: seen.add(k)
        return ans"
minimum deletions to make character frequencies unique,"class Solution:
    def minDeletions(self, s: str) -> int:
        freq = {} # frequency table 
        for c in s: freq[c] = 1 + freq.get(c, 0)
        
        ans = 0
        seen = set()
        for k in freq.values(): 
            while k in seen: 
                k -= 1 
                ans += 1
            if k: seen.add(k)
        return ans"
sell diminishing valued colored balls,"class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        inventory.sort(reverse=True) # inventory high to low 
        inventory += [0]
        ans = 0
        k = 1
        for i in range(len(inventory)-1): 
            if inventory[i] > inventory[i+1]: 
                if k*(inventory[i] - inventory[i+1]) < orders: 
                    ans += k*(inventory[i] + inventory[i+1] + 1)*(inventory[i] - inventory[i+1])//2 # arithmic sum 
                    orders -= k*(inventory[i] - inventory[i+1])
                else: 
                    q, r = divmod(orders, k)
                    ans += k*(2*inventory[i] - q + 1) * q//2 + r*(inventory[i] - q)
                    return ans % 1_000_000_007
            k += 1"
sell diminishing valued colored balls,"class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        fn = lambda x: sum(max(0, xx - x) for xx in inventory) # balls sold 
    
        # last true binary search 
        lo, hi = 0, 10**9
        while lo < hi: 
            mid = lo + hi + 1 >> 1
            if fn(mid) >= orders: lo = mid
            else: hi = mid - 1
        
        ans = sum((x + lo + 1)*(x - lo)//2 for x in inventory if x > lo)
        return (ans - (fn(lo) - orders) * (lo + 1)) % 1_000_000_007"
defuse the bomb,"class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        if k == 0:
            return [0] * len(code)
        data = code + code
        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]
		# result = []
        # for i in range(len(code)):
        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))
        if 0 > k:
            return result[k - 1:] + result[:k - 1]
        return result"
defuse the bomb,"class Solution:
    def helper(self,code,k):
        res = []
        total = sum(code[1:k+1])
        res.append(total)
        i,j = 1,k+1
        while i<len(code):
            if j==len(code):
                j = 0
            total+=-code[i]+code[j]
            res.append(total)
            j+=1
            i+=1
        return res
    def decrypt(self, code: List[int], k: int) -> List[int]:
        if k==0:
            return [0]*len(code)
        if k>0:
            return self.helper(code,k)
        code = code[::-1]
        k=-1*k
        lst = self.helper(code,k)
        return lst[::-1]"
minimum deletions to make string balanced,"class Solution:
    def minimumDeletions(self, s: str) -> int:
        # track the minimum number of deletions to make the current string balanced ending with 'a', 'b'
        end_a, end_b = 0,0 
        for val in s:
            if val == 'a':
                # to end with 'a', nothing to do with previous ending with 'a'
                # to end with 'b', need to delete the current 'a' from previous ending with 'b'
                end_b += 1
            else:
                # to end with 'a', need to delete the current 'b' from previous ending with 'a'
                # to end with 'b', nothing to do, so just pick smaller of end_a, end_b
                end_a, end_b = end_a+1, min(end_a, end_b)
        return min(end_a, end_b)"
minimum deletions to make string balanced,"class Solution:
    def minimumDeletions(self, s: str) -> int:
        stack, res = [], 0
        for i in range(len(s)):
            if stack and s[i] == ""a"" and stack[-1] == ""b"":
                stack.pop()
                res += 1
            else:
                stack.append(s[i])
        return res"
minimum jumps to reach home,"class Solution:
def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
    
    forbidden = set(forbidden)
    limit = max(x,max(forbidden))+a+b
    seen = set()
    q = [(0,0,False)]
    while q:
        p,s,isb = q.pop(0)
        if p>limit or p<0 or p in forbidden or (p,isb) in seen:
            continue
        
        if p==x:
            return s
        
        q.append((p+a,s+1,False))
        if not isb:
            q.append((p-b,s+1,True))
        seen.add((p,isb))
    
    return -1"
minimum jumps to reach home,"class Solution:
    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
        forbidden = set(forbidden)
        visited = set()
        limit = max(x, max(forbidden)) + a + b
        queue = [(0, 0, False)]
        while queue:
            pos, step, back = queue.pop(0)
            if pos > limit or pos < 0 or pos in forbidden or (pos, back) in visited:
                continue
            if pos == x:
                return step
            queue.append((pos+a, step+1, False))
            if not back: queue.append((pos-b, step+1, True))
            visited.add((pos, back))
        return -1"
distribute repeating integers,"class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0)
        
        vals = sorted(freq.values(), reverse=True)
        quantity.sort(reverse=True) # pruning - large values first  
        
        def fn(i): 
            """"""Return True if possible to distribute quantity[i:] to remaining.""""""
            if i == len(quantity): return True 
            seen = set()
            for k in range(len(vals)): 
                if vals[k] >= quantity[i] and vals[k] not in seen: 
                    seen.add(vals[k]) # pruning - unqiue values 
                    vals[k] -= quantity[i]
                    if fn(i+1): return True 
                    vals[k] += quantity[i] # backtracking
                    
        return fn(0)"
distribute repeating integers,"class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        
        arr=[0]*(1001)
        for i in nums:
            arr[i]+=1
            
        arr.sort(reverse=True)
        #print(arr)
        arr=arr[:10]
        dict={}
        def dfs(ind,arr):
            if ind==m:
                return True
            if (ind,tuple(arr)) in dict:
                return dict[(ind,tuple(arr))]
            
            for i in range(0,10):
                if arr[i]>=quantity[ind]:
                    arr[i]-=quantity[ind]
                    a=dfs(ind+1,arr)
                    arr[i]+=quantity[ind]
                    if a:
                        dict[(ind,tuple(arr))]=True
                        
                        return True
                    
            dict[(ind,tuple(arr))]=False
            return False
        m=len(quantity)
        return dfs(0,arr)"
determine if two strings are close,"class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        cnt1, cnt2 = Counter(word1), Counter(word2)
        return cnt1.keys() == cnt2.keys() and sorted(cnt1.values()) == sorted(cnt2.values())"
determine if two strings are close,"class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        
        def fn(word):
            """"""Return freq table of word.""""""
            freq = {}
            for c in word: freq[c] = 1 + freq.get(c, 0)
            return freq
        
        freq1, freq2 = fn(word1), fn(word2)
        return freq1.keys() == freq2.keys() and sorted(freq1.values()) == sorted(freq2.values())"
minimum operations to reduce x to zero,"class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        mp = {0: 0}
        prefix = 0
        for i, num in enumerate(nums, 1): 
            prefix += num
            mp[prefix] = i 
            
        ans = mp.get(x, inf)
        for i, num in enumerate(reversed(nums), 1): 
            x -= num
            if x in mp and mp[x] + i <= len(nums): ans = min(ans, i + mp[x])
        return ans if ans < inf else -1"
minimum operations to reduce x to zero,"class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        x = sum(nums) - x
        if not x: return len(nums) # edge case 
        
        seen = {0: -1}
        ans = prefix = 0
        for i, num in enumerate(nums): 
            prefix += num
            if prefix - x in seen: ans = max(ans, i - seen[prefix - x])
            seen.setdefault(prefix, i)
        return len(nums) - ans if ans else -1"
maximize grid happiness,"class Solution:
    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:
        
        @cache
        def fn(prev, i, j, intro, extro): 
            """"""Return max grid happiness at (i, j).""""""
            if i == m: return 0 # no more position
            if j == n: return fn(prev, i+1, 0, intro, extro)
            if intro == extro == 0: return 0 
            
            prev0 = prev[:j] + (0,) + prev[j+1:]
            ans = fn(prev0, i, j+1, intro, extro)
            if intro: 
                val = 120 
                if i and prev[j]: # neighbor from above 
                    val -= 30 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: # neighbor from left 
                    val -= 30 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (1,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro-1, extro))
            if extro: 
                val = 40 
                if i and prev[j]: 
                    val += 20 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: 
                    val += 20 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (2,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro, extro-1))
            return ans 
        
        return fn((0,)*n, 0, 0, introvertsCount, extrovertsCount)"
check if two string arrays are equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return ''.join(word1) == ''.join(word2)"
check if two string arrays are equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return True if ''.join(word1) == ''.join(word2) else False"
smallest string with a given numeric value,"class Solution:
    def getSmallestString(self, n: int, k: int) -> str:
        res, k, i = ['a'] * n, k - n, n - 1
        while k:
            k += 1
            if k/26 >= 1:
                res[i], k, i = 'z', k - 26, i - 1
            else:
                res[i], k = chr(k + 96), 0

        return ''.join(res)"
smallest string with a given numeric value,"class Solution:
	def getSmallestString(self, n: int, k: int) -> str:
		z = (k - n) // 25
		unique = chr(k - z * 25 - n + 97) if n - z else """"
		return ""a""*(n-z-1) + unique + ""z""*z"
ways to make a fair array,"class Solution:
	def waysToMakeFair(self, nums: List[int]) -> int:
		if len(nums) == 1:
			return 1

		if len(nums) == 2:
			return 0

		prefixEven = sum(nums[2::2])
		prefixOdd = sum(nums[1::2])
		result = 0

		if prefixEven == prefixOdd and len(set(nums)) == 1:
			result += 1

		for i in range(1,len(nums)):
			if i == 1:
				prefixOdd, prefixEven = prefixEven, prefixOdd 

			if i > 1:
				if i % 2 == 0:
					prefixEven -= nums[i-1]
					prefixEven += nums[i-2]

				else:
					prefixOdd -= nums[i-1]
					prefixOdd += nums[i-2]

			if prefixOdd == prefixEven:
				result += 1

		return result"
ways to make a fair array,"class Solution:
    def waysToMakeFair(self, nums: List[int]) -> int:
        odd, even = 0, 0
        for i in range(len(nums)):
            if i % 2:
                odd += nums[i]
            else:
                even += nums[i]
        
        ret = 0

        left_even = left_odd = 0
        for i in range(len(nums)):
            if not i % 2:
                even -= nums[i]
                if left_even + odd == left_odd + even:
                    ret += 1
                left_even += nums[i]
            else:
                odd -= nums[i]
                if left_odd + even == left_even + odd:
                    ret += 1
                left_odd += nums[i]
            
        return ret"
minimum initial energy to finish tasks,"class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x: x[0]-x[1])
        def ok(mid):
            for actual, minimum in tasks:
                if minimum > mid or actual > mid: return False
                if minimum <= mid: mid -= actual
            return True
        l, r = 0, 10 ** 9
        while l <= r:
            mid = (l+r) // 2
            if ok(mid): r = mid - 1
            else: l = mid + 1
        return l"
minimum initial energy to finish tasks,"class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x: x[0]-x[1])
        ans = cur = 0
        for cost, minimum in tasks:
            ans = min(cur-minimum, ans)
            cur -= cost
        return -ans"
maximum repeating substring,"class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        i = 0
        while word*(i+1) in sequence:
            i+=1
        return i"
maximum repeating substring,"class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        for i in range(len(sequence)//len(word)+1,0,-1):
            if i*word in sequence:
                return i
        else:
            return 0"
merge in between linked lists,"class Solution:
    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:
        curr=list1
        for count in range(b):
            if count==a-1:      # travel to a node and   --> step 1
                start=curr      # then save pointer in start
            curr=curr.next   # continue travel to b node  --> step 2
        start.next=list2     # point start to list2   --> step3
        while list2.next:    # travel list2   --> step 4
            list2=list2.next
        list2.next=curr.next  # map end of list2 to b
        return list1"
merge in between linked lists,"class Solution:
    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:

        point1 = list1
        point2 = list1
        for _ in range(b - a):
            point2 = point2.next
        prev = None
        for _ in range(a):
            prev = point1
            point1 = point1.next
            point2 = point2.next
        
        prev.next = list2
        while list2.next:
            list2 = list2.next
        list2.next = point2.next
        
        return list1"
minimum number of removals to make mountain array,"class Solution:
	def minimumMountainRemovals(self, lst: List[int]) -> int:
		l = len(lst)
		dp = [0] * l
		dp1 = [0] * l

		for i in range(l):   # for increasing subsequence
			maxi = 0
			for j in range(i):
				if lst[i] > lst[j]:
					if dp[j] > maxi:
						maxi = dp[j]

			dp[i] = maxi + 1

		for i in range(l - 1, -1, -1):  # for decreasing subsequence
			maxi1 = 0
			for j in range(l - 1, i, -1):
				if lst[i] > lst[j]:
					if dp1[j] > maxi1:
						maxi1 = dp1[j]

			dp1[i] = maxi1 + 1

		ans = 0
		for i in range(l):
			if dp[i] > 1 and dp1[i] > 1:
				temp = dp[i] + dp1[i] - 1
				if temp > ans:
					ans = temp

		return l - ans"
minimum number of removals to make mountain array,"class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)        
        left = [0 for i in range(n)]
        right = [0 for i in range(n)]
        
        for i in range(1, n):
            val = 0 
            for j in range(i):
                if nums[j] < nums[i]:
                    val = max(val, left[j] + 1)
        
            left[i] = val
            
        for i in range(n - 2, -1, -1):
            val = 0 
            for j in range(i + 1, n):
                if nums[j] < nums[i]:
                    val = max(val, right[j] + 1)
            
            right[i] = val
            
        ans = inf
        
        for i in range(1, n - 1):
            if left[i] > 0 and right[i] > 0:
                ans = min(ans, n - 1 - left[i] - right[i])    
        
        return ans"
richest customer wealth,"class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        return max([sum(acc) for acc in accounts])"
richest customer wealth,"class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        res=[]
        for i in accounts:
            res.append(sum(i))
        return max(res)
```easy solution using python basics"
find the most competitive subsequence,"class Solution:
    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:
        stack = [] # (increasing) mono-stack 
        for i, x in enumerate(nums): 
            while stack and stack[-1] > x and len(stack) + len(nums) - i > k: stack.pop()
            if len(stack) < k: stack.append(x)
        return stack"
find the most competitive subsequence,"class Solution:
    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:
        ans, pq = [], []
        prev = -inf 
        for i, x in enumerate(nums): 
            heappush(pq, (x, i))
            if i+k >= len(nums): 
                while pq and pq[0][1] < prev: heappop(pq)
                x, prev = heappop(pq)
                ans.append(x)
        return ans"
minimum moves to make array complementary,"class Solution:  
    def minMoves(self, nums: List[int], limit: int) -> int:
        n = len(nums)
        overlay_arr = [0] * (2*limit+2)
        for i in range(n//2):
            left_boundary = min(nums[i], nums[n-1-i]) + 1
            no_move_value = nums[i] + nums[n-1-i]
            right_boundary = max(nums[i], nums[n-1-i]) + limit
            overlay_arr[left_boundary] -= 1
            overlay_arr[no_move_value] -= 1
            overlay_arr[no_move_value+1] += 1
            overlay_arr[right_boundary+1] += 1
        curr_moves = n   #initial assumption of two moves for each pair
        res = float(""inf"")
		# start Sweeping
        for i in range(2, 2*limit+1):
            curr_moves += overlay_arr[i]
            res = min(res, curr_moves)
        return res"
minimum moves to make array complementary,"class Solution:
    def minMoves(self, nums: List[int], limit: int) -> int:
        diff = [0]*(2*limit+2) # difference array 
        
        for i in range(len(nums)//2): 
            m = min(nums[i], nums[~i]) + 1 # lower bound 
            diff[m] += -1
            x = nums[i] + nums[~i]
            diff[x] += -1
            diff[x+1] += 1
            M = max(nums[i], nums[~i]) + 1 + limit # upper bound 
            diff[M] += 1
        
        for i in range(1, len(diff)): diff[i] += diff[i-1] # prefix sum 
        return len(nums) + min(diff)"
minimize deviation in array,"class Solution:
	def minimumDeviation(self, nums: List[int]) -> int:

		from sortedcontainers import SortedList

		for i in range(len(nums)):

			if nums[i]%2!=0:
				nums[i]=nums[i]*2

		nums = SortedList(nums)

		result = 100000000000

		while True:
			min_value = nums[0]
			max_value = nums[-1]

			if max_value % 2 == 0:
				nums.pop()
				nums.add(max_value // 2)
				max_value = nums[-1]
				min_value = nums[0]

				result = min(result , max_value - min_value)
			else:
				result = min(result , max_value - min_value)
				break

		return result"
minimize deviation in array,"class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        pq = [-2*x if x&amp;1 else -x for x in nums]
        heapify(pq)
        most = max(pq)
        ans = most - pq[0]
        while not pq[0]&amp;1: 
            x = heappop(pq)//2
            heappush(pq, x)
            most = max(most, x)
            ans = min(ans, most - pq[0])
        return ans"
goal parser interpretation,"class Solution:
    def interpret(self, command: str) -> str:
        return command.replace('()','o').replace('(al)','al')"
goal parser interpretation,"class Solution:
    def interpret(self, command: str) -> str:
        s = """"
        i = 0
        while i < len(command):
            if command[i] == ""G"":
                s += ""G""
                i += 1
            else:
                if i < len(command) and command[i+1] == "")"":
                    s += ""o""
                    i += 2
                else:
                    s += ""al""
                    i += 4
        return s"
max number of k sum pairs,"class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        counter = defaultdict(int)
        
        count = 0
        for x in nums:
            comp = k - x
            if counter[comp]>0:
                counter[comp]-=1
                count+=1
            else:
                counter[x] +=1
        
        return count"
max number of k sum pairs,"class Solution:
    def maxOperations(self, A, K):
        A.sort()
        ans, l, r = 0, 0, len(A) - 1
        while l < r:
            val = A[l] + A[r]
            if val <= K: l += 1
            if val >= K: r -= 1
            if val == K: ans += 1
        return ans"
concatenation of consecutive binary numbers,"class Solution:
    def concatenatedBinary(self, n: int) -> int:
        return int("""".join([bin(i)[2:] for i in range(1,n+1)]),2)%(10**9+7)"
concatenation of consecutive binary numbers,"class Solution:
	def concatenatedBinary(self, n: int) -> int:

		binary = ''

		for num in range(1, n+1):

			binary = binary + bin(num)[2:]

		result = int(binary, 2)

		return result % (10**9 + 7)"
minimum incompatibility,"class Solution:
    def minimumIncompatibility(self, nums: List[int], k: int) -> int:
        nums.sort()
        
        def fn(i, cand): 
            """"""Populate stack and compute minimum incompatibility.""""""
            nonlocal ans 
            if cand + len(nums) - i - sum(not x for x in stack) > ans: return 
            if i == len(nums): ans = cand
            else: 
                for ii in range(k): 
                    if len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii]): 
                        stack[ii].append(nums[i])
                        if len(stack[ii]) == 1: fn(i+1, cand)
                        else: fn(i+1, cand + stack[ii][-1] - stack[ii][-2])
                        stack[ii].pop()
        
        ans = inf
        stack = [[] for _ in range(k)]
        fn(0, 0)
        return ans if ans < inf else -1"
minimum incompatibility,"class Solution:
    def minimumIncompatibility(self, nums: List[int], k: int) -> int:
        nums.sort()
        
        def fn(i, cand=0, ans=inf):
            """"""Return minimum incompatibility via backtracking.""""""
            if cand + len(nums) - i - sum(not x for x in stack) >= ans: return ans # early return 
            if i == len(nums): return cand
            for ii in range(k): 
                if len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii]): 
                    stack[ii].append(nums[i])
                    if len(stack[ii]) == 1: ans = fn(i+1, cand, ans)
                    else: ans = fn(i+1, cand + stack[ii][-1] - stack[ii][-2], ans)
                    stack[ii].pop()
            return ans 
        
        stack = [[] for _ in range(k)]
        ans = fn(0)
        return ans if ans < inf else -1"
count the number of consistent strings,"class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        return sum(set(allowed) >= set(i) for i in words)"
count the number of consistent strings,"class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        count = 0
        for i in range(len(words)):
            if sorted(set(list(words[i] + allowed))) == list(sorted(allowed)): count += 1
        return count"
sum of absolute differences in a sorted array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        pre_sum = [0]
        for num in nums:                                     # calculate prefix sum
            pre_sum.append(pre_sum[-1] + num)
        n = len(nums)                                        # render the output
        return [(num*(i+1) - pre_sum[i+1]) + (pre_sum[-1]-pre_sum[i] - (n-i)*num) for i, num in enumerate(nums)]"
sum of absolute differences in a sorted array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        total_sum = sum(nums)
        N = len(nums)
        ans = []
        l_sum = 0
        l_covered = 0

        for i in range(N):
            r_size = N-i-1
            r_sum = total_sum - l_sum - nums[i]
            s = l_covered*nums[i] - l_sum + r_sum - r_size*nums[i]
            # print(i, l_covered*nums[i] - l_sum, r_sum - r_size*nums[i])
            ans.append(s)
            l_sum += nums[i]
            l_covered += 1

        return ans"
stone game vi,"class Solution:
    def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:
        n = len(alice)
        arr = [alice[i] + bob[i] for i in range(n)]
        s = sum(bob)
        res = 0
        k = (n+1)//2
        arr.sort(reverse=True)
        for i in range(0, n, 2):
            res += arr[i]
        
        
        if res > s:
            return 1
        elif res == s:
            return 0 
        else:
            return -1"
stone game vi,"class Solution:
    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:
        pq = [(-x-y, x, y) for x, y in zip(aliceValues, bobValues)]
        heapify(pq)
        
        s0 = s1 = i = 0
        while pq: 
            _, x, y = heappop(pq)
            if i: s1 += y
            else: s0 += x
            i ^= 1
        if s0 > s1: return 1
        if s0 < s1: return -1
        return 0"
delivering boxes from storage to ports,"class Solution:
    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
        dp = [0] + [inf]*len(boxes)
        trips = 2
        ii = 0
        for i in range(len(boxes)):
            maxWeight -= boxes[i][1]
            if i and boxes[i-1][0] != boxes[i][0]: trips += 1
            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:
                maxWeight += boxes[ii][1]
                if boxes[ii][0] != boxes[ii+1][0]: trips-=1
                ii += 1
            dp[i+1] = dp[ii] + trips
        return dp[-1]"
count of matches in tournament,"class Solution:
	def numberOfMatches(self, n: int) -> int:

		# the logic is, among n teams only 1 team will won, so n-1 teams will lose
		# hence there will be n-1 match (so that n-1 teams can lose) 

		return n-1"
count of matches in tournament,"class Solution:
    def numberOfMatches(self, n: int) -> int:
        ans = 0
        while n > 1: 
            ans += n//2 
            n = n//2 + (n&amp;1)
        return ans"
partitioning into minimum number of deci binary numbers,"class Solution:
    def minPartitions(self, n: str) -> int:
        return int(max(n))"
partitioning into minimum number of deci binary numbers,"class Solution:
    def minPartitions(self, n: str) -> int:
        return max(n)"
stone game vii,"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        dp = [[0 for _ in range(len(stones))] for _ in range(len(stones))]     # dp table n x n
        run_sum = [0]                            # running sum -> sum [i..j] = run_sum[j] - run_sum[i]
        s = 0
        
		## Calculation of running sum
        for i in stones:
            s += i
            run_sum.append(s)
		
        n = len(stones) 
        
        for k in range(1, n):               # no. of stones left
            for i in range(0, n - k):   # from each starting point
                remove_i_stone = (run_sum[i+k+1] - run_sum[i+1])    # score after removing i th stone
                remove_j_stone = (run_sum[i+k] - run_sum[i])             # score after removing j th stone
                
                if (n-(k+1))%2 == 0:        # alice's move 
                    dp[i][i+k] = max(remove_i_stone + dp[i+1][i+k],
                                    remove_j_stone + dp[i][i+k-1])
                else:                       # bob's move
                    dp[i][i+k] = min(-remove_i_stone + dp[i+1][i+k],
                                    - remove_j_stone + dp[i][i+k-1])
                    
        return dp[0][n - 1]"
stone game vii,"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)
        
        @lru_cache(1000)
        def fn(lo, hi): 
            """"""Return difference of scores.""""""
            if lo == hi: return 0
            return max(prefix[hi] - prefix[lo+1] - fn(lo+1, hi), prefix[hi-1] - prefix[lo] - fn(lo, hi-1))
            
        return fn(0, len(stones))"
maximum height by stacking cuboids,"class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        cuboids = sorted([sorted(cub) for cub in cuboids], reverse=True)   # sort LxWxH in cube, then sort cube reversely
        ok = lambda x, y: (x[0] >= y[0] and x[1] >= y[1] and x[2] >= y[2]) # make a lambda function to verify whether y can be put on top of x
        n = len(cuboids)
        dp = [cu[2] for cu in cuboids]                                     # create dp array
        ans = max(dp)
        for i in range(1, n):                                              # iterate over each cube
            for j in range(i):                                             # compare with previous calculated cube
                if ok(cuboids[j], cuboids[i]):                             # update dp[i] if cube[i] can be put on top of cube[j]
                    dp[i] = max(dp[i], dp[j] + cuboids[i][2])              # always get the maximum
            ans = max(ans, dp[i])                                          # record the largest value
        return ans"
maximum height by stacking cuboids,"class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        dp=[0]*len(cuboids)
        max_value=0
        for i in range(len(cuboids)):
            cuboids[i].sort()
        cuboids.sort()
        for i in range(len(cuboids)):
            dp[i]=cuboids[i][2]
            for j in range(i):
                if cuboids[i][0]>=cuboids[j][0] and cuboids[i][1]>=cuboids[j][1] and cuboids[i][2]>=cuboids[j][2]:
                    dp[i]=max(dp[i],dp[j]+cuboids[i][2])
            if dp[i]>max_value:
                max_value=dp[i]
        return max_value"
reformat phone number,"class Solution:
    def reformatNumber(self, number: str) -> str:
        number = number.replace(""-"", """").replace("" "", """") # removing - and space 
        ans = []
        for i in range(0, len(number), 3): 
            if len(number) - i != 4: ans.append(number[i:i+3])
            else: 
                ans.extend([number[i:i+2], number[i+2:]])
                break 
        return ""-"".join(ans)"
reformat phone number,"class Solution:
    def reformatNumber(self, number: str) -> str:
        s = number.replace("" "", """").replace(""-"", """")
        pieces = list()
        while s:
            if len(s) == 2:
                pieces.append(s)
                break
            elif len(s) == 4:
                pieces.append(s[:2])
                pieces.append(s[2:])
                break
            else:
                pieces.append(s[:3])
                s = s[3:]
        return ""-"".join(pieces)"
maximum erasure value,"class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        counter=defaultdict(int) # track count of  elements in the window
        res=i=tot=0
		
        for j in range(len(nums)):
            x=nums[j]   
            tot+=x
            counter[x]+=1
            # adjust the left bound of sliding window until you get all unique elements
            while i < j and counter[x]>1: 
                counter[nums[i]]-=1
                tot-=nums[i]
                i+=1
            
            res=max(res, tot)            
        return res"
maximum erasure value,"class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        seen=set() # track visited elements in the window
        res=i=tot=0
        for j in range(len(nums)):
            x=nums[j]                   
			 # adjust the left bound of sliding window until you get all unique elements
            while i < j and x in seen: 
                seen.remove(nums[i])
                tot-=nums[i]
                i+=1                        
            tot+=x
            seen.add(x)
            res=max(res, tot)            
        return res"
jump game vi,"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        pq = [] # max heap 
        for i in reversed(range(len(nums))): 
            while pq and pq[0][1] - i > k: heappop(pq)
            ans = nums[i] - pq[0][0] if pq else nums[i]
            heappush(pq, (-ans, i))
        return ans"
jump game vi,"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        queue = deque()
        for i in reversed(range(len(nums))): 
            while queue and queue[0][1] - i > k: queue.popleft()
            ans = nums[i]
            if queue: ans += queue[0][0]
            while queue and queue[-1][0] <= ans: queue.pop()
            queue.append((ans, i))
        return ans"
checking existence of edge length limited paths,"class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:
        
        parent = [i for i in range(n+1)]
    
        rank = [0 for i in range(n+1)]

        def find(parent, x):

            if parent[x] == x:
                return x
            parent[x] = find(parent, parent[x])
            return parent[x]

        def union(parent, a, b):

            a = find(parent, a)
            b = find(parent, b)

            if a == b:
                return 

            if rank[a] < rank[b]:
                parent[a] = b
            elif rank[a] > rank[b]:
                parent[b] = a
            else:
                parent[b] = a
                rank[a] += 1
                
        edgeList.sort(key = lambda x: x[2])
        res = [0] * len(queries)
        queries = [[i, ch] for i, ch in enumerate(queries)]
        queries.sort(key = lambda x: x[1][2])
        
        ind = 0
        for i, (a, b, w) in queries:
            
            while ind < len(edgeList) and edgeList[ind][2] < w:
                union(parent, edgeList[ind][0], edgeList[ind][1])
                ind += 1
                
            res[i] = find(parent, a) == find(parent, b)
        return res"
checking existence of edge length limited paths,"class Solution:
    def distanceLimitedPathsExist(self, n: int, A: List[List[int]], B: List[List[int]]) -> List[bool]:
        par = {}
        A.sort(key = lambda x: x[2])
        
        for i, query in enumerate(B):
            query.append(i)
        B.sort(key = lambda x: x[2])
        
        def find(a):
            par.setdefault(a, a)
            if par[a] != a:
                par[a] = find(par[a])
            return par[a]
        
        def union(a, b):
            par.setdefault(a, a)
            par.setdefault(b, b)
            par[find(a)] = par[find(b)]
        
        ans = [False]*len(B)
        i = 0
        for a, b, lim, idx in B:
            while i < len(A) and A[i][2] < lim:
                union(A[i][0], A[i][1])
                i += 1
            
            if find(a) == find(b):
                ans[idx] = True
        return ans"
number of students unable to eat lunch,"class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        curr = 0
        
        while students:
            if(students[0] == sandwiches[0]):
                curr = 0
                students.pop(0)
                sandwiches.pop(0)
            else:
                curr += 1
                students.append(students.pop(0))
            
            if(curr >= len(students)):
                break
        
        return len(students)"
number of students unable to eat lunch,"class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        count = len(students)
        while(sandwiches and students and sandwiches[0] in students):
            if(sandwiches[0]!=students[0]):
                students.append(students[0])
                students.pop(0)
            else:
                students.pop(0)
                sandwiches.pop(0)
                count-=1
        return count"
average waiting time,"class Solution:
    def averageWaitingTime(self, customers: List[List[int]]) -> float:
        arr = []
        
        time = 0
        
        for i , j in customers:
            if(i > time):
                time = i + j
            else:
                time += j
            arr.append(time - i)
        
        return sum(arr) / len(arr)"
average waiting time,"class Solution:
    def averageWaitingTime(self, customers: List[List[int]]) -> float:
        waits_total = 0
        end_prev_order = customers[0][0]
        
        for arrival, time in customers:
            overhead = end_prev_order - arrival if end_prev_order > arrival else 0
            waits_total += time + overhead
            end_prev_order = max(end_prev_order, arrival) + time 

        return waits_total / len(customers)"
maximum binary string after change,"lass Solution:
    def maximumBinaryString(self, s: str) -> str:
        #count of 0
        c=0
        #final ans string will contain only one zero.therefore shift the first 0  to c places.Initialize ans string with all 1s
        lst=[""1""]*len(s)
        for i in range (0,len(s)):
            if s[i]==""0"":
                c+=1
        for i in range (0,len(s)):
		#finding the ist 0
            if s[i]==""0"":
                lst[i+c-1]=""0""
                return """".join(lst)
        return s"
maximum binary string after change,"class Solution:
    def maximumBinaryString(self, binary: str) -> str:
        zero = binary.count('0')                         # count number of '0'
        zero_idx = binary.index('0') if zero > 0 else 0  # find the index of fist '0' if exists
        one = len(binary) - zero_idx - zero              # count number of '1' (not including leading '1's)
        return f""{binary[:zero_idx]}{'1'*(zero-1)}{'0'*min(zero, 1)}{'1'*one}"""
minimum adjacent swaps for k consecutive ones,"class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        ii = val = 0 
        ans = inf
        loc = [] # location of 1s
        for i, x in enumerate(nums): 
            if x: 
                loc.append(i)
                m = (ii + len(loc) - 1)//2 # median 
                val += loc[-1] - loc[m] - (len(loc)-ii)//2 # adding right 
                if len(loc) - ii > k: 
                    m = (ii + len(loc))//2 # updated median 
                    val -= loc[m] - loc[ii] - (len(loc)-ii)//2 # removing left 
                    ii += 1
                if len(loc)-ii == k: ans = min(ans, val) # len(ones) - ii effective length
        return ans"
minimum adjacent swaps for k consecutive ones,"class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        loc = [i for i, x in enumerate(nums) if x]
        prefix = [0]
        for x in loc: prefix.append(prefix[-1] + x)
        
        ans = inf
        for i in range(len(loc)-k+1): 
            ans = min(ans, (prefix[i+k] - prefix[i+(k+1)//2]) - (prefix[i+k//2] - prefix[i]))
        return ans - (k//2)*((k+1)//2)"
determine if string halves are alike,"class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        vowels = set('aeiouAEIOU')
        count = 0
        for i in range(len(s)//2):
            if s[i] in vowels:
                count+=1
            if s[-i-1] in vowels:
                count-=1

        return count == 0"
determine if string halves are alike,"class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        vowels = ['a', 'e', 'i', 'o', 'u']
		
		# initializing the first half of the word and the back half variables
        first, firstc = [*s][:len(s)//2], 0
        back, backc = [*s][len(s)//2:], 0
		
		# [*s] creates a list
		# [len(s)//2] finds the middle position of the list
		
		# counts the vowels in first and back half
        for x in first:
            if x.lower() in vowels:
                firstc += 1
        for y in back:
            if y.lower() in vowels:
                backc += 1
		# returns whether the counts are equal to each other
        return firstc == backc"
maximum number of eaten apples,"class Solution:
    def eatenApples(self, apples: List[int], days: List[int]) -> int:
        ans = 0
        
        pq = [] # min-heap 
        for i, (x, d) in enumerate(zip(apples, days)): 
            while pq and pq[0][0] <= i: heappop(pq) # rotten 
            if x: heappush(pq, (i+d, x))
            if pq: 
                ii, x = heappop(pq)
                if x-1: heappush(pq, (ii, x-1))
                ans += 1
        
        i += 1
        while pq: 
            ii, x = heappop(pq)
            x = min(x, ii-i)
            ans += x
            i += x 
        return ans"
maximum number of eaten apples,"class Solution:
    def eatenApples(self, apples: List[int], days: List[int]) -> int:
        n=len(days)
        l=[]
        le=0
        for i in range(n):
            if days[i]!=0 or apples[i]!=0:
                l.append([apples[i],days[i]+i])
                le+=1
        l.sort(key=lambda x:x[1])
        day=0
        res=0
        i=0
        while(i<le):
            A=l[i][0]
            D=l[i][1]
            if day<D:
                diff_days=D-day
  
                mn=min(diff_days,A)
                day+=mn
                res+=mn
            i+=1
  
        return res"
where will the ball fall,"class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])
        @cache
        def helper(r, c):
            if r == m:
                return c
            elif grid[r][c] == 1 and c+1 < n and grid[r][c+1] == 1:
                return helper(r+1, c+1)
            elif grid[r][c] == -1 and 0 <= c-1 and grid[r][c-1] == -1:
                return helper(r+1, c-1)
            else:
                return -1
            
        return [helper(0, j) for j in range(n)]"
where will the ball fall,"class Solution:
def findBall(self, grid: List[List[int]]) -> List[int]:
m,n = len(grid),len(grid[0])
def check(row,col):
### If a ball get out of the box, return col
if row==m:
return col

### note that since grid contains 1 and -1 representing to right and to left, 
### we can just add the grid[row][col] to current collumn to get the new column
new_col = col+grid[row][col]

### if the new column is already out of the box 
### or the neighbor cell doesn't equal to grid[row][col] 
### the ball will get stuck and we just return -1
if new_col==n or new_col==-1 or grid[row][new_col]!=grid[row][col]:
return -1
else:
return check(row+1,new_col)
res = []
for i in range(n):
res.append(check(0,i))
return res"
maximum xor with an element from array,"class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        nums.sort()
        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))
        ans = [-1]*len(queries)
        
        trie = {}
        k = 0
        for m, x, i in queries: 
            while k < len(nums) and nums[k] <= m: 
                node = trie
                val = bin(nums[k])[2:].zfill(32)
                for c in val: node = node.setdefault(int(c), {})
                node[""#""] = nums[k]
                k += 1
            if trie: 
                node = trie
                val = bin(x)[2:].zfill(32)
                for c in val: node = node.get(1-int(c)) or node.get(int(c))
                ans[i] = x ^ node[""#""]
        return ans"
maximum units on a truck,"class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        boxTypes.sort(key=lambda x:x[1],reverse=1)
        s=0
        for i,j in boxTypes:
            i=min(i,truckSize)
            s+=i*j
            truckSize-=i
            if truckSize==0:
                break
        return s"
maximum units on a truck,"class Solution:
	def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
		boxTypes = sorted(boxTypes, key = lambda x : x[1], reverse = True)
		output = 0
		for no, units in boxTypes:
			if truckSize > no:
				truckSize -= no
				output += (no * units)
			else:
				output += (truckSize * units)
				break
		return output"
count good meals,"class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        ans = 0
        freq = defaultdict(int)
        for x in deliciousness: 
            for k in range(22): ans += freq[2**k - x]
            freq[x] += 1
        return ans % 1_000_000_007"
count good meals,"class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        freq = defaultdict(int)
        for x in deliciousness: freq[x] += 1
        
        ans = 0
        for x in freq: 
            for k in range(22): 
                if 2**k - x <= x and 2**k - x in freq: 
                    ans += freq[x]*(freq[x]-1)//2 if 2**k - x == x else freq[x]*freq[2**k-x]
        return ans % 1_000_000_007"
ways to split array into three subarrays,"class Solution:
    def waysToSplit(self, nums: List[int]) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = 0
        for i in range(1, len(nums)): 
            j = bisect_left(prefix, 2*prefix[i])
            k = bisect_right(prefix, (prefix[i] + prefix[-1])//2)
            ans += max(0, min(len(nums), k) - max(i+1, j))
        return ans % 1_000_000_007"
ways to split array into three subarrays,"class Solution:
    def waysToSplit(self, nums: List[int]) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = j = k = 0 
        for i in range(1, len(nums)): 
            j = max(j, i+1)
            while j < len(nums) and 2*prefix[i] > prefix[j]: j += 1
            k = max(k, j)
            while k < len(nums) and 2*prefix[k] <= prefix[i] + prefix[-1]: k += 1
            ans += k - j 
        return ans % 1_000_000_007"
minimum operations to make a subsequence,"class Solution:
    def minOperations(self, target: List[int], arr: List[int]) -> int:
        loc = {x: i for i, x in enumerate(target)}
        stack = []
        for x in arr: 
            if x in loc: 
                i = bisect_left(stack, loc[x])
                if i < len(stack): stack[i] = loc[x]
                else: stack.append(loc[x])
        return len(target) - len(stack)"
minimum operations to make a subsequence,"class Solution:
    def minOperations(self, target, arr):
        n, nums = len(target), []
        D = {target[i]: i for i in range(n)}
        res = [D[i] for i in arr if i in D.keys()]
        for i in res:
            j = bisect.bisect_left(nums, i)
            if j == len(nums): nums.append(i)
            else: nums[j] = i
        return n - len(nums)"
calculate money in leetcode bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        res,k=0,0
        for i in range(n):
            if i%7==0:
                k+=1
            res+=k+(i%7)
        return res"
calculate money in leetcode bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        def week(days, n=1, wek=7):
            res = 0
            for day in range(n, days+n):
                res += day
                print(day)
                if day == wek:
                    return res + week(days-7, n+1, wek+1)
            return res
        return week(n)"
maximum score from removing substrings,"class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
		# to calculate first, high value of x or y
        a, b = 'ab', 'ba'
        if y > x:
            b, a, y, x = a, b, x, y

        answer = 0
        
        for word in [a, b]:
            stack = []

            i = 0
            while i < len(s):
                stack.append(s[i])
                
                n = len(stack)
                prefix = stack[n-2] + stack[n-1]
                # if see the prefix ab or ba move from stack and increment the answer
                if prefix == word:
                    answer += x
                    stack.pop()
                    stack.pop()
                i += 1
            # change the x point to y for 2nd iteration
            x = y
            
            # assign new letters with already removed prefix
            s = ''.join(stack)
        return answer"
maximum score from removing substrings,"class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
        a, b = ""a"", ""b""
        if x < y: 
            x, y = y, x
            a, b = b, a
        ans = cnt0 = cnt1 = 0
        for c in s: 
            if c not in ""ab"": 
                ans += min(cnt0, cnt1) * y
                cnt0 = cnt1 = 0 
            elif c == b:
                if cnt0: 
                    cnt0 -= 1
                    ans += x
                else: cnt1 += 1
            else: cnt0 += 1
        return ans + min(cnt0, cnt1) * y"
construct the lexicographically largest valid sequence,"class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        
        arr = [0]*(2*n-1)     # the array we want to put numbers. 0 means no number has been put here
        i = 0                 # current index to put a number                
        vi = [False] * (n+1)  # check if we have used that number
        
		# backtracking
        def dfs(arr, i, vi):
		    # if we already fill the array successfully, return True
            if i >= (2*n-1):
                return True
				
			# try each number from n to 1
            for x in range(n, 0, -1):
			    # two cases:
			    # x > 1, we check two places. Mind index out of bound here.
			    # x = 1, we only check one place
				# arr[i] == 0 means index i is not occupied
                if (x > 1 and ((not (arr[i] == 0 and (i+x < 2*n-1) and arr[i+x] == 0)) or vi[x]))  \
					or (x == 1 and (arr[i] != 0 or vi[x])):
                    continue
				
				# if it can be placed, then place it
                if x > 1:
                    arr[i] = x
                    arr[i+x] = x
                else:
                    arr[i] = x
                vi[x] = True
				
				# find the next available place
                nexti = i+1
                while nexti < 2*n-1 and arr[nexti]:
                    nexti += 1
				
				# place the next one
                if dfs(arr, nexti, vi):
					# if it success, it is already the lexicographically largest one, we don't search anymore
                    return True
					
				# backtracking... restore the state
                if x > 1:
                    arr[i] = 0
                    arr[i+x] = 0
                else:
                    arr[i] = 0
                vi[x] = False
			
			# we could not find a solution, return False
            return False
		
        dfs(arr, i, vi)
        return arr"
construct the lexicographically largest valid sequence,"class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        ans = [0]*(2*n-1)
        
        def fn(i): 
            """"""Return largest sequence after filling in ith position.""""""
            if i == 2*n-1 or ans[i] and fn(i+1): return True 
            for x in reversed(range(1, n+1)): 
                if x not in ans: 
                    ii = x if x > 1 else 0 
                    if i+ii < 2*n-1 and ans[i] == ans[i+ii] == 0: 
                        ans[i] = ans[i+ii] = x
                        if fn(i+1): return True 
                        ans[i] = ans[i+ii] = 0 
        
        fn(0)
        return ans"
number of ways to reconstruct a tree,"class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        graph = {}
        for x, y in pairs: 
            graph.setdefault(x, set()).add(y)
            graph.setdefault(y, set()).add(x)
        
        ans = 1 
        ancestors = set()
        for n in sorted(graph, key=lambda x: len(graph[x]), reverse=True): 
            p = min(ancestors &amp; graph[n], key=lambda x: len(graph[x]), default=None) # immediate ancestor 
            ancestors.add(n)
            if p: 
                if graph[n] - (graph[p] | {p}): return 0 # impossible to have more than ancestor
                if len(graph[n]) == len(graph[p]): ans = 2
            elif len(graph[n]) != len(graph)-1: return 0
        return ans"
number of ways to reconstruct a tree,"class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        nodes = set()
        graph = {}
        degree = {}
        for x, y in pairs: 
            nodes |= {x, y}
            graph.setdefault(x, set()).add(y)
            graph.setdefault(y, set()).add(x)
            degree[x] = 1 + degree.get(x, 0)
            degree[y] = 1 + degree.get(y, 0)
        
        if max(degree.values()) < len(nodes) - 1: return 0 # no root
        for n in nodes: 
            if degree[n] < len(nodes)-1: 
                nei = set()
                for nn in graph[n]: 
                    if degree[n] >= degree[nn]: nei |= graph[nn] # brothers &amp; childrens
                if nei - {n} - graph[n]: return 0 # impossible
        
        for n in nodes: 
            if any(degree[n] == degree[nn] for nn in graph[n]): return 2 # brothers 
        return 1"
decode xored array,"class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        return [first] + [first:= first ^ x for x in encoded]"
decode xored array,"class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr = [first]
        for i in range(0, len(encoded)):
            arr.append(arr[i] ^ encoded[i])
        return arr"
swapping nodes in a linked list,"class Solution:
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        l = head  # left node
        for _ in range(k-1):
            l = l.next
        # the rest of the code logic here"
swapping nodes in a linked list,"class Solution:
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # Find kth node from left
        l = r = head
        for _ in range(k-1):
            l = l.next
        # Find kth node from right
        # by finding tail node
        tail = l
        while tail.next:
            r, tail = r.next, tail.next
        # Swap values and return
        l.val, r.val = r.val, l.val
        return head"
minimize hamming distance after swap operations,"class Solution:
    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:
        def gen_adjacency():
            adj = {}
            for i in range(len(source)):
                adj[i] = []
            for a, b in allowedSwaps:
                adj[a].append(b)
                adj[b].append(a)
            return adj
        
        def dfs(i):
            visited.add(i)
            this_group.add(i)
            for neigh in adj[i]:
                if neigh not in visited:
                    dfs(neigh)

        adj = gen_adjacency()
        visited = set()
        common_counts = 0
        for i in adj:
            if i not in visited:
                this_group = set()
                dfs(i)
                s_counts = collections.Counter([source[i] for i in this_group])
                t_counts = collections.Counter([target[i] for i in this_group])
                common = set(s_counts).intersection(t_counts)
                for common_int in common:
                    common_counts += min(s_counts[common_int], t_counts[common_int])
        ans = len(source) - common_counts
        return ans"
minimize hamming distance after swap operations,"class Solution:
    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:
        
        # idx to group id
        idx_to_group = {}
        # group id to index set
        group_to_idx = {}
        global_group_id = 0
        
        for swap in allowedSwaps:
            foundGroups = set()
            
            for idx in swap:
                if idx in idx_to_group:
                    foundGroups.add(idx_to_group[idx])
            
            if foundGroups:
                pivot = min(foundGroups)
                for group_id in foundGroups:
                    if pivot != group_id:
                        group_to_idx[pivot].update(group_to_idx[group_id])
                        group_to_idx.pop(group_id)

                group_to_idx[pivot].update(swap)

                for idx in group_to_idx[pivot]:
                    idx_to_group[idx] = pivot
            else:
                for idx in swap:
                    idx_to_group[idx] = global_group_id
                group_to_idx[global_group_id] = set(swap)
                global_group_id += 1
                
        ans = 0
        if group_to_idx == {}:
            for i in range(len(source)):
                if source[i]!=target[i]:
                    ans += 1
        else:
            for group_id in group_to_idx:
                src = {}
                tgt = {}
                for idx in group_to_idx[group_id]:
                    if source[idx] not in src:
                        src[source[idx]] = 0
                    src[source[idx]] += 1

                    if target[idx] not in tgt:
                        tgt[target[idx]] = 0
                    tgt[target[idx]] += 1

                for key in src:
                    if key in tgt:
                        if src[key] > tgt[key]:
                            ans += src[key] - tgt[key]
                    else:
                        ans += src[key]
            
            for i in range(len(source)):
                if i not in idx_to_group and source[i]!=target[i]:
                    ans += 1
            
        return ans"
find minimum time to finish all jobs,"class Solution:
    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:
        jobs.sort(reverse=True)
        
        def fn(i):
            """"""Assign jobs to worker and find minimum time.""""""
            nonlocal ans 
            if i == len(jobs): ans = max(time)
            else: 
                for kk in range(k): 
                    if not kk or time[kk-1] > time[kk]: 
                        time[kk] += jobs[i]
                        if max(time) < ans: fn(i+1)
                        time[kk] -= jobs[i]
            
        ans = inf
        time = [0]*k
        fn(0)
        return ans"
find minimum time to finish all jobs,"class Solution:
    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:
        
        def fn(i):
            """"""Assign jobs to worker and find minimum time.""""""
            nonlocal ans 
            if i == len(jobs): ans = max(time)
            else: 
                for kk in range(k): 
                    if not kk or time[kk-1] != time[kk]: 
                        time[kk] += jobs[i]
                        if max(time) < ans: fn(i+1)
                        time[kk] -= jobs[i]
            
        ans = inf
        time = [0]*k
        fn(0)
        return ans"
number of rectangles that can form the largest square,"class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        freq = {}
        for l, w in rectangles: 
            x = min(l, w)
            freq[x] = 1 + freq.get(x, 0)
        return freq[max(freq)]"
number of rectangles that can form the largest square,"class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        max_len = float('-inf')
        count = 0
        for item in rectangles:
            min_len = min(item)
            if min_len == max_len:
                count += 1
            elif min_len > max_len:
                max_len = min_len
                count = 1

        return count"
tuple with same product,"class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        ans = 0
        freq = {}
        for i in range(len(nums)):
            for j in range(i+1, len(nums)): 
                key = nums[i] * nums[j]
                ans += freq.get(key, 0)
                freq[key] = 1 + freq.get(key, 0)
        return 8*ans"
tuple with same product,"class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        count, ans, n = collections.Counter(), 0, len(nums)
        for i in range(n):
            for j in range(i+1, n):
                ans += 8 * count[nums[i]*nums[j]]
                count[nums[i]*nums[j]] += 1
        return ans"
largest submatrix with rearrangements,"class Solution:
    def largestSubmatrix(self, matrix: List[List[int]]) -> int:
        m, n, ans = len(matrix), len(matrix[0]), 0
        
        for j in range(n):
            for i in range(1, m):
                matrix[i][j] += matrix[i-1][j] if matrix[i][j] else 0
                
        for i in range(m): 
            matrix[i].sort(reverse=1)
            for j in range(n):
                ans = max(ans, (j+1)*matrix[i][j])
        return ans"
largest submatrix with rearrangements,"class Solution:
    def largestSubmatrix(self, matrix: List[List[int]]) -> int:
        d = {}  # dictionary storing row number and corresponding list of the number of ones
        m, n = len(matrix), len(matrix[0])
        
        for col in range(n):               # for each column
            start = -1      # start is initialized to -1, when we will encounter streak ones  it will be initialized
            
            for row in range(m):
                if matrix[row][col]:        # when the cell contains 1
                    if start == -1:         # when the first one is encountered
                        start = row         # set start to the row number 
                else:                       # when the cell contains a 0
                    if start!=-1:           # if there was a streak ones encountered before
                        end = row
                        for row_index in range(start, end):  
                        # iterate over the beginning of the streak till the end
						# for each row index in the streak assign the key to be row index and the corresponding length of streak starting from that point.
                        
                            if row_index not in d:     # if the row index is not present in the dictionary
                                d[row_index] = []      # create an empty list for the row index
                                
                            d[row_index].append(end - row_index)    # append the length of the streak from the row index
                            
                    start = -1                        # re-initialize start to -1 as the streak is over
    
            if start!=-1:  # if the column has ended but the streak was present uptil the end
			# repeat the same process we did above with an exception, end = m
                end = m
                for row_index in range(start, end):
                    if row_index not in d:
                        d[row_index] = []
                    d[row_index].append(end - row_index)
        
		## finding the max area
        area = 0                                   # initialize area to be 0
        for key in d:                              # for each key -> row index
            l = sorted(d[key], reverse = True)     # sort the list of streak lengths
            ht = l[0]                              # initialize height with the max height
            for i in range(len(l)):                # iterate over the list 
                ht = min(ht, l[i])                 # maximum height possible
                width = i + 1                      # width = i + 1
                area = max(area, ht*width)        # area = height x width
        return area"
cat and mouse ii,"class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        m, n = len(grid), len(grid[0])
        mouse_pos = cat_pos = None
		available = 0 # available steps for mouse and cat
		# Search the start pos of mouse and cat
        for i in range(m):
            for j in range(n):
				if grid[i][j] != '#':
                    available += 1
                if grid[i][j] == 'M':
                    mouse_pos = (i, j)
                elif grid[i][j] == 'C':
                    cat_pos = (i, j)
        
        @functools.lru_cache(None)
        def dp(turn, mouse_pos, cat_pos):
            # if turn == m * n * 2:
			# We already search the whole grid (9372 ms 74.3 MB)
			if turn == available * 2:
				# We already search the whole touchable grid (5200 ms 57.5 MB)
                return False
            if turn % 2 == 0:
                # Mouse
                i, j = mouse_pos
                for di, dj in dirs:
                    for jump in range(mouseJump + 1):
						# Note that we want to do range(mouseJump + 1) instead of range(1, mouseJump + 1)
						# considering the case that we can stay at the same postion for next turn.
                        new_i, new_j = i + di * jump, j + dj * jump
                        if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] != '#':
							# Valid pos
                            if dp(turn + 1, (new_i, new_j), cat_pos) or grid[new_i][new_j] == 'F':
                                return True
                        else:
							# Stop extending the jump since we cannot go further
                            break
                return False
            else:
                # Cat
                i, j = cat_pos
                for di, dj in dirs:
                    for jump in range(catJump + 1):
                        new_i, new_j = i + di * jump, j + dj * jump
                        if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] != '#':
                            if not dp(turn + 1, mouse_pos, (new_i, new_j)) or (new_i, new_j) == mouse_pos or grid[new_i][new_j] == 'F':
							# This condition will also handle the case that the cat cannot jump through the mouse
                                return False
                        else:
                            break
                return True
				
        return dp(0, mouse_pos, cat_pos)"
cat and mouse ii,"class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        m, n = len(grid), len(grid[0]) # dimensions 
        walls = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ""F"": food = (i, j)
                elif grid[i][j] == ""C"": cat = (i, j)
                elif grid[i][j] == ""M"": mouse = (i, j)
                elif grid[i][j] == ""#"": walls.add((i, j))
                    
        @lru_cache(None)
        def fn(cat, mouse, turn): 
            """"""Return True if mouse wins.""""""
            if cat == food or cat == mouse or turn >= m*n*2: return False 
            if mouse == food: return True  # mouse reaching food
            
            if not turn &amp; 1: # mouse moving 
                x, y = mouse
                for dx, dy in (-1, 0), (0, 1), (1, 0), (0, -1): 
                    for jump in range(0, mouseJump+1):
                        xx, yy = x+jump*dx, y+jump*dy
                        if not (0 <= xx < m and 0 <= yy < n) or (xx, yy) in walls: break 
                        if fn(cat, (xx, yy), turn+1): return True 
                return False 
            else: # cat moving
                x, y = cat
                for dx, dy in (-1, 0), (0, 1), (1, 0), (0, -1): 
                    for jump in range(0, catJump+1):
                        xx, yy = x+jump*dx, y+jump*dy
                        if not (0 <= xx < m and 0 <= yy < n) or (xx, yy) in walls: break 
                        if not fn((xx, yy), mouse, turn+1): return False
                return True
                    
        return fn(cat, mouse, 0)"
find the highest altitude,"class Solution(object):
    def largestAltitude(self, gain):
        """"""
        :type gain: List[int]
        :rtype: int
        """"""
		#initialize a variable to store the end output
        result = 0
		#initialize a variable to keep track of the altitude at each iteration
        current_altitude=0
		#looping through each of the gains
        for g in gain:
		#updating the current altitude based on the gain
            current_altitude += g
			#if the current altitude is greater than the highest altitude recorded then assign it as the result. This done iteratively, allows us to find the highest altitude
            if current_altitude > result:
                result = current_altitude
        return result"
find the highest altitude,"class Solution:
    def largestAltitude(self, gain: List[int]) -> int:
        ans=[0]
        for i in range(len(gain)):
            ans.append(ans[i]+gain[i])            
        return max(ans)"
minimum number of people to teach,"class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        m = len(languages)
        languages = [set(x) for x in languages]
        
        mp = {}
        for u, v in friendships: 
            if not languages[u-1] &amp; languages[v-1]: 
                for i in range(n):
                    if i+1 not in languages[u-1]: mp.setdefault(u-1, set()).add(i)
                    if i+1 not in languages[v-1]: mp.setdefault(v-1, set()).add(i)
        
        ans = inf
        for i in range(n): 
            val = 0
            for k in range(m): 
                if i in mp.get(k, set()): val += 1
            ans = min(ans, val)
        return ans"
minimum number of people to teach,"class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        languages = [set(x) for x in languages]
        
        users = set()
        for u, v in friendships: 
            if not languages[u-1] &amp; languages[v-1]: 
                users.add(u-1)
                users.add(v-1)
        
        freq = {}
        for i in users: 
            for k in languages[i]:
                freq[k] = 1 + freq.get(k, 0)
        return len(users) - max(freq.values(), default=0)"
decode xored permutation,"class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        n = len(encoded)+1
        XOR = 0
        for i in range(1,n+1):
            XOR = XOR^i
        
        s = 0
        for i in range(1,n,2):
            s = s^encoded[i]
        res = [0]*n
        res[0] = XOR^s
        
        for j in range(1,n):
            res[j] = res[j-1]^encoded[j-1]
        return res"
decode xored permutation,"class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        l=[]
        x=0
        n=len(encoded)+1
        for i in range (1,n+1):      # xor of 1 to n+1
            x^=i
            #print(x)
        for i in range (len(encoded)):   #xor of normal array whoes index is odd
            if i%2==1:
                x^=encoded[i]
                print(x)                 #finding first element of an output
        l.append(x)
        #print(l)
        for i in range (len(encoded)):        #finding first element then calculating xor with encoded elements 
            x=l[i]^encoded[i]
            l.append(x)
        return l"
count ways to make array with product,"class Solution:
    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        # brute DP O(NK) where N is max(q[0]) and K is max(q[1])
        @cache
        def dp(n,k):
            
            if k == 1 or n == 1: return 1
            ways = 0
            for factor in range(1, k+1):
                if k % factor == 0:
                    ways += dp(n-1, k//factor) # or take the '3' part
                    ways %= (10**9+7)
            return ways % (10**9+7)
        
        res = [0] * len(queries)
        for i,(n, k) in enumerate(queries):
            res[i] = dp(n,k)
        
        return res
            
        # better solution -> find out how many prime factors a number has.
        # how many ways to group P numbers into N groups (since array has N values only)
        # but you can group in lesser groups and keep 1 1 1 1 as padding in array :("
count ways to make array with product,"class Solution:
    def waysToFillArray(self, queries, mod = 10**9+7) -> List[int]:
        def getPrimeFactorFreq(n):
            i = 2
            while i*i <= n:
                fre = 0
                while n % i == 0:
                    fre += 1
                    n //= i
                if fre > 0: yield fre
                i += 1
            if n > 1:
                yield 1
    
        @functools.cache
        def combinations(n, r):
            if n < r: return 0
            elif r == 0 or n == r: return 1
            return (combinations(n-1,r-1) + combinations(n-1,r)) % mod
        
        def getWays(n, k):
            ways = 1
            for fre in getPrimeFactorFreq(k):
                print('--', fre)
                # how many ways to place this factor
                # among N boxes, he has `fre` occurance
                # https://cp-algorithms.com/combinatorics/stars_and_bars.html
                ways_cur_factor = combinations(n+fre-1, fre)
                ways = (ways * ways_cur_factor) % mod
            return ways
        
        
        return [getWays(n,k) for n,k in queries]"
latest time by replacing hidden digits,"class Solution:
    def maximumTime(self, time: str) -> str:
        time = list(time)
        for i in range(len(time)): 
            if time[i] == ""?"": 
                if i == 0: time[i] = ""2"" if time[i+1] in ""?0123"" else ""1""
                elif i == 1: time[i] = ""3"" if time[0] == ""2"" else ""9""
                elif i == 3: time[i] = ""5""
                else: time[i] = ""9""
        return """".join(time)"
latest time by replacing hidden digits,"class Solution:
    def maximumTime(self, time: str) -> str:
        maxTime = ""23:59"" if time[0] in ""?2"" and time[1] in ""?0123"" else ""19:59""
        return """".join(t if t != ""?"" else m for t, m in zip(time, maxTime))"
change minimum characters to satisfy one of three conditions,"class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        pa, pb = [0]*26, [0]*26
        for x in a: pa[ord(x)-97] += 1
        for x in b: pb[ord(x)-97] += 1
        
        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3
        for i in range(25): 
            pa[i+1] += pa[i]
            pb[i+1] += pb[i]
            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2
            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1
        return ans"
find kth largest xor coordinate value,"class Solution:
    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions 
        
        ans = []
        for i in range(m): 
            for j in range(n): 
                if i: matrix[i][j] ^= matrix[i-1][j]
                if j: matrix[i][j] ^= matrix[i][j-1]
                if i and j: matrix[i][j] ^= matrix[i-1][j-1]
                ans.append(matrix[i][j])
        return sorted(ans)[-k]"
find kth largest xor coordinate value,"class Solution:
    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions 
        
        pq = []
        for i in range(m): 
            for j in range(n): 
                if i: matrix[i][j] ^= matrix[i-1][j]
                if j: matrix[i][j] ^= matrix[i][j-1]
                if i and j: matrix[i][j] ^= matrix[i-1][j-1]
                heappush(pq, matrix[i][j])
                if len(pq) > k: heappop(pq)
        return pq[0]"
building boxes,"class Solution:
    def minimumBoxes(self, n: int) -> int:
        x = int((6*n)**(1/3))
        if x*(x+1)*(x+2) > 6*n: x -= 1
        
        ans = x*(x+1)//2
        n -= x*(x+1)*(x+2)//6
        k = 1
        while n > 0: 
            ans += 1
            n -= k
            k += 1
        return ans"
building boxes,"class Solution:
    def minimumBoxes(self, n: int) -> int:
        x = int((6*n)**(1/3))
        if x*(x+1)*(x+2) > 6*n: x -= 1
        n -= x*(x+1)*(x+2)//6
        return x*(x+1)//2 + ceil((sqrt(1+8*n)-1)/2)"
maximum number of balls in a box,"class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        freq = defaultdict(int)
        for x in range(lowLimit, highLimit+1):
            freq[sum(int(xx) for xx in str(x))] += 1
        return max(freq.values())"
maximum number of balls in a box,"class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        boxes = [0] * 100
        
        for i in range(lowLimit, highLimit + 1):
			
			# For the current number ""i"", convert it into a list of its digits.
			# Compute its sum and increment the count in the frequency table.
			
            boxes[sum([int(j) for j in str(i)])] += 1
        
        return max(boxes)"
restore the array from adjacent pairs,"class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        graph = {}
        for u, v in adjacentPairs: 
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
        
        ans = []
        seen = set()
        stack = [next(x for x in graph if len(graph[x]) == 1)]
        while stack: 
            n = stack.pop()
            ans.append(n)
            seen.add(n)
            for nn in graph[n]: 
                if nn not in seen: stack.append(nn)
        return ans"
restore the array from adjacent pairs,"class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
		# create the map 
        adj = collections.defaultdict(list)
        for a, b in adjacentPairs:
            adj[a].append(b)
            adj[b].append(a)

		# find the start num
        start = adjacentPairs[0][0]
        for k, v in adj.items():
            if len(v) ==1:
                start = k
                break
				
		# dfs to connect the graph
        nums=[]
        seen = set()
        def dfs(num):
            seen.add(num)
            for next_num in adj[num]:
                if next_num in seen: continue
                dfs(next_num)
            nums.append(num) 
        dfs(start)
        return nums"
can you eat your favorite candy on your favorite day,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum 
        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]"
palindrome partitioning iv,"class Solution:
    def checkPartitioning(self, s: str) -> bool:
        mp = {}
        for i in range(2*len(s)-1): 
            lo, hi = i//2, (i+1)//2
            while 0 <= lo <= hi < len(s) and s[lo] == s[hi]: 
                mp.setdefault(lo, set()).add(hi)
                lo -= 1
                hi += 1
        
        @lru_cache(None)
        def fn(i, k): 
            """"""Return True if s[i:] can be split into k palindromic substrings.""""""
            if k < 0: return False 
            if i == len(s): return k == 0
            return any(fn(ii+1, k-1) for ii in mp[i])
        
        return fn(0, 3)"
palindrome partitioning iv,"class Solution:
    def checkPartitioning(self, s: str) -> bool:
        mp = defaultdict(set)
        for i in range(2*len(s)-1): 
            lo, hi = i//2, (i+1)//2
            while 0 <= lo <= hi < len(s) and s[lo] == s[hi]: 
                mp[lo].add(hi)
                lo, hi = lo-1, hi+1
        
        for i in range(len(s)):
            for j in range(i+1, len(s)):
                if i-1 in mp[0] and j-1 in mp[i] and len(s)-1 in mp[j]: return True
        return False"
sum of unique elements,"class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        hashmap = {}
        for i in nums:
            if i in hashmap.keys():
                hashmap[i] += 1
            else:
                hashmap[i] = 1
        sum = 0
        for k, v in hashmap.items():
            if v == 1: sum += k
        return sum"
sum of unique elements,"class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        uniq = []
        [uniq.append(num) for num in nums if nums.count(num) == 1]
        return sum(uniq)"
maximum absolute sum of any subarray,"class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        ans = mx = mn = 0
        for x in nums: 
            mx = max(mx + x, 0)
            mn = min(mn + x, 0)
            ans = max(ans, mx, -mn)
        return ans"
maximum absolute sum of any subarray,"class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        min_sum = nums[0]
        curr_min = nums[0]
        
        max_sum = nums[0]
        curr_max = max_sum
        
        for i in range(1, len(nums)):
            curr_max = max(nums[i], curr_max + nums[i])
            max_sum = max(curr_max, max_sum)
        
        for i in range(1, len(nums)):
            curr_min = min(nums[i], curr_min + nums[i])
            min_sum = min(curr_min, min_sum)
        
        return max(abs(max_sum), abs(min_sum))"
minimum length of string after deleting similar ends,"class Solution:
    def minimumLength(self, s: str) -> int:
        dd = deque(s)
        while len(dd) >= 2 and dd[0] == dd[-1]:
            ch = dd[0]
            while dd and dd[0] == ch: dd.popleft()
            while dd and dd[-1] == ch: dd.pop()
        return len(dd)"
minimum length of string after deleting similar ends,"class Solution:
    def minimumLength(self, s: str) -> int:
        while len(s) >= 2 and s[0] == s[-1]: 
            s = s.strip(s[0])
        return len(s)"
maximum number of events that can be attended ii,"class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        
        # The number of events
        n = len(events)
        # Sort the events in chronological order
        events.sort()
        
        # k is the number of events we can attend
        # end is the last event we attended's END TIME
        # event_index is the current event we are checking
        @lru_cache(None)
        def dp(end: int, event_index: int, k: int):
            
            # No more events left or we have checked all possible events
            if k == 0 or event_index == n:
                return 0
            
            event = events[event_index]
            event_start, event_end, event_value = event
            # Can we attend this event?
            # Does its start time conflict with the previous events end time?
            # If the start time is the same as the end time we cannot end as well (view example 2)
            if event_start <= end:
                # Could not attend, check the next event
                return dp(end, event_index + 1, k)
            
            # We made it here, so we can attend!
            # Two possible options, we either attend (add the value) or do not attend this event
            # Value for attending versus the value for skipping
            attend = event_value + dp(event_end, event_index + 1, k - 1)
            skip = dp(end, event_index + 1, k)
            
            # Get the best option
            return max(attend, skip)
            
        # Clear cache to save memory
        dp.cache_clear()
        return dp(0, 0, k)"
maximum number of events that can be attended ii,"class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        events.sort()
        starts = [i for i, _, _ in events]
        
        @cache
        def fn(i, k): 
            """"""Return max score of attending k events from events[i:].""""""
            if i == len(events) or k == 0: return 0 
            ii = bisect_left(starts, events[i][1]+1)
            return max(fn(i+1, k), events[i][2] + fn(ii, k-1))
        
        return fn(0, k)"
check if array is sorted and rotated,"class Solution:
    def check(self, nums: List[int]) -> bool:
        i = 0
        while i<len(nums)-1:
            if nums[i]>nums[i+1]: break    # used to find the rotated position
            i+=1
        
        rotated = nums[i+1:]+nums[:i+1]
        for i,e in enumerate(rotated):
            if i<len(rotated)-1 and e>rotated[i+1]:   # check that rerotated array sorted or not
                return False
        return True"
check if array is sorted and rotated,"class Solution:
    def check(self, nums: List[int]) -> bool:
        cnt = 0
        for i in range(1, len(nums)): 
            if nums[i-1] > nums[i]: cnt += 1
        return cnt == 0 or cnt == 1 and nums[-1] <= nums[0]"
maximum score from removing stones,"class Solution:
    def maximumScore(self, a: int, b: int, c: int) -> int:
        a, b, c = sorted((a, b, c))
        if a + b < c: return a + b
        return (a + b + c)//2"
maximum score from removing stones,"class Solution:
    def maximumScore(self, a: int, b: int, c: int) -> int:
        d = sorted([a,b,c])
        r = 0
        while len(d)>1: # continue removing stones when we have more than one piles
            d[0], d[-1] = d[0] - 1, d[-1] - 1   # removing stones from first and last piles
            if len(d) > 0 and d[-1]==0: # check if the last pile is empty
                d = d[:-1]
            if len(d) > 0 and d[0]==0: # check if the first pile is empty
                d = d[1:]
            r += 1  # increasing score after each step
            d = sorted(d)  # sort piles by stones
        return r"
largest merge of two strings,"class Solution:
    def largestMerge(self, word1: str, word2: str) -> str:
        ans = []
        i1 = i2 = 0
        while i1 < len(word1) and i2 < len(word2): 
            if word1[i1:] > word2[i2:]: 
                ans.append(word1[i1])
                i1 += 1
            else: 
                ans.append(word2[i2])
                i2 += 1
        return """".join(ans) + word1[i1:] + word2[i2:]"
largest merge of two strings,"class Solution:
    def largestMerge(self, w1: str, w2: str) -> str:
        ans=[]
        m,n=len(w1),len(w2)
        i=j=0
        while i<m or j<n:
            if w1[i:]>w2[j:]:
                ans.append(w1[i])
                i+=1
            else:
                ans.append(w2[j])
                j+=1
        return ''.join(ans)"
closest subsequence sum,"class Solution:
    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        
        def fn(nums):
            ans = {0}
            for x in nums: 
                ans |= {x + y for y in ans}
            return ans 
        
        nums0 = sorted(fn(nums[:len(nums)//2]))
        
        ans = inf
        for x in fn(nums[len(nums)//2:]): 
            k = bisect_left(nums0, goal - x)
            if k < len(nums0): ans = min(ans, nums0[k] + x - goal)
            if 0 < k: ans = min(ans, goal - x - nums0[k-1])
        return ans"
closest subsequence sum,"class Solution:
    # @lru_cache
    def solve(self, nums, i, sums, path, goal):
        if i == len(nums):
            # print(path, sums)
            self.res = min(self.res, abs(sums - goal))
            return
        self.solve(nums, i + 1, sums + nums[i], path + [nums[i]], goal)
        self.solve(nums, i + 1, sums, path, goal)

    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        self.res = float(""inf"")
        self.solve(nums, 0, 0, [], goal)
        return self.res"
minimum changes to make alternating binary string,"class Solution:
    def minOperations(self, s: str) -> int:
        count = 0
        count1 = 0
        for i in range(len(s)):
            if i % 2 == 0:
                if s[i] == '1':
                    count += 1
                if s[i] == '0':
                    count1 += 1
            else:
                if s[i] == '0':
                    count += 1
                if s[i] == '1':
                    count1 += 1
        return min(count, count1)"
minimum changes to make alternating binary string,"class Solution:
    def minOperations(self, s: str) -> int:
        cnt = 0 # ""010101...""
        for i, c in enumerate(s): 
            if i&amp;1 == int(c): cnt += 1
        return min(cnt, len(s) - cnt)"
count number of homogenous substrings,"class Solution:
    def countHomogenous(self, s: str) -> int:
        res, count, n = 0, 1, len(s)
        for i in range(1,n):
            if s[i]==s[i-1]:
                count+=1
            else:
                if count>1:
                    res+=(count*(count-1)//2)
                count=1    
        if count>1:
            res+=(count*(count-1)//2)
        return (res+n)%(10**9+7)"
count number of homogenous substrings,"class Solution:
	def countHomogenous(self, s: str) -> int:
		count = 0
		for i, j in itertools.groupby(s):
			temp = len(list(j))
			count += (temp * (temp + 1)) // 2

		return count % (10 ** 9 + 7)"
minimum limit of balls in a bag,"class Solution:
    def minimumSize(self, nums: List[int], maxOperations: int) -> int:
        lo, hi = 1, 1_000_000_000
        while lo < hi: 
            mid = lo + hi >> 1
            if sum((x-1)//mid for x in nums) <= maxOperations: hi = mid
            else: lo = mid + 1
        return lo"
minimum limit of balls in a bag,"class Solution:
    def minimumSize(self, nums: List[int], maxOperations: int) -> int:
        n=len(nums);
        
        #a function that will check if the following ans is valid.
        def check(x,op):
            for i in range(n):
                op-=(nums[i]//x);
                if(nums[i]%x==0):
                    op+=1
            return True if op>=0 else False;
        
        #binary search the value of ans
        #since the min value in the bag can be one
        start=1;
        end=max(nums);#max value can be taken as upper bound.
        ans=-1;
        while start<=end:
            mid=(start+end)//2
            
            if(check(mid,maxOperations)):
                ans=mid;
                end=mid-1
            else:
                start=mid+1;
            
        return ans;"
minimum degree of a connected trio in a graph,"class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        graph = [[False]*n for _ in range(n)]
        degree = [0]*n
        
        for u, v in edges: 
            graph[u-1][v-1] = graph[v-1][u-1] = True
            degree[u-1] += 1
            degree[v-1] += 1
        
        ans = inf
        for i in range(n): 
            for j in range(i+1, n):
                if graph[i][j]: 
                    for k in range(j+1, n):
                        if graph[j][k] and graph[k][i]: 
                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6)
        return ans if ans < inf else -1"
minimum degree of a connected trio in a graph,"class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        
        for l in edges:
            l.sort()
        
        trios = self.findTrios(n, edges)
        # Go through each trio
        degrees = []
        for t in trios:
            degree = 0
            for e in edges:
                otherEdge = any(_ in t for _ in e)
                if otherEdge:
                    degree += 1
            
            # Will find three edges that are part of the trio
            degree -= 3
            degrees.append(degree)
        
        minDegree = -1 if not degrees else min(degrees)
        
        return minDegree
        
        
        
    # Find all trios and return them in a list
    def findTrios (self, n, edges) -> List[List[int]]:
        trios = []
        # For every edge
        for edge in edges:
            # Check every node
            for node in range(1, n+1):
                # If the node has an edge to each node in the edge
                if sorted([edge[0], node]) in edges and sorted([edge[1], node]) in edges:
                    # It must be a trio then
                    trio = sorted([node, edge[0], edge[1]])
                    if trio not in trios:
                        trios.append(trio)
        
        return trios"
longest nice substring,"class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        ans = """"
        for i in range(len(s)):
            for ii in range(i+1, len(s)+1):
                if all(s[k].swapcase() in s[i:ii] for k in range(i, ii)): 
                    ans = max(ans, s[i:ii], key=len)
        return ans"
longest nice substring,"class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        if not s: return """" # boundary condition 
        ss = set(s)
        for i, c in enumerate(s):
            if c.swapcase() not in ss: 
                s0 = self.longestNiceSubstring(s[:i])
                s1 = self.longestNiceSubstring(s[i+1:])
                return max(s0, s1, key=len)
        return s"
form array by concatenating subarrays of another array,"class Solution:
    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
        i = 0
        for grp in groups: 
            for ii in range(i, len(nums)):
                if nums[ii:ii+len(grp)] == grp: 
                    i = ii + len(grp)
                    break 
            else: return False
        return True"
form array by concatenating subarrays of another array,"class Solution:
    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
        groups = ['-'.join(str(s) for s in group) for group in groups]
        nums = '-'.join(str(s) for s in nums)
        j = k = 0
        while k < len(groups):
            group = groups[k]
            i = nums.find(group, j)
            if i == -1: return False
            if i == 0 or i > 0 and nums[i-1] == '-':
                j = i + len(group)
                k += 1
            else: j += 1
        return True"
map of highest peak,"class Solution:
    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
        m, n = len(isWater), len(isWater[0]) # dimensions 
        queue = [(i, j) for i in range(m) for j in range(n) if isWater[i][j]]
        
        ht = 0
        ans = [[0]*n for _ in range(m)]
        seen = set(queue)
        
        while queue: 
            newq = []
            for i, j in queue: 
                ans[i][j] = ht
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: 
                        newq.append((ii, jj))
                        seen.add((ii, jj))
            queue = newq
            ht += 1
        return ans"
map of highest peak,"class Solution:
    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
        m, n = len(isWater), len(isWater[0]) # dimensions 
        
        ans = [[-1]*n for _ in range(m)]
        queue = deque()
        for i in range(m): 
            for j in range(n):
                if isWater[i][j]:
                    queue.append((i, j))
                    ans[i][j] = 0

        while queue: 
            i, j = queue.popleft()
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 <= ii < m and 0 <= jj < n and ans[ii][jj] == -1: 
                    ans[ii][jj] = 1 + ans[i][j]
                    queue.append((ii, jj))
        return ans"
tree of coprimes,"class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        tree = {} # tree as adjacency list 
        for u, v in edges: 
            tree.setdefault(u, []).append(v)
            tree.setdefault(v, []).append(u)
        
        ans = [-1]*len(nums)
        path = {} # val -> list of position &amp; depth 
        seen = {0}
        
        def fn(k, i): 
            """"""Populate ans via dfs.""""""
            ii = -1 
            for x in path:
                if gcd(nums[k], x) == 1: # coprime 
                    if path[x] and path[x][-1][1] > ii: 
                        ans[k] = path[x][-1][0]
                        ii = path[x][-1][1]
                        
            path.setdefault(nums[k], []).append((k, i))
            for kk in tree.get(k, []): 
                if kk not in seen: 
                    seen.add(kk)
                    fn(kk, i+1)
            path[nums[k]].pop()
            
            
        fn(0, 0)
        return ans"
tree of coprimes,"class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        
        gcdset = [set() for i in range(51)]
        for i in range(1,51):
            for j in range(1,51):
                if math.gcd(i,j) == 1:
                    gcdset[i].add(j)
                    gcdset[j].add(i)
        
        graph = defaultdict(list)
        for v1, v2 in edges:
            graph[v1].append(v2)
            graph[v2].append(v1)
        
        ans = [-1]*len(nums)
        q = [[0, {}]]
        seen = set([0])
        depth = 0
        while q:
            temp = []
            for node, ancestors in q:
                index_depth = (-1,-1)
                for anc in list(ancestors.keys()):
                    if anc in gcdset[nums[node]]:
                        index, d = ancestors[anc]
                        if d > index_depth[1]:
                            index_depth = (index,d)
                ans[node] = index_depth[0]
                
                copy = ancestors.copy()
                copy[nums[node]] = (node,depth)
                
                for child in graph[node]:
                    if child not in seen:
                        seen.add(child)
                        temp.append([child, copy])
            q = temp
            depth += 1
        return ans"
merge strings alternately,"class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        
        res=''
        
        for i in range(min(len(word1),len(word2))):
            res += word1[i] + word2[i]
            
        return res + word1[i+1:] + word2[i+1:]"
merge strings alternately,"class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        ans = []
        for x, y in zip_longest(word1, word2, fillvalue=""""):
            ans.append(x)
            ans.append(y)
        return """".join(ans)"
minimum number of operations to move all balls to each box,"class Solution:
    def minOperations(self, boxes: str) -> List[int]:
        ans = [0]*len(boxes)
        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)
        for i in range(1, n):
            if boxes[i-1] == '1': leftCount += 1
            leftCost += leftCount # each step move to right, the cost increases by # of 1s on the left
            ans[i] = leftCost
        for i in range(n-2, -1, -1):
            if boxes[i+1] == '1': rightCount += 1
            rightCost += rightCount
            ans[i] += rightCost
        return ans"
minimum number of operations to move all balls to each box,"class Solution:
    def minOperations(self, boxes: str) -> List[int]:
        l = len(boxes)
        ans = [0] * l
        before = 0
        after = 0
        num = 0
        for i in range(l):
            if boxes[i] == ""1"":
                after += 1
                num += i
        for i in range(l):
            ans[i] = num
            if boxes[i] == ""1"":
                before += 1
                after -= 1
            num += before - after
        return ans"
maximum score from performing multiplication operations,"class Solution:
    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        n, m = len(nums), len(multipliers)
        dp = [[0]*m for _ in range(m+1)]
        
        for i in reversed(range(m)):
            for j in range(i, m): 
                k = i + m - j - 1
                dp[i][j] = max(nums[i] * multipliers[k] + dp[i+1][j], nums[j-m+n] * multipliers[k] + dp[i][j-1])
        
        return dp[0][-1]"
maximum score from performing multiplication operations,"class Solution:
    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        
        @lru_cache(2000)
        def fn(lo, hi, k):
            """"""Return max score from nums[lo:hi+1].""""""
            if k == len(multipliers): return 0
            return max(nums[lo] * multipliers[k] + fn(lo+1, hi, k+1), nums[hi] * multipliers[k] + fn(lo, hi-1, k+1))
        
        return fn(0, len(nums)-1, 0)"
maximize palindrome length from subsequences,"class Solution:
    def longestPalindrome(self, word1: str, word2: str) -> int:
        
        @cache
        def fn(lo, hi):
            """"""Return length of longest palindromic subsequence.""""""
            if lo >= hi: return int(lo == hi)
            if word[lo] == word[hi]: return 2 + fn(lo+1, hi-1)
            return max(fn(lo+1, hi), fn(lo, hi-1))
        
        ans = 0
        word = word1 + word2
        for x in ascii_lowercase: 
            i = word1.find(x) 
            j = word2.rfind(x)
            if i != -1 and j != -1: ans = max(ans, fn(i, j + len(word1)))
        return ans"
maximize palindrome length from subsequences,"class Solution:
    def longestPalindrome(self, word1: str, word2: str) -> int:
        s1 = word1 + word2
        n = len(s1)
        dp = [[0] * n for i in range(n)]
        ans = 0
        for i in range(n-1,-1,-1):
		# mark every character as a 1 length palindrome
            dp[i][i] = 1
            for j in range(i+1,n):
			# new palindrome is found
                if s1[i] == s1[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
					# if the palindrome includes both string consider it as a valid
                    if i < len(word1) and j >= len(word1):
                        ans = max(ans,dp[i][j])
                else:
                    dp[i][j] = max(dp[i][j-1],dp[i+1][j])
        
        return ans"
count items matching a rule,"class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        d = {'type': 0, 'color': 1, 'name': 2}
        return sum(1 for item in items if item[d[ruleKey]] == ruleValue)"
count items matching a rule,"class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        return sum(1 for t, c, n in items if (ruleKey, ruleValue) in ((""type"", t), (""color"", c), (""name"", n)))"
closest dessert cost,"class Solution:
    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:
        toppingCosts *= 2
        
        @cache
        def fn(i, x):
            """"""Return sum of subsequence of toppingCosts[i:] closest to x.""""""
            if x < 0 or i == len(toppingCosts): return 0
            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))
        
        ans = inf
        for bc in baseCosts: 
            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))
        return ans"
closest dessert cost,"class Solution:
    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:
        
        @cache
        def fn(i, cost):
            """"""Return sum of subsequence closest to target.""""""
            if cost >= target or i == len(toppingCosts): return cost
            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))
        
        ans = inf
        toppingCosts *= 2
        for cost in baseCosts: 
            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))
        return ans"
equal sum arrays with minimum number of operations,"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible 
        
        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1
        s1, s2 = sum(nums1), sum(nums2)
            
        nums1 = [-x for x in nums1] # max-heap 
        heapify(nums1)
        heapify(nums2)
        
        ans = 0
        while s1 > s2: 
            x1, x2 = nums1[0], nums2[0]
            if -1-x1 > 6-x2: # change x1 to 1
                s1 += x1 + 1
                heapreplace(nums1, -1)
            else: 
                s2 += 6 - x2
                heapreplace(nums2, 6)
            ans += 1
        return ans"
equal sum arrays with minimum number of operations,"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible 
        
        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1
        s1, s2 = sum(nums1), sum(nums2) # s1 >= s2
            
        nums1.sort()
        nums2.sort()
        
        ans = j = 0
        i = len(nums1)-1
        
        while s1 > s2: 
            if j >= len(nums2) or 0 <= i and nums1[i] - 1 > 6 - nums2[j]: 
                s1 += 1 - nums1[i]
                i -= 1
            else: 
                s2 += 6 - nums2[j]
                j += 1
            ans += 1
        return ans"
car fleet ii,"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        # Stack: go from back and use stack to get ans
        # Time: O(n)
        # Space: O(n)
        
        stack = [] # index
        ans = [-1] * len(cars)
        for i in range(len(cars)-1,-1,-1):
            # remove cars that are faster than current car since it will never collide
            while stack and cars[i][1] <= cars[stack[-1]][1]: 
                stack.pop()

            while stack: # if car left, we can compute collide time with current car. 
                collision_t = (cars[stack[-1]][0] - cars[i][0]) / (cars[i][1] - cars[stack[-1]][1])
                # if current car's collide time is greater than previous car's collide time 
                # (previous collided before current), then we have to find previous car's previous car
                # to compute collide time with that car, so we pop from stack and re-process
                # Otherwise, we add that collide time to answer and break
                if ans[stack[-1]] == -1 or collision_t <= ans[stack[-1]]:
                    ans[i] = collision_t
                    break
                stack.pop()
            stack.append(i)
        return ans"
car fleet ii,"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        n=len(cars)
        ans=[-1]*n
        stack=[]
        for i in range(n-1,-1,-1):
            while stack and cars[i][1]<=cars[stack[-1]][1]:
                stack.pop()
            while stack:
                collisionTime=(cars[stack[-1]][0]-cars[i][0])/(cars[i][1]-cars[stack[-1]][1])
                if collisionTime<=ans[stack[-1]] or ans[stack[-1]]==-1:
                    ans[i]=collisionTime
                    break
                stack.pop()
            stack.append(i)
        return ans"
find nearest point that has the same x or y coordinate,"class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        minDist = math.inf
        ans = -1
        for i in range(len(points)):
            if points[i][0]==x or points[i][1]==y:
                manDist = abs(points[i][0]-x)+abs(points[i][1]-y)
                if manDist<minDist:
                    ans = i
                    minDist = manDist
        return ans"
find nearest point that has the same x or y coordinate,"class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        result = None
        maximumDistance = float(""inf"")
        
        for index,point in enumerate(points):
            a,b = point
            distance = abs(x-a) + abs(y-b)
            if distance < maximumDistance and (x == a or y == b):
                maximumDistance = distance
                result = index
        
        return result if result != None else -1"
check if number is a sum of powers of three,"class Solution:
    def checkPowersOfThree(self, n: int) -> bool:
        while n:
            n, rem = divmod(n, 3)
            if rem == 2:
                return False
        return True"
check if number is a sum of powers of three,"class Solution:
    def checkPowersOfThree(self, n: int) -> bool:
        while(n>=1):
            if n%3==2: return False
            n=n//3
        return True"
sum of beauty of all substrings,"class Solution:
    def beautySum(self, s: str) -> int:
        ans = 0 
        for i in range(len(s)):
            freq = [0]*26
            for j in range(i, len(s)):
                freq[ord(s[j])-97] += 1
                ans += max(freq) - min(x for x in freq if x)
        return ans"
sum of beauty of all substrings,"class Solution:
    def beautySum(self, s: str) -> int:
        c, n, ans = Counter(s), len(s), 0
        for i in range(n-2):
            x=c.copy()
            for j in range(n-1,i+1,-1):
                ans+=max(x.values())-min(x.values())
                if x[s[j]]==1:
                    del x[s[j]]
                else:
                    x[s[j]]-=1
            if c[s[i]]==1:
                del c[s[i]]
            else:
                c[s[i]]-=1
        return ans"
count pairs of nodes,"class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        degree = [0]*n
        freq = defaultdict(int)
        for u, v in edges: 
            degree[u-1] += 1
            degree[v-1] += 1
            freq[min(u-1, v-1), max(u-1, v-1)] += 1
        
        vals = sorted(degree)
        
        ans = []
        for query in queries: 
            cnt = 0 
            lo, hi = 0, n-1
            while lo < hi: 
                if query < vals[lo] + vals[hi]: 
                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid
                    hi -= 1
                else: lo += 1
            for u, v in freq: 
                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1
            ans.append(cnt)
        return ans"
check if binary string has at most one segment of ones,"class Solution:
    def checkOnesSegment(self, s: str) -> bool:
        return ""01"" not in s"
check if binary string has at most one segment of ones,"class Solution:
    def checkOnesSegment(self, s: str) -> bool:
        s = s.strip(""0"")
        return (""0"" not in s)"
minimum elements to add to form a given sum,"class Solution:
    def minElements(self, nums: List[int], limit: int, goal: int) -> int:
        return math.ceil(abs(goal - sum(nums)) / limit)"
minimum elements to add to form a given sum,"class Solution:
    def minElements(self, nums: List[int], limit: int, goal: int) -> int:
        return ceil(abs(goal - sum(nums))/limit)"
number of restricted paths from first to last node,"class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        graph = {} # graph as adjacency list 
        for u, v, w in edges: 
            graph.setdefault(u, []).append((v, w))
            graph.setdefault(v, []).append((u, w))
        
        queue = [n]
        dist = {n: 0}
        while queue: 
            newq = []
            for u in queue: 
                for v, w in graph[u]:
                    if v not in dist or dist[u] + w < dist[v]: 
                        dist[v] = dist[u] + w
                        newq.append(v)
            queue = newq
        
        @cache
        def fn(u): 
            """"""Return number of restricted paths from u to n.""""""
            if u == n: return 1 # boundary condition 
            ans = 0
            for v, _ in graph[u]: 
                if dist[u] > dist[v]: ans += fn(v)
            return ans 
        
        return fn(1) % 1_000_000_007"
number of restricted paths from first to last node,"class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        graph = {} # graph as adjacency list 
        for u, v, w in edges: 
            graph.setdefault(u-1, []).append((v-1, w))
            graph.setdefault(v-1, []).append((u-1, w))
        
        # dijkstra's algo
        pq = [(0, n-1)]
        dist = [inf]*(n-1) + [0]
        while pq: 
            d, u = heappop(pq)
            for v, w in graph[u]: 
                if dist[u] + w < dist[v]: 
                    dist[v] = dist[u] + w
                    heappush(pq, (dist[v], v))
        
        @cache
        def fn(u): 
            """"""Return number of restricted paths from u to n.""""""
            if u == n-1: return 1 # boundary condition 
            ans = 0
            for v, _ in graph[u]: 
                if dist[u] > dist[v]: ans += fn(v)
            return ans 
        
        return fn(0) % 1_000_000_007"
make the xor of all segments equal to zero,"class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        freq = defaultdict(lambda: defaultdict(int))
        for i, x in enumerate(nums): freq[i%k][x] += 1 # freq by row
        
        n = 1 << 10
        dp = [0] + [-inf]*(n-1)
        for i in range(k): 
            mx = max(dp)
            tmp = [0]*n
            for x, c in enumerate(dp): 
                for xx, cc in freq[i].items(): 
                    tmp[x^xx] = max(tmp[x^xx], c + cc, mx)
            dp = tmp 
        return len(nums) - dp[0]"
check if one string swap can make strings equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        diff = [[x, y] for x, y in zip(s1, s2) if x != y]
        return not diff or len(diff) == 2 and diff[0][::-1] == diff[1]"
check if one string swap can make strings equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        
        if s1==s2: #strings are equal no swapping required
            return True
        if sorted(s1)!=sorted(s2): #if alphabets of strings are not equal
            return False
        countof=0
        for i in range(len(s1)):
            if s1[i]!=s2[i]:#checking diff aplphabets of both the strings
                countof +=1
        if countof!=2:
                return False
        return True"
find center of star graph,"class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        
        """""" From the Constraints: A valid STAR GRAPH is confirmed. 
		That means the center will be common to every edges. 
		Therefore we can get the center by comparing only first 2 elements""""""
        
        for i in range (1):
            
            # Check if first element of first edge mathches with any element of second edges
            
            if edges[i][0] == edges [i+1][0] or edges[i][0] == edges[i+1][1]:
                return edges[i][0]
            
            #Otherwise second element of first edge will be the answer
            else:
                return edges[i][1]"
find center of star graph,"class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        if edges[0][0] in edges[1]: return edges[0][0]
        return edges[0][1]"
maximum average pass ratio,"class Solution:
	def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
		
		n = len(classes)
		
		impacts = [0]*n
		minRatioIndex = 0
		
		# calculate and store impacts for each class in form of tuples -> (-impactValue, passCount, totalCount)
		for i in range(n):
			passCount = classes[i][0]
			totalCount = classes[i][1]
			
			# calculate the impact  for class i
			currentRatio = passCount/totalCount
			expectedRatioAfterUpdate = (passCount+1)/(totalCount+1)
			impact = expectedRatioAfterUpdate - currentRatio
			
			impacts[i] = (-impact, passCount, totalCount)  # note the - sign for impact
			
		heapq.heapify(impacts)
		
		while(extraStudents > 0):
			# pick the next class with greatest impact 
			_, passCount, totalCount = heapq.heappop(impacts)
			
			# assign a student to the class
			passCount+=1
			totalCount+=1
			
			# calculate the updated impact  for current class
			currentRatio = passCount/totalCount
			expectedRatioAfterUpdate = (passCount+1)/(totalCount+1)
			impact = expectedRatioAfterUpdate - currentRatio
			
			# insert updated impact back into the heap
			heapq.heappush(impacts, (-impact, passCount, totalCount))
			extraStudents -= 1
		
		result = 0
			
		# for all the updated classes calculate the total passRatio 
		for _, passCount, totalCount in impacts:
			result += passCount/totalCount
			
		# return the average pass ratio
		return result/n"
maximum average pass ratio,"class Solution:
    def maxAverageRatio(self, classes: List[List[int]], e: int) -> float:
        heap=[]
        for i,j in classes:
            diff=(i+1)/(j+1)-(i/j)
            heapq.heappush(heap,(-diff,i,j))
        while(e>0):
            diff,i,j=heapq.heappop(heap)
            i+=1
            j+=1
            diff=(i+1)/(j+1)-(i/j)
            heapq.heappush(heap,(-diff,i,j))
            e-=1
        ans=0
        for diff,i,j in heap:
            ans+=(i/j)
        return ans/len(classes)"
maximum score of a good subarray,"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        ans = mn = nums[k]
        lo = hi = k
        while 0 <= lo-1 or hi+1 < len(nums): 
            if lo == 0 or hi+1 < len(nums) and nums[lo-1] < nums[hi+1]: 
                hi += 1
                mn = min(mn, nums[hi])
            else: 
                lo -= 1
                mn = min(mn, nums[lo])
            ans = max(ans, mn * (hi-lo+1))
        return ans"
maximum score of a good subarray,"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        
        N = len(nums)
        
        def next_small_left():
            
            i = 0
            left=[-1]*N
            stack=[]
            for i in range(N):
                while stack and nums[stack[-1]] >= nums[i]:
                    stack.pop()
                if stack:
                    left[i] = stack[-1]
                stack.append(i)
            
            return left
            
        
        def next_small_right():
            right=[N]*N
            stack=[]
            for i in range(N-1,-1,-1):
                while stack and nums[stack[-1]] >= nums[i]:
                    stack.pop()
                if stack:
                    right[i] = stack[-1]
                stack.append(i)
            
            return right
        
        left = next_small_left()
        right = next_small_right()
        # print(left,right)
        N = len(left)
        ans=-1
        for i in range(N):
            if left[i]+1 <= k <= right[i]-1:
                ans = max(ans,(right[i]-left[i]-1)*nums[i])
                # print(i,ans)
        return ans"
second largest digit in a string,"class Solution:
    def secondHighest(self, s: str) -> int:
        s=set(s)
        a=[]
        for i in s:
            if i.isnumeric() :
                a.append(int(i))
        a.sort()
        if len(a)<2:
            return -1
        return a[len(a)-2]"
second largest digit in a string,"class Solution:
    def secondHighest(self, s: str) -> int:
        l = []
        for i in s:
            if i.isdigit() and i not in l:
                l.append(i)
        if len(l) >= 2:
            return int(sorted(l)[-2])
        else:
            return -1"
maximum number of consecutive values you can make,"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        coins.sort()
        
        res = 1
        
        for coin in coins:
            if (res >= coin):
                res += coin
        
        return res"
maximum number of consecutive values you can make,"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        coins.sort()
        ans = 0
        for i in range(len(coins)):
            if coins[i]<=ans+1:
                ans += coins[i]
            else:
                break
        return ans+1"
maximize score after n operations,"class Solution:
    def maxScore(self, nums: List[int]) -> int:
        
        @cache
        def fn(nums, k): 
            """"""Return max score from nums at kth step.""""""
            if not nums: return 0 # boundary condition 
            ans = 0 
            for i in range(len(nums)):
                for j in range(i+1, len(nums)): 
                    rest = nums[:i] + nums[i+1:j] + nums[j+1:]
                    ans = max(ans, k*gcd(nums[i], nums[j]) + fn(tuple(rest), k+1))
            return ans
        
        return fn(tuple(nums), 1)"
maximize score after n operations,"class Solution:
    def maxScore(self, nums: List[int]) -> int:
        n = len(nums)
        
        @cache
        def fn(mask, k): 
            """"""Return maximum score at kth operation with available numbers by mask.""""""
            if mask == 0: return 0 # no more numbers 
            ans = 0
            for i in range(n): 
                if mask &amp; 1 << i:
                    for j in range(i+1, n): 
                        if mask &amp; 1 << j: 
                            mask0 = mask &amp; ~(1<<i) &amp; ~(1<<j) # unset ith &amp; jth bit
                            ans = max(ans, k*gcd(nums[i], nums[j]) + fn(mask0, k+1))
            return ans 
        
        return fn((1<<n) - 1, 1)"
maximum ascending subarray sum,"class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        ans = 0
        for i, x in enumerate(nums): 
            if not i or nums[i-1] >= nums[i]: val = 0 # reset val 
            val += nums[i]
            ans = max(ans, val)
        return ans"
maximum ascending subarray sum,"class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        sum = nums[0]
        x = nums[0]
        i = 1
        while i < len(nums):
            if nums[i] > nums[i-1]:
                x += nums[i]
            else:
                x = nums[i]
            sum = max(x,sum)
            i += 1
        return sum"
number of orders in the backlog,"class Solution:
    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:
        ans = 0
        buy, sell = [], [] # max-heap &amp; min-heap 
        
        for p, q, t in orders: 
            ans += q
            if t: # sell order
                while q and buy and -buy[0][0] >= p: # match 
                    pb, qb = heappop(buy)
                    ans -= 2*min(q, qb)
                    if q < qb: 
                        heappush(buy, (pb, qb-q))
                        q = 0 
                    else: q -= qb 
                if q: heappush(sell, (p, q))
            else: # buy order 
                while q and sell and sell[0][0] <= p: # match 
                    ps, qs = heappop(sell)
                    ans -= 2*min(q, qs)
                    if q < qs: 
                        heappush(sell, (ps, qs-q))
                        q = 0 
                    else: q -= qs 
                if q: heappush(buy, (-p, q))
            
        return ans % 1_000_000_007"
number of orders in the backlog,"class Solution:
    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:
        buy, sell = [], [] # max-heap &amp; min-heap 
        for p, q, t in orders: 
            if t: heappush(sell, [p, q])
            else: heappush(buy, [-p, q])
            
            while buy and sell and -buy[0][0] >= sell[0][0]: 
                qty = min(buy[0][1], sell[0][1])
                buy[0][1] -= qty
                sell[0][1] -= qty
                if not buy[0][1]: heappop(buy)
                if not sell[0][1]: heappop(sell)
        return (sum(q for _, q in sell) + sum(q for _, q in buy)) % 1_000_000_007"
maximum value at a given index in a bounded array,"class Solution:
    def maxValue(self, n: int, index: int, maxSum: int) -> int:
        res_i, crr_sum = 0, n
        l, r, w_hill = index + 1, index - 1, 1 # left/right indices and width of the hill
        while crr_sum <= maxSum:
            l -= 1
            r += 1
            if l == index and r == index:
                crr_sum += w_hill
            else:
                l_, r_ = max(l, 0), min(r, n - 1)
				'''
				when the hill has the same width as the ground, 
				simply just speed up growing by adding the result 
				of dividing (maxSum - crr_sum) by w_hill
				'''
                if l < l_ and r > r_:
                    rm = maxSum - crr_sum
                    res_i += int(rm / w_hill) + 1
                    break
                else:
                    w_hill = r_ - l_ + 1
                    crr_sum += w_hill
            res_i += 1
        return res_i"
maximum value at a given index in a bounded array,"class Solution:
    def maxValue(self, n: int, index: int, maxSum: int) -> int:
        
        def fn(n, x): 
            if n < x: return n*(2*x-n+1)//2
            return x*(1+x)//2 + n - x
        
		# last true binary search
        lo, hi = 0, maxSum
        while lo < hi: 
            mid = lo + hi + 1 >> 1
            sm = fn(index, mid-1) + fn(n-index, mid)
            if sm <= maxSum: lo = mid 
            else: hi = mid - 1
        return lo"
number of different integers in a string,"class Solution:
    def numDifferentIntegers(self, word: str) -> int:
        
        word = re.findall('(\d+)', word)
        numbers = [int(i) for i in word]
        
        return len(set(numbers))"
number of different integers in a string,"class Solution:
    def numDifferentIntegers(self, word: str) -> int:
        seen = set()
        for key, grp in groupby(word, str.isdigit): 
            if key: seen.add(int("""".join(grp)))
        return len(seen)"
minimum number of operations to reinitialize a permutation,"class Solution:
    def reinitializePermutation(self, n: int) -> int:
        ans = 0
        perm = list(range(n))
        while True: 
            ans += 1
            perm = [perm[n//2+(i-1)//2] if i&amp;1 else perm[i//2] for i in range(n)]
            if all(perm[i] == i for i in range(n)): return ans"
minimum number of operations to reinitialize a permutation,"class Solution:
    def reinitializePermutation(self, n: int) -> int:
        res = 0
        
        perm = list(range(n))
        p = perm.copy()
        arr = [0] * n
        
        while arr != p:
            res += 1
            for i in range(n):
                if not i % 2:
                    arr[i] = perm[i // 2]
                else:
                    arr[i] = perm[n // 2 + (i - 1) // 2]
                    
            perm = arr.copy()
                    
        return res"
evaluate the bracket pairs of a string,"class Solution:
    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        knowledge = dict(knowledge)
        answer, start = [], None
        for i, char in enumerate(s):
            if char == '(': 
                start = i + 1
            elif char == ')':
                answer.append(knowledge.get(s[start:i], '?'))
                start = None
            elif start is None: 
                answer.append(char)
        return ''.join(answer)"
evaluate the bracket pairs of a string,"class Solution:
    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        K = { k[0] : k[1] for k in knowledge}
        stack = []
        for ch in s:
            if ch != ')':
                stack.append(ch)
            else:
                word = []
                while stack[-1] != '(':
                    word.append(stack.pop())
                stack.pop()
                stack.append(K.get(''.join(word[::-1]), '?'))
                
        return ''.join(stack)"
maximize number of nice divisors,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        mod = 1_000_000_007
        if primeFactors % 3 == 0: return pow(3, primeFactors//3, mod)
        if primeFactors % 3 == 1: return 1 if primeFactors == 1 else 4*pow(3, (primeFactors-4)//3, mod) % mod
        return 2*pow(3, primeFactors//3, mod) % mod"
determine color of a chessboard square,"class Solution:
    def squareIsWhite(self, c: str) -> bool:
        if c[0] in 'aceg':
            return int(c[1])%2==0
        elif c[0] in 'bdfh':
            return int(c[1])%2==1
        return False"
determine color of a chessboard square,"class Solution:
    def squareIsWhite(self, c: str) -> bool:
        e,o = [""b"",""d"",""f"",""h""], [""a"",""c"",""e"",""g""]
        if int(c[-1]) % 2 == 0:
            if c[0] in e: return False
            else: return True
        else:
            if c[0] in e: return True
            else: return False"
sentence similarity iii,"class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        if len(sentence2)>len(sentence1):
            return self.areSentencesSimilar(sentence2,sentence1)
        sentence1=sentence1.split("" "")
        sentence2=sentence2.split("" "")
        s1=sentence1[:]
        s2=sentence2[:]
        while s1[0]==s2[0]:
                s1.pop(0)
                s2.pop(0)
                if not s2:
                    return True
        if not s2:
            return True
        while s1[-1]==s2[-1]:
                s1.pop()
                s2.pop()
                if not s2:
                    return True
        if not s2:
            return True
        return False"
sentence similarity iii,"class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        lst1, lst2 = sentence1.split("" ""), sentence2.split("" "")
        for i, (a, b) in enumerate(zip(lst1, lst2)):
            if a != b:
                prefix = i
                break
        else:
            return True
        for i, (a, b) in enumerate(zip(lst1[::-1], lst2[::-1])):
            if a != b:
                suffix = i
                break
        else:
            return True
        return prefix + suffix in (len(lst1), len(lst2))"
count nice pairs in an array,"class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        
        # define constants
        n = len(nums)
        MOD = 10**9 + 7
        
        # handle scenario for no pairs
        if n<=1:
            return 0
        
        # utility method to calculate reverse of a number
        # e.g. rev(123) -> 321
        def rev(i):
            new = 0
            while(i!=0):
                r = i%10
                new = new*10+r
                i = i//10
            return new
        
        # calculate frequency of all the diffs
        freq_counter = defaultdict(int)
        for num in nums:
            freq_counter[num-rev(num)] += 1
        
        # for all the frequencies calculate the number of paris
        # which is basically nC2 (read as - ""n choose 2"") -> n*(n-1)/2
        answer = 0
        for freq in freq_counter.keys():
            count = freq_counter[freq]
            # note the modulo operation being performed to handle large answer
            answer = (answer + (count*(count-1))//2)%MOD
                          
        return answer"
count nice pairs in an array,"class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        
        def rev(num):
            return int(str(num)[::-1])
        
        for i in range(len(nums)):
            nums[i] = nums[i] - rev(nums[i])
            
        count = 0
        freq = {}
        
        for i in nums:
            if i in freq.keys(): freq[i] += 1
            else: freq[i] = 1

        for k, v in freq.items():
            count += ((v * (v -1 )) // 2)
            
        return count % (10 ** 9 + 7)"
maximum number of groups getting fresh donuts,"class Solution:
    def maxHappyGroups(self, bs: int, gs: List[int]) -> int:
        c = {i: 0 for i in range(bs)}
        for g in gs:
            c[g % bs] += 1
        ret = c[0]
        c[0] = 0
        
        
        def get_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        def get_diff_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] - 1 if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        for tc in range(2, bs):
            for keys in get_diff_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
        tc = 2
        while True:
            for keys in get_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
            if tc > sum(c.values()): break
            tc += 1
        return ret + bool(sum(c.values()))
            
        ```"
truncate sentence,"class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        words = s.split("" "")
        return "" "".join(words[0:k])"
truncate sentence,"class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        l = list(s.split("" ""))
        return ("" "".join(l[:k]))"
finding the users active minutes,"class Solution:
    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        mp = {}
        for i, t in logs: 
            mp.setdefault(i, set()).add(t)
            
        ans = [0]*k
        for v in mp.values(): 
            if len(v) <= k: 
                ans[len(v)-1] += 1
        return ans"
finding the users active minutes,"class Solution:
    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        # use two-layer dict 
        # first layer record user; second layer record the active minutes 
        
        # 1. Put info. in 2-layer dict O(n)
        d = {}
        for (user, active_min) in logs:
            if not (user in d):
                d[user] = {}
                
            user_log = d[user]
            user_log[active_min] = True 
            
        # 2. Extract info. from 2-layer dict (at most O(n))
        result = [0] * k 
        for user in d:
            result[len(d[user])-1] += 1 # len(d[user]) must >= 1 to exist 
            
        return result"
minimum absolute sum difference,"class Solution:
	def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:
		n = len(nums1)
		diff = []
		sum = 0
		for i in range(n):
			temp = abs(nums1[i]-nums2[i])
			diff.append(temp)
			sum += temp
		nums1.sort()
		best_diff = []
		for i in range(n):
			idx = bisect.bisect_left(nums1, nums2[i])
			if idx != 0 and idx != n:
				best_diff.append(
					min(abs(nums2[i]-nums1[idx]), abs(nums2[i]-nums1[idx-1])))
			elif idx == 0:
				best_diff.append(abs(nums2[i]-nums1[idx]))
			else:
				best_diff.append(abs(nums2[i]-nums1[idx-1]))
		saved = 0
		for i in range(n):
			saved = max(saved, diff[i]-best_diff[i])
		return (sum-saved) % ((10**9)+(7))"
minimum absolute sum difference,"class Solution:
    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:
        nums1, nums2 = zip(*sorted(zip(nums1, nums2)))
        mad = [abs(nums1[i] - nums2[i]) for i in range(len(nums1))]
        M = sum(mad)
        MOD = 10**9 + 7
        best = 0
        for i in range(len(nums1)):
            if nums1[i] != nums2[i]:
                j = bisect.bisect_left(nums1, nums2[i])
                if j == len(nums1):
                    best = max(best, mad[i] - abs(nums1[-1] - nums2[i]))
                elif j == 0:
                    best = max(best, mad[i] - abs(nums1[0] - nums2[i]))
                else:
                    new = min(abs(nums1[j] - nums2[i]), abs(nums1[j-1] - nums2[i]))
                    best = max(best, mad[i] - new)
        return (M - best) % MOD"
number of different subsequences gcds,"class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        nums = set(nums)
        
        ans = 0
        m = max(nums)
        for x in range(1, m+1): 
            g = 0
            for xx in range(x, m+1, x): 
                if xx in nums: 
                    g = gcd(g, xx)
            if g == x: ans += 1
        return ans"
sign of the product of an array,"class Solution:
    def arraySign(self, nums: List[int]) -> int:
        ans = 1
        for x in nums: 
            if x == 0: return 0 
            if x < 0: ans *= -1
        return ans"
sign of the product of an array,"class Solution:
    def arraySign(self, nums: List[int]) -> int:
        signs = False
        for x in nums:
            if x == 0 : return 0
            signs = signs ^ (x < 0)
        if signs : return -1
        else: return 1"
find the winner of the circular game,"class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        nums = list(range(n))
        i = 0 
        while len(nums) > 1: 
            i = (i + k-1) % len(nums)
            nums.pop(i)
        return nums[0] + 1"
find the winner of the circular game,"class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        ans = 0
        for x in range(2, n+1): ans = (ans + k) % x
        return ans + 1"
minimum sideway jumps,"class Solution:
    def minSideJumps(self, obstacles: List[int]) -> int:
        n = len(obstacles)
        dp = [[sys.maxsize] * n for _ in range(3)]
        dp[0][0]= 1
        dp[1][0]= 0
        dp[2][0]= 1
        for i in range(1, n):
            dp[0][i] = dp[0][i-1] if obstacles[i] != 1 else sys.maxsize
            dp[1][i] = dp[1][i-1] if obstacles[i] != 2 else sys.maxsize
            dp[2][i] = dp[2][i-1] if obstacles[i] != 3 else sys.maxsize
            if obstacles[i] != 1:
                for j in [1, 2]:
                    dp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)
            if obstacles[i] != 2:
                for j in [0, 2]:
                    dp[1][i] = min(dp[1][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)
            if obstacles[i] != 3:
                for j in [0, 1]:
                    dp[2][i] = min(dp[2][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)
        return min(dp[0][-1], dp[1][-1], dp[2][-1])"
minimum sideway jumps,"class Solution:
    def minSideJumps(self, obstacles: List[int]) -> int:
        n = len(obstacles)
        a, b, c = 1, 0, 1
        for i in range(1, n):
            a = a if obstacles[i] != 1 else sys.maxsize
            b = b if obstacles[i] != 2 else sys.maxsize
            c = c if obstacles[i] != 3 else sys.maxsize
            if obstacles[i] != 1:
                a = min(a, b + 1 if obstacles[i] != 2 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)
            if obstacles[i] != 2:
                b = min(b, a + 1 if obstacles[i] != 1 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)
            if obstacles[i] != 3:
                c = min(c, a + 1 if obstacles[i] != 1 else sys.maxsize, b + 1 if obstacles[i] != 2 else sys.maxsize)
        return min(a, b, c)"
minimum operations to make the array increasing,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        count = 0
        for i in range(1,len(nums)):
            if nums[i] <= nums[i-1]:
                x = nums[i]
                nums[i] += (nums[i-1] - nums[i]) + 1
                count += nums[i] - x
        return count"
minimum operations to make the array increasing,"class Solution:
	def minOperations(self, nums: List[int]) -> int:
		count = 0

		for i in range(1,len(nums)):
			if nums[i] <= nums[i-1]:
				initial = nums[i] 
				nums[i] = nums[i-1] + 1
				count += nums[i] - initial

		return count"
queries on number of points inside a circle,"class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        return [sum(math.sqrt((x0-x1)**2 + (y0-y1)**2) <= r for x1, y1 in points) for x0, y0, r in queries]"
queries on number of points inside a circle,"class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        points = list(map(complex, *zip(*points)))
		queries = ((complex(x, y), r) for x, y, r in queries)
        return [sum(abs(p - q) <= r for p in points) for q, r in queries]"
maximum xor for each query,"class Solution:
    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:
        res = []
        for i in range(1,len(nums)):
            res.append(2**maximumBit - 1 - nums[i-1])
            nums[i] = nums[i-1]^nums[i]
        res.append(2**maximumBit - 1 - nums[-1])
        return res[::-1]"
maximum xor for each query,"class Solution:
    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:        
        return list(accumulate([nums[0] ^ 2 ** maximumBit - 1] + nums[1:], ixor))[::-1]"
minimum number of operations to make string sorted,"class Solution:
    def makeStringSorted(self, s: str) -> int:
        freq = [0]*26
        for c in s: freq[ord(c) - 97] += 1
        
        MOD = 1_000_000_007
        fac = cache(lambda x: x*fac(x-1)%MOD if x else 1)
        ifac = cache(lambda x: pow(fac(x), MOD-2, MOD)) # Fermat's little theorem (a**(p-1) = 1 (mod p))
        
        ans, n = 0, len(s)
        for c in s: 
            val = ord(c) - 97
            mult = fac(n-1)
            for k in range(26): mult *= ifac(freq[k])
            for k in range(val): ans += freq[k] * mult
            n -= 1
            freq[val] -= 1
        return ans % MOD"
check if the sentence is pangram,"class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        lst=[0]*26
        for i in sentence:
            lst[ord(i)-ord('a')]+=1
        return 0 not in lst"
check if the sentence is pangram,"class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        return len(set(sentence))==26"
maximum ice cream bars,"class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        '''
        1. If the minimum of all costs is greater than amount of coins, the boy can't buy any bar, return 0
        2. Else, sort the list of costs in a non-decreasing order
        3. For each 'cost' in costs, if the cost is less than current coins
                -increase the count of ice cream bars that can be bought by 1
                -decrease the current coins amount by 'cost'
        4. If the cost is greater than current coins, return the ice cream bar count value
        '''
        
        if min(costs)>coins:        #minimum cost is greater than the coins available        
            return 0                #can't buy any ice cream bar
        
        costs=sorted(costs)         #sort the list of costs in a non-decreasing order
        res = 0                     #the resultant count of ice cream bars that can be bought
        for cost in costs:
            if cost<=coins:         #in this case, the boy can buy the ice cream bar
                res+=1              #increase the ice cream bar count
                coins-=cost         #spent an amount equal to 'cost', decrease current coins amount by cost
            else:
                break               #not enough coins, return the bars count
            
        return res"
maximum ice cream bars,"class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        result=0
        costs.sort()
        for i in costs:
            if coins<i:
                break
            result+=1
            coins-=i
        return result"
single threaded cpu,"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        dic=defaultdict(list)
        
        for i in range(len(tasks)):
            dic[tasks[i][0]].append((tasks[i][1],i))
        
        
        ans=[]
        keys=sorted(dic.keys())
        
        while keys:
            k=keys.pop(0)
            pq=dic[k]
            heapq.heapify(pq)
            time=k
            
            while pq:
                p_time,ind=heapq.heappop(pq)
                ans.append(ind)
                time+=p_time
                while keys:
                    if keys[0]>time:
                        break
                    for item in dic[keys.pop(0)]:
                        heapq.heappush(pq,item)
        return ans"
single threaded cpu,"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        heap = []
        available = []
        for i, (e, p) in enumerate(tasks):            
            heappush(heap, (e, p, i))

		e, p, i = heappop(heap)
        last = e + p
        res = [i]        
        while heap or available:            
            while heap and heap[0][0] <= last:
                e, p, i = heappop(heap)
                heappush(available, (p, i, e))
                
            if not available:
                e, p, i = heappop(heap)
                heappush(available, (p, i, e))
                
            p, i, e = heappop(available)
            res.append(i)
            last = max(p + e, last + p)
            
        return res"
find xor sum of all pairs bitwise and,"class Solution:
    #example 1 
    #result =[(1&amp;6)^(1&amp;5)^(2&amp;6)^(2&amp;5)^(3&amp;6)^(3&amp;5)]
                \     /     \    /      \     /
    #           (1&amp;(6^5)) ^ (2&amp;(6^5)) ^ (3&amp;(6^5))   
                   \            |           /
                    \           |          /
                     \          |         /
                      \         |        /
    #                  ((1^2^3) &amp; (6^5))
    def getXORSum(self, a, b):
        x = 0 
        for i in range(len(a)):
            x = x ^ a[i]
        y = 0 
        for j in range(len(b)):
            y = y ^ b[j]
        return x &amp; y"
find xor sum of all pairs bitwise and,"class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        '''
        1. According to the hints, XORSum = (XORSum of arr1) bitwise AND (XORSum of arr2)
        2. Calculate the XOR Sums of arr1 and arr2 separately and store them in separate variables
        3. Perform bitwise AND on those XOR Sums
        '''
        
        xor1 = arr1[0]                      #at first store the first element as the XOR sum of arr1
        xor2 = arr2[0]                      #at first store the first element as the XOR sum of arr2
        
        if len(arr1)>=2:
            for i in range(1,len(arr1)):    
                xor1^=arr1[i]               #iteratively XOR with the next element
            
        if len(arr2)>=2:
            for i in range(1,len(arr2)):
                xor2^=arr2[i]               #iteratively XOR with the next element
                
        return xor1&amp;xor2                    #bitwise AND of XORSum of arr1 and XORSum of arr2"
sum of digits in base k,"class Solution:
    def sumBase(self, n: int, k: int) -> int:
        ans = 0
        while n: 
            n, x = divmod(n, k)
            ans += x
        return ans"
sum of digits in base k,"class Solution:
    def sumBase(self, n: int, k: int) -> int:
        output_sum = 0
        while (n > 0) :
            rem = n % k
            output_sum = output_sum + rem 
            n = int(n / k)
        return output_sum"
frequency of the most frequent element,"class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        sum_s_w = nums[0]
        fin = 1
        i=0
        for j in range(1,n):
            sum_s_w+=nums[j]
            mx = nums[j]
            while sum_s_w+k<mx*(j-i+1):
                sum_s_w -= nums[i]
                i += 1
            fin = max(fin,j-i+1)
        return fin"
frequency of the most frequent element,"class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        nums.sort()
        
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = 0 
        for i in reversed(range(len(nums))): 
            lo, hi = 0, i
            while lo < hi: 
                mid = lo + hi >> 1
                if nums[i] * (i - mid) + prefix[mid] - prefix[i] <= k: hi = mid
                else: lo = mid + 1
            ans = max(ans, i - lo + 1)
        return ans"
longest substring of all vowels in order,"class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        vowels = ""aeiou""
        ans = 0
        cnt = prev = -1 
        for i, x in enumerate(word): 
            curr = vowels.index(x)
            if cnt >= 0: # in the middle of counting 
                if 0 <= curr - prev <= 1: 
                    cnt += 1
                    if x == ""u"": ans = max(ans, cnt)
                elif x == ""a"": cnt = 1
                else: cnt = -1 
            elif x == ""a"": cnt = 1
            prev = curr 
        return ans"
longest substring of all vowels in order,"class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        ans = 0
        cnt = unique = 1
        for i in range(1, len(word)): 
            if word[i-1] <= word[i]: 
                cnt += 1
                if word[i-1] < word[i]: unique += 1
            else: cnt = unique = 1
            if unique == 5: ans = max(ans, cnt)
        return ans"
maximum building height,"class Solution:
    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        restrictions.extend([[1, 0], [n, n-1]])
        restrictions.sort()
        
        for i in reversed(range(len(restrictions)-1)): 
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1] + restrictions[i+1][0] - restrictions[i][0])
        
        ans = 0 
        for i in range(1, len(restrictions)): 
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0])
            ans = max(ans, (restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0] + restrictions[i][1])//2)
        return ans"
maximum building height,"class Solution:
    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        if not restrictions:
            return n - 1
        restrictions.append([1, 0])  # Add the restriction for the initial position
        restrictions.sort(key=lambda x: x[1] + x[0])  # Sort by increasing i + h
        idx = 0  # The index in the restrictions array
        max_height = 0
        while idx < len(restrictions):
            pos, h = restrictions[idx]
            idx += 1
            while idx < len(restrictions) and restrictions[idx][1] - restrictions[idx][0] >= h - pos:
				# skip the next restriction if it is ""above"" the line starting from the current one
                idx += 1
            if idx == len(restrictions):
				# Handles the last restriction: fill the line until the last position at n
                max_height = max(max_height, h + n - pos)
                break
            next_pos, next_h = restrictions[idx]
			# A bit of maths gives us the formula for the maximum height between two consecutive
			# restrictions
            max_height = max(max_height, (h + next_h + next_pos - pos) // 2)
        return max_height"
replace all digits with characters,"class Solution:
    def replaceDigits(self, s: str) -> str:

        ans = """"

        def shift(char, num):
            return chr(ord(char) + int(num))

        for index in range(len(s)):
            ans += shift(s[index-1], s[index]) if index % 2 else s[index]

        return ans"
replace all digits with characters,"class Solution:
    def replaceDigits(self, s: str) -> str:
        return ''.join(chr(ord(s[i-1]) + int(s[i])) if s[i].isdigit() else s[i] for i in range(len(s)))"
maximum element after decreasing and rearranging,"class Solution:
    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
		counter = collections.Counter(arr)
        available = sum(n > len(arr) for n in arr)
        i = ans = len(arr)
        while i > 0:
            # This number is not in arr
            if not counter[i]:
                # Use another number to fill in its place. If we cannot, we have to decrease our max
                if available: available -= 1               
                else: ans -= 1
            # Other occurences can be used for future.
            else:
                available += counter[i] - 1
            i -= 1
        return ans"
maximum element after decreasing and rearranging,"class Solution:
    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
        
        arr.sort()
        arr[0] = 1
        for i in range(1,len(arr)):
            arr[i] = min(arr[i-1]+1,arr[i])
        
        return max(arr)"
closest room,"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans"
minimum distance to the target element,"class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        ans = inf
        for i, x in enumerate(nums): 
            if x == target: 
                ans = min(ans, abs(i - start))
        return ans"
minimum distance to the target element,"class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        if nums[start] == target:return 0
        i, j = start-1, start+1
        while j < len(nums) or i > -1:
            if i > -1:
                if nums[i] == target:
                    return start-i
                i -= 1
            if j < len(nums):
                if nums[j] == target:
                    return j-start
                j += 1"
splitting a string into descending consecutive values,"class Solution:
    def splitString(self, s: str) -> bool:
        
        """"""
        Time = O(2^N)
        Space = O(N) space from stack
        
        """"""
        def dfs(index: int, last: int) -> bool:
            if index == len(s):
                return True
            
			# j: [index, len(s)-1]
            for j in range(index, len(s)):
				# cur: [index, index] ~ [index, len(s)-1]
                cur = int(s[index:j + 1])
				# last: [...,index-1]
				# cur: [index+1, j]
				# last = cur -> next: [j+1,...)
				# DFS condition: cur = last - 1 &amp;&amp; dfs(j+1, cur) == true
                if cur == last - 1 and dfs(j + 1, cur):
                    return True
            return False
        
        for i in range(len(s) - 1):
            last = int(s[:i+1])
            if dfs(i + 1, last):
                return True
        return False"
splitting a string into descending consecutive values,"class Solution:
    def splitString(self, s: str) -> bool:
        s = str(int(s))
        def check(l):
            if len(l)<2:
                return False 
            #print(l)
            for i in range(len(l)-1):
                if int(l[i])!=int(l[i+1])+1:
                    return False
            return True
        
        def backtrack(start,t,s):
            if start==len(s):
                if check(t):
                    return True
            for i in range(start,len(s)):
                if len(s[start:i+1])>1 and len(s[i+1:])>1 and int(s[start:i+1])<int(s[i+1:i+len(s[start:i+1])]):
                    continue
                if len(t)>1 and int(t[-1])<int(s[start:i+1]):
                    return
                t.append(s[start:i+1])
                if backtrack(i+1,t,s):
                    return True
                t.pop()
                
            return False    
        return backtrack(0,[],s)"
minimum adjacent swaps to reach the kth smallest number,"class Solution:
    def getMinSwaps(self, num: str, k: int) -> int:
        num = list(num)
        orig = num.copy()
        
        for _ in range(k): 
            for i in reversed(range(len(num)-1)): 
                if num[i] < num[i+1]: 
                    ii = i+1 
                    while ii < len(num) and num[i] < num[ii]: ii += 1
                    num[i], num[ii-1] = num[ii-1], num[i]
                    lo, hi = i+1, len(num)-1
                    while lo < hi: 
                        num[lo], num[hi] = num[hi], num[lo]
                        lo += 1
                        hi -= 1
                    break 
        
        ans = 0
        for i in range(len(num)): 
            ii = i
            while orig[i] != num[i]: 
                ans += 1
                ii += 1
                num[i], num[ii] = num[ii], num[i]
        return ans"
minimum adjacent swaps to reach the kth smallest number,"class Solution:
    def getMinSwaps(self, num: str, k: int) -> int:
        def next_permutation(nums):
            small = len(nums) - 2
            while small >= 0 and nums[small] >= nums[small+1]: small -= 1 # find last place there is an increase
            if small == -1: nums.reverse()                                # mono-decrease
            else:
                next_larger = small+1
                for i in range(len(nums)-1, small, -1):
                    # find smallest number larger than `nums[small]` from right side of `small`, 
                    #   if there are same value, take the most right one
                    if nums[small] < nums[i]: next_larger = i; break
                nums[small], nums[next_larger] = nums[next_larger], nums[small]
                start = small+1
                nums[start:] = nums[start:][::-1]
            return nums

        origin, num = list(num), list(num)
        for _ in range(k):                    # O(n*k)
            num = next_permutation(num)
        ans, n = 0, len(origin)
        for i in range(n):                    # O(n*n)
            j = num.index(origin[i], i)
            ans += j - i
            num[i:j+1] = [num[j]] + num[i:j]
        return ans"
minimum interval to include each query,"class Solution:
def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
    
    intervals.sort(key = lambda x:x[1]-x[0])
    q = sorted([qu,i] for i,qu in enumerate(queries))
    res=[-1]*len(queries)
	
    for left,right in intervals:
        ind = bisect.bisect(q,[left])
        while ind<len(q) and q[ind][0]<=right:
            res[q.pop(ind)[1]]=right-left+1
    return res"
minimum interval to include each query,"class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
	
        queries_asc = sorted((q, i) for i, q in enumerate(queries))
        intervals.sort()
        
        i, num_intervals = 0, len(intervals)
        size_heap = [] # (size, left)
        
        for pos, qnum in queries_asc:
            
            while i < num_intervals:
                left, right = intervals[i]
                if left > pos:
                    break
                heapq.heappush(size_heap, (right - left + 1, left))
                i += 1
            
            while size_heap:
                size, left = size_heap[0]
                right = left + size - 1
                if right >= pos:
                    break
                heapq.heappop(size_heap)
                   
            queries[qnum] = size_heap[0][0] if size_heap else -1
        
        return queries"
maximum population year,"class Solution:
    def maximumPopulation(self, logs: List[List[int]]) -> int:
        # the timespan 1950-2050 covers 101 years
		delta = [0] * 101

		# to make explicit the conversion from the year (1950 + i) to the ith index
        conversionDiff = 1950 
		
        for l in logs:
			# the log's first entry, birth, increases the population by 1
            delta[l[0] - conversionDiff] += 1 
			
			# the log's second entry, death, decreases the population by 1
            delta[l[1] - conversionDiff] -= 1
        
        runningSum = 0
        maxPop = 0
        year = 1950
		
		# find the year with the greatest population
        for i, d in enumerate(delta):
            runningSum += d
			
			# since we want the first year this population was reached, only update if strictly greater than the previous maximum population
            if runningSum > maxPop:
                maxPop = runningSum
                year = conversionDiff + i
				
        return year"
maximum population year,"class Solution:
    def maximumPopulation(self, logs: List[List[int]]) -> int:
        vals = []
        for x, y in logs: 
            vals.append((x, 1))
            vals.append((y, -1))
        ans = prefix = most = 0
        for x, k in sorted(vals): 
            prefix += k
            if prefix > most: 
                ans = x
                most = prefix 
        return ans"
maximum distance between a pair of values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        length1, length2 = len(nums1), len(nums2)
        i,j = 0,0
        
        result = 0
        while i < length1 and j < length2:
            if nums1[i] > nums2[j]:
                i+=1
            else:
                result = max(result,j-i)
                j+=1
            
        return result"
maximum distance between a pair of values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        max_diff = 0
        i = 0
        j = 0
        while i<len(nums1) and j <len(nums2):
            if i <= j:
                if nums1[i] <= nums2[j]:
                    max_diff=max(max_diff,j-i)
                    j += 1
                else:
                    i += 1
            else:
                j += 1
        return max_diff"
maximum subarray min product,"class Solution:
    def maxSumMinProduct(self, nums: List[int]) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = 0 
        stack = []
        for i, x in enumerate(nums + [-inf]): # append ""-inf"" to force flush all elements
            while stack and stack[-1][1] >= x: 
                _, xx = stack.pop()
                ii = stack[-1][0] if stack else -1 
                ans = max(ans, xx*(prefix[i] - prefix[ii+1]))
            stack.append((i, x))
        return ans % 1_000_000_007"
maximum subarray min product,"class Solution:
    def maxSumMinProduct(self, nums: List[int]) -> int:
        mod=int(1e9+7)
        stack=[] # (index, prefix sum at index)
        rsum=0
        res=0
        
        nums.append(0)
        
        for i, v in enumerate(nums):
            while stack and nums[stack[-1][0]] >= v:
                index, _ = stack.pop()
				
				# if the stack is empty, the subarray sum is the current prefixsum
                arrSum=rsum
                
                if stack:
                    arrSum=rsum-stack[-1][1]
                
				# update res with subarray sum
                res=max(res, nums[index]*arrSum)
                
            rsum+=v
            stack.append((i, rsum))
        
        return res%mod"
largest color value in a directed graph,"class Solution(object):
    def largestPathValue(self, colors, edges):
        n=len(colors)
        graph=defaultdict(list)
        indegree=defaultdict(int)
        
        for u,v in edges:
            graph[u].append(v)
            indegree[v]+=1
        
        queue=[]    
        dp=[[0]*26 for _ in range(n)]
        colorvalues=[ord(c)-ord(""a"") for c in colors]
        for u in range(n):
            if u not in indegree:
                queue.append(u)
                dp[u][colorvalues[u]]=1
            
        visited=0
        while queue:
            u=queue.pop()
            visited+=1

            for v in graph[u]:
                for c in range(26):
                    dp[v][c]=max(dp[v][c],dp[u][c] + (c==colorvalues[v]))
                indegree[v]-=1
                if indegree[v]==0:
                    queue.append(v)
                    del indegree[v]
        if visited<n:
            return -1
        return max(max(x) for x in dp)
		```"
largest color value in a directed graph,"class Solution:
    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        graph = {}
        indeg = [0] * len(colors)
        for u, v in edges: 
            indeg[v] += 1
            graph.setdefault(u, []).append(v)
            
        # Kahn's algo
        roots = [x for x in range(len(colors)) if indeg[x] == 0]
        
        stack = roots.copy()
        nodes = []
        while stack: 
            x = stack.pop()
            nodes.append(x)
            for xx in graph.get(x, []):
                indeg[xx] -= 1
                if indeg[xx] == 0: stack.append(xx)
        if len(nodes) < len(colors): return -1 # cycle detected 
        
        @cache
        def fn(x): 
            """"""Return distribution of (maximized) colors at given node.""""""
            ans = [0]*26
            ans[ord(colors[x]) - 97] = 1
            for xx in graph.get(x, []): 
                val = fn(xx)
                for i in range(26): 
                    if i == ord(colors[x]) - 97: ans[i] = max(ans[i], 1 + val[i])
                    else: ans[i] = max(ans[i], val[i])
            return ans 
        
        ans = [0]*26 
        for root in roots: 
            val = fn(root)
            for i in range(26): ans[i] = max(ans[i], val[i])
        return max(ans)"
sorting the sentence,"class Solution:
    def sortSentence(self, s: str) -> str:
        arr = [i[-1] + i[:-1] for i in s.split()]
        
        arr.sort()
        
        ans = """"
        for i in arr:
            ans += i[1:] + ' '
        
        return ans[:-1]"
sorting the sentence,"class Solution:
    def sortSentence(self, s: str) -> str:
		# split the string and sort the words based upon the last letter
        word_list = sorted(s.split(), key = lambda word: word[-1], reverse = False)
        return "" "".join([word[:-1] for word in word_list])  # join the words, after removing the last letter ie., digit"
incremental memory leak,"class Solution:
    def memLeak(self, memory1: int, memory2: int) -> List[int]:
        i = 1
        while max(memory1, memory2) >= i:
            if memory1 >= memory2:
                memory1 -= i
            else:
                memory2 -= i
            i += 1
        return [i, memory1, memory2]"
incremental memory leak,"class Solution:
    def memLeak(self, m1: int, m2: int) -> List[int]:
        res = [1,m1,m2]
        while 1:
            if res[2] > res[1]:
                mx = 2
            else:
                mx = 1
            if res[0] > res[mx]:
                return res
            else:
                res[mx] -= res[0]
            res[0]+=1"
rotating the box,"class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        # move stones to right, row by row
        for i in range(len(box)):
            stone = 0
            for j in range(len(box[0])):
                if box[i][j] == '#': # if a stone
                    stone += 1
                    box[i][j] = '.'
                elif box[i][j] == '*': # if a obstacle
                    for m in range(stone):
                        box[i][j-m-1] = '#'
                    stone = 0
            # if reaches the end of j, but still have stone
            if stone != 0:
                for m in range(stone):
                        box[i][j-m] = '#'
        
        # rotate box, same as leetcode #48
        box[:]  = zip(*box[::-1])
        
        return box"
rotating the box,"class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        R,C = len(box), len(box[0])
        new_box = [[0 for _ in range(R)] for _ in range(C)]
        
        for r in range(R):
            for c in range(C):
                new_box[c][~r] = box[r][c]   #(2,0) becomes (0,0)  if 2 is the last row.
				
        R,C = C,R
        for c in range(C):
            last = R - 1   # If we find a stone, we move it here
            for r in reversed(range(R)):  # iterate from bottom to top
                if new_box[r][c] == '*':   # if its a barrier, last is now above this barrier
                    last = r - 1
                elif new_box[r][c] == '.': # if its empty, we don't care
                    continue
                elif new_box[r][c] == '#': # we hit a stone. Where do we move it? To last of course.
                    new_box[r][c] = '.'  # set current location to empty as stone is no longer here
                    new_box[last][c] = '#' # stone is now at last place.
                    last -= 1  # decrement last
        return new_box"
sum of floored pairs,"class Solution:
    def sumOfFlooredPairs(self, nums: List[int]) -> int:
        sumP = 0 #To store the value of Sum of floor values
        for i in nums: #Traverse every element in nums
            for j in nums: #Traverse every element in nums
                sumP += (j//i) #Simply do floor division and add the number to sumP
        return sumP % (10**9 +7)#return the sumof the pairs"
sum of floored pairs,"class Solution:
    def sumOfFlooredPairs(self, nums: List[int]) -> int:
        maxi = max(nums) + 1
        dic = {}
        prefix=[0]*maxi
        for i in nums:
            if i in dic:
                dic[i] += 1
            else:
                dic[i] = 1
        #print(dic)
        for i in range(1,maxi):
            if i not in dic:
                prefix[i] = prefix[i-1]
            else:
                prefix[i] = prefix[i-1]+dic[i]
        #print(prefix,dic)
        sumP = 0
        for i in set(nums):
            for j in range(i,maxi,i):
                sumP += dic[i]*(prefix[-1]-prefix[j-1])
				#print(sumP,end = "" "")
        return sumP % (10**9 +7)"
sum of all subset xor totals,"class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        ans = 0
        for mask in range(1 << len(nums)): 
            val = 0
            for i in range(len(nums)): 
                if mask &amp; 1 << i: val ^= nums[i]
            ans += val
        return ans"
sum of all subset xor totals,"class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        ans = 0 
        for x in nums: 
            ans |= x 
        return ans * 2 ** (len(nums)-1)"
minimum number of swaps to make the binary string alternating,"class Solution:
    def minSwaps(self, s: str) -> int:
        ones = s.count(""1"")
        zeros = len(s) - ones 
        if abs(ones - zeros) > 1: return -1 # impossible
        
        def fn(x): 
            """"""Return number of swaps if string starts with x.""""""
            ans = 0 
            for c in s: 
                if c != x: ans += 1
                x = ""1"" if x == ""0"" else ""0""
            return ans//2
        
        if ones > zeros: return fn(""1"")
        elif ones < zeros: return fn(""0"")
        else: return min(fn(""0""), fn(""1""))"
minimum number of swaps to make the binary string alternating,"class Solution:
    def minSwaps(self, s: str) -> int:
        ans = n = len(s)
        zero, one = 0, 0
        for c in s:                                    # count number of 0 &amp; 1s
            if c == '0':
                zero += 1
            else:
                one += 1
        if abs(zero - one) > 1: return -1              # not possible when cnt differ over 1  
        if zero >= one:                                # '010101....' 
            s1 = '01' * (n // 2)                       # when zero == one
            s1 += '0' if n % 2 else ''                 # when zero > one 
            cnt = sum(c1 != c for c1, c in zip(s1, s))
            ans = cnt // 2
        if zero <= one:                                # '101010....'
            s2 = '10' * (n // 2)                       # when zero == one
            s2 += '1' if n % 2 else ''                 # when one > zero 
            cnt = sum(c2 != c for c2, c in zip(s2, s))
            ans = min(ans, cnt // 2)
        return ans"
number of ways to rearrange sticks with k sticks visible,"class Solution:
    def rearrangeSticks(self, n: int, k: int) -> int:
        
        @cache 
        def fn(n, k): 
            """"""Return number of ways to rearrange n sticks to that k are visible.""""""
            if n == k: return 1
            if k == 0: return 0
            return ((n-1)*fn(n-1, k) + fn(n-1, k-1)) % 1_000_000_007
        
        return fn(n, k)"
longer contiguous segments of ones than zeros,"class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        zero_in=temp=0
        for i in s:
            if i==""0"":
                temp+=1
                if temp>zero_in:
                    zero_in=temp
            else:
                temp=0
        # Longest contiguous 0 in s is zero_in    
        return ""1""*(zero_in+1) in s #return boolean value"
longer contiguous segments of ones than zeros,"class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        count0 = count1 = max0 = max1 = 0
        for c in s:
            if c == '0':
                count1 = 0
                count0 += 1
                max0 = max(max0, count0)
            else:
                count0 = 0
                count1 += 1
                max1 = max(max1, count1)
        return (max1 > max0)"
minimum speed to arrive on time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
		# the speed upper is either the longest train ride: max(dist),
		# or the last train ride divide by 0.01: ceil(dist[-1] / 0.01).
		# notice: ""hour will have at most two digits after the decimal point""
        upper = max(max(dist), ceil(dist[-1] / 0.01))
        # 
		# the function to calcute total time consumed
        total = lambda speed: sum(map(lambda x: ceil(x / speed), dist[:-1])) + (dist[-1] / speed)
		# the case of impossible to arrive office on time
        if total(upper) > hour:
            return -1
        # 
		# binary search: find the mimimal among ""all"" feasible answers
        left, right = 1, upper
        while left < right:            
            mid = left + (right - left) // 2
            if total(mid) > hour:
                left = mid + 1 # should be larger
            else:
                right = mid # should explore a smaller one
        return right"
minimum speed to arrive on time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
	
		# helper returns required time to reach the office given a speed
        def getRequiredTime(speed):
            time = sum([ceil(d/speed) for d in dist[:-1]])
            time += dist[-1]/speed
			
            return time
        
        dec = hour % 1 or 1 # decimal part of the `hour`
        lo, hi = 1, ceil( max(dist) / dec ) # min and max speed
		
        res = -1
    
        while lo <= hi:
            mid = (lo + hi) // 2
            
            time = getRequiredTime(mid)
            if time == hour:
                return mid
            
            if time < hour:
                res = mid
                hi = mid - 1
            else:
                lo = mid + 1
            
        return res"
jump game vii,"class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        prefix = [0, 1]
        for i in range(1, len(s)): 
            prefix.append(prefix[-1])
            lo = max(0, i-maxJump)
            hi = max(0, i-minJump+1)
            if s[i] == ""0"" and prefix[hi] - prefix[lo] > 0: prefix[-1] += 1
        return prefix[-1] > prefix[-2]"
jump game vii,"class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        queue, lo = [0], 0
        for x in queue: 
            if x == len(s)-1: return True 
            for xx in range(max(lo+1, x+minJump), min(x+maxJump+1, len(s))): 
                if s[xx] == ""0"": queue.append(xx)
            lo = max(lo, x + maxJump)
        return False"
stone game viii,"class Solution:
    def stoneGameVIII(self, s: List[int]) -> int:
        s, res = list(accumulate(s)), 0
        for i in range(len(s) - 1, 0, -1):
            res = s[i] if i == len(s) - 1 else max(res, s[i] - res)
        return res"
stone game viii,"class Solution:
    def stoneGameVIII(self, stones: List[int]) -> int:        
        s = sum(stones)  
        dp = s
        for i in range(len(stones)-2, 0, -1):
            s -= stones[i+1]
            dp = max(dp, s - dp)    
        return dp"
substrings of size three with distinct characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count=0
        for i in range(len(s)-2):
            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):
                count+=1
        return count"
substrings of size three with distinct characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        k = 3
        if k > len(s):
            return 0
        
        letter_frequency = {}
        count, windowStart = 0, 0
        for windowEnd in range(len(s)):
            if s[windowEnd] not in letter_frequency:
                letter_frequency[s[windowEnd]] = 0
            letter_frequency[s[windowEnd]] += 1
            
            if windowEnd >= k - 1:
                if len(letter_frequency) == k:
                    count+=1
                letter_frequency[s[windowStart]] -= 1
                if letter_frequency[s[windowStart]] ==0:
                    del letter_frequency[s[windowStart]]
                windowStart += 1
        return count"
minimize maximum pair sum in array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        pair_sum = []
        nums.sort()
        for i in range(len(nums)//2):
            pair_sum.append(nums[i]+nums[len(nums)-i-1])
        return max(pair_sum)"
minimize maximum pair sum in array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        
        nums.sort()
        i = 0
        j = len(nums) - 1
        
        res = 0
        
        while i < j:
            res = max(res, nums[i] + nums[j])
            i += 1
            j -= 1
        
        
        return res"
get biggest three rhombus sums in a grid,"class Solution:
def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
    
    def calc(l,r,u,d):
        sc=0
        c1=c2=(l+r)//2
        expand=True
        for row in range(u,d+1):
            if c1==c2:
                sc+=grid[row][c1]
            else:
                sc+=grid[row][c1]+grid[row][c2]
            
            if c1==l:
                expand=False
            
            if expand:
                c1-=1
                c2+=1
            else:
                c1+=1
                c2-=1
        return sc
        
    
    m=len(grid)
    n=len(grid[0])
    heap=[]
    for i in range(m):
        for j in range(n):
            l=r=j
            d=i
            while l>=0 and r<=n-1 and d<=m-1:
                sc=calc(l,r,i,d)
                l-=1
                r+=1
                d+=2
                if len(heap)<3:
                    if sc not in heap:
                        heapq.heappush(heap,sc)
                else:
                    if sc not in heap and sc>heap[0]:
                        heapq.heappop(heap)
                        heapq.heappush(heap,sc)
    
    heap.sort(reverse=True)
    return heap"
get biggest three rhombus sums in a grid,"class Solution:
    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])
        dp = [[[0, 0]] * (n+2) for _ in range(m+2)]
        ans = []
        for i in range(1, m+1):
            for j in range(1, n+1):                            # [i, j] will be the bottom vertex
                ans.append(grid[i-1][j-1])
                dp[i][j] = [grid[i-1][j-1], grid[i-1][j-1]]
                dp[i][j][0] += dp[i-1][j-1][0]                 # dp: major diagonal
                dp[i][j][1] += dp[i-1][j+1][1]                 # dp: minor diagonal
                for win in range(1, min(m, n)):
                    x1, y1 = i-win, j-win                      # left vertex
                    x2, y2 = i-win, j+win                      # right vertex
                    x3, y3 = i-win-win, j                      # top vertex
                    if not (all(1 <= x < m+1 for x in [x1, x2, x3]) and all(1 <= y < n+1 for y in [y1, y2, y3])):
                        break
                    b2l = dp[i][j][0] - dp[x1-1][y1-1][0]      # bottom node to left node (node sum), major diagonal
                    b2r = dp[i][j][1] - dp[x2-1][y2+1][1]      # bottom node to right node (node sum), minor diagonal
                    l2t = dp[x1][y1][1] - dp[x3-1][y3+1][1]    # left node to top node (node sum), minor diagonal
                    r2t = dp[x2][y2][0] - dp[x3-1][y3-1][0]    # right node to top node (node sum), major diagonal
                    vertices_sum = grid[i-1][j-1] + grid[x1-1][y1-1] + grid[x2-1][y2-1] + grid[x3-1][y3-1]
                    cur = b2l + b2r + l2t + r2t - vertices_sum # sum(edges) - sum(4 vertices)
                    ans.append(cur)
        return sorted(set(ans), reverse=True)[:3]              # unique + sort reverse + keep only first 3"
minimum xor sum of two arrays,"class Solution:
    def minimumXORSum(self, a: List[int], b: List[int]) -> int:
        @cache
        def dp(mask: int) -> int:
            i = bin(mask).count(""1"")
            if i >= len(a):
                return 0
            return min((a[i] ^ b[j]) + dp(mask + (1 << j)) 
                       for j in range(len(b)) if mask &amp; (1 << j) == 0)
        return dp(0)"
minimum xor sum of two arrays,"class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        
        @cache 
        def fn(mask, k): 
            """"""Return min xor sum.""""""
            if not mask: return 0 
            ans = inf 
            for i in range(n): 
                if mask &amp; (1<<i): 
                    ans = min(ans, (nums1[i]^nums2[k]) + fn(mask^(1<<i), k+1))
            return ans 
        
        return fn((1<<n)-1, 0)"
check if word equals summation of two words,"class Solution:
    def isSumEqual(self, first: str, second: str, target: str) -> bool:
        def op(s: str): return """".join(chr(ord(ch) - 49) for ch in s)
        return int(op(first)) + int(op(second)) == int(op(target))"
check if word equals summation of two words,"class Solution:
    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:
        mapping = {
            'a':'0', 'b':'1', 'c':'2', 'd':'3', 'e':'4', 'f':'5', 'g':'6', 'h':'7', 'i':'8', 'j':'9'
        }
        
        def decoding(s):
            nonlocal mapping
            return int(''.join(list(map((lambda i:mapping[i]),list(s)))))
        
        return decoding(firstWord) + decoding(secondWord) == decoding(targetWord)"
maximum value after insertion,"class Solution:
    def maxValue(self, n: str, x: int) -> str:
        if int(n)>0:
            ans = """"
            flag = False
            for i in range(len(n)):
                if int(n[i])>=x:
                    ans += n[i]
                else:
                    a = n[:i]
                    b = n[i:]
                    ans = a+str(x)+b
                
                    flag = True
                    break
            if not flag:
                ans += str(x)
        else:
            n = n[1:]
            ans = """"
            flag = False
            for i in range(len(n)):
                if int(n[i])<=x:
                    ans += n[i]
                else:
                    a = n[:i]
                    b = n[i:]
                    ans = a+str(x)+b
            
                    flag = True
                    break
            if not flag:
                ans += str(x)
            ans = ""-""+ans
        
        return ans"
maximum value after insertion,"class Solution:
    def maxValue(self, n: str, x: int) -> str:
        digit = str(x)
        if n[0] == ""-"":
            for i, d in enumerate(n[1:]):
                if d > digit:
                    return f""{n[:i + 1]}{digit}{n[i + 1:]}""
        else:
            for i, d in enumerate(n):
                if d < digit:
                    return f""{n[:i]}{digit}{n[i:]}""
        return n + digit"
process tasks using servers,"class Solution:
def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
    
    # sort the servers in order of weight, keeping index 
    server_avail = [(w,i) for i,w in enumerate(servers)]
    heapify(server_avail)
    tasks_in_progress = []
    res = []
    st=0
    for j,task in enumerate(tasks):
        #starting time of task
        st = max(st,j)
        
        # if any server is not free then we can take start-time equal to end-time of task
        if not server_avail:
            st = tasks_in_progress[0][0]
        
        # pop the completed task's server and push inside the server avail
        while tasks_in_progress and tasks_in_progress[0][0]<=st:
            heapq.heappush(server_avail,heappop(tasks_in_progress)[1])
            
        # append index of used server in res
        res.append(server_avail[0][1])
        
        # push the first available server in ""server_avail"" heap to ""tasks_in_progress"" heap
        heapq.heappush(tasks_in_progress,(st+task,heappop(server_avail)))
    
    return res"
process tasks using servers,"class Solution:
    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
        busy = []
        free = [(wt, i) for i, wt in enumerate(servers)]
        heapify(free)
        
        ans = []
        for t, task in enumerate(tasks): 
            while busy and busy[0][0] == t: 
                _, wt, i = heappop(busy)
                heappush(free, (wt, i))
            if free: wt, i = heappop(free)
            else: t, wt, i = heappop(busy)
            ans.append(i)
            heappush(busy, (t+task, wt, i))
        return ans"
minimum skips to arrive at meeting on time,"class Solution:
    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        if sum(dist)/speed > hoursBefore: return -1 # impossible 
        
        @cache
        def fn(i, k): 
            """"""Return min time (in distance) of traveling first i roads with k skips.""""""
            if k < 0: return inf # impossible 
            if i == 0: return 0 
            return min(ceil((fn(i-1, k) + dist[i-1])/speed) * speed, dist[i-1] + fn(i-1, k-1))
        
        for k in range(len(dist)):
            if fn(len(dist)-1, k) + dist[-1] <= hoursBefore*speed: return k"
egg drop with 2 eggs and n floors,"class Solution:
    @cache
    def twoEggDrop(self, n: int) -> int:
        return min((1 + max(i - 1, self.twoEggDrop(n - i)) for i in range (1, n)), default = 1)"
egg drop with 2 eggs and n floors,"class Solution:
    def twoEggDrop(self, n: int) -> int:
        
        @cache
        def fn(n, k): 
            """"""Return min moves for n floors and k eggs.""""""
            if k == 1: return n 
            if n == 0: return 0 
            ans = inf 
            for x in range(1, n+1): 
                ans = min(ans, 1 + max(fn(x-1, k-1), fn(n-x, k)))
            return ans 
        
        return fn(n, 2)"
determine whether matrix can be obtained by rotation,"class Solution:
    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
        for _ in range(4): 
            if mat == target: return True
            mat = [list(x) for x in zip(*mat[::-1])]
        return False"
determine whether matrix can be obtained by rotation,"class Solution:
    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
        for _ in range(4): 
            if mat == target: return True
            mat = [list(x) for x in zip(*mat[::-1])]
        return False"
reduction operations to make the array elements equal,"class Solution:
    def reductionOperations(self, nums: List[int]) -> int:
        ans = val = 0
        nums.sort()
        for i in range(1, len(nums)): 
            if nums[i-1] < nums[i]: val += 1
            ans += val
        return ans"
reduction operations to make the array elements equal,"class Solution:
    def reductionOperations(self, nums: List[int]) -> int:
        cnt = 0
        n  = len(nums)
        nums.sort()
        i=1
        prev = nums[0]
        while i<n:
            while i<n and nums[i]==prev:
                i+=1
            cnt = cnt + n-i
            if i<n:
                prev = nums[i]
        
        return cnt"
minimum number of flips to make the binary string alternating,"class Solution:
    def minFlips(self, s: str) -> int:
        prev = 0
        start_1, start_0, start_1_odd, start_0_odd = 0,0,sys.maxsize,sys.maxsize
        odd = len(s)%2
        for val in s:
            val = int(val)
            if val == prev:
                if odd:
                    start_0_odd = min(start_0_odd, start_1)
                    start_1_odd += 1
                start_1 += 1
            else:
                if odd:
                    start_1_odd = min(start_1_odd, start_0)
                    start_0_odd += 1
                start_0 += 1
            prev = 1 - prev
        return min([start_1, start_0, start_1_odd, start_0_odd])"
minimum number of flips to make the binary string alternating,"class Solution(object):
    def minFlips(self, s):
        n=len(s) # we save this length as it is length of window
        s+=s #we add this string because we can have any possibility like s[0]->s[n-1] or s[2]->s[n+1]meaning is that any continous variation with n length ... 
        ans=sys.maxint #assiging the answer max possible value as want our answer to be minimum so while comparing min answer will be given 
        ans1,ans2=0,0#two answer variables telling amount of changes we require to make it alternative
        s1=""""#dummy string like 10010101
        s2=""""#dummy string like 01010101
        for i in range(len(s)):
            if i%2==0:
                s1+=""1""
                s2+=""0""
            else :
                s1+=""0""
                s2+=""1""
        for i in range(len(s)):
            if s[i]!=s1[i]:#if they dont match we want a change so ++1
                ans1+=1
            if s[i]!=s2[i]:
                ans2+=1
            
            if i>=n:
                if s[i-n]!=s1[i-n]:#now we have gone ahead so removing the intial element but wait if that element needed a change we added ++ earlier but now he is not our part so why we have his ++ so to nullify its ++ we did a -- in string
                    ans1-=1
                if s[i-n]!=s2[i-n]:
                    ans2-=1
            if i>=n-1#when i reaches n-1 we have n length so we check answer first time and after that we always keep seeing if we get a less answer value and after the loop we get 
                ans=min([ans,ans1,ans2])
        return ans"
minimum space wasted from packaging,"class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        packages.sort()
        prefix = [0]
        for x in packages: prefix.append(prefix[-1] + x)
        
        ans = inf 
        for box in boxes: 
            box.sort()
            if packages[-1] <= box[-1]: 
                kk = val = 0 
                for x in box: 
                    k = bisect_right(packages, x)
                    val += (k - kk) * x - (prefix[k] - prefix[kk])
                    kk = k
                ans = min(ans, val)
        return ans % 1_000_000_007 if ans < inf else -1"
minimum space wasted from packaging,"class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        packages.sort()
        
        ans = inf 
        for box in boxes: 
            box.sort()
            if packages[-1] <= box[-1]: 
                kk = val = 0 
                for x in box: 
                    k = bisect_right(packages, x)
                    val += (k - kk) * x
                    kk = k
                ans = min(ans, val)
        return (ans - sum(packages)) % 1_000_000_007 if ans < inf else -1"
check if all the integers in a range are covered,"class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        ranges = sorted(ranges)
        for s,e in ranges:
            if  s<=left<=e:
                if s<=right<=e:
                    return True
                else:
                    left=e+1
        return False"
check if all the integers in a range are covered,"class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        covered = [0]*(right-left+1)
        for st, ed in ranges: 
            for x in range(st, ed+1): 
                if left <= x <= right: covered[x - left] = 1
        return all(covered)"
find the student that will replace the chalk,"class Solution:
    def chalkReplacer(self, chalk: List[int], k: int) -> int:
        prefix_sum = [0 for i in range(len(chalk))]
        prefix_sum[0] = chalk[0]
        for i in range(1,len(chalk)):
            prefix_sum[i] = prefix_sum[i-1] + chalk[i]
        remainder = k % prefix_sum[-1]
        
        #apply binary search on prefix_sum array, target = remainder 
        start = 0
        end = len(prefix_sum) - 1
        while start <= end:
            mid = start + (end - start) // 2
            if remainder == prefix_sum[mid]:
                return mid + 1
            elif remainder < prefix_sum[mid]:
                end = mid - 1
            else:
                start = mid + 1
        return start"
find the student that will replace the chalk,"class Solution:
    def chalkReplacer(self, chalk: List[int], k: int) -> int:
        x = sum(chalk)
        if x<k:
            k = k%x
        if x == k:
            return 0
        i = 0
        n = len(chalk)
        while True:
            if chalk[i]<=k:
                k -= chalk[i]
            else:
                break
            i +=1
               
        return i"
largest magic square,"class Solution:
    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions 
        rows = [[0]*(n+1) for _ in range(m)] # prefix sum along row
        cols = [[0]*n for _ in range(m+1)] # prefix sum along column
        
        for i in range(m):
            for j in range(n): 
                rows[i][j+1] = grid[i][j] + rows[i][j]
                cols[i+1][j] = grid[i][j] + cols[i][j]
        
        ans = 1
        for i in range(m): 
            for j in range(n): 
                diag = grid[i][j]
                for k in range(min(i, j)): 
                    ii, jj = i-k-1, j-k-1
                    diag += grid[ii][jj]
                    ss = {diag}
                    for r in range(ii, i+1): ss.add(rows[r][j+1] - rows[r][jj])
                    for c in range(jj, j+1): ss.add(cols[i+1][c] - cols[ii][c])
                    ss.add(sum(grid[ii+kk][j-kk] for kk in range(k+2))) # anti-diagonal
                    if len(ss) == 1: ans = max(ans, k+2)
        return ans"
largest magic square,"class Solution:
    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions 
        rows = [[0]*(n+1) for _ in range(m)]
        cols = [[0]*n for _ in range(m+1)]
        diag = [[0]*(n+1) for _ in range(m+1)]
        anti = [[0]*(n+1) for _ in range(m+1)]
        
        for i in range(m):
            for j in range(n): 
                rows[i][j+1] = grid[i][j] + rows[i][j]
                cols[i+1][j] = grid[i][j] + cols[i][j]
                diag[i+1][j+1] = grid[i][j] + diag[i][j]
                anti[i+1][j] = grid[i][j] + anti[i][j+1]
        
        ans = 1
        for i in range(m): 
            for j in range(n): 
                for k in range(1, min(i, j)+1): 
                    ii, jj = i-k, j-k
                    val = diag[i+1][j+1] - diag[ii][jj]
                    match = (val == anti[i+1][jj] - anti[ii][j+1])
                    for r in range(ii, i+1): match &amp;= (val == rows[r][j+1] - rows[r][jj])
                    for c in range(jj, j+1): match &amp;= (val == cols[i+1][c] - cols[ii][c])
                    if match: ans = max(ans, k+1)
        return ans"
minimum cost to change the final value of expression,"class Solution:
    def minOperationsToFlip(self, expression: str) -> int:
        loc = {}
        stack = []
        for i in reversed(range(len(expression))):
            if expression[i] == "")"": stack.append(i)
            elif expression[i] == ""("": loc[stack.pop()] = i 
        
        def fn(lo, hi): 
            """"""Return value and min op to change value.""""""
            if lo == hi: return int(expression[lo]), 1
            if expression[hi] == "")"" and loc[hi] == lo: return fn(lo+1, hi-1) # strip parenthesis 
            mid = loc.get(hi, hi) - 1 
            v, c = fn(mid+1, hi)
            vv, cc = fn(lo, mid-1)
            if expression[mid] == ""|"": 
                val = v | vv 
                if v == vv == 0: chg = min(c, cc)
                elif v == vv == 1: chg = 1 + min(c, cc)
                else: chg = 1 
            else: # expression[k] == ""&amp;""
                val = v &amp; vv
                if v == vv == 0: chg = 1 + min(c, cc)
                elif v == vv == 1: chg = min(c, cc)
                else: chg = 1
            return val, chg
                    
        return fn(0, len(expression)-1)[1]"
redistribute characters to make all strings equal,"class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        map_ = {}
        for word in words:
            for i in word:
                if i not in map_:
                    map_[i] = 1
                else:
                    map_[i] += 1
        n = len(words)
        for k,v in map_.items():
            if (v%n) != 0:
                return False
        return True"
redistribute characters to make all strings equal,"class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        
        joint = ''.join(words)
        set1 = set(joint)
        
        for i in set1 :
            if joint.count(i) % len(words) != 0 : return False 
        return True"
maximum number of removable characters,"class Solution:
    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:
        mp = {x: i for i, x in enumerate(removable)}
        
        def fn(x):
            """"""Return True if p is a subseq of s after x removals.""""""
            k = 0 
            for i, ch in enumerate(s): 
                if mp.get(i, inf) < x: continue 
                if k < len(p) and ch == p[k]: k += 1
            return k == len(p)
        
        lo, hi = -1, len(removable)
        while lo < hi: 
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return lo"
maximum number of removable characters,"class Solution:
    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:
        
        def isSubseq(s,subseq,removed):
            i = 0
            j  = 0
            while i<len(s) and j<len(subseq):
                if i in removed or s[i]!= subseq[j]:
                    i+=1
                    continue
                i+=1
                j+=1
            return j == len(subseq)
        
        removed = set()
        l = 0
        r = len(removable)-1
        ans = 0
        while l<=r:
            mid  = l+(r-l)//2
            removed = set(removable[:mid+1])
            if isSubseq(s,p,removed):
                ans = max(ans,len(removed))
                l = mid+1
                
            else:
                r = mid-1
        return ans"
merge triplets to form target triplet,"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        i = 1
        cur = []
        for a,b,c in triplets:
            if a<=target[0] and b<=target[1] and c<= target[2]:
                cur = [a,b,c]
                break
        if not cur:
            return False
        while i<len(triplets):
            if cur == target:
                return True
            a,b,c = triplets[i]
            x,y,z = cur
            if max(a,x)<=target[0] and max(b,y)<=target[1] and max(c,z)<=target[2]:
                cur = [max(a,x), max(b,y), max(c,z)]
               
            
            i+= 1
        if cur == target:
            return True
        return False"
merge triplets to form target triplet,"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        
        a, b, c = 0, 0, 0
        for i, (x, y, z) in enumerate(triplets):
                if not(  x > target[0] or y > target[1] or z > target[2]):
                     a, b, c = max(a, x), max(b, y), max(c, z)
                        
        return [a, b, c] == target"
the earliest and latest rounds where players compete,"class Solution:
    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed
        
        @cache
        def fn(k, mask): 
            """"""Return earliest and latest rounds.""""""
            can = deque()
            for i in range(n): 
                if mask &amp; (1 << i): can.append(i)
                    
            cand = [] # eliminated player
            while len(can) > 1: 
                p1, p2 = can.popleft(), can.pop()
                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest 
                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated 
                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated 
                else: cand.append([p1, p2]) # both could be elimited 
            
            minn, maxx = inf, -inf
            for x in product(*cand): 
                mask0 = mask
                for i in x: mask0 ^= 1 << i
                mn, mx = fn(k+1, mask0)
                minn = min(minn, mn)
                maxx = max(maxx, mx)
            return minn, maxx
        
        return fn(1, (1<<n)-1)"
find a peak element ii,"class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        m, n = len(mat), len(mat[0])
        l, r = 0, n
        while l <= r:
            mid = (l + r) // 2
            cur_max, left = 0, False
            for i in range(m):
                if i > 0 and mat[i-1][mid] >= mat[i][mid]:
                    continue
                if i+1 < m and mat[i+1][mid] >= mat[i][mid]:   
                    continue
                if mid+1 < n and mat[i][mid+1] >= mat[i][mid]:   
                    cur_max, left = mat[i][mid], not mat[i][mid] > cur_max
                    continue
                if mid > 0 and mat[i][mid-1] >= mat[i][mid]:   
                    cur_max, left = mat[i][mid], mat[i][mid] > cur_max
                    continue
                return [i, mid]
            if left:
                r = mid-1
            else:
                l = mid+1
        return []"
find a peak element ii,"class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        left, right = 0, len(mat[0]) - 1
        
        while left <= right:
            midCol = (left + right)//2
            maxRow = 0
            
            for i in range(len(mat)):
                maxRow = i if mat[i][midCol] > mat[maxRow][midCol] else maxRow
                
            isLeftBig = midCol - 1 >= 0 and mat[maxRow][midCol - 1] > mat[maxRow][midCol]
            isRightBig = midCol + 1 <= len(mat[0]) and mat[maxRow][midCol + 1] > mat[maxRow][midCol]
            
            if not isLeftBig and not isRightBig:
                return [maxRow, midCol]
            
            elif isRightBig:
                left = midCol + 1
            
            else:
                right = midCol - 1
                
        return None"
largest odd number in string,"class Solution:
    def largestOddNumber(self, num: str) -> str:
        
        for i in range(len(num) - 1, -1, -1) :
            if num[i] in {'1','3','5','7','9'} :
                return num[:i+1]
        return ''"
largest odd number in string,"class Solution:
    def largestOddNumber(self, num: str) -> str:
        
        # We have to just find the last index of an odd number, then slice the number upto that index,  becuase an odd number always ends with a number which is not divisible by 2 :)
        
        # Lets take the last index of an odd number as -1
        last_ind = -1
        
        # Iterate through all the numbers for finding a odd number that appears on the last.
        for i , j in enumerate(num[::-1]):
            if(int(j) % 2 != 0):
                last_ind = len(num) - i
                break
        
        # If there is no odd number, return empty string.
        if(last_ind == -1): return """"
                
        # Or return the string upto that index.
        return(num[:last_ind])"
the number of full rounds you have played,"class Solution:
    def numberOfRounds(self, startTime: str, finishTime: str) -> int:
        hs, ms = (int(x) for x in startTime.split("":""))
        ts = 60 * hs + ms
        hf, mf = (int(x) for x in finishTime.split("":""))
        tf = 60 * hf + mf
        if 0 <= tf - ts < 15: return 0 # edge case 
        return tf//15 - (ts+14)//15 + (ts>tf)*96"
the number of full rounds you have played,"class Solution:
    def numberOfRounds(self, startTime: str, finishTime: str) -> int:
        ts = 60 * int(startTime[:2]) + int(startTime[-2:])
        tf = 60 * int(finishTime[:2]) + int(finishTime[-2:])
        if 0 <= tf - ts < 15: return 0 # edge case 
        return tf//15 - (ts+14)//15 + (ts>tf)*96"
count sub islands,"class Solution:
def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
    
    m=len(grid1)
    n=len(grid1[0])
    
    def dfs(i,j):
        if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:
            return
        
        grid2[i][j]=0
        dfs(i+1,j)
        dfs(i,j+1)
        dfs(i,j-1)
        dfs(i-1,j)
        
    # removing all the non-common sub-islands
    for i in range(m):
        for j in range(n):
            if grid2[i][j]==1 and grid1[i][j]==0:
                dfs(i,j)
    
    c=0
	# counting sub-islands
    for i in range(m):
        for j in range(n):
            if grid2[i][j]==1:
                dfs(i,j)
                c+=1
    return c"
count sub islands,"class Solution:
	def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
		queue, row, col, visited = deque([]),len(grid1), len(grid1[0]), set([])
		count = 0
		for x in range(row):
			for y in range(col):
				if grid1[x][y] == 1 and grid2[x][y] == 1:
					grid2[x][y] = ""X""
					queue.append((x,y))
					count += self.subCheck(queue,row,col,visited,grid1,grid2)   
		return count

	def subCheck(self,queue, row, col, visited, grid1, grid2):
		key = True
		while queue:
			x,y = queue.popleft()
			for nx,ny in [[x+1,y], [x-1,y], [x,y+1], [x,y-1]]:
				if 0<=nx<row and 0<=ny<col and grid2[nx][ny] == 1:
					if grid1[nx][ny] != 1:
						key = False
					grid2[nx][ny] = ""X""
					queue.append((nx,ny))

		if key:
			return 1

		return 0"
minimum absolute difference queries,"class Solution:
    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        loc = {}
        for i, x in enumerate(nums): loc.setdefault(x, []).append(i)
        keys = sorted(loc)
        
        ans = []
        for l, r in queries: 
            prev, val = 0, inf
            for x in keys: 
                i = bisect_left(loc[x], l)
                if i < len(loc[x]) and loc[x][i] <= r: 
                    if prev: val = min(val, x - prev)
                    prev = x 
            ans.append(val if val < inf else -1)
        return ans"
remove one element to make the array strictly increasing,"class Solution:
    def canBeIncreasing(self, nums: List[int]) -> bool:
        stack = []
        for i in range(1, len(nums)): 
            if nums[i-1] >= nums[i]: stack.append(i)
                
        if not stack: return True 
        if len(stack) > 1: return False
        i = stack[0]
        return (i == 1 or nums[i-2] < nums[i]) or (i+1 == len(nums) or nums[i-1] < nums[i+1])"
remove one element to make the array strictly increasing,"class Solution:
    def canBeIncreasing(self, nums: List[int]) -> bool:
        prev, seen = -inf, False
        for i, x in enumerate(nums): 
            if prev < x: prev = x
            else: 
                if seen: return False 
                seen = True 
                if i == 1 or nums[i-2] < x: prev = x
        return True"
remove all occurrences of a substring,"class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        lps = [0]
        k = 0 
        for i in range(1, len(part)): 
            while k and part[k] != part[i]: k = lps[k-1]
            if part[k] == part[i]: k += 1
            lps.append(k)
        
        stack = [("""", 0)]
        for ch in s: 
            k = stack[-1][1]
            while k and part[k] != ch: k = lps[k-1]
            if part[k] == ch: k += 1
            stack.append((ch, k))
            if k == len(part): 
                for _ in range(len(part)): stack.pop()
        return """".join(x for x, _ in stack)"
remove all occurrences of a substring,"class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        stack = []
        for ch in s: 
            stack.append(ch)
            if """".join(stack[-len(part):]) == part: 
                for _ in range(len(part)): stack.pop()
        return """".join(stack)"
maximum alternating subsequence sum,"class Solution:
def maxAlternatingSum(self, nums: List[int]) -> int:
    
    ma=0
    mi=0
    for num in nums:
        ma=max(ma,num-mi)
        mi=min(mi,num-ma)
        
    return ma"
maximum alternating subsequence sum,"class Solution:
    def maxAlternatingSum(self, nums: List[int]) -> int:
        n = len(nums)   
        dp = [[0,0] for _ in range(n)] # initialize dp
        dp[0][0] = nums[0] # pre-define
        dp[0][1] = 0 # pre-define

        for i in range(1, n): # iterate through nums starting from index 1
            dp[i][0] = max(nums[i] + dp[i-1][1], dp[i-1][0]) # find which value is higher between choosing or not choosing when the last value is plus.
            dp[i][1] = max(-nums[i] + dp[i-1][0], dp[i-1][1]) # find which value is higher between choosing or not choosing when the last value is minus.
        
        return max(dp[-1]) # find the maximum of the last array of dp of whether the last value is plus or minus, this will be our answer."
maximum product difference between two pairs,"class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        nums.sort()
        return (nums[-1]*nums[-2])-(nums[0]*nums[1])"
maximum product difference between two pairs,"class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        
        nums.sort() # sorting the list, to access first 2 lowest elems &amp; 2 highest elems as we have to calulate max diff of pairs after product. 
        
        prod_pair_1 = nums[0] * nums[1] # product of 2 lowest elems in the list. 
        prod_pair_2 = nums[-1] *  nums[-2] # product of 2 highest elems in the list. 
        
        max_diff = prod_pair_2 - prod_pair_1 # calulating the diff of the product of the above mentioend two paris. 
        
        return max_diff # returning the max difference bet the product."
cyclically rotating a grid,"class Solution:
    def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0]) # dimensions 
        
        for r in range(min(m, n)//2): 
            i = j = r
            vals = []
            for jj in range(j, n-j-1):     vals.append(grid[i][jj])
            for ii in range(i, m-i-1):     vals.append(grid[ii][n-j-1])
            for jj in range(n-j-1, j, -1): vals.append(grid[m-i-1][jj])
            for ii in range(m-i-1, i, -1): vals.append(grid[ii][j])
                
            kk = k % len(vals)
            vals = vals[kk:] + vals[:kk]
            
            x = 0  
            for jj in range(j, n-j-1):     grid[i][jj] = vals[x]; x += 1
            for ii in range(i, m-i-1):     grid[ii][n-j-1] = vals[x]; x += 1
            for jj in range(n-j-1, j, -1): grid[m-i-1][jj] = vals[x]; x += 1
            for ii in range(m-i-1, i, -1): grid[ii][j] = vals[x]; x += 1
        return grid"
cyclically rotating a grid,"class Solution:
def rotateGrid(self, mat: List[List[int]], k: int) -> List[List[int]]:
    
    top = 0
    bottom = len(mat)-1
    left = 0
    right = len(mat[0])-1
    res = []
	
    # storing in res all the boundry matrix elements.
    while left<right and top<bottom:
        local=[]
        for i in range(left,right+1):
            local.append(mat[top][i])
        top+=1
		
        for i in range(top,bottom+1):
            local.append(mat[i][right])
        right-=1
		
        for i in range(right,left-1,-1):
            local.append(mat[bottom][i])
        bottom-=1
		
        for i in range(bottom,top-1,-1):
            local.append(mat[i][left])
        left+=1
        
        res.append(local)
		
	# rotating the elements by k.
    for ele in res:
        l=len(ele)
        r=k%l
        ele[::]=ele[r:]+ele[:r]
    
	# Again storing in the matrix.    
    top = 0
    bottom = len(mat)-1
    left = 0
    right = len(mat[0])-1
    while left<right and top<bottom:
        local=res.pop(0)
        for i in range(left,right+1):
            mat[top][i] = local.pop(0)
        top+=1
		
        for i in range(top,bottom+1):
            mat[i][right] = local.pop(0)
        right-=1
		
        for i in range(right,left-1,-1):
            mat[bottom][i] = local.pop(0)
        bottom-=1
		
        for i in range(bottom,top-1,-1):
            mat[i][left] = local.pop(0)
        left+=1
        
    return mat"
number of wonderful substrings,"class Solution:
    def wonderfulSubstrings(self, word: str) -> int:
        ans = mask = 0
        freq = defaultdict(int, {0: 1})
        for ch in word: 
            mask ^= 1 << ord(ch)-97
            ans += freq[mask]
            for i in range(10): ans += freq[mask ^ 1 << i]
            freq[mask] += 1
        return ans"
number of wonderful substrings,"class Solution:
    def wonderfulSubstrings(self, word: str) -> int:
        
        # we are representing each char with a bit, 0 for count being even and 1 for odd
        # 10 char from a to j
        # array to store 2^10 numbers
        dp=[0]*1024
        
        # jihgfedcba -> 0000000000
        curr=0  # 000..(0-> 10 times) 
        
        # since we are starting with curr as 0 make dp[0]=1
        dp[0]=1
        
        # result
        res=0
        
        for c in word:
            # 1<<i sets i th bit to 1 and else to 0
            # xor will toggle the bit
            curr^= (1<<(ord(c)-ord('a')))
            
            # if curr occurred earlier at j and now at i then [j+1: i] has all zeroes
            # this was to count all zeroes case
            res+=dp[curr]
            
            # now to check if these 100000..,010000..,001.. cases  can be acheived using brute force
            # we want to see if curr ^ delta = 10000.. or 010000.. etc
            # curr^delta =1000... then
            # curr ^ 1000.. = delta
            
            for i in range(10):
                res+=dp[curr ^(1<<i)]      
               
            dp[curr]+=1       
            
        
        
        return res"
count ways to build rooms in an ant colony,"class Solution:
    def waysToBuildRooms(self, prevRoom: List[int]) -> int:
        tree = defaultdict(list)
        for i, x in enumerate(prevRoom): tree[x].append(i)
        
        def fn(n): 
            """"""Return number of nodes and ways to build sub-tree.""""""
            if not tree[n]: return 1, 1 # leaf 
            c, m = 0, 1
            for nn in tree[n]: 
                cc, mm = fn(nn)
                c += cc
                m = (m * comb(c, cc) * mm) % 1_000_000_007
            return c+1, m
        
        return fn(0)[1]"
build array from permutation,"class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        return [nums[nums[i]] for i in range(len(nums))]"
build array from permutation,"class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        # time:O(N) space:O(N)
        
         ans=[0]*len(nums)
         for i in range(len(nums)):
             ans[i] = nums[nums[i]]
         return ans"
eliminate maximum number of monsters,"class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        for i, t in enumerate(sorted((d+s-1)//s for d, s in zip(dist, speed))): 
            if i == t: return i
        return len(dist)"
eliminate maximum number of monsters,"class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        
		def help(a):
            return a[0]/a[1]
        
		temp = []
        for i in range(len(dist)):
            temp.append([dist[i],speed[i]])
        temp = sorted(temp,key = help)
        ans = 0
        i = 0

        while i<len(temp):
            if (temp[i][0] - (temp[i][1])*i) > 0 :
                ans += 1
                i += 1
            else:
                break
        return ans"
count good numbers,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        '''
        ans=1
        MOD=int(10**9+7)
        for i in range(n):
            if i%2==0:
                ans*=5
            else:
                ans*=4
            ans%=MOD
        return ans
        '''
        MOD=int(10**9+7)

        fives,fours=n//2+n%2,n//2
        # 5^fives*4^fours % MOD
        # = 5^fives % MOD * 4^fours % MOD
        return (pow(5,fives,MOD) * pow(4,fours,MOD)) % MOD"
count good numbers,"class Solution:
def countGoodNumbers(self, n: int) -> int:
    MOD = 10**9+7
	
	# No. of even places
    if n%2==0:
        ne=n//2
    else:
        ne=(n+1)//2
    # No. of odd places
    no=n//2
    
    te = pow(5,ne,MOD)      #Total number of even places combinations.
    tp = pow(4,no,MOD)      #Total number of odd/prime combinations.
    return (tp*te)%MOD"
count square sum triples,"```class Solution:
    def countTriples(self, n: int) -> int:
        count = 0
        sqrt = 0
        for i in range(1,n-1):
            for j in range(i+1, n):
                sqrt = ((i*i) + (j*j)) ** 0.5
                if sqrt % 1 == 0 and sqrt <= n:
                    count += 2
        return (count)
		

*Please Upvote if you like*"
count square sum triples,"class Solution:
    def countTriples(self, n: int) -> int:
        ans = 0 
        for a in range(1, n): 
            for b in range(a+1, n): 
                c = int(sqrt(a*a + b*b))
                if a*a + b*b == c*c and c <= n: ans += 2
        return ans"
nearest exit from entrance in maze,"class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        q = collections.deque([(*entrance, 0)])
        m, n = len(maze), len(maze[0])
        maze[entrance[0]][entrance[1]] == '+'    
        while q:
            x, y, c = q.popleft()
            if (x == 0 or x == m-1 or y == 0 or y == n-1) and [x, y] != entrance:
                return c
            for i, j in [(x+_x, y+_y) for _x, _y in [(-1, 0), (1, 0), (0, -1), (0, 1)]]:
                if 0 <= i < m and 0 <= j < n and maze[i][j] == '.':
                    maze[i][j] = '+'
                    q.append((i, j, c + 1))
        return -1"
nearest exit from entrance in maze,"class Solution:
    def nearestExit(self, grid: List[List[str]], entrance: List[int]) -> int:
        m=len(grid)
        n=len(grid[0])
        lst=[[entrance[0],entrance[1],0]]
        visited=[[-1]*n for i in range(m)]
        row=[-1,1,0,0]
        col=[0,0,-1,1]
        visited[entrance[0]][entrance[1]]=1
        while lst:
            x,y,d=lst.pop(0)
            for i in range(4):
                if x+row[i]>=0 and x+row[i]<m and y+col[i]>=0 and y+col[i]<n and visited[x+row[i]][y+col[i]]==-1 and grid[x+row[i]][y+col[i]]=='.':
                    if x+row[i]==0 or x+row[i]==m-1 or y+col[i]==0 or y+col[i]==n-1:
                        return d+1
                    lst.append([x+row[i],y+col[i],d+1])
                    visited[x+row[i]][y+col[i]]=1
        return -1"
sum game,"class Solution:
    def sumGame(self, num: str) -> bool:
        n = len(num)
        q_cnt_1 = s1 = 0
        for i in range(n//2):    # get digit sum and question mark count for the first half of `num`
            if num[i] == '?':
                q_cnt_1 += 1
            else:    
                s1 += int(num[i])
        q_cnt_2 = s2 = 0				
        for i in range(n//2, n): # get digit sum and question mark count for the second half of `num`
            if num[i] == '?':
                q_cnt_2 += 1
            else:    
                s2 += int(num[i])
        s_diff = s1 - s2         # calculate sum difference and question mark difference
        q_diff = q_cnt_2 - q_cnt_1
        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can't win, Alice wins"
sum game,"class Solution:
    def sumGame(self, num: str) -> bool:
        diff = qm = 0 
        for i, ch in enumerate(num): 
            if ch == ""?"": qm += 1 if i < len(num)//2 else -1
            else: diff += int(ch) if i < len(num)//2 else -int(ch)
        return diff * 2 + qm * 9 != 0"
minimum cost to reach destination in time,"class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
        n = len(passingFees)
        mat = {}
        for x, y, time in edges:
            if x not in mat: mat[x] = set()
            if y not in mat: mat[y] = set()
            mat[x].add((y, time))
            mat[y].add((x, time))

        h = [(passingFees[0], 0, 0)]
        visited = set()
        while h:
            fees, time_so_far, city = heappop(h)
            if time_so_far > maxTime: continue
            if city == n - 1: return fees

            if (city, time_so_far) in visited: continue
            visited.add((city, time_so_far))
            
            for nxt, time_to_travel in mat[city]:
                # Check if we are retracing a visited path
                if (nxt, time_so_far - time_to_travel) in visited: continue
                heappush(h, (fees + passingFees[nxt], time_so_far + time_to_travel, nxt))
        return -1"
minimum cost to reach destination in time,"class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
        graph = {}
        for u, v, t in edges: 
            graph.setdefault(u, []).append((v, t))
            graph.setdefault(v, []).append((u, t))
        
        pq = [(passingFees[0], 0, 0)]
        dist = {0: 0}
        while pq: 
            cost, k, t = heappop(pq)
            if k == len(passingFees)-1: return cost
            for kk, tt in graph.get(k, []): 
                if t + tt <= maxTime and t + tt < dist.get(kk, inf): 
                    dist[kk] = t + tt
                    heappush(pq, (cost + passingFees[kk], kk, t + tt))
        return -1"
concatenation of array,"class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        nums.extend(nums)
        return nums"
concatenation of array,"class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        n=len(nums)
        r=[]
        for i in range(0,2*n):
            if i<n:
                r.append(nums[i])
            else:
                r.append(nums[i-n])
        return r"
unique length 3 palindromic subsequences,"class Solution(object):
    def countPalindromicSubsequence(self, s):
        d=defaultdict(list)
        for i,c in enumerate(s):
            d[c].append(i)
        ans=0
        for el in d:
            if len(d[el])<2:
                continue
            a=d[el][0]
            b=d[el][-1]
            ans+=len(set(s[a+1:b]))
        return(ans)"
unique length 3 palindromic subsequences,"class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        if len(s) < 3:
            return 0

        elif len(s) == 3:
            return 1 if s[0]==s[2] else 0
                
        else:
            num_of_palindromes = 0
            unique = list(set(s))
            for char in unique:
                count = s.count(char)
                if count > 1:
                    # find first and last index of char in s
                    a_index = s.index(char)
                    c_index = s.rindex(char)
                    # find num of unique chars between the two indeces 
                    between = s[a_index+1:c_index]
                    num_of_palindromes += len(list(set(between)))
                
            return num_of_palindromes"
painting a grid with three different colors,"class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        
        @cache
        def fn(i, j, mask): 
            """"""Return number of ways to color grid.""""""
            if j == n: return 1 
            if i == m: return fn(0, j+1, mask)
            ans = 0 
            for x in 1<<2*i, 1<<2*i+1, 0b11<<2*i: 
                mask0 = mask ^ x
                if mask0 &amp; 0b11<<2*i and (i == 0 or (mask0 >> 2*i) &amp; 0b11 != (mask0 >> 2*i-2) &amp; 0b11): 
                    ans += fn(i+1, j, mask0)
            return ans % 1_000_000_007
        
        return fn(0, 0, 0)"
painting a grid with three different colors,"class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        M = 10**9 + 7
        ans = 3
        if m == 1:
            for i in range(n-1):
                ans *= 2
                ans %= M
            return ans % M
        
        def IsValid(a):
            return all ( a[i] != a[i+1] for i in range(len(a) - 1) )
            
        if m >= 2:
            # AllStates contains all colorings of a single row of length m using 3 colors (0, 1, 2), hence of size 3^m
            # For example, m = 2, AllStates = [(0,0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
            AllStates = [[0], [1], [2]]
            colors = [0, 1, 2]
            for j in range(m-1):
                L = len(AllStates)
                for i in range(L):
                    x = AllStates.pop(0)
                    for c in colors:
                        AllStates.append(tuple([*x, c]))
            
            # v contains all valid colorings of a single row of length m using 3 colors
            v = set()
            for a in AllStates:
                if IsValid(a):
                    v.add(a)
            d = {i:a for i, a in enumerate(v)}
            
            # construct a graph where vertices are valid single row colorings
            # an edge is present if two colorings satisfy the constraints
            numStates = len(v)
            def IsValidNeigbor(a, b):
                if a not in v or b not in v:
                    return False
                else:
                    for i in range(len(a)):
                        if a[i] == b[i]:
                            return False
                    return True
            
            adj = {i:[] for i in range(numStates)}
            for i in range(numStates):
                for j in range(i+1, numStates):
                    if IsValidNeigbor(d[i], d[j]):
                        adj[i].append(j)
                        adj[j].append(i)
            
            # then the problem becomes: finding the number of paths of length n in the constructed graph,
            # which can be done by an easy-to-understand dp.
            dp = [[0 for _ in range(n+1)] for _ in range(numStates)]
            for i in range(numStates):
                dp[i][1] = 1
            
            
            for j in range(2, n+1):
                for i in range(numStates):
                    for k in adj[i]:
                        dp[i][j] += dp[k][j-1]
                        dp[i][j] %= M
            return sum(dp[i][n] for i in range(numStates)) % M"
merge bsts to create single bst,"class Solution:
    def canMerge(self, trees: List[TreeNode]) -> TreeNode:
        roots, leaves, loners, n = {}, {}, set(), len(trees)
        if n == 1:
            return trees[0]
        for tree in trees:
            if not tree.left and not tree.right:
                loners.add(tree.val)
                continue
            roots[tree.val] = tree
            for node in [tree.left, tree.right]:
                if node:
                    if node.val in leaves:
                        return None
                    leaves[node.val] = node
                
        for loner in loners:
            if loner not in leaves and loner not in roots:
                return None
            
        orphan = None
        for val, tree in roots.items():
            if val not in leaves:
                if orphan:
                    return None
                orphan = tree
        if not orphan:
            return None
        
        def build(node, small, big):
            nonlocal roots
            if not node:
                return True
            if small >= node.val or node.val >= big:
                return False
            
            if node.val in roots:
                node.left, node.right = roots[node.val].left, roots[node.val].right
                del roots[node.val]
            return build(node.left, small, node.val) and build(node.right, node.val, big)
        del roots[orphan.val]
        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)
        return orphan if result and not roots.keys() else None"
maximum number of words you can type,"class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        text = text.split()
        length = len(text)
        brokenLetters = set(brokenLetters)

        for word in text:
            for char in word:
                if char in brokenLetters:
                    length -= 1
                    break
					
        return length"
maximum number of words you can type,"class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        text = text.split()
        length = len(text)
        brokenLetters = list(brokenLetters)
		
        for i in text:
            temp = 0
            for j in i:
                if j in brokenLetters:
                    temp -= 1
                    break
            if temp < 0:
                length -= 1
				
        return length"
add minimum number of rungs,"class Solution:
    def addRungs(self, rungs: List[int], dist: int) -> int:
        return sum((a - b - 1) // dist for a, b in zip(rungs, [0] + rungs))"
add minimum number of rungs,"class Solution:
    def addRungs(self, rungs: List[int], dist: int) -> int:
        newrungs = 0
        prev = 0
        
        for rung in rungs:
            diff = rung - prev
            
            if diff > dist:
                add = diff / dist # Number of rungs we need to add
                
                if add % 1 == 0:
                    add = int(add) - 1
                else:
                    add = int(add)
                newrungs += add
            prev = rung
        
		return newrungs"
maximum number of points with cost,"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        
        dp = points[0]
        
        left = [0] * n ## left side contribution
        right = [0] * n ## right side contribution
        
        for r in range(1, m):
            for c in range(n):
                if c == 0:
                    left[c] = dp[c]
                else:
                    left[c] = max(left[c - 1] - 1, dp[c])
            
            for c in range(n - 1, -1, -1):
                if c == n-1:
                    right[c] = dp[c]
                else:
                    right[c] = max(right[c + 1] - 1, dp[c])
                    
            for c in range(n):
                dp[c] = points[r][c] + max(left[c], right[c])
                
        return max(dp)"
maximum number of points with cost,"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        
        for i in range(m - 1):
            for j in range(1, n):
                points[i][j] = max(points[i][j], points[i][j - 1] - 1)
            
            for j in range(n - 2, -1, -1):
                points[i][j] = max(points[i][j], points[i][j + 1] - 1)
            
            for j in range(n):
                points[i + 1][j] += points[i][j]
        
        return max(points[m - 1])"
check if all characters have equal number of occurrences,"class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        return len(set(Counter(s).values())) == 1"
check if all characters have equal number of occurrences,"class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        a = set(s)
        d = set()
        for i in a:
            d.add(s.count(i))
        if len(d) == 1:
            return True
        else:
            False"
the number of the smallest unoccupied chair,"class Solution:
    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
        arrivals = []
        departures = []
        for ind, (x, y) in enumerate(times):
            heappush(arrivals, (x, ind))
            heappush(departures, (y, ind))
        d = {}
        occupied = [0] * len(times)
        while True:
            if arrivals and departures and arrivals[0][0] < departures[0][0]:
                _, ind = heappop(arrivals)
                d[ind] = occupied.index(0)
                occupied[d[ind]] = 1
                if ind == targetFriend:
                    return d[ind]
            elif arrivals and departures and arrivals[0][0] >= departures[0][0]:
                _, ind = heappop(departures)
                occupied[d[ind]] = 0"
the number of the smallest unoccupied chair,"class Solution:
    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
        vals = []
        for i, (arrival, leaving) in enumerate(times): 
            vals.append((arrival, 1, i))
            vals.append((leaving, 0, i))
        
        k = 0 
        pq = [] # available seats 
        mp = {} # player-to-seat mapping 
        for _, arrival, i in sorted(vals): 
            if arrival: 
                if pq: s = heappop(pq)
                else: 
                    s = k
                    k += 1
                if i == targetFriend: return s
                mp[i] = s
            else: heappush(pq, mp[i]) # new seat available"
describe the painting,"class Solution:
    def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:
		# via this mapping, we can easily know which coordinates should be took into consideration.
        mapping = defaultdict(int)
        for s, e, c in segments:
            mapping[s] += c
            mapping[e] -= c
        
        res = []
        prev, color = None, 0
        for now in sorted(mapping):
            if color: # if color == 0, it means this part isn't painted.
                res.append((prev, now, color))
            
            color += mapping[now]
            prev = now
            
        return res"
describe the painting,"class Solution:
    def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:
        mix, res, last_i = DefaultDict(int), [], 0
        for start, end, color in segments:
            mix[start] += color
            mix[end] -= color
        for i in sorted(mix.keys()):
            if last_i in mix and mix[last_i]:
                res.append([last_i, i, mix[last_i]])
                mix[i] += mix[last_i]
            last_i = i
        return res"
number of visible people in a queue,"class Solution:
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        ans = [0]*len(heights)
        stack = [] # mono-stack 
        for i in reversed(range(len(heights))): 
            while stack and stack[-1] <= heights[i]: 
                ans[i] += 1
                stack.pop()
            if stack: ans[i] += 1
            stack.append(heights[i])
        return ans"
number of visible people in a queue,"class Solution:
    def canSeePersonsCount(self, A):
        n = len(A)
        stack, res = [], [0] * n
        for i in range(n - 1, -1, -1):
            while stack and stack[-1] <= A[i]:
                stack.pop()
                res[i] += 1
            if stack: res[i] += 1
            stack.append(A[i])
        return res"
sum of digits of string after convert,"class Solution:
    def getLucky(self, s: str, k: int) -> int:
        s = """".join(str(ord(ch) - 96) for ch in s)
        for _ in range(k): 
            x = sum(int(ch) for ch in s)
            s = str(x)
        return x"
sum of digits of string after convert,"class Solution:
    def getLucky(self, s: str, k: int) -> int:
        s = """".join(str(ord(ch)-96) for ch in s)
        for _ in range(k): s = str(sum(int(ch) for ch in s))
        return int(s)"
largest number after mutating substring,"class Solution:
    def maximumNumber(self, num: str, change: List[int]) -> str:
        num = list(num)
        on = False 
        for i, ch in enumerate(num): 
            x = int(ch)
            if x < change[x]: 
                on = True
                num[i] = str(change[x])
            elif x > change[x] and on: break
        return """".join(num)"
largest number after mutating substring,"class Solution:
    def maximumNumber(self, num: str, change: List[int]) -> str:

        # make a list from the string for a mutable datatype
        num = list(num)

        # go through the number and start mutating as soon as
        # we hit a number that becomes bigger
        # mark as mutating since we started mutation
        # end the loop if we encounter a number that would
        # get smaller by mutating
        mutated = False
        for idx, n in enumerate(num):

            # get the current digit
            n = int(n)
            if change[n] > n:
                num[idx] = str(change[n])
                mutated = True
            elif change[n] < n and mutated:
                break
        return """".join(num)"
maximum compatibility score sum,"class Solution:
    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        m = len(students)
        
        score = [[0]*m for _ in range(m)]
        for i in range(m): 
            for j in range(m): 
                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))
        
        ans = 0 
        for perm in permutations(range(m)): 
            ans = max(ans, sum(score[i][j] for i, j in zip(perm, range(m))))
        return ans"
maximum compatibility score sum,"class Solution:
    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        m = len(students)
        
        score = [[0]*m for _ in range(m)]
        for i in range(m): 
            for j in range(m): 
                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))
        
        @cache 
        def fn(mask, j): 
            """"""Return max score of assigning students in mask to first j mentors.""""""
            ans = 0 
            for i in range(m): 
                if not mask &amp; (1<<i): 
                    ans = max(ans, fn(mask^(1<<i), j-1) + score[i][j])
            return ans 
        
        return fn(1<<m, m-1)"
delete duplicate folders in system,"class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        paths.sort()
        
        tree = {""#"": -1}
        for i, path in enumerate(paths): 
            node = tree
            for x in path: node = node.setdefault(x, {})
            node[""#""] = i
        
        seen = {}
        mark = set()
        
        def fn(n): 
            """"""Return serialized value of sub-tree rooted at n.""""""
            if len(n) == 1: return ""$"" # leaf node 
            vals = []
            for k in n: 
                if k != ""#"": vals.append(f""${k}${fn(n[k])}"")
            hs = """".join(vals)
            if hs in seen: 
                mark.add(n[""#""])
                mark.add(seen[hs])
            if hs != ""$"": seen[hs] = n[""#""]
            return hs
        
        fn(tree)
        
        ans = []
        stack = [tree]
        while stack: 
            n = stack.pop()
            if n[""#""] >= 0: ans.append(paths[n[""#""]])
            for k in n: 
                if k != ""#"" and n[k][""#""] not in mark: stack.append(n[k])
        return ans"
delete duplicate folders in system,"class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        leaves = []
        trie_lambda = lambda: collections.defaultdict(trie_lambda)
        trie = trie_lambda()
        trie['*'] = trie['**'] = '*'
        
        for p in paths:
            t = trie
            for f in p:
                parent, t = t, t[f]
                t['*'] = parent
                t['**'] = f
        
        def traverse(t):
            if len(t) == 2:
                leaves.append(t)
            else:
                for k, v in t.items():
                    if k[0] != '*':
                        traverse(v)
        traverse(trie)
        
        leaf_ids = set(id(leaf) for leaf in leaves)
        candidates = {id(leaf['*']):leaf['*'] for leaf in leaves}
        
        while candidates:
            new = {}
            dup = collections.defaultdict(list)
            for cand in candidates.values():
                if any(id(v) not in leaf_ids for k, v in cand.items() if k[0] != '*'):
                    continue
                dup[','.join(sorted(cand.keys()))].append(cand)
            for k, v in dup.items():
                if len(v) > 1:
                    for cand in v:
                        f = cand['**']
                        parent = cand['*']
                        del parent[f]
                        leaf_ids.add(id(parent['*' + f]))
                        new[id(parent)] = parent
            candidates = new
        path = []
        ans = []
        def dfs(t):
            for f in t:
                if f[0] != '*':
                    path.append(f)
                    ans.append(list(path))
                    dfs(t[f])
                    path.pop()
        dfs(trie)
        return ans"
three divisors,"class Solution:
    def isThree(self, n: int) -> bool:
        return sum(n%i == 0 for i in range(1, n+1)) == 3"
three divisors,"class Solution:
    def isThree(self, n: int) -> bool:
        if n == 1: return False # edge case 
        
        x = int(sqrt(n))
        if x*x != n: return False 
        
        for i in range(2, int(sqrt(x))+1): 
            if x % i == 0: return False 
        return True"
maximum number of weeks for which you can work,"class Solution:
    def numberOfWeeks(self, milestones: List[int]) -> int:
        _sum, _max = sum(milestones), max(milestones)
		# (_sum - _max) is the sum of milestones from (2) the rest of projects, if True, we can form another project with the same amount of milestones as (1)
		# can refer to the section `Why the greedy strategy works?` for the proof
        if _sum - _max >= _max:  
            return _sum
        return 2 * (_sum - _max) + 1  # start from the project with most milestones (_sum - _max + 1) and work on the the rest of milestones (_sum - _max)"
maximum number of weeks for which you can work,"class Solution:
    def numberOfWeeks(self, m: List[int]) -> int:
        return min(sum(m), 2 * (sum(m) - max(m)) + 1)"
minimum garden perimeter to collect enough apples,"class Solution:
    def minimumPerimeter(self, nap: int) -> int:
        
        
#         here for n = 2 , there are two series :  
#         (1) Diagnal points for n=3 , diagnal apples = 2*n = 6
#         (2) there is series =   2,3,3 =  2+ (sigma(3)-sigma(2))*2
        
#         how to solve:
            
#             here 3  =  sigma(n+(n-1))-sigma(n) = sigma(2*n-1)-sigma(n) =  0.5*2n*(2n-1)-0.5*n*n-1
#         (3) so our final 2,3,3 =   3*2+2 =   (0.5*2n*(2n-1)-0.5*n*n-1)*2+n
#         (4) so final 2,3,3 =  3*n*n - 2*n
#         (5) we have 4 times repitation of (2,3,3)  = 4*(2,3,3)  =   4*(3*n*n - 2*n)   =  12*n*n - 8*n
#         (6) we have 4 diagnal points so their sum(4 diagnal)  = 4*(2*n)
#         (7)  so final sum(total) = 4 diagnal sum + 4(2,3,3)    =   4(2*n)   + 12*n*n - 8*n    =  12*n*n
        
#         so at nth distance we have total  12*n*n  apples at the circumfrance
        
#         so net sum =  sigma(12*n*n)  = 2*n*(n+1)*(2*n+1)
        
        
        n=1
        val=2*n*(n+1)*(2*n+1)
        while(val<nap):
            n+=1
            val=val=2*n*(n+1)*(2*n+1)
        return n*8"
minimum garden perimeter to collect enough apples,"class Solution:
    def minimumPerimeter(self, neededApples: int) -> int:
        A = neededApples
        x = 0
        curr = 0
        
        while curr < A:
            temp = 0
            x += 1
            for i in range(1,x):
                temp += ((x+i)*2)
            curr += 4*(temp + 3*x)
        return 4*(2*x)"
count number of special subsequences,"class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        total_zeros = 0 # number of subsequences of 0s so far
        total_ones = 0 # the number of subsequences of 0s followed by 1s so far
        total_twos = 0 # the number of special subsequences so far
        
        M = 1000000007
        
        for n in nums:
            if n == 0:
                # if we have found new 0 we can add it to any existing subsequence of 0s
                # or use only this 0
                total_zeros += (total_zeros + 1) % M
            elif n == 1:
                # if we have found new 1 we can add it to any existing subsequence of 0s or 0s and 1s
                # to get a valid subsequence of 0s and 1s
                total_ones += (total_zeros + total_ones) % M
            else:
                # if we have found new 2 we can add it to any existing subsequence of 0s and 1s 0r 0s,1s and 2s
                # to get a valid subsequence of 0s,1s and 2s
                total_twos += (total_ones + total_twos) % M
        
        return total_twos % M"
count number of special subsequences,"class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        dp0 = dp1 = dp2 = 0
        for num in nums:
            if num == 2:
                dp2 += dp1 + dp2
            elif num == 1:
                dp1 += dp0 + dp1
            else:
                dp0 += dp0 + 1
                
        return dp2 % (10**9 + 7)"
delete characters to make fancy string,"class Solution:
    def makeFancyString(self, s: str) -> str:
        stack = []
        for letter in s:
            if len(stack) > 1 and letter == stack[-1] == stack[-2]:
                stack.pop()
            stack.append(letter)
        return ''.join(stack)"
delete characters to make fancy string,"class Solution:
    def makeFancyString(self, s: str) -> str:
        stack = []
        for ch in s: 
            if len(stack) > 1 and stack[-2] == stack[-1] == ch: continue 
            stack.append(ch)
        return """".join(stack)"
check if move is legal,"class Solution:
    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:
        for di, dj in (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1): 
            i, j = rMove+di, cMove+dj
            step = 0
            while 0 <= i < 8 and 0 <= j < 8: 
                if board[i][j] == color and step: return True 
                if board[i][j] == ""."" or board[i][j] == color and not step: break 
                i, j = i+di, j+dj
                step += 1
        return False"
check if move is legal,"class Solution:
    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:
        directions = [False] * 8
        moves = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0),
                 (-1, -1), (0, -1), (1, -1)]
        opposite_color = ""W"" if color == ""B"" else ""B""

        for d in range(8):
            r, c = rMove + moves[d][0], cMove + moves[d][1]
            if 0 <= r < 8 and 0 <= c < 8 and board[r][c] == opposite_color:
                directions[d] = True

        for step in range(2, 8):
            if not any(d for d in directions):
                return False
            for d in range(8):
                if directions[d]:
                    r, c = rMove + step * moves[d][0], cMove + step * moves[d][1]
                    if 0 <= r < 8 and 0 <= c < 8:
                        if board[r][c] == color:
                            return True
                        elif board[r][c] == ""."":
                            directions[d] = False
                    else:
                        directions[d] = False
        return False"
minimum total space wasted with k resizing operations,"class Solution:
    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:
        
        @cache
        def fn(i, k): 
            """"""Return min waste from i with k ops.""""""
            if i == len(nums): return 0
            if k < 0: return inf 
            ans = inf
            rmx = rsm = 0
            for j in range(i, len(nums)): 
                rmx = max(rmx, nums[j])
                rsm += nums[j]
                ans = min(ans, rmx*(j-i+1) - rsm + fn(j+1, k-1))
            return ans 
        
        return fn(0, k)"
minimum total space wasted with k resizing operations,"class Solution:
    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:
        n = len(nums)
        
        if k == 0:
            mx = max(nums)
            return sum(list(map(lambda x: mx-x, nums)))
        if k >= n-1:
            return 0
        
        dp = [[math.inf for i in range(n)] for j in range(k+1)]
        wasted = [[0 for i in range(n)] for j in range(n)]
        
        for i in range(0, n):
            prev_max = nums[i]
            for j in range(i, n):
                if prev_max >= nums[j]:
                    wasted[i][j] = wasted[i][j-1] + prev_max - nums[j]
                else:
                    diff = nums[j] - prev_max
                    wasted[i][j] = diff * (j - i) + wasted[i][j-1]
                    prev_max = nums[j]
        
        for i in range(n):
            dp[0][i] = wasted[0][i]
        
        for j in range(1, k+1):
            for i in range(j, n):
                for l in range(j, i+1):
                    dp[j][i] = min(dp[j][i], dp[j-1][l-1] + wasted[l][i])

        return dp[k][n-1]"
maximum product of the length of two palindromic substrings,"class Solution:
    def maxProduct(self, s: str) -> int:
        n = len(s)
        
        # Manacher's algo
        hlen = [0]*n # half-length
        center = right = 0 
        for i in range(n): 
            if i < right: hlen[i] = min(right - i, hlen[2*center - i])
            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: 
                hlen[i] += 1
            if right < i+hlen[i]: center, right = i, i+hlen[i]
        
        prefix = [0]*n
        suffix = [0]*n
        for i in range(n): 
            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)
            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)
        
        for i in range(1, n): 
            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)
            suffix[i] = max(suffix[i], suffix[i-1]-2)
        
        for i in range(1, n): 
            prefix[i] = max(prefix[i-1], prefix[i])
            suffix[~i] = max(suffix[~i], suffix[~i+1])
        
        return max(prefix[i-1]*suffix[i] for i in range(1, n))"
check if string is a prefix of array,"class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        i = 0
        for word in words: 
            if s[i:i+len(word)] != word: return False 
            i += len(word)
            if i == len(s): return True 
        return False"
check if string is a prefix of array,"class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        
        a = ''
    
        for i in words:
            
            a += i
            
            if a == s:
                return True
            if not s.startswith(a):
                break
                     
        return False"
remove stones to minimize the total,"class Solution:
    def minStoneSum(self, piles: List[int], k: int) -> int:
        pq = [-x for x in piles]
        heapify(pq)
        for _ in range(k): heapreplace(pq, pq[0]//2)
        return -sum(pq)"
remove stones to minimize the total,"class Solution:
    def minStoneSum(self, piles: List[int], k: int) -> int:
        heap = [-p for p in piles]
        heapq.heapify(heap)
        for _ in range(k):
            cur = -heapq.heappop(heap)
            heapq.heappush(heap, -(cur-cur//2))
        return -sum(heap)"
minimum number of swaps to make the string balanced,"class Solution:
    def minSwaps(self, s: str) -> int:
        res, bal = 0, 0
        for ch in s:
            bal += 1 if ch == '[' else -1
            if bal == -1:
                res += 1
                bal = 1
        return res"
minimum number of swaps to make the string balanced,"class Solution:
    def minSwaps(self, s: str) -> int:
        count = 0
        for i in s:
            if i == ""["":
                count += 1  # increment only if we encounter an open bracket. 
            else:
                if count > 0:  #decrement only if count is positive. Else do nothing and move on. This is because for the case "" ] [ [ ] "" we do not need to in
                    count -= 1
        return (count + 1) // 2"
find the longest valid obstacle course at each position,"class Solution:
def longestObstacleCourseAtEachPosition(self, obs: List[int]) -> List[int]:
    local = []
    res=[0 for _ in range(len(obs))]
    for i in range(len(obs)):
        n=obs[i]
        if len(local)==0 or local[-1]<=n:
            local.append(n)
            res[i]=len(local)
        else:
            ind = bisect.bisect_right(local,n)
            local[ind]=n
            res[i]=ind+1
    
    return res"
find the longest valid obstacle course at each position,"class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        ans, vals = [], []
        for i, x in enumerate(obstacles): 
            k = bisect_right(vals, x)
            ans.append(k+1)
            if k == len(vals): vals.append(x)
            else: vals[k] = x
        return ans"
number of strings that appear as substrings in word,"class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        return sum(x in word for x in patterns)"
number of strings that appear as substrings in word,"class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        count=0
        for i in patterns:
            if i in word:
                count+=1
        return count"
array with elements not equal to average of neighbors,"class Solution:
   
        
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        if len(nums)==3:
            nums[1],nums[0] = nums[0],nums[1]
            return nums
        for i in range(1,len(nums)-1):
            if nums[i]-nums[i-1] == nums[i+1]-nums[i]:
                if i!=len(nums)-2:
                    nums[i+1],nums[i+2] = nums[i+2],nums[i+1] 
                if i==len(nums)-2:
                    nums[i+1],nums[0] = nums[0],nums[i+1]
        return nums"
array with elements not equal to average of neighbors,"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        res,l,r = [],0,len(nums) - 1
        while len(res) != len(nums):
            res.append(nums[l])
            l += 1
            
            if l <= r :
                res.append(nums[r])
                r -= 1
        return res"
minimum non zero product of the array elements,"class Solution:
    def minNonZeroProduct(self, p: int) -> int:
        x = (1 << p) - 1
        return pow(x-1, (x-1)//2, 1_000_000_007) * x % 1_000_000_007"
minimum non zero product of the array elements,"class Solution:
def minNonZeroProduct(self, p: int) -> int:
    
    MOD = 10**9+7
    h = 2**p - 2                                   
    n = 2**(p-1)-1
    
    return ((pow(h,n,MOD))*(h+1))%MOD"
last day where you can still cross,"class Solution(object):
    def latestDayToCross(self, row, col, cells):
        l,h=0,len(cells)-1
        ans=-1
        while l<=h:
            m=(l+h)>>1
            if self.isPath(cells,m,row,col):
                l=m+1
                ans=m+1
            else:
                h=m-1
        return ans
    def isPath(self,cells,ind,row,col):
        grid=[[0 for i in range(col)] for j in range(row)]
        for i in range(ind+1):
            x,y=cells[i]
            grid[x-1][y-1]=1
        vis=set()
        for i in range(col):
            if grid[0][i]!=1:
                dq=deque()
                dq.append((0,i))
                dr=[(-1,0),(0,-1),(1,0),(0,1)]
                while dq:
                    x,y=dq.popleft()
                    if x==row-1:
                        return True
                    for d in dr:
                        dx,dy=d
                        if 0<=x+dx<row and 0<=y+dy<col and grid[x+dx][y+dy]!=1 and (x+dx,y+dy) not in vis:
                            vis.add((x+dx,y+dy))
                            dq.append((x+dx,y+dy))
        return False"
last day where you can still cross,"class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        _board = [[0 for _ in range(col)] for _ in range(row)]
        board = None
        
        def search(days):
            def dfs(x, y):
                res = False
                for _x, _y in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                    if not (0 <= _x < row and 0 <= _y < col):
                        continue
                    if board[_x][_y]:
                        continue
                    if _x == row - 1:
                        return True
                    board[_x][_y] = 1
                    res |= dfs(_x, _y)
                return res
            
            flood(days)
            for j in range(col):
                if not board[0][j]:
                    board[0][j] = 1
                    if dfs(0, j):
                        return True
            return False
        
        def flood(days):
            nonlocal board
            board = deepcopy(_board)
            for i in range(days):
                board[cells[i][0] - 1][cells[i][1] - 1] = 1
        
        l, r = 0, len(cells)
        while l < r:
            mid = l + (r - l) // 2
            if search(mid):
                l = mid + 1
            else:
                r = mid
        return l - 1"
find if path exists in graph,"class Solution(object):
    def validPath(self, n, edges, start, end):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type start: int
        :type end: int
        :rtype: bool
        """"""
        visited = [False]*n
        d = {}
		#store the undirected edges for both vertices
        for i in edges:
            if i[0] in d:
                d[i[0]].append(i[1])
            else:
                d[i[0]] = [i[1]]
                
            if i[1] in d:
                d[i[1]].append(i[0])
            else:
                d[i[1]] = [i[0]]
        #create a queue as we will apply BFS
        q = [start]
        while q:
            curr = q.pop(0)  #pop the first element as we do in queue
            if curr == end:  #if its the end then we can return True
                return True
            elif curr in d and not visited[curr]: #else if it is not the end then check whether its visited or not
                q.extend(d[curr])  #add the adjacent vertices of the current node to the queue
            visited[curr] = True  #mark this curr vertex as visited = True, so that we dont visit this vertex again
        return False  #return False if the queue gets empty and we dont reach the end"
find if path exists in graph,"class Solution:
    def validPath(self, n: int, edges: List[List[int]], start: int, end: int) -> bool:
        graph = self.buildGraph(edges)
        return self.hasPath(graph, start, end, set())
    
	# function to convert list of edges to adjacency list graph
    def buildGraph(self, edges):
        graph = {}
        for edge in edges:
            a, b = edge
            if a not in graph:
                graph[a] = []
            if b not in graph:
                graph[b] = []
            graph[a].append(b)
            graph[b].append(a)    
        return graph
    
    def hasPath(self, graph, src, dst, visited):
        if src == dst:
            return True
        if src in visited:
            return False
        visited.add(src)
        for neighbour in graph[src]:
            if self.hasPath(graph, neighbour, dst, visited) == True:
                return True
        return False"
minimum time to type word using special typewriter,"class Solution:
    def minTimeToType(self, word: str) -> int:
        ans = len(word)
        prev = ""a""
        for ch in word: 
            val = (ord(ch) - ord(prev)) % 26 
            ans += min(val, 26 - val)
            prev = ch
        return ans"
minimum time to type word using special typewriter,"class Solution:
    def minTimeToType(self, word: str) -> int:
        count = 0
        ini = 'a'
        for i in word:
            x = abs(ord(i) - ord(ini))
            count += min(x, 26-x) + 1
            ini = i
        return count"
maximum matrix sum,"class Solution:
    def maxMatrixSum(self, matrix: List[List[int]]) -> int:
        ans = mult = 0
        val = inf 
        for i in range(len(matrix)): 
            for j in range(len(matrix)):
                ans += abs(matrix[i][j])
                val = min(val, abs(matrix[i][j]))
                if matrix[i][j] < 0: mult ^= 1
        return ans - 2*mult*val"
maximum matrix sum,"class Solution:
def maxMatrixSum(self, matrix: List[List[int]]) -> int:
    s,c,z,m=0,0,0,float('inf')
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j]<0:
                c+=1
            if matrix[i][j]==0:
                z=1
            s+=abs(matrix[i][j])
            m=min(m,abs(matrix[i][j]))
            
    if c%2==0 or z>0:
        return s
    else:
        return s-m*2"
number of ways to arrive at destination,"class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        graph = {}
        for u, v, time in roads: 
            graph.setdefault(u, {})[v] = time
            graph.setdefault(v, {})[u] = time
            
        dist = [inf]*n
        dist[-1] = 0
        stack = [(n-1, 0)]
        while stack: 
            x, t = stack.pop()
            if t == dist[x]: 
                for xx in graph.get(x, {}): 
                    if t + graph[x][xx] < dist[xx]: 
                        dist[xx] = t + graph[x][xx]
                        stack.append((xx, t + graph[x][xx]))
                        
        @cache
        def fn(x):
            """"""Return """"""
            if x == n-1: return 1 
            if dist[x] == inf: return 0 
            ans = 0 
            for xx in graph.get(x, {}): 
                if graph[x][xx] + dist[xx] == dist[x]: ans += fn(xx)
            return ans % 1_000_000_007
        
        return fn(0)"
number of ways to arrive at destination,"class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        graph = {}
        for u, v, time in roads: 
            graph.setdefault(u, []).append((v, time))
            graph.setdefault(v, []).append((u, time))
        
        dist = [inf] * n
        dist[0] = 0
        ways = [0] * n
        ways[0] = 1
        
        pq = [(0, 0)]
        while pq: 
            d, u = heappop(pq)
            if d > dist[-1]: break
            if d == dist[u]: 
                for v, time in graph.get(u, []): 
                    if dist[u] + time < dist[v]: 
                        dist[v] = dist[u] + time
                        ways[v] = ways[u]
                        heappush(pq, (dist[v], v))
                    elif dist[u] + time == dist[v]: ways[v] += ways[u]
        return ways[-1] % 1_000_000_007"
number of ways to separate numbers,"class Solution:
    def numberOfCombinations(self, num: str) -> int:
        n = len(num)
        lcs = [[0]*(n+1) for _ in range(n)]
        for i in reversed(range(n)): 
            for j in reversed(range(i+1, n)): 
                if num[i] == num[j]: lcs[i][j] = 1 + lcs[i+1][j+1]
        
        def cmp(i, j, d): 
            """"""Return True if """"""
            m = lcs[i][j]
            if m >= d: return True 
            return num[i+m] <= num[j+m]
        
        dp = [[0]*(n+1) for _ in range(n)]
        for i in range(n): 
            if num[i] != ""0"": 
                for j in range(i+1, n+1): 
                    if i == 0: dp[i][j] = 1
                    else: 
                        dp[i][j] = dp[i][j-1]
                        if 2*i-j >= 0 and cmp(2*i-j, i, j-i): dp[i][j] += dp[2*i-j][i]
                        if 2*i-j+1 >= 0 and not cmp(2*i-j+1, i, j-i-1): dp[i][j] += dp[2*i-j+1][i]
        return sum(dp[i][n] for i in range(n)) % 1_000_000_007"
find greatest common divisor of array,"class Solution:
    def findGCD(self, nums: List[int]) -> int:
        gcd = lambda a, b: a if b == 0 else gcd(b, a % b)
        return gcd(max(nums), min(nums))"
find greatest common divisor of array,"class Solution:
    #O(n) traverse
    #O(1) space
    def getMinMax(self, nums: List[int]) -> List[int]:
        min, max = nums[0], nums[0]
        for num in nums:
            if max < num: max = num
            if min > num: min = num
        return [max,min]

    #Euclidian gcd
    #constraint: a>b
    #O(h) where h is number of digits in (smaller number) b
    #O(1) space
    def gcd(self, ints: List[int]) -> int:
        a,b = ints[0], ints[1]
        while ((a % b) > 0):
            remainder = a % b
            a = b
            b = remainder
        return b

    # 2 <= nums.length <= 1000
    # 1 <= nums[i] <= 1000
    # O(h+n) = O(n)
    # O(n) space with nums inside
    def findGCD(self, nums: List[int]) -> int:
        return self.gcd(self.getMinMax(nums))"
find unique binary string,"class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        return list(set(list((map(lambda x:"""".join(list(map(str,x))),list(itertools.product([0,1],repeat=len(nums)))))))-set(nums))[0]"
find unique binary string,"class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        ans = []
        for i, x in enumerate(nums): 
            if x[i] == ""1"": ans.append(""0"")
            else: ans.append(""1"")
        return """".join(ans)"
minimize the difference between target and chosen elements,"class Solution:
    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        
        # store the mxn size of the matrix
        m = len(mat)
        n = len(mat[0])
        
        dp = defaultdict(defaultdict)
        
        # Sorting each row of the array for more efficient pruning
        # Note:this purely based on the observation on problem constraints (although interesting :))
        for i in range(m):
            mat[i] = sorted(mat[i])
        
        # returns minimum absolute starting from from row i to n-1 for the target
        globalMin = float(""inf"")
        def findMinAbsDiff(i,prevSum):
            nonlocal globalMin
            if i == m:
                globalMin = min(globalMin, abs(prevSum-target))
                return abs(prevSum-target)
            
            # pruning step 1
            # because the array is increasing &amp; prevSum &amp; target will always be positive
            if prevSum-target > globalMin:
                return float(""inf"")
            
            
            if (i in dp) and (prevSum in dp[i]):
                return dp[i][prevSum]
            
            minDiff = float(""inf"")
            # for each candidate select that and backtrack
            for j in range(n):
                diff = findMinAbsDiff(i+1, prevSum+mat[i][j])
                # pruning step 2 - break if we found minDiff 0 --> VERY CRTICIAL
                if diff == 0:
                    minDiff = 0
                    break
                minDiff = min(minDiff, diff)
            
            dp[i][prevSum] = minDiff
            return minDiff
        
        return findMinAbsDiff(0, 0)"
minimize the difference between target and chosen elements,"class Solution:
	def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
		rows = len(mat)
		old_hash_set = set({0})

		for i in range(rows):
			hash_set = set()
			max_val = None
			for elem in old_hash_set:
				for row_val in sorted(mat[i]):
					if max_val is not None and elem + row_val >= max_val:
						continue

					if max_val is None and elem + row_val >= target:
						max_val = elem + row_val
						hash_set.add(max_val)
					else:
						hash_set.add(elem+row_val)
			old_hash_set = hash_set

		min_dif = float('inf')

		for elem in old_hash_set:
			if min_dif > abs(target-elem):
				min_dif = abs(target-elem)

		return min_dif"
find array given subset sums,"class Solution:
    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        res = []  # Result set
        sums.sort()
        
        while len(sums) > 1:
            num = sums[-1] - sums[-2] # max - secondMax
            countMap = Counter(sums) # Get count of each elements
            excluding = [] # Subset sums that do NOT contain num
            including = [] # Subset sums that contain num
            
            for x in sums:
                if countMap.get(x) > 0:
                    excluding.append(x)
                    including.append(x+num)
                    countMap[x] -= 1
                    countMap[x+num] -= 1
                    
			# Check validity of excluding set	
            if 0 in excluding:
                sums = excluding
                res.append(num)
            else:
                sums = including
                res.append(-1*num)
        
        return res"
find array given subset sums,"class Solution:
    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        sums.sort()
        ans = []
        for _ in range(n): 
            diff = sums[1] - sums[0]
            ss0, ss1 = [], []
            freq = defaultdict(int)
            on = False 
            for i, x in enumerate(sums): 
                if not freq[x]: 
                    ss0.append(x)
                    freq[x+diff] += 1
                    if x == 0: on = True 
                else: 
                    ss1.append(x)
                    freq[x] -= 1
            if on: 
                ans.append(diff)
                sums = ss0 
            else: 
                ans.append(-diff)
                sums = ss1
        return ans"
minimum difference between highest and lowest of k scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        return min(nums[i+k-1]-nums[i] for i in range(len(nums)-k+1))"
minimum difference between highest and lowest of k scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 100000
        
        for i in range(len(nums) - k + 1):
            arr = nums[i:i + k]
            res = min(res, arr[-1] - arr[0])
            
        return res"
find the kth largest integer in the array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        nums = sorted(map(int, nums), reverse=True)
        return str(nums[k-1])"
find the kth largest integer in the array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        return sorted(nums, key=int)[-k]"
minimum number of work sessions to finish the tasks,"class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -> int:
        subsets = []
        self.ans = len(tasks)
        
        def func(idx):
            if len(subsets) >= self.ans:
                return
            
            if idx == len(tasks):
                self.ans = min(self.ans, len(subsets))
                return
            
            for i in range(len(subsets)):
                if subsets[i] + tasks[idx] <= sessionTime:
                    subsets[i] += tasks[idx]
                    func(idx + 1)
                    subsets[i] -= tasks[idx]
            
            subsets.append(tasks[idx])
            func(idx + 1)
            subsets.pop()
        
        func(0)
        return self.ans"
minimum number of work sessions to finish the tasks,"class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -> int:
        tasks = sorted(tasks)

        @lru_cache(None)
        def recur_fn(x,tasks):
            if len(tasks) == 0:
                return 1
            ans = 0
            result = []
            if tasks[0] > x:
                ans += 1  #on to the new session as can't fit anything in 
                x = sessionTime #resets remaining session time to full session 
            for i,val in enumerate(tasks):
                if val <= x:
                    result.append(recur_fn(x-val,tasks[0:i] + tasks[i+1:]))
                else:
                    break
            return ans + min(result)
        
        return recur_fn(sessionTime,tuple(tasks))"
number of unique good subsequences,"class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        
        @cache
        def fn(i, mask, v): 
            """"""Return # unique good subsequences starting with 1.""""""
            if i == len(binary) or not mask: return v
            x = int(binary[i])
            if not mask &amp; (1<<x): return fn(i+1, mask, v)
            return (fn(i+1, 3, 1) + fn(i+1, mask^(1<<x), v)) % 1_000_000_007
        
        return fn(0, 2, 0) + int(""0"" in binary)"
number of unique good subsequences,"class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        f0 = f1 = 0
        for ch in binary: 
            if ch == ""0"": f0 += f1
            else: f1 += f0 + 1
        return (f0 + f1 + int(""0"" in binary)) % 1_000_000_007"
find the middle index in array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        left = 0 # nums[0] + nums[1] + ... + nums[middleIndex-1]
        right = sum(nums) # nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]

        for i, num in enumerate(nums): # we can use normal for loop as well.
            right -= num # as we are trying to find out middle index so iteratively we`ll reduce the value of right to find the middle index
            if left == right: # comparing the values for finding out the middle index.
                return i # if there is any return the index whixh will be our required index.
            left += num # we have to add the num iteratively. 

        return -1"
find the middle index in array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        A = [0] + list(accumulate(nums)) + [0]
        total, n = sum(nums), len(nums)
        for i in range(n):
            if A[i] == total - A[i] - nums[i]:
                return i
        return -1"
find all groups of farmland,"class Solution:
    def findFarmland(self, land: List[List[int]]) -> List[List[int]]:
        m, n = len(land), len(land[0])
        ans = []
        for i in range(m):
            for j in range(n): 
                if land[i][j]: # found farmland
                    mini, minj = i, j 
                    maxi, maxj = i, j 
                    stack = [(i, j)]
                    land[i][j] = 0 # mark as visited 
                    while stack: 
                        i, j = stack.pop()
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                            if 0 <= ii < m and 0 <= jj < n and land[ii][jj]: 
                                stack.append((ii, jj))
                                land[ii][jj] = 0 
                                maxi = max(maxi, ii)
                                maxj = max(maxj, jj)
                    ans.append([mini, minj, maxi, maxj])
        return ans"
find all groups of farmland,"class Solution:
    def findFarmland(self, land: List[List[int]]) -> List[List[int]]:
        res = []
        visited = {}
        rows, cols = len(land), len(land[0])
        
        def bfs(i, j):
            q = deque([(i, j)])
            max_i, max_j = i, j
            while q:
                i, j = q.popleft()
                max_i, max_j = max(max_i, i), max(max_j, j)
                for a, b in ((0, 1), (1, 0)):
                    u, v = i + a, j + b
                    if 0 <= u <= rows - 1 and 0 <= v <= cols - 1 and land[u][v] and (u, v) not in visited:
                        visited[(u, v)] = 1
                        q.append((u, v))
            return max_i, max_j
        
        for i in range(rows):
            for j in range(cols):
                if land[i][j] and (i, j) not in visited:
                    visited[(i, j)] = 1
                    x, y = bfs(i, j)
                    res.append([i, j, x, y])
        return res"
the number of good subsets,"class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        freq = [0] * 31
        for x in nums: freq[x] += 1
        
        masks = [0] * 31
        for x in range(1, 31): 
            if x == 1: masks[x] = 0b10
            else: 
                bits = 0
                xx = x
                for k in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29): 
                    while xx % k == 0: 
                        if (bits >> k) &amp; 1: break # repeated factors 
                        bits ^= 1 << k
                        xx //= k
                    else: continue 
                    break 
                else: masks[x] = bits
                    
        @cache
        def fn(x, m): 
            """"""Return number of good subsets.""""""
            if x == 31: return int(m > 2)
            ans = fn(x+1, m)
            if freq[x] and masks[x]: 
                if x == 1: ans *= 2**freq[x]
                elif not m &amp; masks[x]: ans += freq[x] * fn(x+1, m | masks[x])
            return ans % 1_000_000_007
        
        return fn(1, 0)"
the number of good subsets,"class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

        cands = {}
        for x in range(1, 31):
            orig = x
            mask = 0
            for p in primes:
                if x % p: continue
                if p > x: break
                x //= p
                mask ^= (1 << p)
            if x == 1:
                cands[orig] = mask


        cnt = {k: v for k, v in Counter(nums).items() if k in cands}
        cnt_key = list(filter(lambda x: x> 1, sorted(cnt)))
        n = len(cnt_key)
        M = 10**9 + 7
        
        @lru_cache(None)
        def dp(i, mask):
            if i == n:
                return mask > 0
            ans = dp(i+1, mask)
            if mask &amp; cands[cnt_key[i]] == 0:
                ans += cnt[cnt_key[i]] * dp(i+1, mask ^ cands[cnt_key[i]])
            return ans % M
        
        return (dp(0, 0) * pow(2, cnt.get(1, 0))) % M"
count special quadruplets,"class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        idx = defaultdict(list)
        for i in range(len(nums)-1):
            for j in range(i+1, len(nums)):
                idx[nums[j]-nums[i]].append(i)
        
        count = 0 
        for i in range(len(nums)-3):
            for j in range(i+1, len(nums)-2):
                count += sum(k > j for k in idx[nums[i]+nums[j]])
                        
        return count"
count special quadruplets,"class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        ans = 0
        freq = defaultdict(int)
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                for k in range(j+1, len(nums)):
                    ans += freq[nums[k] - nums[i] - nums[j]]
            freq[nums[i]] += 1
        return ans"
the number of weak characters in the game,"class Solution:
    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
        
        properties.sort(key=lambda x: (-x[0],x[1]))
        
        ans = 0
        curr_max = 0
        
        for _, d in properties:
            if d < curr_max:
                ans += 1
            else:
                curr_max = d
        return ans"
the number of weak characters in the game,"class Solution:
    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
        
        properties.sort(key=lambda x: (x[0], -x[1]))
        
        stack = []
        ans = 0
        
        for a, d in properties:
            while stack and stack[-1] < d:
                stack.pop()
                ans += 1
            stack.append(d)
        return ans"
first day where you have been in all the rooms,"class Solution:
    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:
        odd = [0]
        even = [1]
        for i in range(1, len(nextVisit)): 
            odd.append((even[-1] + 1) % 1_000_000_007)
            even.append((2*odd[-1] - odd[nextVisit[i]] + 1) % 1_000_000_007)
        return odd[-1]"
first day where you have been in all the rooms,"class Solution:
    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:
        n = len(nextVisit)
        dp = [0] * n
        mod = int(1e9+7)
        for i in range(n-1):
            # dp[i]: moves need to visited `i`
            # dp[i] - dp[nextVisit[i]] + 1: odd visit at i, then back to nextVisited[i] (+1), then move back to i (dp[i] - dp[nextVisit[i]]) for even visit
            # dp[i] + 1: even visit at i, then from i to i+1
            dp[i+1] = (dp[i] - dp[nextVisit[i]] + 1 + dp[i] + 1) % mod
        return dp[n-1]"
reverse prefix of word,"class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        try:
            ix = word.index(ch)
            return word[:ix+1][::-1] + word[ix+1:]
        except ValueError:
            return word"
reverse prefix of word,"class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        if ch not in word:
            return word
        return (''.join(reversed(word[:(word.index(ch)+1)]))+word[(word.index(ch))+1:])"
number of pairs of interchangeable rectangles,"class Solution:
    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
        preSum = []
        for rec in rectangles:
            preSum.append(rec[1]/rec[0])
        
        dic1 = {}
        for i in range(len(preSum)-1, -1, -1):
            if preSum[i] not in dic1.keys():
                dic1[preSum[i]] = [0,1]
            else:
                dic1[preSum[i]][0] = dic1[preSum[i]][0] + dic1[preSum[i]][1]
                dic1[preSum[i]][1] += 1
        
        return sum ([v[0] for v in dic1.values()])"
number of pairs of interchangeable rectangles,"class Solution:
    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
        count=0
        d=dict()
        for i in range(len(rectangles)):
            ratio=rectangles[i][0]/rectangles[i][1]
            if ratio not in d:
                d[ratio]=1
            else:
                count+=d[ratio]
                d[ratio]+=1
        return count"
maximum product of the length of two palindromic subsequences,"class Solution:
    def maxProduct(self, s: str) -> int:
        subs = []
        n = len(s)
        def dfs(curr, ind, inds):
            if ind == n:
                if curr == curr[::-1]:
                    subs.append((curr, inds))
                return
            dfs(curr+s[ind], ind+1, inds|{ind})
            dfs(curr, ind+1, inds)
        
        dfs('', 0, set())
        
        res = 0
        n = len(subs)
        for i in range(n):
            s1, i1 = subs[i]
            for j in range(i+1, n):
                s2, i2 = subs[j]
                if len(i1 &amp; i2) == 0:
                    res = max(res, len(s1)*len(s2))
        return res"
maximum product of the length of two palindromic subsequences,"class Solution:
    def maxProduct(self, s: str) -> int:
        
        @cache
        def lps(mask): 
            """"""Return length of longest palindromic sequence.""""""
            if not mask: return 0
            if not mask &amp; (mask-1): return 1
            lo = int(log2(mask &amp; ~(mask-1))) # least significant set bit
            hi = int(log2(mask)) # most significant set bit 
            if s[lo] == s[hi]: return 2 + lps(mask^(1<<lo)^(1<<hi))
            return max(lps(mask^(1<<lo)), lps(mask^(1<<hi)))
        
        ans = 0
        for mask in range(1 << len(s)): 
            comp = (1 << len(s)) - 1 ^ mask
            ans = max(ans, lps(mask) * lps(comp))
        return ans"
smallest missing genetic value in each subtree,"class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        ans = [1] * len(parents)
        if 1 in nums: 
            tree = {}
            for i, x in enumerate(parents): 
                tree.setdefault(x, []).append(i)
                
            k = nums.index(1)
            val = 1
            seen = set()
            
            while k != -1: 
                stack = [k]
                while stack: 
                    x = stack.pop()
                    seen.add(nums[x])
                    for xx in tree.get(x, []): 
                        if nums[xx] not in seen: 
                            stack.append(xx)
                            seen.add(nums[xx])
                while val in seen: val += 1
                ans[k] = val
                k = parents[k]
        return ans"
count number of pairs with absolute difference k,"class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        seen = defaultdict(int)
        counter = 0
        for num in nums:
            tmp, tmp2 = num - k, num + k
            if tmp in seen:
                counter += seen[tmp]
            if tmp2 in seen:
                counter += seen[tmp2]
            
            seen[num] += 1
        
        return counter"
count number of pairs with absolute difference k,"class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        seen = defaultdict(int)
        counter = 0
        for num in nums:
            counter += seen[num-k] + seen[num+k]
            seen[num] += 1
        return counter"
find original array from doubled array,"class Solution:
    def findOriginalArray(self, changed: List[int]) -> List[int]:
        
        """"""
        The idea is to:
            1st sort the numbers
            2nd Create a counter to save the frequency of each number
            3nd iterate the array and for each number check if the double exists.
            4rd after taking len(changed) // 2 numbers return the answer
            
        Time complexity: O(nlog(n)) 
        Space complexity: O(n)
        
        """"""
        
        
        if len(changed) % 2 != 0: # If there are not even amount the numbers there is no solution.
            return []
        
        changed.sort()
        
        c = Counter(changed) # The counter is needed because we have 0s
        
        answer = []
        for num in changed:
            if num in c and c[num] >= 1: # Check if the number is available (we may have taken it before)
                c[num] -= 1 # we mark the number as used by decreasing the counter (only needed for the zeros)
                if (num * 2) in c and c[(num * 2)] >= 1: # Take the one that doubles it if exists
                    answer.append(num)
                    c[num*2] -= 1 # The number has been taken.
            
            if len(answer) == len(changed) // 2:
                return answer
        
        return []"
find original array from doubled array,"class Solution:
    def findOriginalArray(self, changed: List[int]) -> List[int]:
        changed.sort()
        stk,res=deque([]),[]
        for i in changed:
            if stk and stk[0]*2==i:
                b=stk.popleft()
                res.append(b)
            else:
                stk.append(i)
        return res if not stk else []"
maximum earnings from taxi,"class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
        
        d = {}
        for start,end,tip in rides:
            if end not in d:
                d[end] =[[start,tip]]
            else:
                d[end].append([start,tip])
        
       
        dp = [0]*(n+1)
        dp[0] = 0
        
        for i in range(1,n+1):
            dp[i] = dp[i-1]
            if i in d:
                temp_profit = 0
                for start,tip in d[i]:
                    if (i-start)+tip+dp[start] > temp_profit:
                        temp_profit = i-start+tip+dp[start]
                dp[i] = max(dp[i],temp_profit)
                
                
        return dp[-1]"
maximum earnings from taxi,"class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
        mp = {}
        for start, end, tip in rides: 
            mp.setdefault(start, []).append((end, tip))
        
        @cache
        def fn(x): 
            """"""Return max earning at x.""""""
            if x == n: return 0 
            ans = fn(x+1)
            for xx, tip in mp.get(x, []): 
                ans = max(ans, xx - x + tip + fn(xx))
            return ans 
        
        return fn(1)"
minimum number of operations to make array continuous,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        nums = sorted(set(nums))
        
        ans = ii = 0
        for i, x in enumerate(nums): 
            if x - nums[ii] >= n: ii += 1
            ans = max(ans, i - ii + 1)
        return n - ans"
minimum number of operations to make array continuous,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        nums = sorted(set(nums))
		
        answer = float(""+inf"")
        for i, start in enumerate(nums):
            
            search = start + n - 1  # number to search
            start, end = 0, len(nums)-1
            
            while start <= end:
                mid = start + (end - start) // 2
                if nums[mid] <= search:
                    idx = mid
                    start = mid + 1
                else:
                    end = mid - 1
            
            changes = idx - i + 1
            answer = min(answer, n - changes)
        return answer"
final value of variable after performing operations,"class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        x = 0
        for o in operations:
            if '+' in o:
                x += 1
            else:
                x -= 1
        return x"
final value of variable after performing operations,"class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        return sum(1 if '+' in o else -1 for o in operations)"
sum of beauty in the array,"class Solution:
    def sumOfBeauties(self, nums: List[int]) -> int:
        beauty=[0]*len(nums)
        for i in range(1,len(nums)-1):
            leftarr=nums[:i]
            rightarr=nums[i+1:]
            if(max(leftarr)<nums[i] and min(rightarr)>nums[i]):
                beauty[i]=2
            elif(nums[i-1]<nums[i] and nums[i+1]>nums[i]):
                beauty[i]=1
            else:
                beauty[i]=0
        return sum(beauty)"
sum of beauty in the array,"class Solution:
    def sumOfBeauties(self, a: List[int]) -> int:
        temp,temp2=a[0],a[-1]
        left=([a[0]]+[0]*(len(a)-1))
        right=[0]*(len(a)-1) + [a[-1]]
        for i in range(1,len(a)):
            left[i]=max(a[i-1],temp)
            temp=left[i]
        for i in range(len(a)-2,-1,-1):
            right[i]=min(a[i+1],temp2)
            temp2=right[i]
        res=0
        for i in range(1,len(a)-1):
            if(a[i]>left[i] and a[i]<right[i]):
                res+=2
            elif(a[i]>a[i-1] and a[i]<a[i+1]):
                res+=1
        return res"
longest subsequence repeated k times,"class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        freq = [0] * 26
        for ch in s: freq[ord(ch)-97] += 1
        
        cand = [chr(i+97) for i, x in enumerate(freq) if x >= k] # valid candidates 
        
        def fn(ss): 
            """"""Return True if ss is a k-repeated sub-sequence of s.""""""
            i = cnt = 0
            for ch in s: 
                if ss[i] == ch: 
                    i += 1
                    if i == len(ss): 
                        if (cnt := cnt + 1) == k: return True  
                        i = 0
            return False 
        
        ans = """"
        queue = deque([""""])
        while queue: 
            x = queue.popleft()
            for ch in cand:  
                xx = x + ch
                if fn(xx): 
                    ans = xx
                    queue.append(xx)
        return ans"
longest subsequence repeated k times,"class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        def helper(subString, string):
            n, m = len(subString), len(string)
            i, j = 0, 0
            while i < n and j < m: 
                if subString[i] == string[j]:
                    i += 1
                j += 1
                
            return i == n
            
        counter = defaultdict(lambda: 0)
        
        for char in s: 
            counter[char] += 1
            
        chars = [key for key in counter if counter[key] >= k]
        chars.sort()
        
        ans = """"
        stack = [""""]
        while stack: 
            prefix = stack.pop(0)
            for char in chars:  
                word = prefix + char
                if helper(word*k, s):                     
                    stack.append(word)
                    ans = word
                    
        return ans"
maximum difference between increasing elements,"class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        ans = -1 
        prefix = inf
        for i, x in enumerate(nums): 
            if i and x > prefix: ans = max(ans, x - prefix)
            prefix = min(prefix, x)
        return ans"
maximum difference between increasing elements,"class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        mn,mx=float('inf'),-1
        for i in range(len(nums)):
            mn=min(mn,nums[i])
            mx=max(mx,nums[i]-mn)
        if mx==0: return -1
        return mx"
grid game,"class Solution(object):
    def gridGame(self, grid):
        
        top, bottom = grid
        top_sum = sum(top)
        bottom_sum = 0
        res = float('inf')
        
        for i in range(len(top)):
            top_sum -= top[i]
            res = min(res, max(top_sum, bottom_sum))
            bottom_sum += bottom[i]
            
        return res"
grid game,"class Solution:
    def gridGame(self, grid: List[List[int]]) -> int:
        ans = inf
        prefix = 0
        suffix = sum(grid[0])
        for i in range(len(grid[0])): 
            suffix -= grid[0][i]
            ans = min(ans, max(prefix, suffix))
            prefix += grid[1][i]
        return ans"
check if word can be placed in crossword,"class Solution:
    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
        for x in board, zip(*board): 
            for row in x: 
                for s in """".join(row).split(""#""): 
                    for w in word, word[::-1]: 
                        if len(s) == len(w) and all(ss in ("" "", ww) for ss, ww in zip(s, w)): return True 
        return False"
check if word can be placed in crossword,"class Solution:
    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
        for x in board, zip(*board): 
            for row in x:
                for k, grp in groupby(row, key=lambda x: x != ""#""): 
                    grp = list(grp)
                    if k and len(grp) == len(word): 
                        for w in word, word[::-1]: 
                            if all(gg in ("" "", ww) for gg, ww in zip(grp, w)): return True 
        return False"
the score of students solving math expression,"class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        
        @cache
        def fn(lo, hi): 
            """"""Return possible answers of s[lo:hi].""""""
            if lo+1 == hi: return {int(s[lo])}
            ans = set()
            for mid in range(lo+1, hi, 2): 
                for x in fn(lo, mid): 
                    for y in fn(mid+1, hi): 
                        if s[mid] == ""+"" and x + y <= 1000: ans.add(x + y)
                        elif s[mid] == ""*"" and x * y <= 1000: ans.add(x * y)
            return ans 
                
        target = eval(s)
        cand = fn(0, len(s))
        ans = 0 
        for x in answers: 
            if x == target: ans += 5
            elif x in cand: ans += 2
        return ans"
the score of students solving math expression,"class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        @lru_cache(None)
        def allEval(x):
            lo = eval(x)
            if lo > 1000:
                return set()
            ans = set([lo])
            if '*' not in x or '+' not in x or lo==1000:
                return ans
            for pos, char in enumerate(x):
                if char not in ['+', '*']:
                    continue
                left, right = allEval(x[:pos]), allEval(x[pos+1:])
                if char == '+':
                    ans |= {a + b for a in left for b in right if a+b<=1000}
                if char == '*':
                    ans |= {a * b for a in left for b in right if a*b<=1000}
            return ans
        S = allEval(s)
        correct = eval(s)
        return sum(5 if x==correct else (2 if x in S else 0) for x in answers)"
convert 1d array into 2d array,"class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        ans = []
        if len(original) == m*n: 
            for i in range(0, len(original), n): 
                ans.append(original[i:i+n])
        return ans"
convert 1d array into 2d array,"class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        return [original[i:i+n] for i in range(0, len(original), n)] if m*n == len(original) else []"
number of pairs of strings with concatenation equal to target,"class Solution:
    def numOfPairs(self, nums: List[str], target: str) -> int:
        freq = Counter(nums)
        ans = 0 
        for k, v in freq.items(): 
            if target.startswith(k): 
                suffix = target[len(k):]
                ans += v * freq[suffix]
                if k == suffix: ans -= freq[suffix]
        return ans"
number of pairs of strings with concatenation equal to target,"class Solution:
    def numOfPairs(self, nums, target):
        return sum(i + j == target for i, j in permutations(nums, 2))"
maximize the confusion of an exam,"class Solution:
	def maxConsecutiveAnswers(self, string: str, k: int) -> int:
		result = 0
		j = 0
		count1 = k
		for i in range(len(string)):
			if count1 == 0 and string[i] == ""F"":
				while string[j] != ""F"":
					j+=1
				count1+=1 
				j+=1

			if string[i] == ""F"":
				if count1 > 0:
					count1-=1

			if i - j + 1 > result:
				result = i - j + 1

		j = 0
		count2 = k
		for i in range(len(string)):
			if count2 == 0 and string[i] == ""T"":
				while string[j] != ""T"":
					j+=1
				count2+=1 
				j+=1

			if string[i] == ""T"":
				if count2 > 0:
					count2-=1

			if i - j + 1 > result:
				result = i - j + 1

		return result"
maximize the confusion of an exam,"class Solution:
    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:
        n = len(answerKey)
        left = ret = numT = numF = 0
        
        for right in range(n):
            if answerKey[right]=='T':
                numT+=1
            else:
                numF+=1
            while numT>k and numF>k:
                if answerKey[left]=='T':
                    numT-=1
                else:
                    numF-=1
                left+=1
            ret = max(ret, right-left+1)
        return ret"
maximum number of ways to partition an array,"class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        prefix = [0]
        loc = defaultdict(list)
        for i, x in enumerate(nums): 
            prefix.append(prefix[-1] + x)
            if i < len(nums)-1: loc[prefix[-1]].append(i)
        
        ans = 0 
        if prefix[-1] % 2 == 0: ans = len(loc[prefix[-1]//2]) # unchanged 
        
        total = prefix[-1]
        for i, x in enumerate(nums): 
            cnt = 0 
            diff = k - x
            target = total + diff 
            if target % 2 == 0: 
                target //= 2
                cnt += bisect_left(loc[target], i)
                cnt += len(loc[target-diff]) - bisect_left(loc[target-diff], i)
            ans = max(ans, cnt)
        return ans"
maximum number of ways to partition an array,"class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        """"""This is a good problem. It's not difficult, but is quite complex.

        The idea is that once we change a position at i, for all the pivots at
        1...i, the sum of the left half stay the same whereas the sum of
        the right half changes by delta = k - nums[i]. Similarly, for all the
        pivots at i + 1...n - 1, the left half changes by delta, whereas the
        right half stay the same.

        We can pre-compute all the differences at each pivot position and make
        that into a diffs = [d1, d2, .... , dn-1]

        Then after a change at i, if we want the pivots at 1...i to form a good
        partition, we must have left - (right + delta) = 0 => delta = left - right
        In other words, the number of good partitions is the count of d1, d2, ...
        di that are equal to delta. Similarly, if we want the pivots at i + 1...
        n - 1 to form a good partition, we must have left + delta - right = 0
        => left - right = -delta. In other words, the number of good partitions
        is the count of di+1, ...., dn-1 that are equal to -delta.

        Based on this, we progressively build a left sum and right sum to
        compute the diffs array. And then progressively build a left counter
        and right counter to compute the number of matches to delta and -delta.

        The difficulty is in the implementation, especially with the indices.

        O(N), 7339 ms, faster than 32.20%
        """"""
        N = len(nums)
        diffs = []
        sl, sr = 0, sum(nums)
        for i in range(N - 1):
            sl += nums[i]
            sr -= nums[i]
            diffs.append(sl - sr)
        diffs.append(math.inf)  # to prevent error in the counter arithemtic
        
        cl, cr = Counter(), Counter(diffs)
        res = cl[0] + cr[0]
        for i in range(N):
            d = k - nums[i]
            res = max(res, cl[d] + cr[-d])
            cl[diffs[i]] += 1
            cr[diffs[i]] -= 1
        return res"
minimum moves to convert string,"class Solution:
    def minimumMoves(self, s: str) -> int:
        ans = i = 0
        while i < len(s): 
            if s[i] == ""X"": 
                ans += 1
                i += 3
            else: i += 1
        return ans"
minimum moves to convert string,"class Solution:
    def minimumMoves(self, s: str) -> int:
        i, m = 0, 0
        l = len(s)

        while i < l:
            if s[i] != 'X':
                i += 1
            elif 'X' not in s[i:i+1]:
                i += 2
            elif 'X' in s[i:i+2]:
                m += 1
                i += 3
        return m"
find missing observations,"class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        missing_val, rem = divmod(mean * (len(rolls) + n) - sum(rolls), n)
        if rem == 0:
            if 1 <= missing_val <= 6:
                return [missing_val] * n
        elif 1 <= missing_val < 6:
            return [missing_val + 1] * rem + [missing_val] * (n - rem)
        return []"
find missing observations,"class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        total = mean * (len(rolls) + n) - sum(rolls)
        if not n <= total <= 6*n: return []
        q, r = divmod(total, n)
        return [q]*(n-r) + [q+1]*r"
stone game ix,"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        freq = defaultdict(int)
        for x in stones: freq[x % 3] += 1
        
        if freq[0]%2 == 0: return freq[1] and freq[2]
        return abs(freq[1] - freq[2]) >= 3"
stone game ix,"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        stones = [v % 3 for v in stones]
        
        d = defaultdict(int)
        for v in stones:
            d[v] += 1
        
        while d[1] >= 2 and d[2] >= 2:
            d[2] -= 1
            d[1] -= 1
        
        if d[0] % 2 == 0: # number of 0s will not influent the result
            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):
                return True
        else:
            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):
                return True
            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):
                return True

        return False"
smallest k length subsequence with occurrences of a letter,"class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        counts,total = 0, 0
        n = len(s)
        for ch in s:
            if ch==letter:
                total +=1
        stack = []
        occ = 0
        for idx,ch in enumerate(s):
            if ch==letter:
                counts +=1
            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): 
                occ -= stack.pop()==letter
            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):
                stack.append(ch)
            elif ch==letter and len(stack)+(total-counts)<k:
                stack.append(ch)
                occ +=1
        return ''.join(stack)"
smallest k length subsequence with occurrences of a letter,"class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        s = list(s)
        stack = []
        countAll = s.count(letter)
        count = 0
        for ind, i in enumerate(s):
            while stack and stack[-1] > i:
                if stack[-1] == letter and i != letter:
                    if countAll+count-1 < repetition:
                        break
                if len(stack)+len(s)-ind-1 < k:
                    break
                if stack[-1] == letter:
                    count-=1
                stack.pop()
            stack.append(i)
            if i == letter:
                count+=1
                countAll-=1
        temp = 0
        while len(stack)+temp > k:
            if stack[-1] == letter and count <= repetition:
                temp+=1
            if stack[-1] == letter:
                count-=1
            stack.pop()
        return """".join(stack)+temp*letter"
two out of three,"class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        s1, s2, s3 = set(nums1), set(nums2), set(nums3)
        return (s1&amp;s2) | (s2&amp;s3) | (s1&amp;s3)"
two out of three,"class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        freq = Counter()
        for nums in nums1, nums2, nums3: freq.update(set(nums))
        return [k for k, v in freq.items() if v >= 2]"
minimum operations to make a uni value grid,"class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        vals = [x for row in grid for x in row]
        if len(set(val%x for val in vals)) > 1: return -1 # impossible
        median = sorted(vals)[len(vals)//2] # O(N) possible via ""quick select""
        return sum(abs(val - median)//x for val in vals)"
minimum operations to make a uni value grid,"class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        li = []
        
        # convert matrix to array, we dont care about the structure itself. We just want the values
        for val in grid:
            li+= val
        
        # sort the array
        li.sort()
        
        # get the middle value, which is equidistant from both sides
        median = li[len(li)//2]
        ops = 0
        
        # run the loop over all the elements to calculate the number of operations needed
        for val in li:
            
            # this is the condtion which determines if our number can reach the other number with adding/subtracting k
            if abs(val-median)%x != 0:
                return -1
            ops += abs(val-median)//x
        return ops"
partition array into two arrays to minimize sum difference,"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        N = len(nums) // 2 # Note this is N/2, ie no. of elements required in each.
        
        def get_sums(nums): # generate all combinations sum of k elements
            ans = {}
            N = len(nums)
            for k in range(1, N+1): # takes k element for nums
                sums = []
                for comb in combinations(nums, k):
                    s = sum(comb)
                    sums.append(s)
                ans[k] = sums
            return ans
        
        left_part, right_part = nums[:N], nums[N:]
        left_sums, right_sums = get_sums(left_part), get_sums(right_part)
        ans = abs(sum(left_part) - sum(right_part)) # the case when taking all N from left_part for left_ans, and vice versa
        total = sum(nums) 
        half = total // 2 # the best sum required for each, we have to find sum nearest to this
        for k in range(1, N):
            left = left_sums[k] # if taking k no. from left_sums
            right = right_sums[N-k] # then we have to take remaining N-k from right_sums.
            right.sort() # sorting, so that we can binary search the required value
            for x in left:
                r = half - x # required, how much we need to add in x to bring it closer to half.
                p = bisect.bisect_left(right, r) # we are finding index of value closest to r, present in right, using binary search
                for q in [p, p-1]:
                    if 0 <= q < len(right):
                        left_ans_sum = x + right[q]
                        right_ans_sum = total - left_ans_sum
                        diff = abs(left_ans_sum - right_ans_sum)
                        ans = min(ans, diff) 
        return ans"
partition array into two arrays to minimize sum difference,"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        
        n = len(nums)
        tot = sum(nums)

        l, r = nums[:n//2], nums[n//2:]
        lsum, rsum = defaultdict(set), defaultdict(set)

        for k in range(n // 2 + 1):
            lsum[k] |= set(map(sum, combinations(l, k)))
            rsum[k] |= set(map(sum, combinations(r, k)))
        
        
        ans = float('inf')
        for k in lsum:
            rsum_cand = sorted(rsum[n // 2 - k])
            for ls in lsum[k]:
                cand = tot // 2 - ls                
                loc = bisect.bisect(rsum_cand, cand)
                if loc == 0:
                    rs = rsum_cand[loc]
                    ans = min(ans, abs(tot - 2 * (rs + ls)))
                elif loc == len(rsum_cand):
                    rs = rsum_cand[loc-1]
                    ans = min(ans, abs(tot - 2 * (rs + ls)))
                else:
                    rs1, rs2 = rsum_cand[loc-1], rsum_cand[loc]
                    ans = min(ans, abs(tot - 2 * (rs1 + ls)), abs(tot - 2 * (rs2 + ls)))        
        
        return ans"
minimum number of moves to seat everyone,"class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats.sort()
        students.sort()
        return sum(abs(seat - student) for seat, student in zip(seats, students))"
minimum number of moves to seat everyone,"class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats_cnt, students_cnt = [0] * (max(seats) + 1), [0] * (max(students) + 1)
        for seat in seats:
            seats_cnt[seat] += 1
        for student in students:
            students_cnt[student] += 1
        ans = 0
        i = j = 1
        while i < len(students_cnt):
            if students_cnt[i]:
                # find the next available seat
                while j < len(seats_cnt) and not seats_cnt[j]:
                    j += 1
                ans += abs(i - j)
                seats_cnt[j] -= 1
                students_cnt[i] -= 1
            else:
                i += 1
        return ans"
remove colored pieces if both neighbors are the same color,"class Solution:
    def winnerOfGame(self, s: str) -> bool:
        
        a = b = 0
        
        for i in range(1,len(s)-1):
            if s[i-1] == s[i] == s[i+1]:
                if s[i] == 'A':
                    a += 1
                else:
                    b += 1
                    
        return a>b"
remove colored pieces if both neighbors are the same color,"class Solution:
    def winnerOfGame(self, s: str) -> bool:
        a=[]
        p=""C""
        for i in s:
            if i==p:
                a[-1]+=1
            else:
                p=i
                a.append(1)
        odd,even=0,0
        for i in range(len(a)):
            if i%2:
                odd += max(0,a[i]-2)
            else:
                even += max (0,a[i]-2)
        if s[0]==""A"" and even>odd:
            return True
        if s[0]==""B"" and odd>even:
            return True
        return False"
the time when the network becomes idle,"class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        graph = {}
        for u, v in edges: 
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
        
        dist = [-1]*len(graph)
        dist[0] = 0 
        val = 0
        queue = [0]
        while queue: 
            val += 2
            newq = []
            for u in queue: 
                for v in graph[u]: 
                    if dist[v] == -1: 
                        dist[v] = val
                        newq.append(v)
            queue = newq
        
        ans = 0
        for d, p in zip(dist, patience): 
            if p: 
                k = d//p - int(d%p == 0)
                ans = max(ans, d + k*p)
        return ans + 1"
the time when the network becomes idle,"class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        graph = defaultdict(set)
        for a, b in edges:
            graph[a].add(b)
            graph[b].add(a)
            
        dis = {}
        queue = deque([(0, 0)])
        visited = set([0])
        while queue:
            cur, length = queue.popleft()
            dis[cur] = length * 2
            for nxt in graph[cur]:
                if nxt not in visited:
                    queue.append((nxt, length + 1))
                    visited.add(nxt)
        
        ans = -float(""inf"")
        for i in range(1, len(patience)):
            if patience[i] < dis[i]:
                rem = dis[i] % patience[i]
                lastCall = dis[i] - (rem) if rem > 0 else dis[i] - patience[i]
                ans = max(ans, lastCall + dis[i]) 
            else:
                ans = max(ans, dis[i])
        return ans + 1

# time and space complexity
# time: O(n + m)
# space: O(n)
# n = number of nodes
# m = len(edges)"
kth smallest product of two sorted arrays,"class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        
        def fn(val):
            """"""Return count of products <= val.""""""
            ans = 0
            for x in nums1: 
                if x < 0: ans += len(nums2) - bisect_left(nums2, ceil(val/x))
                elif x == 0: 
                    if 0 <= val: ans += len(nums2)
                else: ans += bisect_right(nums2, floor(val/x))
            return ans 
            
        lo, hi = -10**10, 10**10 + 1
        while lo < hi: 
            mid = lo + hi >> 1
            if fn(mid) < k: lo = mid + 1
            else: hi = mid
        return lo"
kth smallest product of two sorted arrays,"class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        neg = [x for x in nums1 if x < 0]
        pos = [x for x in nums1 if x >= 0]
        
        def fn(val):
            """"""Return count of products <= val.""""""
            ans = 0
            lo, hi = 0, len(nums2)-1
            for x in neg[::-1] + pos if val >= 0 else neg + pos[::-1]: 
                if x < 0: 
                    while lo < len(nums2) and x*nums2[lo] > val: lo += 1
                    ans += len(nums2) - lo
                elif x == 0: 
                    if 0 <= val: ans += len(nums2)
                else: 
                    while 0 <= hi and x*nums2[hi] > val: hi -= 1
                    ans += hi+1
            return ans 
        
        lo, hi = -10**10, 10**10 + 1
        while lo < hi: 
            mid = lo + hi >> 1
            if fn(mid) < k: lo = mid + 1
            else: hi = mid
        return lo"
check if numbers are ascending in a sentence,"class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        nums = [int(w) for w in s.split() if w.isdigit()]
        return all(nums[i-1] < nums[i] for i in range(1, len(nums)))"
check if numbers are ascending in a sentence,"class Solution:
    def areNumbersAscending(self, s):
        nums = re.findall(r'\d+', s)
        return nums == sorted(set(nums), key=int)"
count number of maximum bitwise or subsets,"class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        target = reduce(or_, nums)
        
        @cache
        def fn(i, mask): 
            """"""Return number of subsets to get target.""""""
            if mask == target: return 2**(len(nums)-i)
            if i == len(nums): return 0 
            return fn(i+1, mask | nums[i]) + fn(i+1, mask)
        
        return fn(0, 0)"
count number of maximum bitwise or subsets,"class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        
        def dfs(i,val):
            if maxBit == val : return 1<<(len(nums)-i)
            if i == len(nums): return 0
            return dfs(i+1,val|nums[i]) + dfs(i+1,val)
        maxBit = 0
        for i in nums: maxBit |= i
        return dfs(0,0)"
second minimum time to reach destination,"class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        graph = [[] for _ in range(n)]
        for u, v in edges: 
            graph[u-1].append(v-1)
            graph[v-1].append(u-1)
        pq = [(0, 0)]
        seen = [[] for _ in range(n)]
        least = None
        while pq: 
            t, u = heappop(pq)
            if u == n-1: 
                if least is None: least = t
                elif least < t: return t 
            if (t//change) &amp; 1: t = (t//change+1)*change # waiting for green
            t += time
            for v in graph[u]: 
                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: 
                    seen[v].append(t)
                    heappush(pq, (t, v))"
second minimum time to reach destination,"class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        graph = [[] for _ in range(n)]
        for u, v in edges: 
            graph[u-1].append(v-1)
            graph[v-1].append(u-1)
        
        least = None
        queue = deque([(0, 0)])
        seen = [[] for _ in range(n)]
        while queue: 
            t, u = queue.popleft()
            if u == n-1: 
                if least is None: least = t
                elif least < t: return t 
            if (t//change) &amp; 1: t = (t//change+1)*change # waiting for green
            t += time
            for v in graph[u]: 
                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: 
                    seen[v].append(t)
                    queue.append((t, v))"
number of valid words in a sentence,"class Solution:
    def countValidWords(self, sentence: str) -> int:
        
        def fn(word): 
            """"""Return true if word is valid.""""""
            seen = False 
            for i, ch in enumerate(word): 
                if ch.isdigit() or ch in ""!.,"" and i != len(word)-1: return False
                elif ch == '-': 
                    if seen or i == 0 or i == len(word)-1 or not word[i+1].isalpha(): return False 
                    seen = True 
            return True 
        
        return sum(fn(word) for word in sentence.split())"
number of valid words in a sentence,"class Solution:
    def countValidWords(self, sentence: str) -> int:
        pattern = re.compile(r'(^[a-z]+(-[a-z]+)?)?[,.!]?$')
        return sum(bool(pattern.match(word)) for word in sentence.split())"
next greater numerically balanced number,"class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        while True: 
            n += 1
            nn = n 
            freq = defaultdict(int)
            while nn: 
                nn, d = divmod(nn, 10)
                freq[d] += 1
            if all(k == v for k, v in freq.items()): return n"
next greater numerically balanced number,"class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        
        def fn(i, x):
            if i == k:
                if all(d == v for d, v in freq.items() if v): yield x
            else: 
                for d in range(1, k+1):
                    if freq[d] < d <= freq[d] + k - i: 
                        freq[d] += 1
                        yield from fn(i+1, 10*x+d)
                        freq[d] -= 1

        for k in (len(str(n)), len(str(n))+1):
            freq = Counter()
            for val in fn(0, 0):
                if val > n: return val"
count nodes with the highest score,"class Solution:
    def countHighestScoreNodes(self, parents: List[int]) -> int:
        graph = collections.defaultdict(list)
        for node, parent in enumerate(parents):  # build graph
            graph[parent].append(node)
        n = len(parents)                         # total number of nodes
        d = collections.Counter()
        def count_nodes(node):                   # number of children node + self
            p, s = 1, 0                          # p: product, s: sum
            for child in graph[node]:            # for each child (only 2 at maximum)
                res = count_nodes(child)         # get its nodes count
                p *= res                         # take the product
                s += res                         # take the sum
            p *= max(1, n - 1 - s)               # times up-branch (number of nodes other than left, right children ans itself)
            d[p] += 1                            # count the product
            return s + 1                         # return number of children node + 1 (self)
        count_nodes(0)                           # starting from root (0)
        return d[max(d.keys())]                  # return max count"
count nodes with the highest score,"class Solution:
    def countHighestScoreNodes(self, parents: List[int]) -> int:
        tree = [[] for _ in parents]
        for i, x in enumerate(parents): 
            if x >= 0: tree[x].append(i)
                
        freq = defaultdict(int)
        
        def fn(x): 
            """"""Return count of tree nodes.""""""
            left = right = 0
            if tree[x]: left = fn(tree[x][0])
            if len(tree[x]) > 1: right = fn(tree[x][1])
            score = (left or 1) * (right or 1) * (len(parents) - 1 - left - right or 1)
            freq[score] += 1
            return 1 + left + right
        
        fn(0)
        return freq[max(freq)]"
parallel courses iii,"class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        graph = { course:[] for course in range(n)}
        inDegree = [0]*n
        # 1- build graph
        #  convert 1-base into 0-baseindexes and add to graph
        # Note: choose Prev->next since it helps to preserve the topology order
        for prevCourse,nextCourse in relations:
            prevCourse,nextCourse = prevCourse-1, nextCourse-1
            graph[prevCourse].append(nextCourse)
            inDegree[nextCourse] += 1

        # 2 Assign time cost
        q = collections.deque()
        cost = [0] * n
        for course in range(n):
            if inDegree[course] == 0:
                q.append(course)
                cost[course] = time[course] # number of months
        # 3- BFS
        while q:
            prevCourse = q.popleft()
            for nextCourse in graph[prevCourse]:
                # Update cost[nextCourse] using the maximum cost of the predecessor course
                cost[nextCourse] = max(cost[nextCourse], cost[prevCourse] + time[nextCourse])
                inDegree[nextCourse] -= 1
                if inDegree[nextCourse] == 0:
                    q.append(nextCourse)
        return max(cost)
		```"
parallel courses iii,"class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        graph = [[] for _ in range(n)]
        indeg = [0]*n 
        for u, v in relations: 
            graph[u-1].append(v-1)
            indeg[v-1] += 1
        
        start = [0]*n
        queue = deque((i, time[i]) for i, x in enumerate(indeg) if x == 0)
        
        while queue: 
            u, t = queue.popleft() # earlist to finish course u
            for v in graph[u]: 
                start[v] = max(start[v], t) # earlist to start course v
                indeg[v] -= 1
                if indeg[v] == 0: queue.append((v, start[v] + time[v]))
        return max(s+t for s, t in zip(start, time))"
kth distinct string in an array,"class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        freq = Counter(arr)
        for x in arr: 
            if freq[x] == 1: k -= 1
            if k == 0: return x
        return """""
kth distinct string in an array,"class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        n = len(arr)
        cnt = defaultdict(int)
        for c in arr:
            cnt[c] += 1
        
        distinct = []
        for i in range(n):
            if cnt[arr[i]] == 1:
                distinct.append(arr[i])
                
        if len(distinct) < k:
            return """"
        else:
            return distinct[k-1]"
two best non overlapping events,"class Solution:
def maxTwoEvents(self, events: List[List[int]]) -> int:
    
    events.sort()
    heap = []
    res2,res1 = 0,0
    for s,e,p in events:
        while heap and heap[0][0]<s:
            res1 = max(res1,heapq.heappop(heap)[1])
        
        res2 = max(res2,res1+p)
        heapq.heappush(heap,(e,p))
    
    return res2"
two best non overlapping events,"class Solution:
    def maxTwoEvents(self, events: List[List[int]]) -> int:
        time = []
        vals = []
        ans = prefix = 0
        for st, et, val in sorted(events, key=lambda x: x[1]): 
            prefix = max(prefix, val)
            k = bisect_left(time, st)-1
            if k >= 0: val += vals[k]
            ans = max(ans, val)
            time.append(et)
            vals.append(prefix)
        return ans"
plates between candles,"class Solution:
    def platesBetweenCandles(self, s: str, qs: List[List[int]]) -> List[int]:
        n=len(s)
        prefcandle=[-1]*n #this stores the position of closest candle from current towards left
        suffcandle=[0]*n #this stores the position of closest candle from current towards right
        
        pref=[0]*n #stores the number of plates  till ith position from 0 - for i = 0 -> n 
        
        ind=-1
        c=0
        #The following method calculates number of plates(*) till ith position from 0 - for i = 0 -> n 
        for i in range(n):
            if ind!=-1 and s[i]=='*':
                c+=1
            elif s[i]=='|':
                ind=i
            pref[i]=c
              
        #this method calculates the left nearest candle to a point
        #intial is -1 as to left of leftmost element no candle can be present
        ind =-1
        for i in range(n):
            if s[i] == '|':
                ind=i
            prefcandle[i]=ind
            
        #this method calculates the right nearest candle to a point
        #intial is infinity as to right of rightmost element no candle can be present
        ind = float('inf')       
        for i in range(n-1, -1, -1):
            if s[i]=='|':
                ind=i
            suffcandle[i]=ind

        #m = no of queries
        m=len(qs)
        ans=[0]*m

        for i in range(m):
            c=0
            l=qs[i][0]
            r=qs[i][1]
            
            #check if left nearest candle of right boundary is after left boundary
            #check if right nearest candle of left boundary is before right boundary
            # to summarise - here we find if there is a pair of candle present within the given range or not
            if prefcandle[r]<l or suffcandle[l]>r:
                continue
            
            #desired answer is no of pplates(*) only inside 2 candles (|) inside the given boundary area
            ans[i]=pref[prefcandle[r]]-pref[suffcandle[l]]
        return ans"
plates between candles,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        prefix = [0]
        candles = []
        for i, ch in enumerate(s): 
            if ch == '|': candles.append(i)
            if ch == '|': prefix.append(prefix[-1])
            else: prefix.append(prefix[-1] + 1)
        
        ans = []
        for x, y in queries: 
            lo = bisect_left(candles, x)
            hi = bisect_right(candles, y) - 1
            if 0 <= hi and lo < len(candles) and lo <= hi: 
                ans.append(prefix[candles[hi]+1] - prefix[candles[lo]])
            else: ans.append(0)
        return ans"
number of valid move combinations on chessboard,"class Solution:
    BOARD_SIZE = 8
    
    def diag(self, r, c):
        # Return all diagonal indices except (r, c)
        # Diagonal indices has the same r - c
        inv = r - c
        result = []
        for ri in range(self.BOARD_SIZE):
            ci = ri - inv
            if 0 <= ci < self.BOARD_SIZE and ri != r:
                result.append((ri, ci))

        return result
    
    def reverseDiag(self, r, c):
        # Return all reverse diagonal indices except (r, c)
        # Reverse diagonal indices has the same r + c
        inv = r + c
        result = []
        for ri in range(self.BOARD_SIZE):
            ci = inv - ri
            if 0 <= ci < self.BOARD_SIZE and ri != r:
                result.append((ri, ci))

        return result
    
    def generatePossiblePositions(self, piece, start):
        # Generate list of possible positions for every figure
        rs, cs = start[0] - 1, start[1] - 1

        # Start position
        result = [(rs, cs)]

        # Straight
        if piece == ""rook"" or piece == ""queen"":
            result.extend([(r, cs) for r in range(self.BOARD_SIZE) if r != rs])
            result.extend([(rs, c) for c in range(self.BOARD_SIZE) if c != cs])

        # Diagonal
        if piece == ""bishop"" or piece == ""queen"":
            result.extend(self.diag(rs, cs))
            result.extend(self.reverseDiag(rs, cs))

        return result
    
    def collide(self, start1, end1, start2, end2):
        # Check if two figures will collide
        # Collision occures if: 
        #  - two figures have the same end points
        #  - one figure stands on the way of second one
        #
        # For this purpose let's model each step of two pieces 
        # and compare their positions at every time step.
        
        def steps(start, end):
            # Total steps that should be done
            return abs(end - start)

        def step(start, end):
            # Step direction -1, 0, 1
            if steps(start, end) == 0:
                return 0
            return (end - start) / steps(start, end)

        (rstart1, cstart1), (rend1, cend1) = start1, end1
        (rstart2, cstart2), (rend2, cend2) = start2, end2

        # Find step direction for each piece
        rstep1, cstep1 = step(rstart1, rend1), step(cstart1, cend1)
        rstep2, cstep2 = step(rstart2, rend2), step(cstart2, cend2)

        # Find maximum number of steps for each piece
        max_step1 = max(steps(rstart1, rend1), steps(cstart1, cend1))
        max_step2 = max(steps(rstart2, rend2), steps(cstart2, cend2))

        # Move pieces step by step and compare their positions
        for step_i in range(max(max_step1, max_step2) + 1):
            step_i1 = min(step_i, max_step1)
            r1 = rstart1 + step_i1 * rstep1
            c1 = cstart1 + step_i1 * cstep1

            step_i2 = min(step_i, max_step2)
            r2 = rstart2 + step_i2 * rstep2
            c2 = cstart2 + step_i2 * cstep2

            # If positions are the same then collision occures
            if r1 == r2 and c1 == c2:
                return True

        return False
    
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        if len(pieces) == 0:
            return 0

        n = len(pieces)
        
        # Make zero-indexed
        start_positions = [[r - 1, c - 1] for r, c in positions]
        
        # All possible positions
        possible_positions = [
            self.generatePossiblePositions(piece, start) 
            for piece, start in zip(pieces, positions)
        ]
        
        # Let's use DFS with backtracking
        # For that we will keep set of already occupied coordinates
        # and current positions of pieces
        occupied = set()
        current_positions = [None] * n  # None means that we didn't placed the piece
        
        def collision(start, end):
            # Helper to check if moving from start to end position will collide with someone
            for start2, end2 in zip(start_positions, current_positions):
                if end2 is not None and self.collide(start, end, start2, end2):
                    return True
            return False

        def dfs(piece_i=0):
            # All pieces are placed
            if piece_i == n:
                return 1

            result = 0
            for position in possible_positions[piece_i]:
                # If position already occupied of collides with other pieces then skip it
                if position in occupied or collision(start_positions[piece_i], position):
                    continue
                
                # Occupy the position
                occupied.add(position)
                current_positions[piece_i] = position
                
                # Run DFS for next piece
                result += dfs(piece_i + 1)
                
                # Release the position
                occupied.remove(position)
                current_positions[piece_i] = None
                
            return result

        return dfs()"
number of valid move combinations on chessboard,"class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        n = len(pieces)
        mp = {""bishop"": ((-1, -1), (-1, 1), (1, -1), (1, 1)),
              ""queen"" : ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)), 
              ""rook""  : ((-1, 0), (0, -1), (0, 1), (1, 0))}
        
        dirs = [[]] # directions
        for piece in pieces: dirs = [x+[xx] for x in dirs for xx in mp[piece]]
        
        positions = tuple(map(tuple, positions))
        
        def fn(*args): 
            """"""Return possible moves along given direction.""""""
            stack = [((1<<n)-1, positions)]
            while stack: 
                mask, pos = stack.pop()
                ans.add(pos)
                m = mask
                while m: 
                    p = []
                    for i in range(n): 
                        if m &amp; (1 << i): 
                            p.append((pos[i][0] + args[i][0], pos[i][1] + args[i][1]))
                            if not (1 <= p[i][0] <= 8 and 1 <= p[i][1] <= 8): break 
                        else: p.append(pos[i])
                    else: 
                        cand = tuple(p)
                        if len(set(cand)) == len(cand) and m: stack.append((m, cand))
                    m = mask &amp; (m-1)

        ans = set()
        for d in dirs: fn(*d)
        return len(ans)"
smallest index with equal value,"class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        return next((i for i, x in enumerate(nums) if i%10 == x), -1)"
smallest index with equal value,"class Solution(object):
    def smallestEqual(self, nums, i=0):
        return -1 if i == len(nums) else ( i if i%10 == nums[i] else self.smallestEqual(nums, i+1) )"
find the minimum and maximum number of nodes between critical points,"class Solution:
    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
        min_res = math.inf
        min_point = max_point = last_point = None
        prev_val = head.val
        head = head.next
        i = 1
        while head.next:
            if ((head.next.val < head.val and prev_val < head.val) or
               (head.next.val > head.val and prev_val > head.val)):
                
                if min_point is None:
                    min_point = i
                else:
                    max_point = i
                
                if last_point:
                    min_res = min(min_res, i - last_point)
                
                last_point = i
            
            prev_val = head.val
            i += 1
            head = head.next
        
        if min_res == math.inf:
            min_res = -1
        max_res = max_point - min_point if max_point else -1
        
        return [min_res, max_res]"
find the minimum and maximum number of nodes between critical points,"class Solution:
    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
        arr,dist=[],[]
        diff=10 ** 5 
        index=0
        while head:
            arr.append(head.val)
            head=head.next
        for i in range(1,len(arr)-1):
            if (arr[i-1] > arr[i] and arr[i+1] >arr[i]) or (arr[i-1] < arr[i] and arr[i]> arr[i+1]):
                dist.append(i)
                if index>=1:
                    diff=min(diff,dist[index]-dist[index-1])
                index+=1
        if not dist or len(dist)==1:return [-1,-1]
        else: 
            return [diff,dist[-1]-dist[0]]"
minimum operations to convert number,"class Solution:
    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        ans = 0
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                val = queue.popleft()
                if val == goal: return ans 
                if 0 <= val <= 1000: 
                    for x in nums: 
                        for op in (add, sub, xor): 
                            if op(val, x) not in seen: 
                                seen.add(op(val, x))
                                queue.append(op(val, x))
            ans += 1
        return -1"
minimum operations to convert number,"class Solution:
    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        ans = 0
        queue = deque([start])
        visited = [False]*1001
        while queue: 
            for _ in range(len(queue)): 
                val = queue.popleft()
                if val == goal: return ans 
                if 0 <= val <= 1000 and not visited[val]: 
                    visited[val] = True
                    for x in nums: 
                        for xx in (val+x, val-x, val^x):
                            queue.append(xx)
            ans += 1
        return -1"
check if an original string exists given two encoded strings,"class Solution:
    def possiblyEquals(self, s1: str, s2: str) -> bool:
        
        def gg(s): 
            """"""Return possible length""""""
            ans = [int(s)]
            if len(s) == 2: 
                if s[1] != '0': ans.append(int(s[0]) + int(s[1]))
                return ans
            elif len(s) == 3: 
                if s[1] != '0': ans.append(int(s[:1]) + int(s[1:]))
                if s[2] != '0': ans.append(int(s[:2]) + int(s[2:]))
                if s[1] != '0' and s[2] != '0': ans.append(int(s[0]) + int(s[1]) + int(s[2]))
            return ans 
        
        @cache
        def fn(i, j, diff): 
            """"""Return True if s1[i:] matches s2[j:] with given differences.""""""
            if i == len(s1) and j == len(s2): return diff == 0
            if i < len(s1) and s1[i].isdigit(): 
                ii = i
                while ii < len(s1) and s1[ii].isdigit(): ii += 1
                for x in gg(s1[i:ii]): 
                    if fn(ii, j, diff-x): return True 
            elif j < len(s2) and s2[j].isdigit(): 
                jj = j 
                while jj < len(s2) and s2[jj].isdigit(): jj += 1
                for x in gg(s2[j:jj]): 
                    if fn(i, jj, diff+x): return True 
            elif diff == 0: 
                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False 
                return fn(i+1, j+1, 0)
            elif diff > 0: 
                if i == len(s1): return False 
                return fn(i+1, j, diff-1)
            else: 
                if j == len(s2): return False 
                return fn(i, j+1, diff+1)
            
        return fn(0, 0, 0)"
check if an original string exists given two encoded strings,"class Solution:
    def possiblyEquals(self, s1: str, s2: str) -> bool:
        
        def gg(s): 
            """"""Return possible length.""""""
            ans = {int(s)}
            for i in range(1, len(s)): 
                ans |= {x+y for x in gg(s[:i]) for y in gg(s[i:])}
            return ans
        
        @cache
        def fn(i, j, diff): 
            """"""Return True if s1[i:] matches s2[j:] with given differences.""""""
            if i == len(s1) and j == len(s2): return diff == 0
            if i < len(s1) and s1[i].isdigit(): 
                ii = i
                while ii < len(s1) and s1[ii].isdigit(): ii += 1
                for x in gg(s1[i:ii]): 
                    if fn(ii, j, diff-x): return True 
            elif j < len(s2) and s2[j].isdigit(): 
                jj = j 
                while jj < len(s2) and s2[jj].isdigit(): jj += 1
                for x in gg(s2[j:jj]): 
                    if fn(i, jj, diff+x): return True 
            elif diff == 0: 
                if i < len(s1) and j < len(s2) and s1[i] == s2[j]: return fn(i+1, j+1, 0)
            elif diff > 0: 
                if i < len(s1): return fn(i+1, j, diff-1)
            else: 
                if j < len(s2): return fn(i, j+1, diff+1)
            return False 
            
        return fn(0, 0, 0)"
count vowel substrings of a string,"class Solution:
    def countVowelSubstrings(self, word: str) -> int:
        ans = 0 
        freq = defaultdict(int)
        for i, x in enumerate(word): 
            if x in ""aeiou"": 
                if not i or word[i-1] not in ""aeiou"": 
                    jj = j = i # set anchor
                    freq.clear()
                freq[x] += 1
                while len(freq) == 5 and all(freq.values()): 
                    freq[word[j]] -= 1
                    j += 1
                ans += j - jj
        return ans"
count vowel substrings of a string,"class Solution:
    def countVowelSubstrings(self, word: str) -> int:
        vowels = ('a', 'e', 'i', 'o', 'u')
        
        result = 0
        start = 0
        vowel_idx = {}
        for idx, c in enumerate(word):
            if c in vowels:
                if not vowel_idx:
                    start = idx       
                vowel_idx[c] = idx
                if len(vowel_idx) == 5:
                    result += min(vowel_idx.values()) - start + 1 
            elif vowel_idx:
                vowel_idx = {}
                
        return result"
vowels of all substrings,"class Solution:
    def countVowels(self, word: str) -> int:
        count = 0
        sz = len(word)
        
        for pos in range(sz):
            if word[pos] in 'aeiou':
                count += (sz - pos) * (pos + 1)
        
        return count"
vowels of all substrings,"class Solution:
    def countVowels(self, word: str) -> int:
        return sum((i + 1) * (len(word) - i) for i, ch in enumerate(word) if ch in 'aeiou')"
minimized maximum of products distributed to any store,"class Solution:
    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:
        lo, hi = 1, max(quantities)
        while lo < hi: 
            mid = lo + hi >> 1
            if sum(ceil(qty/mid) for qty in quantities) <= n: hi = mid 
            else: lo = mid + 1
        return lo"
minimized maximum of products distributed to any store,"class Solution:
    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:

        l, r = 1, max(quantities)
        while l <= r:
            mid = (l+r)//2
            # count the number of stores needed if the max distribution is mid
            # one store can has max one product only and we need to distribute all the quantities
            cnt = 0
            for x in quantities:
                # if 0<=x<=mid, cnt = 1, if mid<x<=2mid, cnt = 2
                cnt += (x+mid-1)//mid
            
            # if with max distribution is mid, but number of stores needed is larger than actual stores n, then will need to increase the distribution, else we can further lower down the distribution.
            if cnt > n:
                l = mid + 1
            else:
                r = mid - 1
        
        return l"
maximum path quality of a graph,"class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
        ans = 0
        graph = collections.defaultdict(dict)
        for u, v, t in edges:
            graph[u][v] = t
            graph[v][u] = t
        
        def dfs(curr, visited, score, cost):
            if curr == 0:
                nonlocal ans
                ans = max(ans, score)
            
            for nxt, time in graph[curr].items():
                if time <= cost:
                    dfs(nxt, visited|set([nxt]), score+values[nxt]*(nxt not in visited), cost-time)
        
        dfs(0, set([0]), values[0], maxTime)
        return ans"
maximum path quality of a graph,"class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
        ans = 0
        graph = collections.defaultdict(dict)
        for u,v,t in edges:
            graph[u][v] = t
            graph[v][u] = t
        
        # node, cost, visited, score
        q = collections.deque([(0, maxTime, set([0]), values[0])])
        while q:
            curr, cost, visited, score = q.popleft()
            if curr == 0:
                ans = max(ans, score)
            for nxt, time in graph[curr].items():
                if time > cost:
                    continue
                q.append((nxt, cost-time, visited|set([nxt]), score + values[nxt]*(nxt not in visited)))

        return ans"
check whether two strings are almost equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        freq = [0]*26
        for x in word1: freq[ord(x)-97] += 1
        for x in word2: freq[ord(x)-97] -= 1
        return all(abs(x) <= 3 for x in freq)"
check whether two strings are almost equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        
        # make an array to track occurences for every letter of the
        # alphabet
        alphabet = [0]*26
        
        # go through both words and count occurences
        # word 1 add and word 2 subtract
        # after this we have the differences for every letter
        for index in range(len(word1)):
            alphabet[ord(word1[index]) - 97] += 1
            alphabet[ord(word2[index]) - 97] -= 1
        
        # find min and max and check that it is less than three
        return min(alphabet) >= -3 and max(alphabet) <= 3"
most beautiful item for each query,"class Solution:
	def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:

		items.sort()
		dic = dict()
		res = []
		gmax = 0
		for p,b in items:
			gmax = max(b,gmax)
			dic[p] = gmax

		keys = sorted(dic.keys())
		for q in queries:
			ind = bisect.bisect_left(keys,q)
			if ind<len(keys) and keys[ind]==q:
				res.append(dic[q])
			elif ind==0:
				res.append(0)
			else:
				res.append(dic[keys[ind-1]])

		return res"
most beautiful item for each query,"class Solution:
    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:
        items.sort()
        ans = [0]*len(queries)
        prefix = ii = 0 
        for x, i in sorted((x, i) for i, x in enumerate(queries)): 
            while ii < len(items) and items[ii][0] <= x: 
                prefix = max(prefix, items[ii][1])
                ii += 1
            ans[i] = prefix
        return ans"
maximum number of tasks you can assign,"class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        # workers sorted in reverse order, tasks sorted in normal order
        def can_assign(n):
            task_i = 0
            task_temp = deque()
            n_pills = pills
            for i in range(n-1,-1,-1):
                while task_i < n and tasks[task_i] <= workers[i]+strength:
                    task_temp.append(tasks[task_i])
                    task_i += 1
                
                if len(task_temp) == 0:
                    return False
                if workers[i] >= task_temp[0]:
                    task_temp.popleft()
                elif n_pills > 0:
                    task_temp.pop()
                    n_pills -= 1
                else:
                    return False
            return True
        
        tasks.sort()
        workers.sort(reverse = True)
        
        l = 0
        r = min(len(tasks), len(workers))
        res = -1
        while l <= r:
            m = (l+r)//2
            if can_assign(m):
                res = m
                l = m+1
            else:
                r = m-1
        return res"
maximum number of tasks you can assign,"class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        tasks.sort()
        workers.sort()
        
        def fn(k, p=pills): 
            """"""Return True if k tasks can be completed.""""""
            ww = workers[-k:]
            for t in reversed(tasks[:k]): 
                if t <= ww[-1]: ww.pop()
                elif t <= ww[-1] + strength and p: 
                    p -= 1
                    i = bisect_left(ww, t - strength)
                    ww.pop(i)
                else: return False 
            return True 
          
        lo, hi = 0, min(len(tasks), len(workers))
        while lo < hi: 
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return lo"
time needed to buy tickets,"class Solution:
    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:
        secs = 0 
        i = 0
        while tickets[k] != 0:
            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore
                tickets[i] -= 1 # decrease the value by 1 everytime
                secs += 1 # increase secs by 1

            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator
            
        return secs"
time needed to buy tickets,"class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))"
reverse nodes in even length groups,"class Solution:
    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:
        n, node = 0, head
        while node: n, node = n+1, node.next
        
        k, node = 0, head 
        while n: 
            k += 1
            size = min(k, n)
            stack = []
            if not size &amp; 1: 
                temp = node 
                for _ in range(size): 
                    stack.append(temp.val)
                    temp = temp.next 
            for _ in range(size): 
                if stack: node.val = stack.pop()
                node = node.next 
            n -= size
        return head"
reverse nodes in even length groups,"class Solution:
    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:
        start_joint = head 
        group_size = 1
        while start_joint and start_joint.next: 
            group_size += 1
            start = end = start_joint.next 
            group_num = 1 
            while end and end.next and group_num < group_size: 
                end = end.next 
                group_num += 1 
            end_joint = end.next 
            if group_num % 2 != 0: 
                start_joint = end 
                continue 
            start_joint.next = self.reverse(start, end, end_joint)
            start_joint = start 
        return head
    def reverse(self, start, end, end_joint): 
        prev, curr = end_joint, start
        while curr and curr != end_joint: 
            next_node = curr.next
            curr.next = prev
            prev, curr = curr, next_node
        return prev"
decode the slanted ciphertext,"class Solution:
    def decodeCiphertext(self, encodedText: str, rows: int) -> str:
        cols, res = len(encodedText) // rows, """"
        for i in range(cols):
            for j in range(i, len(encodedText), cols + 1):
                res += encodedText[j]
        return res.rstrip()"
decode the slanted ciphertext,"class Solution:
    def decodeCiphertext(self, encodedText: str, rows: int) -> str:
        #print(len(encodedText),rows,len(encodedText)//rows)
        if len(encodedText)==0:
            return """"
        ans =''
        x =[]
        c = len(encodedText)//rows
        for i in range(0,len(encodedText),c):
            x.append(list(encodedText[i:i+c]))
        #print(x)
        for i in range(c):
            k = i
            p=''
            for j in range(rows):
                try:
                    p = p+x[j][k]
                except:
                    pass
                k = k+1
            ans = ans+p
        return ans.rstrip()"
process restricted friend requests,"class Solution:
    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        
        result = [False for _ in requests]
        
        connected_components = [{i} for i in range(n)]
        
        connected_comp_dict = {}
        for i in range(n):
            connected_comp_dict[i] = i
        
        banned_by_comps = [set() for i in range(n)]
        for res in restrictions:
            banned_by_comps[res[0]].add(res[1])
            banned_by_comps[res[1]].add(res[0])
        for i,r in enumerate(requests):
            n1, n2 = r[0], r[1]
            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]
            if c1 == c2:
                result[i] = True
            else:
                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):
                    connected_components[c1].update(connected_components[c2])
                    banned_by_comps[c1].update(banned_by_comps[c2])
                    for node in connected_components[c2]:
                        connected_comp_dict[node] = c1
                    result[i] = True
                
        return result"
two furthest houses with different colors,"class Solution:
    def maxDistance(self, colors: List[int]) -> int:
        ans = 0 
        for i, x in enumerate(colors): 
            if x != colors[0]: ans = max(ans, i)
            if x != colors[-1]: ans = max(ans, len(colors)-1-i)
        return ans"
two furthest houses with different colors,"class Solution:
    def maxDistance(self, colors: List[int]) -> int:
		#first pass
        l, r = 0, len(colors)-1
        dist = 0
        
        while r > l:
            if colors[r] != colors[l]:
                dist = r-l
				#slight performance increase, break out if you find it 
				#because it can't get bigger than this
                break 
            r -= 1
			
        #second pass, backwards
        l, r = 0, len(colors)-1
        while r > l:
            if colors[r] != colors[l]:
                dist = max(dist, r-l)
                break
            l += 1
        
        return dist"
watering plants,"class Solution:
    def wateringPlants(self, plants: List[int], capacity: int) -> int:
        ans = 0
        can = capacity
        for i, x in enumerate(plants): 
            if can < x: 
                ans += 2*i
                can = capacity
            ans += 1
            can -= x
        return ans"
watering plants,"class Solution:
    def wateringPlants(self, plants: List[int], capacity: int) -> int:
        s, p, c = 0, -1, capacity
        for i, e in enumerate(plants):
            if e <= c: s += i - p; c -= e
            else: s += p + i + 2; c = capacity - e
            p = i
        return s"
sum of k mirror numbers,"class Solution:
    def kMirror(self, k: int, n: int) -> int:
        
        def fn(x):
            """"""Return next k-symmetric number.""""""
            n = len(x)//2
            for i in range(n, len(x)): 
                if int(x[i])+1 < k: 
                    x[i] = x[~i] = str(int(x[i])+1)
                    for ii in range(n, i): x[ii] = x[~ii] = '0'
                    return x
            return [""1""] + [""0""]*(len(x)-1) + [""1""]
                
        x = [""0""]
        ans = 0
        for _ in range(n): 
            while True: 
                x = fn(x)
                val = int("""".join(x), k)
                if str(val)[::-1] == str(val): break
            ans += val
        return ans"
sum of k mirror numbers,"class Solution:
    def kMirror(self, k: int, n: int) -> int:

        def numberToBase(n, b):
            if n == 0:
                return [0]
            digits = []
            while n:
                digits.append(n % b)
                n //= b
            return digits[::-1]
        
        # not used
        def baseToNumber(arr, b):
            ans = 0
            for x in arr:
                ans = ans * b + int(x)
            return ans
        
        def is_mirror(s):
            l, r = 0, len(s)-1
            while l <= r:
                if s[l] != s[r]:
                    return False
                l += 1
                r -= 1
            return True
        
        def gen():
            '''
            generate for value with different length
            when i == 0: num[1, 10)
            size of num: 1, 2 -> 1 or 11
            when i == 1: [10, 100)
            size of num: 3, 4 -> 10 or 101
            when i == 2: [100, 1000)
            size of num: 5, 6 -> 10001 or 100001
            
            the num will be increasing
            '''
            for i in range(30):
                for num in range(10**i, 10**(i+1)):
                    s = str(num) + str(num)[::-1][1:]
                    yield int(s)
                for num in range(10**i, 10**(i+1)):
                    s = str(num) + str(num)[::-1]
                    yield int(s)
        
        ans = 0
        left = n
        for num in gen():
            base = numberToBase(num, k)
			# if is_mirror(base):
            if base == base[::-1]:
                ans += num
                left -= 1
            if left == 0:
                break

        return ans"
count common words with one occurrence,"class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        freq1, freq2 = Counter(words1), Counter(words2)
        return len({w for w, v in freq1.items() if v == 1} &amp; {w for w, v in freq2.items() if v == 1})"
count common words with one occurrence,"class Solution:
	def countWords(self, words1: List[str], words2: List[str]) -> int:
		count = Counter(words1 + words2)
		return len([word for word in count if count[word] == 2 and word in words1 and word in words2])"
minimum number of food buckets to feed the hamsters,"class Solution:
    def minimumBuckets(self, street: str) -> int:
        street = list(street)
        ans = 0 
        for i, ch in enumerate(street): 
            if ch == 'H' and (i == 0 or street[i-1] != '#'): 
                if i+1 < len(street) and street[i+1] == '.': street[i+1] = '#'
                elif i and street[i-1] == '.': street[i-1] = '#'
                else: return -1
                ans += 1
        return ans"
minimum number of food buckets to feed the hamsters,"class Solution:
    def minimumBuckets(self, street: str) -> int:
        
        patterns = ['H.H', '.H', 'H.', 'H'] # 4 patterns (excluding '.' cuz it costs 0 )
        costs = [1, 1, 1, -1] # corresponding costs
        res = 0
        for p, c in zip(patterns, costs): # firstly, detect 'H.H'; secondly, detect '.H' and 'H.'; ...
            t = street.count(p) # occurences
            if (t >= 1):
                if (c == -1):  # if found an impossible case...
                    return -1
                res += c * t # accumulate the cost
                street = street.replace(p, '#') # erase such arrangement
        return res"
minimum cost homecoming of a robot in a grid,"class Solution:
def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
    src_x,src_y = startPos[0],startPos[1]
    end_x,end_y = homePos[0], homePos[1]
    
    if src_x < end_x:
        rc = sum(rowCosts[src_x+1:end_x+1])
    elif src_x > end_x:
        rc = sum(rowCosts[end_x:src_x])
    else:
        rc=0
    
    if src_y < end_y:
        cc = sum(colCosts[src_y+1:end_y+1])
    elif src_y > end_y:
        cc = sum(colCosts[end_y:src_y])
    else:
        cc=0
    
    return cc+rc"
minimum cost homecoming of a robot in a grid,"class Solution:
    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
        cost = 0
        if startPos[0] < homePos[0]:
            cost += sum(rowCosts[r] for r in range(startPos[0] + 1,
                                                   homePos[0] + 1))
        elif startPos[0] > homePos[0]:
            cost += sum(rowCosts[r] for r in range(startPos[0] - 1,
                                                   homePos[0] - 1, -1))
        if startPos[1] < homePos[1]:
            cost += sum(colCosts[c] for c in range(startPos[1] + 1,
                                                   homePos[1] + 1))
        elif startPos[1] > homePos[1]:
            cost += sum(colCosts[c] for c in range(startPos[1] - 1,
                                                   homePos[1] - 1, -1))
        return cost"
count fertile pyramids in a land,"class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        vals = [[inf]*n for _ in range(m)]
        for i in range(m):
            for j in range(n): 
                if grid[i][j] == 0: vals[i][j] = 0
                elif j == 0: vals[i][j] = 1
                else: vals[i][j] = min(vals[i][j], 1 + vals[i][j-1])
                if grid[i][~j] == 0: vals[i][~j] = 0
                elif j == 0: vals[i][~j] = 1
                else: vals[i][~j] = min(vals[i][~j], 1 + vals[i][~j+1])
        
        def fn(vals): 
            """"""Return count of pyramid in given grid.""""""
            ans = 0 
            for j in range(n):
                width = 0
                for i in range(m): 
                    if vals[i][j]: width = min(width+1, vals[i][j])
                    else: width = 0
                    ans += max(0, width-1)
            return ans 
        
        return fn(vals) + fn(vals[::-1])"
count fertile pyramids in a land,"class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        #checks if there are 3 ones below (x,y)
        def check(x,y):
            count = 0
            to_check = {(1,0),(1,-1),(1,1)}
            for dx,dy in to_check:
                if(0<=x+dx<len(grid) and 0<=y+dy<len(grid[0]) and grid[x+dx][y+dy]==1):
                    count += 1
            if(count == 3):
                return True
            else:
                return False
        
        memo = {}
        #dp returns the number of pyramid levels under (x,y)
        def dp(x,y):
            if((x,y) in memo):
                return memo[(x,y)]
            levels = 0
            if(check(x,y)==True):
                levels += 1
            else:
                return levels
            to_check = {(1,0),(1,-1),(1,1)}
            t = float('inf')
            #t is the number of additional levels
            for dx,dy in to_check: 
                if(0<=x+dx<len(grid) and 0<=y+dy<len(grid[0]) and grid[x+dx][y+dy]==1):
                    t = min(t,dp(x+dx,y+dy))
            memo[(x,y)] = levels + t
            return levels + t      
        
		#check number of normal pyramidal plots
        ans = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if(grid[i][j] == 1):
                    ans += dp(i,j)
        
		#check number of inverse pyramidal plots
        memo = {}
        grid = grid[::-1]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if(grid[i][j] == 1):
                    ans += dp(i,j)
        return ans"
find target indices after sorting array,"class Solution:
    def targetIndices(self, nums, target):
        ans = []
        for i,num in enumerate(sorted(nums)):
            if num == target: ans.append(i)
        return ans"
find target indices after sorting array,"class Solution:
    def targetIndices(self, nums, target):
        return [i for i,num in enumerate(sorted(nums)) if num==target]"
k radius subarray averages,"class Solution:
  def getAverages(self, nums: List[int], k: int) -> List[int]:
    res = [-1]*len(nums)

    left, curWindowSum, diameter = 0, 0, 2*k+1
    for right in range(len(nums)):
      curWindowSum += nums[right]
      if (right-left+1 >= diameter):
        res[left+k] = curWindowSum//diameter
        curWindowSum -= nums[left]
        left += 1
    return res"
k radius subarray averages,"class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = [-1]*len(nums)
        for i, x in enumerate(nums): 
            if k <= i < len(nums)-k: ans[i] = (prefix[i+k+1] - prefix[i-k])//(2*k+1)
        return ans"
removing minimum and maximum from array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        imin = nums.index(min(nums))
        imax = nums.index(max(nums))
        return min(max(imin, imax)+1, len(nums)-min(imin, imax), len(nums)+1+min(imin, imax)-max(imin, imax))"
removing minimum and maximum from array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        n = len(nums)
        x = nums.index(min(nums)) + 1
        y = nums.index(max(nums)) + 1
        
        res = min(max(n-x+1, n-y+1) , max(x,y))       #minimum of going from right and going from left
        if x > y:  #exchange if needed so as to do one operation later assuming x is the smaller index
            x, y = y, x
        
        option = x + (n - y) + 1 #going left for smaller and right for larger
        res = min(res, option)
        
        return res if n > 2 else n"
find all people with secret,"class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        can = {0, firstPerson}
        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): 
            queue = set()
            graph = defaultdict(list)
            for x, y, _ in grp: 
                graph[x].append(y)
                graph[y].append(x)
                if x in can: queue.add(x)
                if y in can: queue.add(y)
                    
            queue = deque(queue)
            while queue: 
                x = queue.popleft()
                for y in graph[x]: 
                    if y not in can: 
                        can.add(y)
                        queue.append(y)
        return can"
find all people with secret,"class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        can = {0, firstPerson}
        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): 
            stack = set()
            graph = defaultdict(list)
            for x, y, _ in grp: 
                graph[x].append(y)
                graph[y].append(x)
                if x in can: stack.add(x)
                if y in can: stack.add(y)
                    
            stack = list(stack)
            while stack: 
                x = stack.pop()
                for y in graph[x]: 
                    if y not in can: 
                        can.add(y)
                        stack.append(y)
        return can"
finding 3 digit even numbers,"class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        ans = set()
        for x, y, z in permutations(digits, 3): 
            if x != 0 and z &amp; 1 == 0: 
                ans.add(100*x + 10*y + z) 
        return sorted(ans)"
finding 3 digit even numbers,"class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        ans = []
        freq = Counter(digits)
        for x in range(100, 1000, 2): 
            if not Counter(int(d) for d in str(x)) - freq: ans.append(x)
        return ans"
delete the middle node of a linked list,"class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow,fast,prev=head,head,None
        while fast and fast.next:
            prev=slow
            slow=slow.next
            fast=fast.next.next
        if prev==None:
            return None
        prev.next=slow.next
        return head"
delete the middle node of a linked list,"class Solution:
	def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:

		if head.next == None:
			return

		slow, fast = head, head
		prev = None

		while fast and fast.next:
			prev = slow
			slow = slow.next
			fast = fast.next.next

		prev.next = slow.next

		return head"
step by step directions from a binary tree node to another,"class Solution:
    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        
        def lca(node): 
            """"""Return lowest common ancestor of start and dest nodes.""""""
            if not node or node.val in (startValue , destValue): return node 
            left, right = lca(node.left), lca(node.right)
            return node if left and right else left or right
        
        root = lca(root) # only this sub-tree matters
        
        ps = pd = """"
        stack = [(root, """")]
        while stack: 
            node, path = stack.pop()
            if node.val == startValue: ps = path 
            if node.val == destValue: pd = path
            if node.left: stack.append((node.left, path + ""L""))
            if node.right: stack.append((node.right, path + ""R""))
        return ""U""*len(ps) + pd"
step by step directions from a binary tree node to another,"class Solution:
    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
	
        graph=defaultdict(list)    
        stack=[(root)]
		
		#Step1: Build Graph
        while stack:
            node=stack.pop()
            
            if node.left:
                graph[node.val].append((node.left.val,""L""))
                graph[node.left.val].append((node.val,""U""))
                stack.append(node.left)
            if node.right:
                graph[node.val].append((node.right.val,""R""))
                graph[node.right.val].append((node.val,""U""))
                stack.append(node.right)
        #Step 2: Normal BFS
        q=deque([(startValue,"""")])
        seen=set()
        seen.add(startValue)
        
        while q:
            node,path=q.popleft()
            if node==destValue:
                return path
            
            for neigh in graph[node]:
                v,d=neigh
                if v not in seen:
                    q.append((v,path+d))
                    seen.add(v)
        return -1"
valid arrangement of pairs,"class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        degree = defaultdict(int) # net out degree 
        for x, y in pairs: 
            graph[x].append(y)
            degree[x] += 1
            degree[y] -= 1
                
        for k in degree: 
            if degree[k] == 1: 
                x = k
                break 
                
        ans = []

        def fn(x): 
            """"""Return Eulerian path via dfs.""""""
            while graph[x]: fn(graph[x].pop()) 
            ans.append(x)
        
        fn(x)
        ans.reverse()
        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]"
valid arrangement of pairs,"class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        degree = defaultdict(int) # net out degree 
        for x, y in pairs: 
            graph[x].append(y)
            degree[x] += 1
            degree[y] -= 1
                
        for k in degree: 
            if degree[k] == 1: 
                x = k
                break 
                
        ans = []
        stack = [x]
        while stack: 
            while graph[stack[-1]]: 
                stack.append(graph[stack[-1]].pop())
            ans.append(stack.pop())
        ans.reverse()
        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]"
find subsequence of length k with the largest sum,"class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        tuple_heap = [] # Stores (value, index) as min heap
        for i, val in enumerate(nums):
            if len(tuple_heap) == k:
                heappushpop(tuple_heap, (val, i)) # To prevent size of heap growing larger than k
            else:
                heappush(tuple_heap, (val, i))
		# heap now contains only the k largest elements with their indices as well.
        tuple_heap.sort(key=lambda x: x[1]) # To get the original order of values. That is why we sort it by index(x[1]) &amp; not value(x[0])
        ans = []
        for i in tuple_heap:
            ans.append(i[0])
        return ans"
find subsequence of length k with the largest sum,"class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        import heapq
        
        h = []
        n = len(nums)
        for i in range(n):
            heapq.heappush(h, (-nums[i], i))
            
        res = []
        for _ in range(k):
            v, idx = heapq.heappop(h)
            res.append(idx)
        res.sort()
        return [nums[idx] for idx in res]"
find good days to rob the bank,"class Solution:
    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:
        suffix = [0]*len(security)
        for i in range(len(security)-2, 0, -1): 
            if security[i] <= security[i+1]: suffix[i] = suffix[i+1] + 1
        
        ans = []
        prefix = 0
        for i in range(len(security)-time): 
            if i and security[i-1] >= security[i]: prefix += 1
            else: prefix = 0
            if prefix >= time and suffix[i] >= time: ans.append(i)
        return ans"
find good days to rob the bank,"class Solution:
    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:

      grid1 = [0, 1]
      grid2 = [0, 1]

      for i in range(len(security)-1):
        if security[i] >= security[i+1]: grid1.append(1)
        else: grid1.append(0)
        if security[i] <= security[i+1]: grid2.append(1)
        else: grid2.append(0)

      start = 0
      for i in range(len(grid1)):
        start += grid1[i]
        grid1[i] = start

      start = 0
      for i in range(len(grid2)):
        start += grid2[i]
        grid2[i] = start

      res = []

      for t in range(time+1, len(grid1)-time):
        if grid1[t] - grid1[t-time] == time and grid2[t+time] - grid2[t] == time:
          res.append(t-1)

      return res"
detonate the maximum bombs,"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        if len(bombs)==1:
            return 1
        
        adlist={i:[] for i in range(len(bombs))}
        
        for i in range(len(bombs)):
            x1,y1,r1=bombs[i]
            for j in range(i+1,len(bombs)):
                x2,y2,r2=bombs[j]
                dist=((x2-x1)**2+(y2-y1)**2)**(1/2)
                if dist<=r1:
                    adlist[i].append(j)  
                if dist<=r2:
                    adlist[j].append(i)
        
        def dfs(adlist,seen,start):
            seen.add(start)
            for i in adlist[start]:
                if i not in seen:
                    dfs(adlist,seen,i)
        maxx=1   
        for v in adlist:
            seen=set()
            seen.add(v)
            dfs(adlist,seen,v)
            maxx=max(maxx,len(seen))
        return maxx"
detonate the maximum bombs,"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        graph = [[] for _ in bombs]
        for i, (xi, yi, ri) in enumerate(bombs): 
            for j, (xj, yj, rj) in enumerate(bombs): 
                if i < j: 
                    dist2 = (xi-xj)**2 + (yi-yj)**2
                    if dist2 <= ri**2: graph[i].append(j)
                    if dist2 <= rj**2: graph[j].append(i)
        
        def fn(x):
            """"""Return connected components of x.""""""
            ans = 1
            seen = {x}
            stack = [x]
            while stack: 
                u = stack.pop()
                for v in graph[u]: 
                    if v not in seen: 
                        ans += 1
                        seen.add(v)
                        stack.append(v)
            return ans 
        
        return max(fn(x) for x in range(len(bombs)))"
rings and rods,"class Solution:
    def countPoints(self, r: str) -> int:
        ans = 0
        for i in range(10):
            i = str(i)
            if 'R'+i in r and 'G'+i in r and 'B'+i in r:
                ans += 1
        return ans"
rings and rods,"class Solution:
    def countPoints(self, rings: str) -> int:
        d = dict()
        ct = 0
        l = 0
        r=1
        while r<len(rings):
            if rings[r] in d:
                d[rings[r]].add(rings[l])
            else:
                d[rings[r]] = set()
                d[rings[r]].add(rings[l])
                
            l=r+1
            r+=2
            
        for i in d:
            if len(d[i]) == 3:
                ct+=1
                
        return ct"
sum of subarray ranges,"class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        
        def fn(op): 
            """"""Return min sum (if given gt) or max sum (if given lt).""""""
            ans = 0 
            stack = []
            for i in range(len(nums) + 1): 
                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): 
                    mid = stack.pop()
                    ii = stack[-1] if stack else -1 
                    ans += nums[mid] * (i - mid) * (mid - ii)
                stack.append(i)
            return ans 
        
        return fn(lt) - fn(gt)"
sum of subarray ranges,"class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        res = 0
        min_stack, max_stack = [], []
        n = len(nums)
        nums.append(0)

        for i, num in enumerate(nums):
            while min_stack and (i == n or num < nums[min_stack[-1]]):
                top = min_stack.pop()
                starts = top - min_stack[-1] if min_stack else top + 1
                ends = i - top
                res -= starts * ends * nums[top]
                
            min_stack.append(i)
            
            while max_stack and (i == n or num > nums[max_stack[-1]]):
                top = max_stack.pop()
                starts = top - max_stack[-1] if max_stack else top + 1
                ends = i - top
                res += starts * ends * nums[top]
                
            max_stack.append(i)
        
        
        return res"
watering plants ii,"class Solution:
    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:
        ans = 0 
        lo, hi = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while lo < hi: 
            if canA < plants[lo]: ans += 1; canA = capacityA
            canA -= plants[lo]
            if canB < plants[hi]: ans += 1; canB = capacityB
            canB -= plants[hi]
            lo, hi = lo+1, hi-1
        if lo == hi and max(canA, canB) < plants[lo]: ans += 1
        return ans"
watering plants ii,"class Solution:
    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:
        a, b = 0, len(plants) - 1
        waterA, waterB = capacityA, capacityB
        res = 0
        while a < b:
            if waterA < plants[a]:
                res += 1
                waterA = capacityA
            waterA -= plants[a]
            a += 1
            
            if waterB < plants[b]:
                res += 1
                waterB = capacityB
            waterB -= plants[b]
            b -= 1
        
        if a == b and waterA < plants[a] and waterB < plants[a]:
            res += 1
        return res"
maximum fruits harvested after at most k steps,"class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
    
        fruitMap = defaultdict(int)
        
        for position, amount in fruits:
            fruitMap[position] = amount
        
        
        if k == 0:
            return fruitMap[startPos]
        
        totalLeft = 0 # max sum if we go k steps to the left
        totalRight = 0 # max sum if we go k steps to the right
        inBetween = 0 # max sum if we go x steps to the left &amp; k steps to the right (ensuring that we don't move more than k steps in total)
        
        dp = dict()
        
        for i in range(startPos,startPos-k-1, -1):
            totalLeft += fruitMap[i]
            dp[i] = totalLeft
            
        for i in range(startPos,startPos+k+1):
            totalRight += fruitMap[i]
            dp[i] = totalRight
            
        
        leftSteps = 1
        rightSteps = k-2
        
        while rightSteps > 0:
            currAmount = 0
            
            # go right &amp; collect
            currAmount += dp[startPos-leftSteps]
            # go left &amp; collect
            currAmount += dp[startPos+rightSteps]
            
            
            inBetween = max(inBetween, currAmount-fruitMap[startPos])
            
            leftSteps += 1
            rightSteps -= 2
        
        
        leftSteps = k-2
        rightSteps = 1
        
        while leftSteps > 0:
            currAmount = 0
            
            # go right &amp; collect
            currAmount += dp[startPos-leftSteps]
            # go left &amp; collect
            currAmount += dp[startPos+rightSteps]
            
            inBetween = max(inBetween, currAmount-fruitMap[startPos])
            
            leftSteps -= 2
            rightSteps += 1
        
            
        return max(totalLeft, totalRight, inBetween)"
maximum fruits harvested after at most k steps,"class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        ans = rsm = ii = 0 
        for i, (p, x) in enumerate(fruits): 
            if p > startPos + k: break 
            rsm += x
            if p <= startPos: fn = lambda ii: startPos - fruits[ii][0]
            else: fn = lambda ii: min(2*(p-startPos) + (startPos-fruits[ii][0]), (p-startPos) + 2*(startPos-fruits[ii][0]))
            while ii <= i and fn(ii) > k: 
                rsm -= fruits[ii][1]
                ii += 1
            ans = max(ans, rsm)
        return ans"
find first palindromic string in the array,"class Solution:
    def firstPalindrome(self, words):
        for word in words:
            if word == word[::-1]: return word
        return """""
find first palindromic string in the array,"class Solution:
    def firstPalindrome(self, words):
        for word in words:
            if self.isPalindrome(word): return word
        return """"
    
    def isPalindrome(self, word):
        l, r = 0, len(word)-1
        while l < r:
            if word[l] != word[r]: return False
            l += 1
            r -= 1
        return True"
adding spaces to a string,"class Solution:
    def addSpaces(self, s: str, spaces: List[int]) -> str:
        
        arr = []
        prev = 0
        for space in spaces:
            arr.append(s[prev:space])
            prev = space
        arr.append(s[space:])
       
        return "" "".join(arr)"
adding spaces to a string,"class Solution:
    def addSpaces(self, s: str, spaces: List[int]) -> str:
        arr=[]
        prev=0
        for i in spaces:
            arr.append(s[prev:i])
            prev=i
        arr.append(s[i:])
        return "" "".join(arr)"
number of smooth descent periods of a stock,"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        ans = 0 
        for i, x in enumerate(prices): 
            if i == 0 or prices[i-1] != x + 1: cnt = 0
            cnt += 1
            ans += cnt 
        return ans"
number of smooth descent periods of a stock,"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        result,count = 0,1
        for i in range(1,len(prices)):
            if prices[i] + 1 == prices[i-1]:
                count += 1
            else:
                result += (count * (count+1))//2
                count = 1
        result += (count * (count+1))//2
        return result"
minimum operations to make the array k increasing,"class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        
        def fn(sub): 
            """"""Return ops to make sub non-decreasing.""""""
            vals = []
            for x in sub: 
                k = bisect_right(vals, x)
                if k == len(vals): vals.append(x)
                else: vals[k] = x
            return len(sub) - len(vals)
        
        return sum(fn(arr[i:len(arr):k]) for i in range(k))"
minimum operations to make the array k increasing,"class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        ans = 0 
        for _ in range(k): 
            vals = []
            for i in range(_, len(arr), k): 
                if not vals or vals[-1] <= arr[i]: vals.append(arr[i])
                else: vals[bisect_right(vals, arr[i])] = arr[i]
            ans += len(vals)
        return len(arr) - ans"
maximum number of words found in sentences,"class Solution:
    def mostWordsFound(self, ss: List[str]) -> int:
        return max(s.count("" "") for s in ss) + 1"
maximum number of words found in sentences,"class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        mx=0
        for i in sentences:
            c=i.split()
            if len(c)>mx:
                mx=len(c)
        return mx"
find all possible recipes from given supplies,"class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        graph, can_make, supplies = {recipe : [] for recipe in recipes},  {}, set(supplies)
        def dfs(recipe : str) -> bool:
            if recipe not in can_make:
                can_make[recipe] = False
                can_make[recipe] = all([dfs(ingr) for ingr in graph[recipe]])
            return can_make[recipe]
        for i, recipe in enumerate(recipes):
            for ingr in ingredients[i]:
                if ingr not in supplies:
                    graph[recipe].append(ingr if ingr in graph else recipe)
        return [recipe for recipe in recipes if dfs(recipe)]"
find all possible recipes from given supplies,"class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        indeg = defaultdict(int)
        graph = defaultdict(list)
        for r, ing in zip(recipes, ingredients): 
            indeg[r] = len(ing)
            for i in ing: graph[i].append(r)
        
        ans = []
        queue = deque(supplies)
        recipes = set(recipes)
        while queue: 
            x = queue.popleft()
            if x in recipes: ans.append(x)
            for xx in graph[x]: 
                indeg[xx] -= 1
                if indeg[xx] == 0: queue.append(xx)
        return ans"
check if a parentheses string can be valid,"class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        def validate(s: str, locked: str, op: str) -> bool:
            bal, wild = 0, 0
            for i in range(len(s)):
                if locked[i] == ""1"":
                    bal += 1 if s[i] == op else -1
                else:
                    wild += 1
                if wild + bal < 0:
                    return False
            return bal <= wild
        return len(s) % 2 == 0 and validate(s, locked, '(') and validate(s[::-1], locked[::-1], ')')"
check if a parentheses string can be valid,"class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        if len(s)&amp;1: return False
        bal = 0
        for ch, lock in zip(s, locked):
            if lock == '0' or ch == '(': bal += 1
            elif ch == ')': bal -= 1
            if bal < 0: return False 
        bal = 0
        for ch, lock in zip(reversed(s), reversed(locked)): 
            if lock == '0' or ch == ')': bal += 1
            elif ch == '(': bal -= 1
            if bal < 0: return False
        return True"
abbreviating the product of a range,"class Solution:
    def abbreviateProduct(self, left: int, right: int) -> str:
        ans = prefix = suffix = 1
        trailing = 0 
        flag = False 
        for x in range(left, right+1): 
            if not flag: 
                ans *= x
                while ans % 10 == 0: ans //= 10 
                if ans >= 1e10: flag = True 
            prefix *= x
            suffix *= x
            while prefix >= 1e12: prefix //= 10 
            while suffix % 10 == 0: 
                trailing += 1
                suffix //= 10 
            if suffix >= 1e10: suffix %= 10_000_000_000
        while prefix >= 100000: prefix //= 10 
        suffix %= 100000
        if flag: return f""{prefix}...{suffix:>05}e{trailing}""
        return f""{ans}e{trailing}"""
abbreviating the product of a range,"class Solution:
    def abbreviateProduct(self, left: int, right: int) -> str:
        #Step1: count the num of trailing zeros
        factor_two, factor_five = 0, 0
        curr_factor = 2
        while curr_factor <= right:
            factor_two += (right // curr_factor) - ((left - 1) // curr_factor)
            curr_factor *= 2
        curr_factor = 5
        while curr_factor <= right:
            factor_five += (right // curr_factor) - ((left - 1) // curr_factor)
            curr_factor *= 5
        trailing_zeros = min(factor_two, factor_five)
        
        #Step2: Multiply until it gets too big, while dividing 2 and 5
		divide_two_so_far, divide_five_so_far = 0, 0
        curr_num = 1
        for i in range(left, right + 1):
            multiply = i
            while multiply % 2 == 0 and divide_two_so_far < trailing_zeros:
                multiply //= 2
                divide_two_so_far += 1
            while multiply % 5 == 0 and divide_five_so_far < trailing_zeros:
                multiply //= 5
                divide_five_so_far += 1
            curr_num *= multiply
            if curr_num >= 10 ** 10:
                break
        
        #if the number doesn't get too large (less than or equal to 10 digits)
        if curr_num < 10 ** 10:
            return str(curr_num) + 'e' + str(trailing_zeros)
        
        #Step2: if the number exceeds 10 ** 10, then keep track of the first and last digits
        first_digits, last_digits = int(str(curr_num)[:12]), int(str(curr_num)[-5:])
        start = i + 1
        for i in range(start, right + 1):
            multiply = i
            while multiply % 2 == 0 and divide_two_so_far < trailing_zeros:
                multiply //= 2
                divide_two_so_far += 1
            while multiply % 5 == 0 and divide_five_so_far < trailing_zeros:
                multiply //= 5
                divide_five_so_far += 1
            first_digits = int(str(first_digits * multiply)[:12])
            last_digits = int(str(last_digits * multiply)[-5:])
        
		#output
        return str(first_digits)[:5] + '...' + '{:>05d}'.format(last_digits) + 'e' + str(trailing_zeros)"
a number after a double reversal,"class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        return not num or num % 10"
a number after a double reversal,"class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
	    # False cases are those if last the digit of any 2(+) digit number = 0 
        if len(str(num)) > 1 and str(num)[-1] == ""0"":
            return False
        else:
		# Else, every integer is true
            return True"
execution of all suffix instructions staying in a grid,"class Solution:
    def executeInstructions(self, n: int, startPos: list[int], s: str) -> list[int]:

        def num_of_valid_instructions(s, pos, start, end):
            row, colon = pos
            k = 0
            for i in range(start, end):
                cur = s[i]
                row += (cur == 'D') - (cur == 'U')
                colon += (cur == 'R') - (cur == 'L')
                if not (0 <= row < n and 0 <= colon < n):
                    return k
                k += 1
            return k

        ans = []
        for i in range(len(s)):
            ans.append(num_of_valid_instructions(s, startPos, i, len(s)))
        return ans"
execution of all suffix instructions staying in a grid,"class Solution:
    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:
        d = {'U':(-1, 0),'D':(1, 0), 'R':(0, 1), 'L':(0, -1)}
        m = len(s)
        ans = [0]*m
        
        def isBounded(start, end):
            return (0<= start < n and 0<= end < n)
                
        for i in range(m):
            x, y = startPos
            for j in range(i, m):
                dx, dy = d[s[j]]
                x += dx; y += dy
                
                if not isBounded(x, y):
                    break
                ans[i] += 1
        return ans"
intervals between identical elements,"class Solution:
    def getDistances(self, arr: List[int]) -> List[int]:
        loc = defaultdict(list)
        for i, x in enumerate(arr): loc[x].append(i)
        
        for k, idx in loc.items(): 
            prefix = list(accumulate(idx, initial=0))
            vals = []
            for i, x in enumerate(idx): 
                vals.append(prefix[-1] - prefix[i] - prefix[i+1] - (len(idx)-2*i-1)*x)
            loc[k] = deque(vals)
        
        return [loc[x].popleft() for x in arr]"
intervals between identical elements,"class Solution:
    def getDistances(self, arr: List[int]) -> List[int]:
        n = len(arr)
        d = defaultdict(list)
        for i, v in enumerate(arr): d[v].append(i)
            
        
        res = defaultdict(list)
        for v, idx in d.items():
            ps = list(accumulate(idx, initial=0))
            vals = []
            idn = len(idx)
            for i, x in enumerate(idx):
                vals.append(i*x-ps[i] + ps[-1]-ps[i+1]-(idn-i-1)*x)

            res[v] = deque(vals)
            
        return [res[v].popleft() for v in arr]"
recover the original array,"class Solution:
    def recoverArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        cnt = Counter(nums)
        for i in range(1, len(nums)): 
            diff = nums[i] - nums[0]
            if diff and diff&amp;1 == 0: 
                ans = []
                freq = cnt.copy()
                for k, v in freq.items(): 
                    if v: 
                        if freq[k+diff] < v: break 
                        ans.extend([k+diff//2]*v)
                        freq[k+diff] -= v
                else: return ans"
recover the original array,"class Solution:
    def recoverArray(self, nums):
        self.n, self.nums = len(nums) // 2, sorted(nums)

        small = self.nums[0]
        for x in self.nums[1:]:
            k = x - small # this represents 2 * k from the problem statement
            if k % 2 or not k: continue
            temp = self.valid(k)
            if temp: return temp
        return []

    def valid(self, k):
        counts = defaultdict(list)
        for i in range(len(self.nums) - 1, -1, -1):
            counts[self.nums[i]].append(i)

        # go through each value from smallest to largest
        # at each value check for corresponding (val + k)
        # keep track of which values are used when checking
        # ahead for the (val + k)
        # finally add (val + k / 2) if we find the corresponding
		# (val + k) as it is the value from the original array
        ans, used = [], [False] * len(self.nums)
        for i, v in enumerate(self.nums):
            if used[i]: continue
            if not counts[v + k]: return []
            used[counts[v + k].pop()] = True
            ans.append(v + k // 2)
        return ans"
check if all as appears before all bs,"class Solution:
    def checkString(self, s: str) -> bool:
        return ''.join(sorted(s)) == s"
check if all as appears before all bs,"class Solution:
    def checkString(self, s: str) -> bool:
        appeared_b = False
        for char in s:
            if char == 'b':
                appeared_b = True
            else:
                if appeared_b:
                    return False
        return True"
number of laser beams in a bank,"class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        a, s = [x.count(""1"") for x in bank if x.count(""1"")], 0

		# ex: bank is [[00101], [01001], [00000], [11011]]
		# a would return [2, 2, 4]

        for c in range(len(a)-1):
            s += (a[c]*a[c+1])

			# basic math to find the total amount of lasers
			# for the first iteration: s += 2*2
			# for the second iteration: s += 2*4
			# returns s = 12

        return s"
number of laser beams in a bank,"class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        ans = prev = 0 
        for row in bank: 
            curr = row.count('1')
            if curr: 
                ans += prev * curr
                prev = curr 
        return ans"
destroying asteroids,"class Solution:
    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:
        asteroids = sorted(asteroids)
        for i in asteroids:
            if i <= mass:
                mass += i
            else:
                return False
        return True"
destroying asteroids,"class Solution:
    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:
        # ///// TC O(nlogn) //////
        asteroids.sort()
        
        for asteroid in asteroids:
            if mass >= asteroid:
                mass += asteroid
            else:
                return False
        return True"
maximum employees to be invited to a meeting,"class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        n = len(favorite)
        graph = [[] for _ in range(n)]
        for i, x in enumerate(favorite): graph[x].append(i)
        
        def bfs(x, seen): 
            """"""Return longest arm of x.""""""
            ans = 0 
            queue = deque([x])
            while queue: 
                for _ in range(len(queue)): 
                    u = queue.popleft()
                    for v in graph[u]: 
                        if v not in seen: 
                            seen.add(v)
                            queue.append(v)
                ans += 1
            return ans 
        
        ans = 0 
        seen = [False]*n
        for i, x in enumerate(favorite): 
            if favorite[x] == i and not seen[i]: 
                seen[i] = seen[x] = True 
                ans += bfs(i, {i, x}) + bfs(x, {i, x})
                
        dp = [0]*n
        for i, x in enumerate(favorite): 
            if dp[i] == 0: 
                ii, val = i, 0
                memo = {}
                while ii not in memo: 
                    if dp[ii]: 
                        cycle = dp[ii]
                        break
                    memo[ii] = val
                    val += 1
                    ii = favorite[ii]
                else: cycle = val - memo[ii]
                for k in memo: dp[k] = cycle
        return max(ans, max(dp))"
capitalize the title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        title = title.split()
        word = """"
        for i in range(len(title)):
            if len(title[i]) < 3:
                word = word + title[i].lower() + "" ""
            else:
                word = word + title[i].capitalize() + "" ""
        return word[:-1]"
capitalize the title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        title = title.split()
        word = []
        for i in range(len(title)):
            if len(title[i]) < 3:
                word.append(title[i].lower())
            else:
                word.append(title[i].capitalize())
        return "" "".join(word)"
maximum twin sum of a linked list,"class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        nums = []
        curr = head
        while curr:
            nums.append(curr.val)
            curr = curr.next
        
        N = len(nums)
        res = 0
        for i in range(N // 2):
            res = max(res, nums[i] + nums[N - i - 1])
        return res"
maximum twin sum of a linked list,"class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        def reverse(head):
            prev, curr = None, head
            while curr:
                next_node = curr.next
                curr.next = prev
                prev, curr = curr, next_node
            return prev
        
        slow, fast = head, head
        while fast:
            slow = slow.next
            fast = fast.next.next
        
        first = head
        second = reverse(slow)
        max_so_far = 0
        
        while second:
            summ = first.val + second.val
            max_so_far = max(max_so_far, summ)
            first, second = first.next, second.next
        
        return max_so_far"
longest palindrome by concatenating two letter words,"class Solution:
    def longestPalindrome(self, words: List[str]) -> int:
        dc=defaultdict(lambda:0)
        for a in words:
            dc[a]+=1
        count=0
        palindromswords=0
        inmiddle=0
        wds=set(words)
        for a in wds:
            if(a==a[::-1]):
                if(dc[a]%2==1):
                    inmiddle=1
                palindromswords+=(dc[a]//2)*2
            elif(dc[a[::-1]]>0):
                count+=(2*(min(dc[a],dc[a[::-1]])))
                dc[a]=0
        return (palindromswords+count+inmiddle)*2
        ``"
longest palindrome by concatenating two letter words,"class Solution:
    def longestPalindrome(self, words: List[str]) -> int:
        lookup = Counter(words)
        p_len = 0
        mid = 0
        
        for word in lookup.keys():
            if word[0] == word[1]:
                if lookup[word]%2 == 0:
                    p_len += lookup[word]
                else:
                    p_len += lookup[word]-1
                    mid = 1
                    
            elif word[::-1] in lookup:
                p_len += min(lookup[word], lookup[word[::-1]])
        
        return (p_len + mid) * 2"
stamping the grid,"class Solution:
    def prefix_sum(self, grid: List[List[int]]) -> List[List[int]]:
            ps = [[grid[row][col] for col in range(len(grid[0]))]for row in range(len(grid))]
            
            for row in range(len(grid)):
                for col in range(1, len(grid[0])):
                    ps[row][col] = ps[row][col-1] + grid[row][col]
            
            for row in range(1, len(grid)):
                for col in range(len(grid[0])):
                    ps[row][col] = ps[row-1][col] + ps[row][col]
            
            return ps
			
    def sumRegion(self, ps, row1: int, col1: int, row2: int, col2: int) -> int:
            ans = 0
            if row1 == 0 and col1 == 0:
                ans = ps[row2][col2]
            elif row1 == 0:
                ans = ps[row2][col2] - ps[row2][col1-1]
            elif col1 == 0:
                ans = ps[row2][col2] - ps[row1-1][col2]
            else:
                ans = ps[row2][col2] - ps[row1-1][col2] - ps[row2][col1-1] + ps[row1-1][col1-1]
            return ans

    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
        diff = [[0 for col in range(len(grid[0])+1)]for row in range(len(grid)+1)]
        
        ps = self.prefix_sum(grid)
        cover = 0
        
        for row in range(len(grid)-(stampHeight-1)):
            for col in range(len(grid[0])-(stampWidth-1)):
                sub_sum = self.sumRegion(ps, row, col, row+stampHeight-1, col+stampWidth-1)
                if sub_sum == 0:
                    diff[row][col] += 1
                    diff[row][col+stampWidth] -= 1
                    diff[row+stampHeight][col] -= 1
                    diff[row+stampHeight][col+stampWidth] = 1
        pref_diff = self.prefix_sum(diff)
        m, n = len(grid), len(grid[0])
        
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == 0 and pref_diff[row][col] == 0: return False 
        
        return True"
stamping the grid,"class Solution:
    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
        m, n = len(grid), len(grid[0])
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m):
            for j in range(n): 
                prefix[i+1][j+1] = grid[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
        
        seen = [[0]*n for _ in range(m)]
        for i in range(m-stampHeight+1): 
            for j in range(n-stampWidth+1): 
                diff = prefix[i+stampHeight][j+stampWidth] - prefix[i+stampHeight][j] - prefix[i][j+stampWidth] + prefix[i][j]
                if diff == 0: seen[i][j] = 1
                    
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m): 
            for j in range(n): 
                prefix[i+1][j+1] = seen[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
                
        for i in range(m):
            ii = max(0, i-stampHeight+1)
            for j in range(n): 
                jj = max(0, j-stampWidth+1)
                if grid[i][j] == 0 and prefix[i+1][j+1] - prefix[i+1][jj] - prefix[ii][j+1] + prefix[ii][jj] == 0: return False 
        return True"
check if every row and column contains all numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        lst = [0]*len(matrix)
        for i in matrix:
            if len(set(i)) != len(matrix):
                return False
            for j in range(len(i)):
                lst[j] += i[j]
        return len(set(lst)) == 1"
check if every row and column contains all numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        # bitmask
        n = len(matrix)

        for i in range(n):
            row_bit, col_bit, bitmask = 1, 1, 1
            for j in range(n):
                row_bit ^= 1 << matrix[i][j]
                col_bit ^= 1 << matrix[j][i]
                bitmask |= 1 << j + 1

            if row_bit ^ bitmask or col_bit ^ bitmask:
                return False
        
        return True"
minimum swaps to group all 1s together ii,"class Solution:
    def minSwaps(self, nums: List[int]) -> int:
        width = sum(num == 1 for num in nums) #width of the window
        nums += nums
        res = width
        curr_zeros = sum(num == 0 for num in nums[:width]) #the first window is nums[:width]
        
        for i in range(width, len(nums)):
            curr_zeros -= (nums[i - width] == 0) #remove the leftmost 0 if exists
            curr_zeros += (nums[i] == 0) #add the rightmost 0 if exists
            res = min(res, curr_zeros) #update if needed
        
        return res"
minimum swaps to group all 1s together ii,"class Solution:
    def minSwaps(self, nums: List[int]) -> int:
        ones = nums.count(1)
        n = len(nums)
        res = ones
        start = 0
        end = ones-1
        zeroesInWindow = sum(num==0 for num in nums[start:end+1])
        
        while start < n:
            # print(start, end , zeroesInWindow)
            res = min(res, zeroesInWindow)
            if nums[start] == 0: zeroesInWindow -= 1 
            start += 1
            end += 1
            if nums[end%n] == 0: zeroesInWindow += 1
                
        return res"
count words obtained after adding a letter,"class Solution:
    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:
        seen = set()
        for word in startWords: 
            m = 0
            for ch in word: m ^= 1 << ord(ch)-97
            seen.add(m)
            
        ans = 0 
        for word in targetWords: 
            m = 0 
            for ch in word: m ^= 1 << ord(ch)-97
            for ch in word: 
                if m ^ (1 << ord(ch)-97) in seen: 
                    ans += 1
                    break 
        return ans"
count words obtained after adding a letter,"class Solution:
    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:
        sw = {}
        
        for ss in startWords:
            sw[ss] = Counter(ss)
            
        
        S = set()
        
        for target in targetWords:
            counter_t = Counter(target)
            
            for ss in sw:
                if len(target) == len(ss) + 1 and len(counter_t.keys()) == len(sw[ss].keys()) + 1:
                    s = sum([val for key, val in (sw[ss] &amp; counter_t).items()])
                    if s == len(ss):
                        S.add(target)
                        break

        return len(S)"
earliest possible day of full bloom,"class Solution:
    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:
        res = 0
        for grow, plant in sorted(zip(growTime, plantTime)):
            res = max(res, grow) + plant
        return res"
earliest possible day of full bloom,"class Solution:
    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:
        data = list(zip(plantTime, growTime))
        data.sort(key=lambda x: -x[1]) #sort by grow time in descending order
        
        res = 0
        start_time = 0
        for plant, grow in data:
            start_time += plant
            res = max(res, start_time + grow)
        return res"
divide a string into groups of size k,"class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        length = len(s)
        res=[]
        for i in range(0,length,k):
            if i+k>length:
                break
            res.append(s[i:i+k])
        mod =length%k 
        
        if mod!= 0:
            fill_str = fill *(k-mod)
            add_str = s[i:]+fill_str
            res.append(add_str)
            
        return res"
divide a string into groups of size k,"class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        ans = []
        for i in range(0, len(s), k): 
            ss = s[i:i+k]
            ans.append(ss + (k-len(ss))*fill)
        return ans"
minimum moves to reach target score,"class Solution:
   def minMoves(self, target: int, maxDoubles: int) -> int:
       moves = 0
       while maxDoubles > 0 and target > 1:
           if target % 2 == 1:
               target -= 1
           else:
               target //= 2
               maxDoubles -= 1
           moves += 1
       moves += target - 1
       return moves"
minimum moves to reach target score,"class Solution:
    def minMoves(self, target: int, maxDoubles: int) -> int:
        # If all maxDoubles are expired then number of -1 operations to go from target to 1 is (target-1)
		# If target is 1 that means we return 0. Since target is 1, we return target-1
        if maxDoubles == 0 or target == 1:
            return target - 1
        subracts = 0 # Considering no -1 operation required initially
        if target%2 != 0: # Target is odd, we must do one -1 operation to make it even
            subracts=1
            target-=1 # Target is now even
        target = target//2
        maxDoubles -= 1 # Since we used a maxDouble operation we have one less /2 operation to work from
        return self.minMoves(target, maxDoubles)+subracts+1
        # we add 1 here as we will do the /2 operation always"
solving questions with brainpower,"class Solution:
    def mostPoints(self, q: List[List[int]]) -> int:
        @cache
        def dfs(i: int) -> int:
            return 0 if i >= len(q) else max(dfs(i + 1), q[i][0] + dfs(i + 1 + q[i][1]))
        return dfs(0)"
solving questions with brainpower,"class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions) # total number of questions
        memo = [-1] * n # memo array of size n. 
		# If memo[i] is not computed then its value must be -1 and we need to find memo[i]
		# If memo[i] != -1, this means we have already calculated this and we dont need to recompute it
        def rec_func(index, current_val) -> int: # index is the current question number to process and current_val is the max marks upto this question
            if index >= n: # It means that we have gone through all the questions thus return the current_val
                return current_val
            if memo[index] == -1: # memo[i] == -1, not computed before and so we need to solve it
                points = questions[index][0] # points for current question
                brainpower = questions[index][1] # brainpower for current question
                a = rec_func(index + brainpower + 1, points) # Recursive call considering we solve the current question
                b = rec_func(index + 1, 0) # Recursive call considering we skip the current question
                memo[index] = max(a, b) # choose which ever choice yields us the best result
            return current_val+memo[index]
        return rec_func(0, 0)"
maximum running time of n computers,"class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        batteries.sort()
        extra = sum(batteries[:-n])
        batteries = batteries[-n:]
        
        ans = prefix = 0 
        for i, x in enumerate(batteries): 
            prefix += x 
            if i+1 < len(batteries) and batteries[i+1]*(i+1) - prefix > extra: return (prefix + extra) // (i+1)
        return (prefix + extra) // n"
maximum running time of n computers,"class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        batteries.sort(reverse=True)
        refills = batteries[n:]
        s = sum(refills)
        res = 0
        for i in range(n-1, 0, -1):
            cur = batteries[i]
            prev = batteries[i-1]
            if prev == cur:
                continue
            smaller_batteries = n-i
            need_for_refill = smaller_batteries * (prev-cur)
            if need_for_refill <= s:
                s -= need_for_refill
            else:
                return cur + s // smaller_batteries
            
        return batteries[0] + s // n"
minimum cost of buying candies with discount,"class Solution:
    def minimumCost(self, cost: List[int]) -> int:
        cost.sort(reverse=True)
        res, i, N = 0, 0, len(cost)
        while i < N:
            res += sum(cost[i : i + 2])
            i += 3
        return res"
minimum cost of buying candies with discount,"class Solution:
    def minimumCost(self, cost: List[int]) -> int:
        cost.sort(reverse=True)
        res, idx, N = 0, 0, len(cost)
        while idx < N:
            res += sum(cost[idx : idx + 2])
            idx += 3
        return res"
count the hidden sequences,"class Solution:
    def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:
        diff = list(accumulate(diff, initial = 0))
        return max(0, upper - lower - (max(diff) - min(diff)) + 1)"
count the hidden sequences,"class Solution:
    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:
        prefix = mn = mx = 0 
        for x in differences: 
            prefix += x
            mn = min(mn, prefix)
            mx = max(mx, prefix)
        return max(0, (upper-lower) - (mx-mn) + 1)"
k highest ranked items within a price range,"class Solution:
    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        ans = []
        queue = deque([(0, *start)])
        grid[start[0]][start[1]] *= -1 
        while queue: 
            x, i, j = queue.popleft()
            if pricing[0] <= -grid[i][j] <= pricing[1]: ans.append((x, -grid[i][j], i, j))
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] > 0: 
                    queue.append((x+1, ii, jj))
                    grid[ii][jj] *= -1
        return [[i, j] for _, _, i, j in sorted(ans)[:k]]"
k highest ranked items within a price range,"class Solution:
    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
        allowed = dict()
        for r, row in enumerate(grid):
            for c, v in enumerate(row):
                if v > 0:
                    allowed[(r, c)] = v

        heap_ans = []
        low_price, high_price = pricing
        start_r, start_c = start
        start_tpl = (start_r, start_c)
        distance = 0
        if low_price <= allowed[start_tpl] <= high_price:
            heappush(heap_ans, (distance, allowed[start_tpl], start_r, start_c))
        allowed.pop(start_tpl)

        level = [start_tpl]
        while len(heap_ans) < k and level:
            new_level = []
            distance += 1
            for r, c in level:
                for new_tpl in [(r + 1, c), (r, c + 1), (r - 1, c), (r, c - 1)]:
                    if new_tpl in allowed:
                        if low_price <= allowed[new_tpl] <= high_price:
                            heappush(heap_ans, (distance, allowed[new_tpl],
                                                new_tpl[0], new_tpl[1]))
                        allowed.pop(new_tpl)
                        new_level.append(new_tpl)
            level = new_level

        ans = []
        count = 0
        while heap_ans and count < k:
            _, _, r, c = heappop(heap_ans)
            ans.append([r, c])
            count += 1

        return ans"
number of ways to divide a long corridor,"class Solution:
    def numberOfWays(self, corridor: str) -> int:
        #edge case
        num_S = corridor.count('S')
        if num_S == 0 or num_S % 2 == 1:
            return 0
        
        mod = 10 ** 9 + 7
        curr_s = 0
        divide_spots = []
        
        for char in corridor:
			curr_s += (char == 'S')
            if curr_s > 0 and curr_s % 2 == 0:
                divide_spots[-1] += 1
            else:
                if not divide_spots or divide_spots[-1] > 0:
                    divide_spots.append(0)
        
        res = 1
        for num in divide_spots[:-1]:
            res = res * num % mod
        return res"
number of ways to divide a long corridor,"class Solution:
    def numberOfWays(self, corridor: str) -> int:
        #edge case
        num_S = corridor.count('S')
        if num_S == 0 or num_S % 2 == 1:
            return 0
        
        mod = 10 ** 9 + 7
        curr_s = 0
        res = 1
        spots = 0
        
        for char in corridor:
            curr_s += (char == 'S')
            if curr_s > 0 and curr_s % 2 == 0:
                spots += 1
            else:
                if spots != 0:
                    res = res * spots % mod
                    spots = 0
        
        return res"
count elements with strictly smaller and greater elements,"class Solution:
    def countElements(self, nums: List[int]) -> int:
        res = 0
        mn = min(nums)
        mx = max(nums)
        for i in nums:
            if i > mn and i < mx:
                res += 1
        return res"
count elements with strictly smaller and greater elements,"class Solution:
    def countElements(self, nums: List[int]) -> int:
        mi=min(nums)
        ma=max(nums)
        c=0
        for i in range(len(nums)):
            if nums[i]>mi and nums[i]<ma:
                c+=1
        return c"
rearrange array elements by sign,"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        return [i for t in zip([p for p in nums if p > 0], [n for n in nums if n < 0]) for i in t]"
rearrange array elements by sign,"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        ans, positives, negatives = [], [], []
        for val in nums:
            if val >= 0:
                positives.append(val)
            else:
                negatives.append(val)
        for i in range(len(positives)):
            ans.append(positives[i])
            ans.append(negatives[i])
        return ans"
find all lonely numbers in the array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        m = Counter(nums)
        return [n for n in nums if m[n] == 1 and m[n - 1] + m[n + 1] == 0]"
find all lonely numbers in the array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        dict1=dict()
        l=[]
        for i in nums:
            if(i in dict1.keys()):
                dict1[i]=-1
            else:    
                dict1[i]=1
            dict1[i-1]=-1
            dict1[i+1]=-1    
        for i in nums:
            if(dict1[i]==1):
                l.append(i)
        return l"
maximum good people based on statements,"class Solution:
    def maximumGood(self, statements: List[List[int]]) -> int:
        ans, n = 0, len(statements)
        for person in itertools.product([0, 1], repeat=n): # use itertools to create a list only contains 0 or 1
            valid = True                                   # initially, we think the `person` list is valid
            for i in range(n):
                if not person[i]: continue                 # only `good` person's statement can lead to a contradiction, we don't care what `bad` person says
                for j in range(n):
                    if statements[i][j] == 2: continue     # ignore is no statement was made
                    if statements[i][j] != person[j]:      # if there is a contradiction, then valid = False
                        valid = False
                        break                              # optimization: break the loop when not valid
                if not valid:                              # optimization: break the loop when not valid
                    break        
            if valid: 
                ans = max(ans, sum(person))                # count sum only when valid == True
        return ans"
maximum good people based on statements,"class Solution:
    def maximumGood(self, statements: List[List[int]]) -> int:
        ans, n = 0, len(statements)
        for mask in range(1 << n):                           # 2**n possibilities
            valid = True
            for i in range(n):
                if not (mask >> i) &amp; 1: continue             # check if the `i`th person is a `good` person
                for j in range(n):
                    if statements[i][j] == 2: continue
                    elif statements[i][j] != (mask >> j) &amp; 1:# check if `i`th person's statement about `j` matches what `mask` says
                        valid = False
                        break                                # optimization: break the loop when not valid
                if not valid: 
                    break                                    # optimization: break the loop when not valid
            if valid: 
                ans = max(ans, bin(mask).count('1'))         # count `1` in mask, take the largest
        return ans"
keep multiplying found values by two,"class Solution:

 def findFinalValue(self, nums: List[int], original: int) -> int:

    while original in nums:
	
        original *= 2
		
    return original"
keep multiplying found values by two,"class Solution:
    def findFinalValue(self, n: List[int], o: int) -> int:
        n = sorted(n)
        for i in range(len(n)) :
            if o == n[i]:
                o *= 2
        return o"
all divisions with the highest score of a binary array,"class Solution:
    def maxScoreIndices(self, nums: List[int]) -> List[int]:
        ans = [0]
        cand = most = nums.count(1)
        for i, x in enumerate(nums): 
            if x == 0: cand += 1
            elif x == 1: cand -= 1
            if cand > most: ans, most = [i+1], cand
            elif cand == most: ans.append(i+1)
        return ans"
all divisions with the highest score of a binary array,"class Solution:
    def maxScoreIndices(self, nums: List[int]) -> List[int]:
		n=len(nums)
		zero=[0]*(n+1)
		one=[0]*(n+1)
		for i in range(n):
			zero[i+1]=zero[i]+(nums[i]==0)
		for i in range(n-1,-1,-1):
			one[i]=one[i+1]+(nums[i]==1)
		total = [0]*(n+1)
		m=0
		res=[]
		for i in range(n+1):
			total[i]=zero[i]+one[i]
			if total[i]>m:
				res=[]
				m=total[i]
			if total[i]==m:
				res+=[i]
		return res"
find substring with given hash value,"class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        pp = pow(power, k-1, modulo)
        hs = ii = 0 
        for i, ch in enumerate(reversed(s)): 
            if i >= k: hs -= (ord(s[~(i-k)]) - 96)*pp
            hs = (hs * power + (ord(ch) - 96)) % modulo
            if i >= k-1 and hs == hashValue: ii = i 
        return s[~ii:~ii+k or None]"
find substring with given hash value,"class Solution:
	def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:

		sc=0
		i=len(s)-1
		a=0
		m = (power**k)%modulo

		while i>-1:

			sc=(sc*power + ord(s[i])-97+1)%modulo

			if i+k<len(s):
				sc=(sc-((ord(s[i+k])-97+1)*m))%modulo

			if sc==hashValue:
				a=i
			i=i-1

		return s[a:a+k]"
minimum sum of four digit number after splitting digits,"class Solution:
    def minimumSum(self, num: int) -> int:
        num = sorted(str(num),reverse=True)
        n = len(num)    
        res = 0
        even_iteration = False
        position = 0
        for i in range(n):
            res += int(num[i])*(10**position)
            if even_iteration:
                position += 1
                even_iteration = False
            else:
                even_iteration = True
        return res"
minimum sum of four digit number after splitting digits,"class Solution:
    def minimumSum(self, num: int) -> int:
        num = sorted(str(num),reverse=True)
        return int(num[0]) + int(num[1]) + int(num[2])*10 + int(num[3])*10"
partition array according to given pivot,"class Solution:
	def pivotArray(self, nums: List[int], pivot: int) -> List[int]:

		ans=[]

		nums.remove(pivot)

		i=0
		ans.append(pivot)

		for j in nums:
			if j<pivot:
				ans.insert(i,j)
				i=i+1
			elif j==pivot:
				ans.insert(i+1,j)
			else:
				ans.append(j)

		return ans"
partition array according to given pivot,"class Solution:
  def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
    less = 0
    equal = 0
    
    for n in nums :
      if   n <  pivot : less  += 1
      elif n == pivot : equal += 1
    
    greater = less + equal
    equal   = less
    less    = 0
    
    ans = [0]*len(nums)
    
    for n in nums :
      if   n <  pivot :
        ans[less] = n
        less += 1
      elif n == pivot : 
        ans[equal] = n
        equal += 1
      else :
        ans[greater] = n
        greater += 1
        
    return ans"
minimum cost to set cooking time,"class Solution:
    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:
        def count_cost(minutes, seconds): # Calculates cost for certain configuration of minutes and seconds
            time = f'{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}' # mm:ss
            time = time.lstrip('0') # since 0's are prepended we remove the 0's to the left to minimize cost
            t = [int(i) for i in time]
            current = startAt
            cost = 0
            for i in t:
                if i != current:
                    current = i
                    cost += moveCost
                cost += pushCost
            return cost
        ans = float('inf')
        for m in range(100): # Check which [mm:ss] configuration works out
            for s in range(100):
                if m * 60 + s == targetSeconds: 
                    ans = min(ans, count_cost(m, s))
        return ans"
minimum cost to set cooking time,"class Solution:
    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:
        start_c, min_cost = str(startAt), inf

        def cost(t: str) -> int:
            return (pushCost * len(t) + moveCost *
                    sum(a != b for a, b in zip(start_c + t, t)))

        for minutes in range(max(0, targetSeconds - 99) // 60,
                             ceil(targetSeconds / 60) + 1):
            seconds = targetSeconds - minutes * 60
            if -1 < minutes < 100 and -1 < seconds < 100:
                set_time = str(minutes) if minutes else """"
                set_time += f""{seconds:0>2d}"" if set_time else f""{seconds}""
                min_cost = min(min_cost, cost(set_time))

        return min_cost"
minimum difference in sums after removal of elements,"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 3

        # calculate max_sum using min_heap for second part
        min_heap = nums[(2 * n) :]
        heapq.heapify(min_heap)

        max_sum = [0] * (n + 2)
        max_sum[n + 1] = sum(min_heap)
        for i in range((2 * n) - 1, n - 1, -1):
            # push current
            heapq.heappush(min_heap, nums[i])
            # popout minimum from heap
            val = heapq.heappop(min_heap)
            # max_sum for this partition
            max_sum[i - n + 1] = max_sum[i - n + 2] - val + nums[i]


        # calculate min_sum using max_heap for first part
        max_heap = [-x for x in nums[:n]]
        heapq.heapify(max_heap)

        min_sum = [0] * (n + 2)
        min_sum[0] = -sum(max_heap)
        for i in range(n, (2 * n)):
            # push current
            heapq.heappush(max_heap, -nums[i])
            # popout maximum from heap
            val = -heapq.heappop(max_heap)
            # min_sum for this partition
            min_sum[i - n + 1] = min_sum[i - n] - val + nums[i]


        # find min difference bw second part (max_sum) and first part (min_sum)
        ans = math.inf
        for i in range(0, n + 1):
            print(i, min_sum[i], max_sum[i])
            ans = min((min_sum[i] - max_sum[i + 1]), ans)

        return ans"
minimum difference in sums after removal of elements,"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        # Python solution using SortedList, time complexity O(nlogn), space complexity O(n)
        n = len(nums) // 3
		
        from sortedcontainers import SortedList
        leftArr = SortedList(nums[ : n])
        rightArr = SortedList(nums[n : ])
		
        # leftSum is the minimum subsequence sum of leftArr, rightSum is the maximum subsequence sum of rightArr
        leftSum, rightSum = sum(leftArr), sum(rightArr[n : ])
        minDiff = leftSum - rightSum
		
        for i in range(n, n * 2):
            # if nums[i] belongs to the n smallest values of leftArr, thus leftSum needs to be updated
            if nums[i] < leftArr[-1]:
                leftSum += nums[i] - leftArr[-1]
            leftArr.add(nums[i])
            leftArr.pop(-1)
			
            # if nums[i] belongs to the n largest values of rightArr, thus rightSum needs to be updated
            if rightArr.bisect_left(nums[i]) - len(rightArr) >= -n:
                rightSum += rightArr[-(n + 1)] - nums[i]
            rightArr.remove(nums[i])
			
            minDiff = min(minDiff, leftSum - rightSum)
			
        return minDiff"
sort even and odd indices independently,"class Solution:
	def sortEvenOdd(self, nums: List[int]) -> List[int]:
		n = len(nums)
		for i in range(0,n,2):
			for j in range(i+2,n,2):
				if nums[i] > nums[j]:
					nums[i],nums[j] = nums[j], nums[i]

		for i in range(1,n,2):
			for j in range(i+2,n,2):
				if nums[i] < nums[j]:
					nums[i],nums[j] = nums[j], nums[i]
		return nums"
sort even and odd indices independently,"class Solution:
    def sortEvenOdd(self, nums: List[int]) -> List[int]:
        even_list = []
        odd_list = []
        for i in range(len(nums)):
            if((i%2)==0):
                even_list.append(nums[i])
            else:
                odd_list.append(nums[i])
        even_list = sorted(even_list)
        odd_list = sorted(odd_list, reverse = True)
        i=0; j=0
        for m in range(len(nums)):
            if m&amp;1:
                nums[m] = odd_list[j]
                j+=1
            else:
                nums[m] = even_list[i]
                i+=1
        return nums"
smallest value of the rearranged number,"class Solution:
    def smallestNumber(self, num: int) -> int:
        
        if num == 0 : return 0 
        snum = sorted(str(num))
        if snum[0] == '-' :
            return -int("""".join(snum[:0:-1]))
        elif snum[0] == '0' :
            x = snum.count('0')
            return """".join([snum[x]]+['0'*x]+snum[x+1:])
        else :
            return """".join(snum)"
smallest value of the rearranged number,"class Solution:
    def smallestNumber(self, num: int) -> int:
        if num==0:
            return 0
        if num>=0:
            num=str(num)
            num=sorted(num)
            ans=''
            z=num.count('0')
            for i in range(z):
                num.pop(0)
            if len(num)>0:
                ans+=num[0]
            ans+='0'*z
            for i in range(1,len(num)):
                ans+=num[i]
        else:
            num=str(num)
            num=sorted(num[1:])
            num.sort(reverse=True)
            ans='-'
            for i in range(len(num)):
                ans+=num[i]
        return ans"
minimum time to remove all cars containing illegal goods,"class Solution:
    def minimumTime(self, s: str) -> int:
        ans = inf 
        prefix = 0 
        for i, ch in enumerate(s): 
            if ch == '1': prefix = min(2 + prefix, i+1)
            ans = min(ans, prefix + len(s)-1-i)
        return ans"
minimum time to remove all cars containing illegal goods,"class Solution:
    def minimumTime(self, s: str) -> int:
        costL2R = [None]*len(s)
        cost = 0 if s[0]=='0' else 1
        costL2R[0]=cost
        for i in range(1,len(s)):
            if s[i]=='1':
                cost = min(cost+2,i+1)
            costL2R[i]=cost           
                
        costR2L = [None]*len(s)
        cost = 0 if s[-1]=='0' else 1
        costR2L[-1] = cost
        for i in range(len(s)-2,-1,-1):
            if s[i]=='1':
                cost = min(cost+2,len(s) - (i+1)+1)
            costR2L[i] = cost
        costR2L.append(0)
            
        minCost = len(s)
        for i in range(len(s)):
            minCost = min(minCost,costL2R[i]+costR2L[i+1])
        return minCost"
count operations to obtain zero,"class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        ans = 0 
        while num1 and num2: 
            ans += num1//num2
            num1, num2 = num2, num1%num2
        return ans"
count operations to obtain zero,"class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        ct=0
        while num2 and num1:
            if num1>=num2:
                num1=num1-num2
            else:
                num2=num2-num1
            ct+=1
        return ct"
minimum operations to make the array alternating,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        pad = lambda x: x + [(None, 0)]*(2-len(x))
        even = pad(Counter(nums[::2]).most_common(2))
        odd = pad(Counter(nums[1::2]).most_common(2))
        return len(nums) - (max(even[0][1] + odd[1][1], even[1][1] + odd[0][1]) if even[0][0] == odd[0][0] else even[0][1] + odd[0][1])"
minimum operations to make the array alternating,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        odd, even = Counter(), Counter()
        for i, x in enumerate(nums): 
            if i&amp;1: odd[x] += 1
            else: even[x] += 1
        
        def fn(freq): 
            key = None
            m0 = m1 = 0
            for k, v in freq.items(): 
                if v > m0: key, m0, m1 = k, v, m0
                elif v > m1: m1 = v
            return key, m0, m1
        
        k0, m00, m01 = fn(even)
        k1, m10, m11 = fn(odd)
        return len(nums) - max(m00 + m11, m01 + m10) if k0 == k1 else len(nums) - m00 - m10"
removing minimum number of magic beans,"class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        beans.sort()
        return sum(beans) - max((len(beans)-i)*x for i, x in enumerate(beans))"
removing minimum number of magic beans,"class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        beans.sort()
        n, s = len(beans), sum(beans) 
        return min(s - bag*(n - i) for i, bag in enumerate(beans))"
maximum and sum of array,"class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        
        @cache
        def fn(k, m): 
            """"""Return max AND sum.""""""
            if k == len(nums): return 0 
            ans = 0 
            for i in range(numSlots): 
                if m &amp; 1<<2*i == 0 or m &amp; 1<<2*i+1 == 0: 
                    if m &amp; 1<<2*i == 0: mm = m ^ 1<<2*i
                    else: mm = m ^ 1<<2*i+1
                    ans = max(ans, (nums[k] &amp; i+1) + fn(k+1, mm))
            return ans 
        
        return fn(0, 0)"
maximum and sum of array,"class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        
        @lru_cache(None)
        def dp(i, m1, m2):
            if i == len(nums):
                return 0

            ans = float('-inf')
            for j in range(numSlots):
                if m1 &amp; (1 << j):
                    ans = max(ans, (nums[i] &amp; (j + 1)) + dp(i + 1, m1 ^ (1 << j), m2))
                elif m2 &amp; (1 << j):
                    ans = max(ans, (nums[i] &amp; (j + 1)) + dp(i + 1, m1, m2 ^ (1 << j)))
            return ans

        return dp(0, (1<<numSlots)-1, (1<<numSlots)-1)"
count equal and divisible pairs in an array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        n=len(nums)
        c=0
        for i in range(0,n):
            for j in range(i+1,n):
                if nums[i]==nums[j] and ((i*j)%k==0):
                    c+=1
        return c"
count equal and divisible pairs in an array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        n=len(nums)
        c=0
        for i in range(0,n):
            for j in range(i+1,n):
                if nums[i]==nums[j] and ((i*j)%k==0):
                    c+=1
        return c"
find three consecutive integers that sum to a given number,"class Solution:
    def sumOfThree(self, num: int) -> List[int]:
        return [] if num % 3 else [num//3-1, num//3, num//3+1]"
find three consecutive integers that sum to a given number,"class Solution:
    def sumOfThree(self, num: int) -> List[int]:
        r=[]
        if num%3==0:
            r.append((num//3)-1)
            r.append((num//3))
            r.append((num//3)+1)
        return r"
maximum split of positive even integers,"class Solution:
    def maximumEvenSplit(self, finalSum: int) -> List[int]:
        l=set()
        if finalSum%2!=0:
            return l
        else:
            s=0
            i=2                       # even pointer 2, 4, 6, 8, 10, 12...........
            while(s<finalSum):
                s+=i                #sum 
                l.add(i)      # append the i in list
                i+=2
            if s==finalSum:  #if sum s is equal to finalSum then no modidfication required
                return l
            else:
                l.discard(s-finalSum)  #Deleting the element which makes s greater than finalSum
				return l"
maximum split of positive even integers,"class Solution:
    def maximumEvenSplit(self, finalSum: int) -> List[int]:
        arr = []
        if finalSum % 2 == 0: # If finalSum is odd then we cannot ever divide it with the given conditions
            a, i = finalSum // 2, 1 # a is the number of 2's and i is the number of 2's that we will use to form a even number in the current iteration
            while i <= a: # Till we have sufficient number of 2's available
                arr.append(2*i) # Join the i number of 2's to form a even number
                a -= i # Number of 2's remaining reduces by i
                i += 1 # Number of 2's required in next itertation increases by 1
            s = sum(arr)
            arr[-1] += finalSum - s # This is done if their were still some 2's remaining that could not form a number due to insufficient count, then we add the remaining 2's into the last number.
        return arr"
count good triplets in an array,"class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        hashmap2 = {}
        for i in range(n):
            hashmap2[nums2[i]] = i
        indices = []
        for num in nums1:
            indices.append(hashmap2[num])
        from sortedcontainers import SortedList
        left, right = SortedList(), SortedList()
        leftCount, rightCount = [], []
        for i in range(n):
            leftCount.append(left.bisect_left(indices[i]))
            left.add(indices[i])
        for i in range(n - 1, -1, -1):
            rightCount.append(len(right) - right.bisect_right(indices[i]))
            right.add(indices[i])
        count = 0
        for i in range(n):
            count += leftCount[i] * rightCount[n - 1 - i]
        return count"
count good triplets in an array,"class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        res = 0
        m2 = [0] * n
        q = []
        
		# Build index map of nums2
        for i in range(n):
            m2[nums2[i]] = i
            
        for p1 in range(n):
            p2 = m2[nums1[p1]] # Position of nums1[p1] in nums2
            idx = bisect.bisect(q, p2) # Position smaller than this one so far
            q.insert(idx, p2)
            before = idx
            after = n-1 - p1 - p2 + before # Based on number of unique values before and after are the same
            res += before * after
            
        return res"
count integers with even digit sum,"class Solution:
    def countEven(self, num: int) -> int:
        return num // 2 if sum([int(k) for k in str(num)]) % 2 == 0 else (num - 1) // 2"
count integers with even digit sum,"class Solution:
    def countEven(self, num: int) -> int:
        count = 0
        for i in range(num+1):
            sum_of_digits = sum(int(digit) for digit in str(i)) 
            if sum_of_digits % 2 == 0 and sum_of_digits != 0:
                count += 1
        return count"
merge nodes in between zeros,"class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        d=ListNode(0)
        t=0
        r=ListNode(0,d)
        while head:
            if head.val!=0:
                t+=head.val
            else:
                print(t)
                if t!=0:
                    d.next=ListNode(t)
                    d=d.next
                    t=0
            head=head.next
        return r.next.next"
merge nodes in between zeros,"class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = node = ListNode()
        chunk = head
        while chunk: 
            chunk = chunk.next 
            sm = 0 
            while chunk and chunk.val: 
                sm += chunk.val 
                chunk = chunk.next 
            if sm: node.next = node = ListNode(sm)
        return dummy.next"
construct string with repeat limit,"class Solution:
    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
        pq = [(-ord(k), v) for k, v in Counter(s).items()] 
        heapify(pq)
        ans = []
        while pq: 
            k, v = heappop(pq)
            if ans and ans[-1] == k: 
                if not pq: break 
                kk, vv = heappop(pq)
                ans.append(kk)
                if vv-1: heappush(pq, (kk, vv-1))
                heappush(pq, (k, v))
            else: 
                m = min(v, repeatLimit)
                ans.extend([k]*m)
                if v-m: heappush(pq, (k, v-m))
        return """".join(chr(-x) for x in ans)"
construct string with repeat limit,"class Solution:
    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
        table = Counter(s)
        char_set = ['0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
                    't', 'u', 'v', 'w', 'x', 'y', 'z']
        sorted_table = []
        for i in range(26,-1,-1):
            if char_set[i] in table:
                sorted_table.append((char_set[i],table[char_set[i]]))

        result = """"
        n = len(sorted_table)
        for i in range(n):
            char, curr_freq = sorted_table[i] # The lexicographically larger character and its frequency
            index_to_take_from = i + 1 # We take from this index the next lexicographically larger character(TEMP) if the repeatLimit for A is exceeded
            while curr_freq > repeatLimit: # Limit exceeded
                result += char*repeatLimit # Add repeatLimit number of character A's
                curr_freq -= repeatLimit # Decrease frequency of character A
                # Now we search for the next lexicographically superior character that can be used once
                while index_to_take_from < n: # Till we run out of characters
                    ch_avail, freq_avail = sorted_table[index_to_take_from]
                    if freq_avail == 0: # If its freq is 0 that means that it was previously used. This is done as we are not removing the character from table if its freq becomes 0. 
                        index_to_take_from += 1 # Check for next lexicographically superior character
                    else:
                        result += ch_avail # If found then add that character 
                        sorted_table[index_to_take_from] = (ch_avail,freq_avail-1) # Update the new characters frequency
                        break
                else:
                    break # We cannot find any lexicographically superior character
            else:
                result += char*curr_freq # If the freq is in limits then just add them
        return result"
count array pairs divisible by k,"class Solution:
    def coutPairs(self, nums: List[int], k: int) -> int:
        factors = []
        for x in range(1, int(sqrt(k))+1):
            if k % x == 0: factors.append(x)
        ans = 0 
        freq = Counter()
        for x in nums: 
            x = gcd(x, k)
            ans += freq[k//x]
            for f in factors: 
                if x % f == 0 and f <= x//f: 
                    freq[f] += 1
                    if f < x//f: freq[x//f] += 1
        return ans"
count array pairs divisible by k,"class Solution:
    def coutPairs(self, nums: List[int], k: int) -> int:
        # Generate all factors of k
        factors = []
        for i in range(1, int(k ** 0.5) + 1):
            if k % i == 0:
                factors.append(i)
				# To prevent us from putting the same number into it
                if k // i != i:
                    factors.append(k // i)
        
        res = 0
        counter = collections.Counter()
        for num in nums:
            # `k // math.gcd(num, k)` is the smallest factor that makes `num` multiply it will be divisible by k
            res += counter[k // math.gcd(num, k)]
            
            for factor in factors:
                # if num % factor == 0, means if can provide this factor for other `num` to multiply and make it divisible by k
                if num % factor == 0:
                    counter[factor] += 1
        return res"
counting words with a given prefix,"class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        return sum(word.find(pref) == 0 for word in words)"
counting words with a given prefix,"class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        ans = 0
        for i in words:
            if i[:len(pref)] == pref:
                ans += 1
        return ans"
minimum number of steps to make two strings anagram ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        fs, ft = Counter(s), Counter(t)
        return sum((fs-ft).values()) + sum((ft-fs).values())"
minimum number of steps to make two strings anagram ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        a=Counter(s)
        b=Counter(t)
        c=(a-b)+(b-a)
        
        count=0
        for i in c:
            count+=c[i]
        return count"
minimum time to complete trips,"class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        r = min(time) * totalTrips + 1 # This is the worst case answer possible for any case. Could use big values like 10^15 as well but they might slow the time down for smaller cases.
        l = 0
        ans = 0

        def check_status(expected_time: int) -> int:
            nonlocal ans
            count = 0
            for i in time:
                count += expected_time // i # Total trips with time expected_time should be integer part of expected_time // i
            if count < totalTrips:
                return 1 # Since number of trips are less then required, left moves to mid
            elif count >= totalTrips:
                ans = expected_time # stores the latest result. This is guaranteed to be the minimum possible answer.
                return -1 # Since number of trips are greater/equal to required, right moves to mid

        while l < r-1: # Till Binary Search can continue. 
            mid = (l + r) // 2 # mid is the current expected time.
            status = check_status(mid) # The return values 1/-1 in check_status function determines which pointer to move.
            if status == 1:
                l = mid
            else:
                r = mid
                
        return ans"
minimum time to complete trips,"class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        
        from collections import Counter
        import numpy as np
        
        dic = Counter(time)
        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))
        
		# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5
        if np.size(k_arr) == 1 and k_arr[0] == 1: 
            if totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]
            else: return totalTrips // v_arr[0] + 1
        
		# binary search
        l, r = min(k_arr), min(k_arr) * totalTrips
        idx = (l + r) // 2   # mid
        
        while l + 1 < r:
            temp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)
            if temp >= totalTrips:
                r = idx
                idx = (r + l) // 2
            else:
                l = idx
                idx = (r + l) // 2
            
        return r"
minimum time to finish the race,"class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        tires.sort()
        newTires = []
        minTime = [changeTime*(i-1) + tires[0][0]*i for i in range(numLaps+1)]
        minTime[0] = 0
        maxi = 0
        for f,r in tires:
            if not newTires or f>newTires[-1][0] and r<newTires[-1][1]:
                newTires.append([f,r])
                t = f
                i = 1
                while i<numLaps and t*(r-1)<changeTime:
                    t = t*r + f
                    i += 1
                    if minTime[i]>t:
                        minTime[i]=t
                        maxi = max(i,maxi)
        for lap in range(numLaps+1):
            for run in range(min(lap,maxi+1)):
                minTime[lap] = min(minTime[lap],minTime[lap-run]+changeTime+minTime[run])
        return minTime[numLaps]"
minimum time to finish the race,"class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        init = [inf] * 20
        for f, r in tires: 
            prefix = term = f
            for i in range(20): 
                init[i] = min(init[i], prefix)
                term *= r
                if term >= f+changeTime: break 
                prefix += term
        
        @cache
        def fn(n): 
            """"""Return min time to finish n laps.""""""
            ans = init[n-1] if n <= 20 else inf
            for nn in range(1, min(20, n//2)+1): 
                ans = min(ans, fn(nn) + fn(n-nn) + changeTime)
            return ans 
        
        return fn(numLaps)"
most frequent number following key in an array,"class Solution:
    def mostFrequent(self, nums, key):
        counts = {}
        
        for i in range(1,len(nums)):
            if nums[i-1]==key:
                if nums[i] not in counts: counts[nums[i]] = 1
                else: counts[nums[i]] += 1
        
        return max(counts, key=counts.get)"
most frequent number following key in an array,"class Solution:
    def mostFrequent(self, nums, key):
        arr = [nums[i] for i in range(1,len(nums)) if nums[i-1]==key]
        c = Counter(arr)
        return max(c, key=c.get)"
sort the jumbled numbers,"class Solution:
    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        @cache
        def convert(i: int):
            res, pow10 = 0, 1
            while i:
                res += pow10 * mapping[i % 10]
                i //= 10
                pow10 *= 10
            return res
        return sorted(nums, key=lambda i: mapping[i] if i < 10 else convert(i))"
sort the jumbled numbers,"class Solution:
	def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
		res = []
		for num in nums:
			ans = """"
			for char in str(num):
				ans += str(mapping[int(char)])
			res.append(int(ans))
		final = list(zip(nums, res))
		final = sorted(final, key=lambda x: x[1])
		return [tup[0] for tup in final]"
all ancestors of a node in a directed acyclic graph,"class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        #Use Kahn's algorithm of toposort using a queue and bfs!
        graph = [[] for _ in range(n)]
        indegrees = [0] * n
        
        #Time: O(n^2)
        #Space: O(n^2 + n + n) -> O(n^2)
        
        #1st step: build adjacency list grpah and update the initial indegrees of every node!
        for edge in edges:
            src, dest = edge[0], edge[1]
            graph[src].append(dest)
            indegrees[dest] += 1
        
        
        queue = deque()
        ans = [set() for _ in range(n)]
        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!
        for i in range(len(indegrees)):
            if(indegrees[i] == 0):
                queue.append(i)
        
        #Kahn's algorithm initiation!
        #while loop will run for each and every node in graph!
        #in worst case, adjacency list for one particular node may contain all other vertices!
        while queue:
            cur = queue.pop()
            
            #for each neighbor
            for neighbor in graph[cur]:
                #current node is ancestor to each and every neighboring node!
                ans[neighbor].add(cur)
                #every ancestor of current node is also an ancestor to the neighboring node!
                ans[neighbor].update(ans[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        #at the end, we should have set of ancestors for each and every node!
        #in worst case, set s for ith node could have all other vertices be ancestor to node i !
        ans = [(sorted(list(s))) for s in ans]
        return ans"
all ancestors of a node in a directed acyclic graph,"class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        ans = [[] for _ in range(n)]
        
        graph = defaultdict(list)
        for f, t in edges:
            graph[t].append(f)
        
        memo = defaultdict(list)
        def dfs(src):
            if src in memo:
                return memo[src]
            
            for nei in graph[src]:
                memo[src] += [nei]+dfs(nei)
            
            memo[src] = list(set(memo[src]))
            return memo[src]
        
        for i in range(n):
            dfs(i)
        return [sorted(memo[i]) for i in range(n)]"
minimum number of moves to make palindrome,"class Solution:
    def minMovesToMakePalindrome(self, s: str) -> int:
        ans = 0 
        while len(s) > 2: 
            lo = s.find(s[-1])
            hi = s.rfind(s[0])
            if lo < len(s)-hi-1: 
                ans += lo 
                s = s[:lo] + s[lo+1:-1]
            else: 
                ans += len(s)-hi-1
                s = s[1:hi] + s[hi+1:]
        return ans"
minimum number of moves to make palindrome,"class Solution:
    def minMovesToMakePalindrome(self, s: str) -> int:
        # At each point, we look at the first and the last elements
        # if they are the same, then we skip them, else we find
        # another element in the string that matches the left
        # element and then we make the necessary swaps to move it
        # to the right place. 
        # if we can't find that element -- this means this is the middle element
        # in the palindrome, we just move it one position to the right and continue
        # over the next few iterations, it will be moved to the center automatically
        # run it for string = ""dpacacp"", answer should be 4
        # the character that should be in the middle is ""d""
        l, r, res, st = 0, len(s)-1, 0, list(s)
        while l < r:
            if st[l] != st[r]:
                i = r
                while i > l and st[l] != st[i]:
                    i -= 1
                if i == l:
                    st[i], st[i+1] = st[i+1], st[i]
                    res += 1
                    continue
                else:
                    while i < r:
                        st[i], st[i+1] = st[i+1], st[i]
                        i += 1
                        res += 1
            l, r = l+1, r-1
        return res"
cells in a range on an excel sheet,"class Solution:
    def cellsInRange(self, s: str) -> List[str]:
        return [chr(c)+str(r) for c in range(ord(s[0]), ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]"
cells in a range on an excel sheet,"class Solution:
    def cellsInRange(self, s: str) -> List[str]:
        start, end = s.split(':')
        start_letter, start_num = start[0], int(start[-1])
        end_letter, end_num = end[0], int(end[1])
        alphabet = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
        alphabet_slice = \
            alphabet[alphabet.index(start_letter):alphabet.index(end_letter) + 1]
        res = list()
        for el in alphabet_slice:
            res += [el + str(num) for num in range(start_num, end_num + 1)]
        return res"
append k integers with minimal sum,"class Solution:
    def minimalKSum(self, nums: List[int], k: int) -> int:
        ans = k*(k+1)//2
        prev = -inf 
        for x in sorted(nums): 
            if prev < x: 
                if x <= k: 
                    k += 1
                    ans += k - x
                else: break
                prev = x
        return ans"
append k integers with minimal sum,"class Solution:
    def minimalKSum(self, nums: List[int], k: int) -> int:
        nums.sort()
        res = 0
        nums.insert(0, 0)
        nums.append(2000000001)
        n = len(nums)
        for i in range(n-1):
            start = nums[i] # This is the lowerbound for current iteration
            end = nums[i+1] # This is the higherbound for current iteration
            if start == end:
                continue
            a = start + 1 # Starting value is lowerbound + 1
            n = min(end - start - 1, k) # Since the total number possible b/w start and end might be more than the k numbers left, so always choose the minimum.
            v = (n*(2*a + n - 1))//2 # n/2[2a + (n-1)d] with d = 1
            res += v # Add the sum of elements selected into res
            k -= n # n number of k's expired, thus k decrements
        return res"
create binary tree from descriptions,"class Solution:
    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        mp = {}
        seen = set()
        for p, c, left in descriptions: 
            if p not in mp: mp[p] = TreeNode(p)
            if c not in mp: mp[c] = TreeNode(c)
            if left: mp[p].left = mp[c]
            else: mp[p].right = mp[c]
            seen.add(c)
        for p, _, _ in descriptions: 
            if p not in seen: return mp[p]"
create binary tree from descriptions,"class Solution:
    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        root = None
        table = {}
        for arr in descriptions:
            parent = arr[0]
            child = arr[1]
            isleft = arr[2]
            if table.get(parent, None) is None: # If key parent does not exist in table
                table[parent] = [TreeNode(parent), False]
            if table.get(child, None) is None: If key child does not exist in table
                table[child] = [TreeNode(child), False]
            table[child][1] = True # Since child is going to have a parent in the current iteration, set its has parent property to True
            if isleft == 1:
                table[parent][0].left = table[child][0]
            else:
                table[parent][0].right = table[child][0]
		# Now traverse the hashtable and check which node still has no parent
        for k, v in table.items():
            if not v[1]: # Has parent is False, so root is found.
                root = k
				break
        return table[root][0]"
replace non coprime numbers in array,"class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:       

        stack = nums[:1]
        
        for j in range(1, len(nums)):
            cur = nums[j]
            while stack and math.gcd(stack[-1], cur) > 1:
                prev = stack.pop()
                cur = math.lcm(prev, cur)
            stack.append(cur)            
               
        return stack"
replace non coprime numbers in array,"class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        stack = []
        for x in nums: 
            while stack and gcd(stack[-1], x) > 1: x = lcm(x, stack.pop())
            stack.append(x)
        return stack"
find all k distant indices in an array,"class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        ind_j = []
        for ind, elem in enumerate(nums):
            if elem == key:
                ind_j.append(ind)
        res = []
        for i in range(len(nums)):
            for j in ind_j:
                if abs(i - j) <= k:
                    res.append(i)
                    break
        return sorted(res)"
find all k distant indices in an array,"class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        keys = [-math.inf] + [idx for idx, num in enumerate(nums) if num == key] + [math.inf]
        N = len(nums)
        res = []
        left = 0
        
        for i in range(N):
            if i - keys[left] <= k or keys[left + 1] - i <= k:
                res.append(i)
            if keys[left + 1] == i:
                left += 1
        return res"
count artifacts that can be extracted,"class Solution:
    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:
	    # Time: O(max(artifacts, dig)) which is O(N^2) as every position in the grid can be in dig
		# Space: O(dig) which is O(N^2)
        result, dig_pos = 0, set(tuple(pos) for pos in dig)
        for pos in artifacts:
            if all((x, y) in dig_pos for x in range(pos[0], pos[2] + 1) for y in range(pos[1], pos[3] + 1)):     
                result += 1
        return result"
count artifacts that can be extracted,"class Solution:
    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:
        pos_to_artifacts = {} # (x, y) => artifact unique index
        artifacts_to_remaining = {} # artifact unique index to remaining spots for artifact to dig up
        results = 0
        
		# Each artifact is identified by a unique index.
        for id, artifact in enumerate(artifacts):
            start, end = (artifact[0], artifact[1]), (artifact[2], artifact[3])
            size = 0
            for x in range(start[0], end[0] + 1):
                for y in range(start[1], end[1] + 1):
                    pos_to_artifacts[(x, y)] = id
                    size += 1
            artifacts_to_remaining[id] = size
        
        for pos in dig:
            if tuple(pos) not in pos_to_artifacts:
                continue
            id = pos_to_artifacts[tuple(pos)]
            artifacts_to_remaining[id] = artifacts_to_remaining[id] - 1
            if artifacts_to_remaining[id] == 0:
                results += 1

        return results"
maximize the topmost element after k moves,"class Solution:
    def maximumTop(self, nums: List[int], k: int) -> int:
        if len(nums) == 1:
            if k%2 != 0:
                return -1
            return nums[0]
        
        if k == 0:
            return nums[0]
        if k == len(nums):
            return max(nums[:-1])
        if k > len(nums):
            return max(nums)
        if k == 1:
            return nums[1]
        m = max(nums[:k-1])
        m = max(m, nums[k])
        return m"
maximize the topmost element after k moves,"class Solution:
    def maximumTop(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if k == 0:
            return nums[0]
        if k == 1:
            if n == 1:
                return -1
            else:
                return nums[1]
        if n == 1:
            if k % 2 != 0:
                return -1
            else:
                return nums[0]
        if k - n - 1 >= 0:
            return max(nums)
        if n == k:
            return max(nums[0:k - 1])
        if n > k:
            return max(max(nums[0:k - 1]), nums[k])"
minimum weighted subgraph with the required paths,"class Solution:
    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
        forward, backward = dict(), dict()
        for start, end, weight in edges:
            if start in forward:
                if end in forward[start]:
                    forward[start][end] = min(weight, forward[start][end])
                else:
                    forward[start][end] = weight
            else:
                forward[start] = {end: weight}
            if end in backward:
                if start in backward[end]:
                    backward[end][start] = min(weight, backward[end][start])
                else:
                    backward[end][start] = weight
            else:
                backward[end] = {start: weight}

        def travel(origin: int, relations: dict, costs: list) -> None:
            level = {origin}
            costs[origin] = 0
            while level:
                new_level = set()
                for node in level:
                    if node in relations:
                        for next_node, w in relations[node].items():
                            if w + costs[node] < costs[next_node]:
                                new_level.add(next_node)
                                costs[next_node] = w + costs[node]
                level = new_level

        from_src1 = [inf] * n
        from_src2 = [inf] * n
        from_dest = [inf] * n

        travel(src1, forward, from_src1)
        travel(src2, forward, from_src2)
        travel(dest, backward, from_dest)

        combined_cost = min(sum(tpl)
                            for tpl in zip(from_src1, from_src2, from_dest))

        return combined_cost if combined_cost < inf else -1"
minimum weighted subgraph with the required paths,"class Solution:
    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
        graph = [[] for _ in range(n)]
        trans = [[] for _ in range(n)]
        for u, v, w in edges: 
            graph[u].append((v, w))
            trans[v].append((u, w))
        
        def bfs(x, graph): 
            dist = [inf] * n
            dist[x] = 0 
            queue = deque([(x, 0)])
            while queue: 
                u, w = queue.popleft()
                if dist[u] == w: 
                    for v, ww in graph[u]: 
                        if w+ww < dist[v]: 
                            dist[v] = w+ww
                            queue.append((v, w+ww))
            return dist
        
        ds1 = bfs(src1, graph)
        ds2 = bfs(src2, graph)
        dd = bfs(dest, trans)
        
        ans = min(x+y+z for x, y, z in zip(ds1, ds2, dd))
        return ans if ans < inf else -1"
divide array into equal pairs,"class Solution:

    def divideArray(self, nums: List[int]) -> bool:
        lena = len(nums)
        count = sum(num//2 for num in Counter(nums).values())
        return (lena/2 == count)"
divide array into equal pairs,"class Solution:
    def divideArray(self, nums: List[int]) -> bool:      
        return not reduce(lambda x,elem: x ^ {elem}, nums, set())"
maximize number of subsequences in a string,"class Solution:
    def maximumSubsequenceCount(self, string: str, pattern: str) -> int:

        text = pattern[0]+string
        text1 = string + pattern[1]
        cnt,cnt1 = 0,0
        ans,ans1 = 0,0
        
        for i in range(len(text)):
            if text[i] == pattern[0]:
                cnt+=1
            elif text[i] == pattern[1]:
                ans+= cnt
        if pattern[0] == pattern[1]:
            ans = ((cnt)*(cnt-1))//2
        # appending at the last 
        for i in range(len(text1)):
            if text1[i] == pattern[0]:
                cnt1+=1
            elif text1[i] == pattern[1]:
                ans1+= cnt1
        if pattern[0] == pattern[1]:
            ans1 = ((cnt1)*(cnt1-1))//2
        return max(ans1,ans)"
maximize number of subsequences in a string,"class Solution:
    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:
        
        # Logic:
        # I am sure if I filter letters of pattern, I can accomplish my task.
        # I am sure if I append the first letter of the pattern in the filtered string,
        # at the beginning and the second letter of the pattern at the end, I can get the maximum
        # number subsequences which is the pattern.
        # I need to count the occurrance of pattern[0] and pattern[1]
        #After I filtered, The only letters in string are pattern[0] and pattern[1]
        #let_ONE=0 #The maximum number of subsequence up to the current index
        #let_TWO=0 # The second letter counter==pattern[1]
        
        filtered=[]
        for let in text:
            if let  in pattern:
                filtered.append(let)
        return  max(self.maxFinder(False,filtered,pattern),
                    self.maxFinder(True,filtered,pattern))
        
        
    def maxFinder(self,atTheBeginning,string,pattern):
        
        let_ONE=0 
        let_TWO=0
        if not atTheBeginning:
            let_TWO=1
        for index in range(len(string)-1,-1,-1):
            if string[index]==pattern[0]:
                let_ONE+=let_TWO
            if string[index]==pattern[1]:
                let_TWO+=1
        if atTheBeginning:
            let_ONE+=let_TWO
        return let_ONE"
minimum operations to halve array sum,"class Solution:
    def halveArray(self, nums: List[int]) -> int:
        s = sum(nums)
        goal = s / 2
        res = 0
        
        for i, num in enumerate(nums):
            nums[i] = -num
        heapq.heapify(nums)
        
        while s > goal:
            halfLargest = -heapq.heappop(nums) / 2
            s -= halfLargest
            heapq.heappush(nums, -halfLargest)
            res += 1
        
        return res"
minimum operations to halve array sum,"class Solution:
    def halveArray(self, nums: List[int]) -> int:
        s = sum(nums)
        
        nums = [-i for i in nums]
        heapify(nums)
        
        total, halve, res = s, s/2, 0
        while total > halve:
            total += nums[0]/2
            heapreplace(nums, nums[0]/2)
            res += 1
            
        return res"
minimum white tiles after covering with carpets,"class Solution:
    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
        
        @cache
        def fn(i, n):
            """"""Return min while tiles at k with n carpets left.""""""
            if n < 0: return inf 
            if i >= len(floor): return 0 
            if floor[i] == '1': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))
            return fn(i+1, n)
        
        return fn(0, numCarpets)"
minimum white tiles after covering with carpets,"class Solution:
    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
        dp = [[0]*(1 + numCarpets) for _ in range(len(floor)+1)]
        for i in range(len(floor)-1, -1, -1): 
            for j in range(0, numCarpets+1): 
                if floor[i] == '1': 
                    dp[i][j] = 1 + dp[i+1][j] 
                    if j: 
                        if i+carpetLen >= len(floor): dp[i][j] = 0 
                        else: dp[i][j] = min(dp[i+carpetLen][j-1], dp[i][j])
                else: dp[i][j] = dp[i+1][j]
        return dp[0][numCarpets]"
count hills and valleys in an array,"class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        
        #cnt: An integer to store total hills and valleys
        #left: Highest point of hill or lowest point of valley left of the current index
        cnt, left = 0, nums[0]
        
        for i in range(1, len(nums)-1):
            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):
                cnt+=1
                left=nums[i]
        return cnt"
count hills and valleys in an array,"class Solution:
    def countHillValley(self, nums: List[int]) -> int:

        def remove_adjacent(nums): #removing adjacent duplicates as they neither add to a hill or valley
            i = 1
            while i < len(nums):    
                if nums[i] == nums[i-1]:
                    nums.pop(i)
                    i -= 1  
                i += 1
            return nums
        nums=remove_adjacent(nums)

        count=0

        for i in range(1,len(nums)-1):
            
            if (nums[i-1]<=nums[i] and nums[i]>nums[i+1]) or (nums[i-1]>nums[i] and nums[i]<=nums[i+1]):
                count+=1
        return count"
count collisions on a road,"class Solution:
    def countCollisions(self, directions: str) -> int:
        return sum(d!='S' for d in directions.lstrip('L').rstrip('R'))"
count collisions on a road,"class Solution:
    def countCollisions(self, directions: str) -> int:
        ans = 0
        # At the beginning, leftest car can go without collide
        # At the beginning, rightest car can go without collide
        
        leftc = rightc = 0
        
        for c in directions:
            # if left side, no car stop or right answer + 0
            # if left side start to have car go right or stop
            # then cars after that are bound to be stopped so answer + 1
            if c == ""L"":
                ans += leftc
            else:
                leftc = 1
                
        for c in directions[::-1]:
            # if right side, no car stop or left answer + 0
            # if right side start to have car go left or stop
            # then cars after that are bound to be stopped so answer + 1
            if c == ""R"":
                ans += rightc
            else:
                rightc = 1
       
        return ans"
maximum points in an archery competition,"class Solution:
    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:
        
        # Initialization with round 1 (round 0 is skipped)
        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}
        
        # Loop from round 2
        for i in range(2, 12):
            prev = dp
            dp = {}
            
            # Consider two possible strategies for each state from last round: to bid and not to bid
            for key in prev:
                
                # Base case: not to bid in this round. Score and arrows left do not change.
                # Simply append 0 at the end to the key.
                newkey1 = list(key)
                newkey1.append(0)
                score, arrowleft = prev[key]
                
                newval1 = (score, arrowleft)
                dp[tuple(newkey1)] = newval1
                
                # If we still have enough arrows, we can bid in this round
                if arrowleft >= aliceArrows[i] + 1:
                    newkey2 = list(key)
                    newkey2.append(aliceArrows[i] + 1)
                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))
                    dp[tuple(newkey2)] = newval2
        
        # Select the bidding history with max score
        maxscore, res = 0, None
        for key in dp:
            score, _ = dp[key]
            if score > maxscore:
                maxscore = score
                res = list(key)
        
        # Taking care of the corner case, where too many arrows are given
        if sum(res) < numArrows:
            res[0] = numArrows - sum(res)
        
        return res"
maximum points in an archery competition,"class Solution:
    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:
        bobArrows = []
        for i in range(12):
            bobArrows.append(aliceArrows[i] + 1)
        maxScore, maxBinNum = 0, None
        for binNum in range(2 ** 12):
            tempScore, tempArrows = 0, 0
            tempBinNum = binNum
            k = 0
            while tempBinNum > 0:
                if tempBinNum % 2 == 1:
                    tempScore += k
                    tempArrows += bobArrows[k]
                tempBinNum //= 2
                k += 1
            if tempArrows <= numArrows and tempScore > maxScore:
                maxScore = tempScore
                maxBinNum = binNum
        output = [0] * 12
        k = 0
        while maxBinNum > 0:
            if maxBinNum % 2 == 1:
                output[k] = bobArrows[k]
            maxBinNum //= 2
            k += 1
        if sum(output) < numArrows:
            output[0] += numArrows - sum(output)
        return output"
find the difference of two arrays,"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        
        set_1 = list_to_set(nums1)
        set_2 = list_to_set(nums2)
        
        return remove_same_elements(set_1, set_2)
                
# Convert the lists into sets via helper method.      
def list_to_set(arr: List[int]):
    
    s = set()
    
    for i in arr:
        s.add(i)
        
    return s   

# Now when the two lists are sets, use the difference attribute to filter common elements of the two sets.
def remove_same_elements(x, y):
    
    x, y = list(x - y), list(y - x)
        
    return [x, y]


# Runtime: 185 ms, faster than 95.96% of Python3 online submissions for Find the Difference of Two Arrays.
# Memory Usage: 14.3 MB, less than 51.66% of Python3 online submissions for Find the Difference of Two Arrays.

# If you like my work, then I'll appreciate a like. Thanks!"
find the difference of two arrays,"class Solution:
    def findDifference(self, n1: List[int], n2: List[int]) -> List[List[int]]:
        return [set(n1) - set(n2),set(n2) - set(n1)]"
minimum deletions to make array beautiful,"class Solution:
    def minDeletion(self, nums: List[int]) -> int:
        # Greedy !
        # we first only consider requirement 2: nums[i] != nums[i + 1] for all i % 2 == 0
        # at the begining, we consider the num on the even index
        # when we delete a num, we need consider the num on the odd index
        # then repeat this process
        # at the end we check the requirement 1: nums.length is even or not
        
        n = len(nums)
        count = 0
        # flag is true then check the even index
        # flag is false then check the odd index
        flag = True
        
        for i in range(n):
            # check the even index
            if flag:
                if i % 2 == 0 and i != n -1 and nums[i] == nums[i + 1]:
                    count += 1
                    flag = False
            # check the odd index
            elif not flag:
                if i % 2 == 1 and i != n -1 and nums[i] == nums[i + 1]:
                    count += 1
                    flag = True
        
        curLength = n - count
        
        return count if curLength % 2 == 0 else count + 1"
minimum deletions to make array beautiful,"class Solution:
    def minDeletion(self, nums: List[int]) -> int:
        n = len(nums)
        dels = cnt = 0

        for i in range(n - 1):
            if (cnt % 2) == 0 and (nums[i] == nums[i + 1]):
                dels += 1
            else:
                cnt += 1
                
        cnt += 1         # Take the last element as it is.
        dels += cnt &amp; 1  # If final count is odd, delete last element.
        return dels"
find palindrome with fixed length,"class Solution:
    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:
        # think the palindromes in half
        # e.g. len  = 4 we only consider the first 2 digits
        # half: 10, 11, 12, 13, 14, ..., 19, 20, 
        # full: 1001, 1111, 1221, 1331, ...
        # e.g. len = 5 we consider the first 3 digits
        # half: 100, 101, 102, ...
        # full: 10001, 10101, 10201, ...
        
        result = []
        
        for i in queries:
            result.append(self.generatePalindrome(intLength, i))
        
        return result
    
    def generatePalindrome(self, length, num):
        # index start from 0
		# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0
		# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1
        index = num -1
        
		# if the length is even
		# we only think about the fisrt half of digits
        if length % 2 == 0:
            cur = int('1' + '0' * (length // 2 -1))
            maxLength = len(str(cur))
            cur += index
            
            if len(str(cur)) > maxLength:
                return -1
            
            else:
                cur = str(cur)
                cur = cur + cur[::-1]
                cur = int(cur)
                return cur
				
        # if the length is odd
		# we consider first (length // 2 + 1) digits
        else:
            cur = int('1' + '0' * (length // 2))
            maxLength = len(str(cur))
            cur += index
            
            if len(str(cur)) > maxLength:
                return -1
            
            else:
                cur = str(cur)
                temp = str(cur)[:-1]
                cur = cur + temp[::-1]
                cur = int(cur)
                return cur"
find palindrome with fixed length,"class Solution:
    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:
	
        ans = []
			
        # number of palindromic numbers in base k with n digits can be found by the formulas: 
		# k, if n == 1 and (k - 1) * (k ** floor((n - 1) / 2)), if n > 1
		# we accumulate numbers for each possible length, starting with 1. 
		# for example: [10, 19, 109, 199, 1099...]
		
        limit = [10, 19]

        for i in range(3, intLength + 1):
            limit.append(limit[-1] + 9 * (10 ** int((i - 1) / 2)))
        
        def helper(num):
            left = str(num)
            
            if intLength % 2 == 0:
                right = str(num)[::-1]
            else:
                right = str(num)[:-1][::-1]
            
            return int(left + right)
        
		# now we form our palindrome if the serial number is less or equal to the limit,
		# else we append -1 to our answer.
		# left part of the desired palindrome can be computed by following:
		# 10 ** digits + serial_number - 1 
		         
        if intLength % 2 == 0:
            digits = intLength // 2 - 1
        else:
            digits = intLength // 2
		
        for i in queries:
            if i <= limit[intLength - 1]:
                half = 10 ** digits + i - 1
                tmp = helper(half)
                
                if len(str(tmp)) <= intLength:
                    ans.append(tmp)
                else:
                    ans.append(-1)
            else:
                ans.append(-1)
            
        return ans"
maximum value of k coins from piles,"class Solution:
    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:
        n, m = len(piles), 0
        prefixSum = []
        for i in range(n):
            temp = [0]
            for j in range(len(piles[i])):
                temp.append(temp[-1] + piles[i][j])
                m += 1
            prefixSum.append(temp)
        if m == k:
            return sum(temp[-1] for temp in prefixSum)
            
        dp = [[0] * (k + 1) for _ in range(n)]
        for j in range(1, k + 1):
            if j < len(prefixSum[0]):
                dp[0][j] = prefixSum[0][j]
        
        for i in range(1, n):
            for j in range(1, k + 1):
                for l in range(len(prefixSum[i])):
                    if l > j:
                        break
                    dp[i][j] = max(dp[i][j], prefixSum[i][l] + dp[i - 1][j - l])
        return dp[n - 1][k]"
maximum value of k coins from piles,"class Solution:
    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:
        
        n = len(piles)
        cache = {}    # <--------------- Caching using dictionary

        def dp(index, remain_k):
            
            if remain_k == 0:
                return 0
            if index == n:
                return 0
            if (index, remain_k) in cache:
                return cache[(index, remain_k)]

            ans = 0
            ans = max(ans, dp(index+1, remain_k))
            running_prefix = 0
            for i in range(1, min(remain_k, len(piles[index]))+1):
                running_prefix += piles[index][i-1]
                ans = max(ans, running_prefix+dp(index+1, remain_k-i))
            cache[(index, remain_k)] = ans
            return ans
        
        return dp(0, k)"
minimum bit flips to convert number,"class Solution:
    def minBitFlips(self, s: int, g: int) -> int:
        count = 0
        while s or g:
            if s%2 != g%2: count+=1
            s, g = s//2, g//2
        return count"
minimum bit flips to convert number,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        return bin(start ^ goal).count(""1"")"
find triangular sum of an array,"class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        return sum(n * comb(len(nums) - 1, i) for i, n in enumerate(nums)) % 10"
find triangular sum of an array,"class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        res, nCr, n = 0, 1, len(nums) - 1
        for r, num in enumerate(nums):
            res = (res + num  * nCr) % 10
            nCr = nCr * (n - r) // (r + 1)
        return res"
number of ways to select buildings,"class Solution:
    def numberOfWays(self, s: str) -> int:
        zeros = s.count('0')
        ones = len(s) - zeros
        zeroPrefix = onePrefix = res = 0
        for c in s:
            if c == '0':
                res += onePrefix * (ones - onePrefix)
                zeroPrefix += 1
            else:
                res += zeroPrefix * (zeros - zeroPrefix)
                onePrefix += 1
        
        return res"
number of ways to select buildings,"class Solution:
    def numberOfWays(self, s: str) -> int:
        prefix = []
        one = zero = 0
        for c in s:                                # find number of 0 or 1 before index `i`
            prefix.append([zero, one])
            if c == '1':
                one += 1
            else:
                zero += 1    
        suffix = []        
        one = zero = 0
        for c in s[::-1]:                          # find number of 0 or 1 after index `i`
            suffix.append([zero, one])
            if c == '1':
                one += 1
            else:
                zero += 1    
        suffix = suffix[::-1]                      # reverse since we trace from right to left 
        ans = 0
        for i, c in enumerate(s):                  # for c=='1' number of combination is prefix[i][0] * suffix[i][0] ([0 before index `i`] * [0 after index `i`])
            if c == '1':
                ans += prefix[i][0] * suffix[i][0]
            else:    
                ans += prefix[i][1] * suffix[i][1]
        return ans"
sum of scores of built strings,"class Solution:
    def sumScores(self, s: str) -> int:
        mod = 119_218_851_371
        hs = 0 
        vals = [0]
        for i, ch in enumerate(s): 
            hs = (hs * 26 + ord(ch) - 97) % mod
            vals.append(hs)
        
        p26 = [1]
        for _ in range(len(s)): p26.append(p26[-1] * 26 % mod)
        
        ans = 0 
        for i in range(len(s)): 
            if s[0] == s[i]: 
                lo, hi = i, len(s)
                while lo < hi: 
                    mid = lo + hi + 1 >> 1
                    hs = (vals[mid] - vals[i]*p26[mid-i]) % mod
                    if hs == vals[mid-i]: lo = mid
                    else: hi = mid - 1
                ans += lo - i 
        return ans"
sum of scores of built strings,"class Solution:
    def sumScores(self, s: str) -> int:
        ans = [0] * len(s)
        lo = hi = ii = 0 
        for i in range(1, len(s)): 
            if i <= hi: ii = i - lo 
            if i + ans[ii] <= hi: ans[i] = ans[ii]
            else: 
                lo, hi = i, max(hi, i)
                while hi < len(s) and s[hi] == s[hi - lo]: hi += 1
                ans[i] = hi - lo 
                hi -= 1
        return sum(ans) + len(s)"
minimum number of operations to convert time,"class Solution:
    def convertTime(self, current: str, correct: str) -> int:
        current_time = 60 * int(current[0:2]) + int(current[3:5]) # Current time in minutes
        target_time = 60 * int(correct[0:2]) + int(correct[3:5]) # Target time in minutes
        diff = target_time - current_time # Difference b/w current and target times in minutes
        count = 0 # Required number of operations
		# Use GREEDY APPROACH to calculate number of operations
        for i in [60, 15, 5, 1]:
            count += diff // i # add number of operations needed with i to count
            diff %= i # Diff becomes modulo of diff with i
        return count"
minimum number of operations to convert time,"class Solution:
    def convertTime(self, s: str, c: str) -> int:
        dif=(int(c[:2])*60+int(c[3:]))-(int(s[:2])*60+int(s[3:]))
        count=0
        print(dif)
        arr=[60,15,5,1]
        for x in arr:
            count+=dif//x
            dif=dif%x
        return count"
find players with zero or one losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        winners, losers, table = [], [], {}
        for winner, loser in matches:
            # map[key] = map.get(key, 0) + change . This format ensures that KEY NOT FOUND error is always prevented.
            # map.get(key, 0) returns map[key] if key exists and 0 if it does not.
            table[winner] = table.get(winner, 0)  # Winner
            table[loser] = table.get(loser, 0) + 1
        for k, v in table.items(): # Player k with losses v
            if v == 0:
                winners.append(k) # If player k has no loss ie v == 0
            if v == 1:
                losers.append(k) # If player k has one loss ie v == 1
        return [sorted(winners), sorted(losers)] # Problem asked to return sorted arrays."
find players with zero or one losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        winners=[x for (x,y) in matches]
		losers=[y for (x,y) in matches]
        perfect_winners=list(set(winners)-set(losers))
        C=Counter(losers) ; one_lost=[loser for loser in C if C[loser]==1]
        return [sorted(perfect_winners), sorted(one_lost)]"
maximum candies allocated to k children,"class Solution:
    def maximumCandies(self, candies, k):
        n = len(candies)
        left = 1  # the least number of candy in each stack we can give to each student is one
        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array
        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. 
               # If we don't have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.

        while left <= right:  # binary search
            numberOfPiles = 0
            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack

            for i in range(n):   # loop through the array to find the numbers of stack we can form
                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)

            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute
                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student 
                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student
            else: 
                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student
        return ans"
maximum candies allocated to k children,"class Solution:
    def maximumCandies(self, C: List[int], k: int) -> int:
        lo=0 ; hi=sum(C)//k
        while lo<hi:
            mid=(lo+hi)//2+1
            if sum(c//mid for c in C)>=k: lo=mid
            else: hi=mid-1
        return lo"
largest number after digit swaps by parity,"class Solution:
    def largestInteger(self, num: int):
        n = len(str(num))
        arr = [int(i) for i in str(num)]
        odd, even = [], []
        for i in arr:
            if i % 2 == 0:
                even.append(i)
            else:
                odd.append(i)
        odd.sort()
        even.sort()
        res = 0
        for i in range(n):
            if arr[i] % 2 == 0:
                res = res*10 + even.pop()
            else:
                res = res*10 + odd.pop()
        return res"
largest number after digit swaps by parity,"class Solution:
    def largestInteger(self, num: int) -> int:
        oddHeap = []
        evenHeap = []
        evenParity = []
        
        while num>0:
            rem = num % 10
            num = num // 10
            if rem%2 == 0:
                heapq.heappush(evenHeap, -rem)
                evenParity.append(True)
            else:
                heapq.heappush(oddHeap, -rem)
                evenParity.append(False)
                
        return self.constructNum(evenHeap, oddHeap, reversed(evenParity))
        
    def constructNum(self, evenHeap, oddHeap, evenParity):
        result = 0
        for parity in evenParity:        
            if parity:
                result = result * 10 + (-heapq.heappop(evenHeap))
            else:
                result = result * 10 + (-heapq.heappop(oddHeap))
        return result"
minimize result by adding parentheses to expression,"class Solution:
    def minimizeResult(self, expression: str) -> str:
        plus_index, n, ans = expression.find('+'), len(expression), [float(inf),expression] 
        def evaluate(exps: str):
            return eval(exps.replace('(','*(').replace(')', ')*').lstrip('*').rstrip('*'))
        for l in range(plus_index):
            for r in range(plus_index+1, n):
                exps = f'{expression[:l]}({expression[l:plus_index]}+{expression[plus_index+1:r+1]}){expression[r+1:n]}'
                res = evaluate(exps)
                if ans[0] > res:
                    ans[0], ans[1] = res, exps
        return ans[1]"
minimize result by adding parentheses to expression,"class Solution:
    def minimizeResult(self, expression: str) -> str:
        nums = expression.split('+')
        m, n = len(nums[0]), len(nums[1])
        min_val = math.inf
        for i in range(m):
            for j in range(1, n+1):
                left = int(nums[0][:m-1-i]) if m-1-i > 0 else 1
                right = int(nums[1][j:]) if j < n else 1
                val = (int(nums[0][m-1-i:]) + int(nums[1][:j])) * left * right
                if val < min_val:
                    res = nums[0][:m-1-i] + '(' + nums[0][m-1-i:] + '+' + nums[1][:j] + ')' + nums[1][j:]
                    min_val = val

        return res"
maximum product after k increments,"class Solution:
    def maximumProduct(self, nums: List[int], k: int) -> int:
        heap = nums.copy()
        heapify(heap)
        for i in range(k):
            t = heappop(heap)
            heappush(heap, t + 1)
        ans = 1
        mod = 1000000007
        for i in heap:
            ans = (ans*i) % mod
        return ans"
maximum product after k increments,"class Solution:
    def maximumProduct(self, nums: List[int], k: int) -> int:
        mod = 1_000_000_007
        nums.sort()
        for i, x in enumerate(nums): 
            target = nums[i+1] if i+1 < len(nums) else inf
            diff = (target-x) * (i+1)
            if diff <= k: k -= diff 
            else: break 
        q, r = divmod(k, i+1)
        ans = pow(x+q+1, r, mod) * pow(x+q, i+1-r, mod) % mod
        for ii in range(i+1, len(nums)): 
            ans = ans * nums[ii] % mod
        return ans"
maximum total beauty of the gardens,"class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        flowers = sorted(min(target, x) for x in flowers)
        prefix = [0]
        ii = -1 
        for i in range(len(flowers)): 
            if flowers[i] < target: ii = i 
            if i: prefix.append(prefix[-1] + (flowers[i]-flowers[i-1])*i)
        ans = 0 
        for k in range(len(flowers)+1): 
            if k: newFlowers -= target - flowers[-k]
            if newFlowers >= 0: 
                while 0 <= ii and (ii+k >= len(flowers) or prefix[ii] > newFlowers): ii -= 1
                if 0 <= ii: kk = min(target-1, flowers[ii] + (newFlowers - prefix[ii])//(ii+1))
                else: kk = 0 
                ans = max(ans, k*full + kk*partial)
        return ans"
maximum total beauty of the gardens,"class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        q, q_acc = [], [0] #eligible gardens < target and its prefix sum
        full_need_acc = [0] #diff to target prefix sum
        ans = 0
        n = len(flowers)
        flowers.sort()

        for f in flowers:
            if f >= target: 
                ans += full
                continue
            q.append(f)
            q_acc.append(q_acc[-1] + f)
        
        for f in flowers[::-1]:
            if f >= target: continue
            full_need_acc.append(full_need_acc[-1] + max(0, target - f))

        res = 0
        for i, x in enumerate(full_need_acc):
            if x > newFlowers: break
            if i == len(full_need_acc) - 1:
                res = max(res, i * full)
                continue
            l, h = flowers[0], target - 1
            while l < h:
                mid = l + (h - l + 1) // 2
                loc = bisect.bisect_left(q, mid, lo=0, hi=len(q)-i)
                if mid * loc - q_acc[loc] <= newFlowers - x:
                    l = mid
                else:
                    h = mid - 1
            res = max(res, i * full + l * partial)
        return ans + res
	```"
add two integers,"class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2"
add two integers,"class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1+num2"
root equals sum of children,"class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return root.left.val+root.right.val == root.val"
root equals sum of children,"class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return root.val == root.left.val + root.right.val"
find closest number to zero,"class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        m = 10 ** 6
        for i in nums:
            x = abs(i-0)
            if x < m:
                m = x
                val = i
            elif x == m and val < i:
                val = i
        return val"
find closest number to zero,"class Solution:
def findClosestNumber(self, nums: List[int]) -> int:
    num=float('inf')
    nums.sort()
    for i in nums:
        if abs(i)<=num:
            num=abs(i)
            c=i
    return c"
number of ways to buy pens and pencils,"class Solution:
    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:
        if total < cost1 and total < cost2:
            return 1
        ways = 0
        if cost1 > cost2:
            for i in range(0, (total // cost1)+1):
                rem = total - (i * cost1)
                ways += (rem // cost2) + 1
            return ways
        for i in range(0, (total // cost2)+1):
            rem = total - (i * cost2)
            ways += (rem // cost1) + 1
        return ways"
number of ways to buy pens and pencils,"class Solution:
    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:
        
        result = 0
        budget = total
        
        cost1, cost2 = sorted([cost1, cost2], reverse = True)
        
        for i in range((budget // cost1) + 1):
            budget = total
            budget -= (i * cost1)
            j = max(budget // cost2, 0)
            result += j + 1

        return result"
maximum score of a node sequence,"class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
      
      connection = {}
      
      for source, target in edges:
        if source not in connection: connection[source] = [target]
        else: connection[source].append(target)
          
        if target not in connection: connection[target] = [source]
        else: connection[target].append(source)
          
      res = -1
      
      max_dict = {}
      for key, value in connection.items():
        max1, max2, max3 = -sys.maxsize, -sys.maxsize, -sys.maxsize
        n1, n2, n3 = None, None, None
        for element in value:
          if scores[element] > max1:
            max1, max2, max3 = scores[element], max1, max2
            n1, n2, n3 = element, n1, n2
          elif scores[element] > max2:
            max2, max3 = scores[element], max2
            n2, n3 = element, n2
          elif scores[element] > max3:
            max3 = scores[element]
            n3 = element
        max_dict[key] = []
        if n1 != None: max_dict[key].append(n1)
        if n2 != None: max_dict[key].append(n2)
        if n3 != None: max_dict[key].append(n3)
             
      for source, target in edges:
        base = scores[source] + scores[target]
        
        n_s = max_dict[source]
        n_t = max_dict[target]
        if len(n_s) == 1 or len(n_t) == 1:
          pass
        else:
          new_n_s = [x for x in n_s if x != target]
          new_n_t = [x for x in n_t if x != source]
          if new_n_s[0] != new_n_t[0]:
            res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[0]])
          else:
            if len(new_n_s) > 1:
              res = max(res, base + scores[new_n_s[1]] + scores[new_n_t[0]])
            if len(new_n_t) > 1:
              res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[1]])      
    
      return res"
calculate digit sum of a string,"class Solution:
    def digitSum(self, s: str, k: int) -> str:
        while len(s) > k:
            set_3 = [s[i:i+k] for i in range(0, len(s), k)]
            s = ''
            for e in set_3:
                val = 0
                for n in e:
                    val += int(n)
                s += str(val)
        return s"
calculate digit sum of a string,"class Solution:
    def digitSum(self, s: str, k: int) -> str:
        def divideString(s: str, k: int) -> List[str]: # Utility function to return list of divided groups.
            l, n = [], len(s)
            for i in range(0, n, k):
                l.append(s[i:min(i + k, n)])
            return l
        while len(s)>k: # Till size of s is greater than k
            arr, temp = divideString(s, k), [] # arr is the list of divided groups, temp will be the list of group sums
            for group in arr: # Traverse the group and add its digits
                group_sum = 0
                for digit in group:
                    group_sum += int(digit)
                temp.append(str(group_sum)) # Sum of digits of current group
            s = ''.join(temp) # s is replaced by the group digit sum for each group.
        return s"
minimum rounds to complete all tasks,"class Solution:
    def minimumRounds(self, tasks: List[int]) -> int:
        table, res = Counter(tasks), 0 # Counter to hold frequency of ith task and res stores the result.
        for count in table.values():
            if count <= 1: return -1 # If count <= 1 then it cannot follow the condition hence return -1.
            res += ceil(count / 3) # Total number of groups increments after 3 values. 
        return res"
minimum rounds to complete all tasks,"class Solution:
    def minimumRounds(self, tasks: List[int]) -> int:
        mp={}
        # storing frequency of each element in mp
        for i in tasks:
            if i in mp:
                mp[i]+=1
            else:
                mp[i]=1
        cnt=0
        for i in mp:
            f=0
            while mp[i]>3:
                mp[i]-=3
                f=1
                cnt+=1
            if mp[i]==2 or mp[i]==3:
                cnt+=1
            elif f==0:
                return -1
            else:
                cnt+=1
        return cnt"
maximum trailing zeros in a cornered path,"class Solution:
    def maxTrailingZeros(self, grid: List[List[int]]) -> int:
        ans = 0
        m, n = len(grid), len(grid[0])
        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]
        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                temp= grid[i][j]
                while temp % 2 == 0:
                    prefixH[i][j + 1][0] += 1
                    prefixV[i + 1][j][0] += 1
                    temp //= 2
                while temp % 5 == 0:
                    prefixH[i][j + 1][1] += 1
                    prefixV[i + 1][j][1] += 1
                    temp //= 5
                for k in range(2):
                    prefixH[i][j + 1][k] += prefixH[i][j][k]
                    prefixV[i + 1][j][k] += prefixV[i][j][k]
        for i in range(m):
            for j in range(n):
                left = prefixH[i][j]
                up = prefixV[i][j]
                right, down, center = [0] * 2, [0] * 2, [0] * 2
                for k in range(2):
                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]
                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]
                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]
                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2
                for k in range(2):
                    LU[k] += left[k] + up[k] + center[k]
                    LD[k] += left[k] + down[k] + center[k]
                    RU[k] += right[k] + up[k] + center[k]
                    RD[k] += right[k] + down[k] + center[k]
                ans = max(ans,
                          min(LU[0], LU[1]),
                          min(LD[0], LD[1]),
                          min(RU[0], RU[1]),
                          min(RD[0], RD[1]))
        return ans"
maximum trailing zeros in a cornered path,"class Solution:
    def maxTrailingZeros(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        f2 = [[0]*n for _ in range(m)]
        f5 = [[0]*n for _ in range(m)]
        for i in range(m): 
            for j in range(n): 
                x = grid[i][j]
                while x % 2 == 0: 
                    f2[i][j] += 1
                    x //= 2 
                x = grid[i][j]
                while x % 5 == 0: 
                    f5[i][j] += 1
                    x //= 5 
        
        h = [[[0, 0] for j in range(n+1)] for i in range(m+1)]
        v = [[[0, 0] for j in range(n+1)] for i in range(m+1)]

        for i in range(m): 
            for j in range(n): 
                h[i][j+1][0] = h[i][j][0] + f2[i][j]
                h[i][j+1][1] = h[i][j][1] + f5[i][j]
                v[i+1][j][0] = v[i][j][0] + f2[i][j]
                v[i+1][j][1] = v[i][j][1] + f5[i][j]
        
        ans = 0 
        for i in range(m): 
            for j in range(n): 
                hh = [h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]]
                vv = [v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]]
                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j]))
                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1]))
                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1]))
                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j]))
        return ans"
longest path with different adjacent characters,"class Solution:
    def longestPath(self, par: List[int], s: str) -> int:
        dit = {}
        # store tree in dictionary
        for i in range(len(par)):
            if par[i] in dit:
                dit[par[i]].append(i)
            else:
                dit[par[i]] = [i]
                
        ans = 1        
        def dfs(n):
            nonlocal ans
            if n not in dit:
                return 1
            
            largest=0 # largest path lenght among all children
            second_largest=0 # second largest path lenght among all children
            for u in dit[n]:
                curr = dfs(u)
                if s[u]!=s[n]: # pick child path if child and parent both have different value
                    if curr>largest:
                        second_largest = largest
                        largest = curr
                    elif curr>second_largest:
                        second_largest = curr
                        
            ans = max(ans,largest+second_largest+1) # largest path including parent with at most two children 
            
            return largest+1  # return largest path end at parent
        
        dfs(0)
        return ans
        ```"
longest path with different adjacent characters,"class Solution:
    def longestPath(self, parent: List[int], s: str) -> int:
        tree = defaultdict(list)
        for child,  par in enumerate(parent):
            tree[par].append(child)
            
        max_length = 1
        def maxLength(node):
            nonlocal max_length
            if not tree[node]:
                return 1
            heap = [-1,-1]
            for child in tree[node]:
                if s[child] != s[node]:
                    heappush(heap,-1*(maxLength(child) + 1))
                else:
                    maxLength(child)
            first_max= -heappop(heap)
            second_max = -heappop(heap)
            cur_max = first_max + second_max - 1
            max_length = max(max_length,cur_max)
            
            return first_max
        maxLength(0)
        return max_length"
intersection of multiple arrays,"class Solution:
    def intersection(self, nums: List[List[int]]) -> List[int]:
        res = set(nums[0])
        for i in range(1, len(nums)):
            res &amp;= set(nums[i])
        res = list(res)
        res.sort()
        return res"
intersection of multiple arrays,"class Solution:
    def intersection(self, nums: List[List[int]]) -> List[int]:
        res = []
        concat = []
        for i in range(len(nums)):
            concat += nums[i]
        for i in set(concat):
            if concat.count(i) == len(nums):
                res.append(i)
        return sorted(res)"
count lattice points inside a circle,"class Solution:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        points = set()
        for x, y, r in circles:
            for dx in range(-r, r + 1, 1):
                temp = math.floor(math.sqrt(r ** 2 - dx ** 2))
                for dy in range(-temp, temp + 1):
                    points.add((x + dx, y + dy))
        return len(points)"
count lattice points inside a circle,"class Solution:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        res=[]
        for cirlcle in circles:
            x=cirlcle[0]
            y= cirlcle[1]
            rad = cirlcle[2]
            for x1 in range(x-rad,x+rad+1):
                for y1 in range(y-rad,y+rad+1):
                    if((x-x1)*(x-x1)+(y-y1)*(y-y1))<=rad*rad:
                            res.append((x1,y1))
        mylist=list(set(res))
        return len(mylist)"
count number of rectangles containing each point,"class Solution:
    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
        mp = defaultdict(list)
        for l, h in rectangles: mp[h].append(l)
        for v in mp.values(): v.sort()
        ans = []
        for x, y in points: 
            cnt = 0 
            for yy in range(y, 101): 
                if yy in mp: cnt += len(mp[yy]) - bisect_left(mp[yy], x)
            ans.append(cnt)
        return ans"
count number of rectangles containing each point,"class Solution:
    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
        maxH = 101 
        hToL = [[] for _ in range(maxH)]
        
		# Create the 100 list (0 is not used) 
        for l, h in rectangles:
            hToL[h].append(l)
			
        # Sort the 100 list
        for h in range(1, maxH):
            hToL[h].sort()
        
		res = []
        for px, py in points:
            count = 0
            # Only search the height (y) which equals to or greater than given py 
            for h in range(py, maxH):
                if len(hToL[h]) == 0:
                    continue
                # Find the first index of length (x) which equals to or greater than given px in the sorted array
                idx = bisect.bisect_left(hToL[h], px) 
                count += len(hToL[h]) - idx
            res.append(count)
        return res

# Time Complexity: O(100*RlogR + P*100*logR) = O(RlogR + PlogR)  //if we consider 100 is a constant
# Space Complexity: O(R)"
number of flowers in full bloom,"class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:
        start, end, res = [], [], []
        for i in flowers:
            start.append(i[0])
            end.append(i[1])
        start.sort() #bisect only works with sorted data
        end.sort()

        for p in persons:
            num = bisect_right(start, p) - bisect_left(end, p)
            res.append(num)
        return res
#bisect_right(start, p) gives you the number of flowers that are in full bloom at person p.
#bisect_left(end, p) gives you number of flowers that are not in full bloom at person p.
#we have to tighten our bound to get exact number of flowers that are in bloom or not, thats why we are using right and left of bisect module."
number of flowers in full bloom,"class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:
        all_points = sorted([(x, 0) for x in persons] + [(x, -1) for x, _ in flowers] + [(x, 1) for _, x in flowers])
        results = {}
        cnt = 0
        for x, t in all_points:
            if t == -1:
                cnt += 1
            elif t == 1:
                cnt -= 1
            else:
                results[x] = cnt
        return [results[p] for p in persons]"
count prefixes of a given string,"class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        count=0
        for i in words:
            if (s[:len(i)]==i):
                count+=1
        return count"
count prefixes of a given string,"class Solution:
    def countPrefixes(self, a: List[str], s: str) -> int:
        r=0
        for i in a:
            if len(i)<=len(s) and i==s[:len(i)]:
                r+=1
        return r"
minimum average difference,"class Solution:
    def minimumAverageDifference(self, a: List[int]) -> int:
        l=0
        r=sum(a)
        z=100001
        y=0
        n=len(a)
        
        for i in range(n-1):
            l+=a[i]
            r-=a[i]
        
            d=abs((l//(i+1))-(r//(n-i-1)))
            if d<z:
                z=d
                y=i
        
        if sum(a)//n<z:
            y=n-1
        
        return y"
minimum average difference,"class Solution:
    def minimumAverageDifference(self, nums: List[int]) -> int:
        left_sum, right_sum = 0, sum(nums)
        left, right = 0, len(nums)
        min_value, return_idx= abs(right_sum//right), len(nums)-1
        
        for i in range(0,len(nums) - 1):
            left_sum += nums[i]
            left+=1
            right_sum -= nums[i]
            right -=1
            curr = abs(left_sum//left - right_sum//right)
            if min_value > curr or (min_value == curr and i < return_idx):
                min_value = curr
                return_idx = i
        
        return return_idx"
count unguarded cells in the grid,"class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        vis = [[0]*n for _ in range(m)]
        # i - rows, j - colums
        # sum(row.count('hit') for row in grid)
        for i,j in walls:
            vis[i][j] = 2
        for i,j in guards:
            vis[i][j] = 2
        for i,j in guards:
            for l in range(j-1,-1,-1):
                if self.checkWall(i,l,vis):
                    break    
                vis[i][l] = 1
            for r in range(j+1,n):
                if self.checkWall(i,r,vis):
                    break
                vis[i][r] = 1
            for u in range(i-1,-1,-1):
                if self.checkWall(u,j,vis):
                    break
                vis[u][j] = 1
            for d in range(i+1,m):
                if self.checkWall(d,j, vis):
                    break
                vis[d][j] = 1
        return sum(row.count(0) for row in vis)
        
    def checkWall(self, i, j, vis):
        if vis[i][j] ==2:
            return True"
count unguarded cells in the grid,"class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        
        #Create a matrix, hint from question
        mat = [[0 for _ in range(n)] for _ in range(m)] 
        
        for [i,j] in guards:
            mat[i][j] = 1   
        for [i,j] in walls:
            mat[i][j] = -1
        
        #dfs for marking paths.
        def dfs(i,j,di):
            if i<0 or i>=m or j<0 or j>=n or mat[i][j] == 1 or mat[i][j] == -1:
                return
            else:
                mat[i][j] = 2
            i = i + lst[di]
            j = j + lst[di+1]
            dfs(i,j,di)
        
        lst = [1,0,-1,0,1]
        for [i,j] in guards:
            for idx in range(4):  
                k = i + lst[idx]
                l = j + lst[idx+1]
                dfs(k,l,idx)
        
        #count uncovered cells.
        count = 0
        for i in range(m):
            for j in range(n):
                if mat[i][j]==0:
                    count +=1
        return count"
escape the spreading fire,"class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
      
      #region growing to assign each grass with the time that it will catch fire
      
      m, n = len(grid), len(grid[0])
      
      start = []
      
      for i in range(m):
        for j in range(n):
          if grid[i][j] == 1:
            start.append([i,j])
            grid[i][j] = 'F'
          elif grid[i][j] == 2:
            grid[i][j] = 'W'
            
      visited = set()
      for element in start: visited.add(tuple(element))
        
      time = 1
      
      while start:
        new_start = []
        for x, y in start:
          if x >= 1:
            if grid[x-1][y] == 0 and (x-1, y) not in visited:
              new_start.append([x-1, y])
              visited.add((x-1, y))
              grid[x-1][y] = time
          if x < m-1:
            if grid[x+1][y] == 0 and (x+1, y) not in visited:
              new_start.append([x+1, y])
              visited.add((x+1, y))
              grid[x+1][y] = time
          if y >= 1:
            if grid[x][y-1] == 0 and (x, y-1) not in visited:
              new_start.append([x, y-1])
              visited.add((x, y-1))
              grid[x][y-1] = time
          if y < n-1:
            if grid[x][y+1] == 0 and (x, y+1) not in visited:
              new_start.append([x, y+1])
              visited.add((x, y+1))
              grid[x][y+1] = time
        time += 1
        start = new_start
        
        
      #memo variable will save time from search path that is already proved to be impossible
      memo = {}
      def search(x, y, time, visited):
        if (x,y) in memo and time >= memo[(x,y)]: return False
        if time > grid[-1][-1]: return False
        if x == m-1 and y == n-1:
          if grid[x][y] == 0:
            return True
          else: 
            if grid[x][y] >= time:
              return True
        else:
          if grid[x][y] == time: return False
          visited.add((x,y))
          if x >= 1:
            if grid[x-1][y] != 'W' and grid[x-1][y] != 'F' and grid[x-1][y] > time  and (x-1, y) not in visited:
              res = search(x-1, y, time+1, visited)
              if res: return True
          if x < m-1:
            if grid[x+1][y] != 'W' and grid[x+1][y] != 'F' and grid[x+1][y] > time  and (x+1, y) not in visited:
              res = search(x+1, y, time+1, visited)
              if res: return True
          if y >= 1:
            if grid[x][y-1] != 'W' and grid[x][y-1] != 'F' and grid[x][y-1] > time  and (x, y-1) not in visited:
              res = search(x, y-1, time+1, visited)
              if res: return True
          if y < n-1:
            if grid[x][y+1] != 'W' and grid[x][y+1] != 'F' and grid[x][y+1] > time  and (x, y+1) not in visited:
              res = search(x, y+1, time+1, visited)
              if res: return True
          visited.remove((x,y))
          if (x,y) not in memo: memo[(x,y)] = time
          else: memo[(x,y)] = min(time, memo[(x,y)])
          return False
        
      if grid[0][0] == 0:
        if search(0, 0, -sys.maxsize, set()): return 10**9
        else: return -1
      else:
        start, end = 0, grid[0][0]-1
        
        #binary search
 
        while start < end:
          mid = ceil((start + end)/2)
          if search(0, 0, mid, set()):
            start = mid
          else:
            end = mid - 1
        if start != 0: return start
        else:
          if search(0, 0, 0, set()): return 0
          else: return -1"
escape the spreading fire,"class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        
        m, n = len(grid), len(grid[0])
        def nei(x, y):
            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 2:
                    yield nx, ny

        # recreate array to store earliest time caught fire for each grassland
        arr = [[0] * n for _ in range(m)]
        for x in range(m):
            for y in range(n):
                if grid[x][y] == 0:
                    arr[x][y] = float('inf')
                elif grid[x][y] == 1:
                    arr[x][y] = -1
                elif grid[x][y] == 2:
                    arr[x][y] = -2

        # start from each fire and compute earliest time to reach each grass
        def fire_reach_grass(i, j):
            q = [(0, i, j)]
            while q:
                new_q = []
                for t, x, y in q:
                    for nx, ny in nei(x, y):
                        if arr[nx][ny] <= t + 1: continue
                        arr[nx][ny] = t + 1
                        new_q.append((t+1, nx, ny))
                q = new_q
            
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    fire_reach_grass(i, j)

        def person_reach_safehouse(delay):
            q = [(delay, 0, 0)]
            vis = defaultdict(lambda: float('inf'), {(0, 0): 0})
            while q:
                new_q = []
                for t, x, y in q:
                    for nx, ny in nei(x, y):
                        #  reach safehouse and fire spread at same time is allowed
                        if nx == m - 1 and ny == n - 1 and arr[nx][ny] >= t + 1: return True
                        # otherwise reach at same time at grassland is not allowed
                        if arr[nx][ny] == -1 or arr[nx][ny] <= t + 1 or vis[nx, ny] <= t + 1: continue
                        vis[nx, ny] = t + 1
                        new_q.append((t+1, nx, ny))
                q = new_q
            return False
        
        # binary search to find the maximum delay time
        l, h = 0, m*n
        while l < h:
            mid = l + (h - l + 1) // 2
            if person_reach_safehouse(mid):
                l = mid
                if mid == m*n: return 10**9
            else:
                if mid == 0: return -1
                h = mid - 1
        return l if person_reach_safehouse(l) else -1"
remove digit from number to maximize result,"class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        
        # Initializing the last index as zero
        last_index = 0
        
        #iterating each number to find the occurences, \
        # and to find if the number is greater than the next element \ 

        for num in range(1, len(number)):
            
            # Handling [case 1] and [case 2]
            if number[num-1] == digit:
                if int(number[num]) > int(number[num-1]):
                    return number[:num-1] + number[num:]
                else:
                    last_index = num - 1
        
        # If digit is the last number (last occurence) in the string [case 3]
        if number[-1] == digit:
            last_index = len(number) - 1

        return number[:last_index] + number[last_index + 1:]"
remove digit from number to maximize result,"class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        ans = 0
        for i, dig in enumerate(list(number)):
            if dig == digit:
                ans = max(ans, int(number[:i]+number[i+1:]))
        
        return str(ans)"
minimum consecutive cards to pick up,"class Solution:
    def minimumCardPickup(self, cards: List[int]) -> int:
        minPick = float('inf')
        seen = {}
        for i, n in enumerate(cards):
            if n in seen:
                if i - seen[n] + 1 < minPick:
                    minPick = i - seen[n] + 1
            seen[n] = i
        if minPick == float('inf'):
            return -1
        return minPick"
minimum consecutive cards to pick up,"class Solution:
    def minimumCardPickup(self, cards: List[int]) -> int:
        HashMap={}
        lengths=[]
        for i,j in enumerate(cards):
            if j in HashMap:
                lengths.append(abs(HashMap[j]-i)+1)
                HashMap[j]=i
            else:
                HashMap[j]=i
        if len(lengths)>0:
            return min(lengths)
        else:
            return -1``"
k divisible elements subarrays,"class Solution:
    def countDistinct(self, nums: List[int], k: int, p: int) -> int:
        n = len(nums)                        
        sub_arrays = set()
        
		# generate all combinations of subarray
        for start in range(n):
            cnt = 0
            temp = ''
            for i in range(start, n):
                if nums[i]%p == 0:
                    cnt+=1                 
                temp+=str(nums[i]) + ',' # build the sequence subarray in CSV format          
                if cnt>k: # check for termination 
                    break
                sub_arrays.add(temp)                                    
                
        return len(sub_arrays)"
k divisible elements subarrays,"class Solution:
    def countDistinct(self, nums: List[int], k: int, p: int) -> int:
        def dfs(idx, k, path):
            nonlocal res, visited
            if idx == len(nums):
                visited.add(tuple(path[:]))
                return
            
            if nums[idx] % p == 0 and k > 0:
                path.append(nums[idx])
                if tuple(path) not in visited:
                    visited.add(tuple(path))
                    res += 1
                dfs(idx + 1, k - 1, path)
            elif nums[idx] % p != 0:
                path.append(nums[idx])
                if tuple(path) not in visited:
                    visited.add(tuple(path))
                    res += 1
                dfs(idx + 1, k, path)
            
        res = 0
        visited = set()
        for i in range(len(nums)):
            dfs(i, k, [])
        return res"
total appeal of a string,"class Solution:
    def appealSum(self, s: str) -> int:
        res, cur, prev = 0, 0, defaultdict(lambda: -1)
        for i, ch in enumerate(s):
            cur += i - prev[ch]
            prev[ch] = i
            res += cur
        return res"
total appeal of a string,"class Solution:
    def appealSum(self, s: str) -> int:
        lastSeenMap = {s[0]: 0}
        prev, curr, res = 1, 0, 1
        
        for i in range(1, len(s)):
            if s[i] in lastSeenMap:
                curr = prev + (i - lastSeenMap[s[i]])
            else:
                curr = prev + (i + 1)
            res += curr
            prev = curr
            lastSeenMap[s[i]] = i
        return res"
largest 3 same digit number in string,"class Solution:
    def largestGoodInteger(self, n: str) -> str:
        return max(n[i-2:i+1] if n[i] == n[i - 1] == n[i - 2] else """" for i in range(2, len(n)))"
largest 3 same digit number in string,"class Solution:
    def largestGoodInteger(self, num: str) -> str:
        res = '' 
        cnt = 1
        for i in range(1, len(num)):
            if num[i] == num[i-1]:
                cnt+=1
            else:
                cnt = 1
            if cnt == 3:
                res = max(res, num[i] * 3)
                
        return res"
count nodes equal to average of subtree,"class Solution:
    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
        
        def fn(node): 
            nonlocal ans
            if not node: return 0, 0 
            ls, ln = fn(node.left)
            rs, rn = fn(node.right)
            s = node.val + ls + rs
            n = 1 + ln + rn
            if s//n == node.val: ans += 1
            return s, n
        
        ans = 0 
        fn(root)
        return ans"
count nodes equal to average of subtree,"class Solution:
    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
        ans = 0 
        mp = {None: (0, 0)}
        node, stack = root, []
        prev = None
        while node or stack: 
            if node: 
                stack.append(node)
                node = node.left 
            else: 
                node = stack[-1]
                if node.right and node.right != prev: node = node.right
                else: 
                    stack.pop()
                    ls, lc = mp[node.left]
                    rs, rc = mp[node.right]
                    sm, cnt = ls + node.val + rs, lc + 1 + rc
                    mp[node] = (sm, cnt)
                    if sm//cnt == node.val: ans += 1
                    prev = node 
                    node = None
        return ans"
count number of texts,"class Solution:
    def countTexts(self, pressedKeys: str) -> int:
        MOD = 1_000_000_007 
        
        @cache 
        def fn(n, k): 
            """"""Return number of possible text of n repeated k times.""""""
            if n < 0: return 0
            if n == 0: return 1
            ans = 0
            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD
            return ans 
        
        ans = 1
        for key, grp in groupby(pressedKeys): 
            if key in ""79"": k = 4
            else: k = 3
            ans = (ans * fn(len(list(grp)), k)) % MOD 
        return ans"
count number of texts,"class Solution:
    def countTexts(self, pressedKeys: str) -> int:
        dp = [0] * (len(pressedKeys)+1)
        dp[0] = 1
        for i, ch in enumerate(pressedKeys):
            dp[i+1] = dp[i]
            if i and pressedKeys[i-1] == ch: 
                dp[i+1] += dp[i-1]
                if i >= 2 and pressedKeys[i-2] == ch: 
                    dp[i+1] += dp[i-2]
                    if i >= 3 and pressedKeys[i-3] == ch and ch in ""79"": dp[i+1] += dp[i-3]
            dp[i+1] %= 1_000_000_007
        return dp[-1]"
check if there is a valid parentheses string path,"class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:  
        m = len(grid)
        n = len(grid[0])
        @lru_cache(maxsize=None)
        def hasValidPathInner(x, y, cnt):
            # cnt variable would act as a counter to track 
            # the balance of parantheses sequence
            if x == m or y == n or cnt < 0:
                return False
            
            # logic to check the balance of sequence
            cnt += 1 if grid[x][y] == '(' else -1
            
            # if balanced and end of grid, return True
            if x == m - 1 and y == n - 1 and not cnt:
                return True
            
            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)

        return hasValidPathInner(0, 0, 0)"
check if there is a valid parentheses string path,"class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:
        m, n = len(grid), len(grid[0])
        
        @cache
        def fn(i, j, v): 
            """"""Return True if value of v at (i, j) is possible.""""""
            if i == m-1 and j == n-1: return v == 0 
            for ii, jj in (i+1, j), (i, j+1): 
                if 0 <= ii < m and 0 <= jj < n: 
                    if grid[ii][jj] == '(': vv = v+1
                    else: vv = v-1
                    if 0 <= vv <= min(ii+jj+1, m+n-ii-jj) and fn(ii, jj, vv): return True 
            return False 
        
        return fn(0, 0, 1)"
find the k beauty of a number,"class Solution:
    """"""
    Time:   O(log10(n)*k)
    Memory: O(log10(n))
    """"""

    def divisorSubstrings(self, num: int, k: int) -> int:
        str_num = str(num)
        return sum(
            num % int(str_num[i - k:i]) == 0
            for i in range(k, len(str_num) + 1)
            if int(str_num[i - k:i]) != 0
        )"
find the k beauty of a number,"class Solution:
    """"""
    Time:   O(log10(n))
    Memory: O(1)
    """"""

    def divisorSubstrings(self, num: int, k: int) -> int:
        power = 10 ** (k - 1)
        tmp, window = divmod(num, 10 * power)

        count = int(window and not num % window)
        while tmp:
            tmp, digit = divmod(tmp, 10)
            window = digit * power + window // 10
            count += window and not num % window

        return count"
number of ways to split array,"class Solution:
    def waysToSplitArray(self, n: List[int]) -> int:
        n = list(accumulate(n))
        return sum(n[i] >= n[-1] - n[i] for i in range(len(n) - 1))"
number of ways to split array,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        lsum, rsum, ans = 0, sum(nums), 0
        for i in range(len(nums) - 1):
            lsum += nums[i]
            rsum -= nums[i]
            ans += (lsum >= rsum)
        return ans"
maximum white tiles covered by a carpet,"class Solution:
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        tiles.sort()
        ans = ii = val = 0 
        for i in range(len(tiles)): 
            hi = tiles[i][0] + carpetLen - 1
            while ii < len(tiles) and tiles[ii][1] <= hi:
                val += tiles[ii][1] - tiles[ii][0] + 1
                ii += 1
            partial = 0 
            if ii < len(tiles): partial = max(0, hi - tiles[ii][0] + 1)
            ans = max(ans, val + partial)
            val -= tiles[i][1] - tiles[i][0] + 1
        return ans"
maximum white tiles covered by a carpet,"class Solution:
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        tiles = sorted(tiles, key = lambda x : x[0])
        prefix_sum = [0]
        res = 0
        for idx, (start, end) in enumerate(tiles):
            cur_cover = 0
            prefix_sum.append(prefix_sum[-1] + (end - start + 1))
            begin = max(0, end - carpetLen + 1)
            l, r = -1, len(tiles)
            while l + 1 < r:
                mid = (l + r) // 2 # >> 1
                if tiles[mid][0] <= begin:
                    l = mid
                else:
                    r = mid
            if tiles[max(0, l)][0] <= begin <= tiles[max(0, l)][1]:
                cur_cover += tiles[l][1] - begin + 1
            cur_cover += prefix_sum[idx + 1] - prefix_sum[l + 1]
            res = max(res, cur_cover)
        return res"
substring with largest variance,"class Solution:
    def largestVariance(self, s: str) -> int:
        ans = 0 
        seen = set(s)
        for x in ascii_lowercase: 
            for y in ascii_lowercase: 
                if x != y and x in seen and y in seen: 
                    vals = []
                    for ch in s: 
                        if ch == x: vals.append(1)
                        elif ch == y: vals.append(-1)
                    cand = prefix = least = 0 
                    ii = -1 
                    for i, v in enumerate(vals): 
                        prefix += v
                        if prefix < least: 
                            least = prefix 
                            ii = i 
                        ans = max(ans, min(prefix-least, i-ii-1))
        return ans"
substring with largest variance,"class Solution:
    def largestVariance(self, s: str) -> int:
        d = collections.defaultdict(list)
        for i, c in enumerate(s):                                       # for each letter, create a list of its indices
            d[c].append(i)
        ans = 0
        for x, chr1 in enumerate(string.ascii_lowercase):               # character 1
            for chr2 in string.ascii_lowercase[x+1:]:                   # character 2
                if chr1 == chr2 or chr1 not in d or chr2 not in d:
                    continue
                prefix = i = p1 = p2 = 0
                hi = hi_idx = lo = lo_idx = 0
                n1, n2 = len(d[chr1]), len(d[chr2])
                while p1 < n1 or p2 < n2:                               # two pointers
                    if p1 < n1 and p2 < n2:
                        if d[chr1][p1] < d[chr2][p2]:
                            prefix, p1 = prefix+1, p1+1                 # count prefix
                        else:
                            prefix, p2 = prefix-1, p2+1
                    elif p1 < n1:        
                        prefix, p1 = prefix+1, p1+1
                    else:
                        prefix, p2 = prefix-1, p2+1
                    if prefix > hi:                                     # update high value
                        hi, hi_idx = prefix, i
                    if prefix < lo:                                     # update low value
                        lo, lo_idx = prefix, i
                    ans = max(ans, min(prefix-lo, i-lo_idx-1))          # update ans by calculate difference, i-lo_idx-1 is to handle when only one elements are showing up
                    ans = max(ans, min(hi-prefix, i-hi_idx-1)) 
                    i += 1 
        return ans"
find resultant array after removing anagrams,"class Solution:
    def removeAnagrams(self, w: List[str]) -> List[str]:
        return [next(g) for _, g in groupby(w, sorted)]"
find resultant array after removing anagrams,"class Solution:
    def removeAnagrams(self, w: List[str]) -> List[str]:
        return [w[i] for i in range(0, len(w)) if i == 0 or sorted(w[i]) != sorted(w[i - 1])]"
maximum consecutive floors without special floors,"class Solution:
    def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:
        special.sort()
        res = special[0] - bottom
        
        for i in range(1, len(special)):
            res = max(res, special[i] - special[i - 1] - 1)
            
        return max(res, top - special[-1])"
maximum consecutive floors without special floors,"class Solution:
    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:
        c = 0 
        special.sort()
        c = special[0]-bottom
        bottom = special[0]
        for i in range(1,len(special)):
            if special[i]-bottom>1:
                c = max(c,special[i]-bottom-1)
            bottom = special[i]
        if top-bottom>1:
                c = max(c,top-bottom)
        return c"
largest combination with bitwise and greater than zero,"class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        return max(sum(n &amp; (1 << i) > 0 for n in candidates) for i in range(0, 24))"
largest combination with bitwise and greater than zero,"class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
		s = [0 for _ in range(30)]
        for c in candidates:
            b = bin(c)[2:][::-1]
            for i, d in enumerate(b):
                if d == '1':
                    s[i] += 1
        return max(s)"
percentage of letter in string,"class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        a = s.count(letter)
        return (a*100)//len(s)"
percentage of letter in string,"class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        c=0
        for i in s:
            if i==letter:
                c+=1
        n=len(s)
        return int(c/n*100)"
maximum bags with full capacity of rocks,"class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        remaining = [0] * len(capacity)
        res = 0
        
        for i in range(len(capacity)):
            remaining[i] = capacity[i] - rocks[i]
        remaining.sort()
        
        for i in range(len(remaining)):
            if remaining[i] > additionalRocks:
                break
                
            additionalRocks -= remaining[i]
            res += 1
        
        return res"
maximum bags with full capacity of rocks,"class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        l = []
        c = 0
        for i in range(len(capacity)):
            if capacity[i]-rocks[i]:
                l.append(capacity[i]-rocks[i])
            else:
                c+=1
        l.sort()
        for i in range(len(l)):
            a = l[i]
            if a<=additionalRocks:
                c+=1
                additionalRocks-=a 
            else:
                break
        return c"
minimum lines to represent a line chart,"class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        # key point: never use devision to judge whether 3 points are on a same line or not, use the multiplication instead !!
        
        n = len(stockPrices)
        stockPrices.sort(key = lambda x: (x[0], x[1]))
        
        if n == 1:
            return 0
        
        pre_delta_y = stockPrices[0][1] - stockPrices[1][1]
        pre_delta_x = stockPrices[0][0] - stockPrices[1][0]
        num = 1
        
        for i in range(1, n-1):
            cur_delta_y = stockPrices[i][1] - stockPrices[i+1][1]
            cur_delta_x = stockPrices[i][0] - stockPrices[i+1][0]
            
            if pre_delta_y * cur_delta_x != pre_delta_x * cur_delta_y:
                num += 1
                pre_delta_x = cur_delta_x
                pre_delta_y = cur_delta_y
        
        return num"
minimum lines to represent a line chart,"class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        if len(stockPrices) == 1:
            return 0
        stockPrices.sort(key = lambda x: x[0])
        ans = 1
        for i in range(1,len(stockPrices)-1):
            if (stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]) != (stockPrices[i+1][0]-stockPrices[i][0])*(stockPrices[i][1]-stockPrices[i-1][1]):
                ans += 1
        return ans"
sum of total strength of wizards,"class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        strength = [0] + strength + [0]
        def calc_prefix_sum(array):
            if not array: return []
            result = [array[0]]
            for el in array[1:]:
                result.append(array[-1]+el)
            return result
        prefix_sums = calc_prefix_sum(strength)
        pp_sums = calc_prefix_sum(prefix_sums)
        stack = [0]
        total = 0
        for right in range(len(strength)):
            while pp_sums[stack[-1]] > pp_sums[right]:
                left = stack[-2]
                i = stack.pop()
                pos = (i - left) * (pp_sums[right] - pp_sums[i])
                neg = (right - i) * (pp_sums[i] - pp_sums[left])
                total += pp_sums[i] * (pos - neg)
                stack.push(right)
        return total % (10**9+7)
    def totalStrength(self, strength):
        res, S, A = 0, [0], [0] + strength + [0]                           # O(N)
        P = list(itertools.accumulate(itertools.accumulate(A), initial=0)) # O(N)
        for r in range(len(A)):                                            # O(N)
            while A[S[-1]] > A[r]:                                         # O(1) amortized
                l, i = S[-2], S.pop()
                res += A[i] * ((i - l) * (P[r] - P[i]) - (r - i) * (P[i] - P[l]))
            S.append(r)
        return res % (10 ** 9 + 7)"
sum of total strength of wizards,"class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        ans = 0 
        stack = []
        prefix = list(accumulate(accumulate(strength), initial=0))
        for i, x in enumerate(strength + [0]): 
            while stack and stack[-1][1] >= x: 
                mid = stack.pop()[0]
                lo = stack[-1][0] if stack else -1 
                left = prefix[mid] - prefix[max(lo, 0)]
                right = prefix[i] - prefix[mid]
                ans = (ans + strength[mid]*(right*(mid-lo) - left*(i-mid))) % 1_000_000_007
            stack.append((i, x))
        return ans"
check if number has equal digit count and digit value,"class Solution:
    def digitCount(self, num: str) -> bool:
        counter=Counter(num)
        for i in range(len(num)):
            if counter[f'{i}'] != int(num[i]):
                return False
        return True"
check if number has equal digit count and digit value,"class Solution:
    def digitCount(self, num: str) -> bool:
        n=len(num)
        
        for i in range(n):
            if(num.count(str(i))!=int(num[i])):
                return False
            
        return True"
sender with largest word count,"class Solution:
    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
        d={}
        l=[]
        for i in range(len(messages)):
            if senders[i] not in d:
                d[senders[i]]=len(messages[i].split())
            else:
                d[senders[i]]+=len(messages[i].split())
        x=max(d.values())
        for k,v in d.items():
            if v==x :
                l.append(k)
        if len(l)==1:
            return l[0]
        else:
            l=sorted(l)[::-1]      #Lexigograhical sorting of list
            return l[0]"
sender with largest word count,"class Solution:
    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
        words_count = defaultdict(int)
        for m, person in zip(messages, senders):
            words_count[person] += len(m.split())
                
        max_len = max(words_count.values())
        
        names = sorted([name for name, words in words_count.items() if words == max_len], reverse=True)
        return names[0]"
maximum total importance of roads,"class Solution:
    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        Arr = [0] * n  # i-th city has Arr[i] roads
        for A,B in roads:
            Arr[A] += 1 # Each road increase the road count
            Arr[B] += 1
        Arr.sort()  # Cities with most road should receive the most score
        summ = 0
        for i in range(len(Arr)):
            summ += Arr[i] * (i+1)  # Multiply city roads with corresponding score
        
        return summ"
maximum total importance of roads,"class Solution:
    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        
        '''The main idea is to count the frequency of the cities connected to roads and then 
           keep on assigning the integer value from one to n to each cities after sorting it. '''
        
        f = [0 for _ in range(n)]   # for storing the frequency of each city connected to pathways
        
        for x, y in roads:
            f[x] += 1
            f[y] += 1
        
        f.sort()
        s = 0
        for i in range(len(f)):
            s += f[i] * (i+1)  # assigning and storing the integer value to each cities frequency in ascending order
        return s"
rearrange characters to make target string,"class Solution:
    def rearrangeCharacters(self, s: str, target: str) -> int:
        counter_s = Counter(s)        
        return min(counter_s[c] // count for c,count in Counter(target).items())"
rearrange characters to make target string,"class Solution:
    def rearrangeCharacters(self, s: str, target: str) -> int:
        cnt, cnt1 = Counter(s), Counter(target)
        return min(cnt[ch] // cnt1[ch] for ch in cnt1.keys())"
apply discount to prices,"class Solution:
    def discountPrices(self, sentence: str, discount: int) -> str:
        s = sentence.split() # convert to List to easily update
        m = discount / 100 
        for i,word in enumerate(s):
            if word[0] == ""$"" and word[1:].isdigit(): # Check whether it is in correct format
                num = int(word[1:]) * (1-m) # discounted price
                w = ""$"" + ""{:.2f}"".format(num) #correctly format
                s[i] = w #Change inside the list
        
        return "" "".join(s) #Combine the updated list
		```"
apply discount to prices,"class Solution:
    def discountPrices(self, s: str, d: int) -> str:
            return ' '.join((f""${(int(w[1:])*(1-(d/100))):.2f}"" if w.startswith('$') and w[1:].isnumeric() else w for w in s.split()))"
steps to make array non decreasing,"class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        n = len(nums)
        l = [i-1 for i in range(n)]
        r = [i+1 for i in range(n)]
        q = []
        dist = dict()
        ans = 0
        for i in range(1, n):
            if nums[i] < nums[i-1]:
                q.append(i)
                dist[i] = 1
                ans = 1
        while len(q) != 0:
            u = q.pop(0)
            ans = max(ans, dist[u])
            if r[u] < n:
                l[r[u]] = l[u]
            if l[u] > -1:
                r[l[u]] = r[u]
            if r[u] not in dist and r[u] < n and nums[r[u]] < nums[l[u]]:
                dist[r[u]] = dist[u] + 1
                q.append(r[u])
        return ans"
steps to make array non decreasing,"class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        n=len(nums)
        dp=[0]*n
        stack=[]
        for i in range(n-1,-1,-1):
            while stack and nums[i]>nums[stack[-1]]:
                dp[i]=max(dp[i]+1,dp[stack[-1]])
                stack.pop()
            stack.append(i)
        return max(dp)"
minimum obstacle removal to reach corner,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dist = [[inf]*n for _ in range(m)]
        dist[0][0] = 0
        pq = [(0, 0, 0)]
        while pq: 
            x, i, j = heappop(pq)
            if i == m-1 and j == n-1: return x
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 <= ii < m and 0 <= jj < n and x + grid[ii][jj] < dist[ii][jj]: 
                    dist[ii][jj] = x + grid[ii][jj]
                    heappush(pq, (dist[ii][jj], ii, jj))"
minimum obstacle removal to reach corner,"class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        if grid[0][0] == 0:
            q = [(0, 0, 0)]
        else:
            q = [(0, 0, 1)]
        visit = set()
        
        while q:
            cost, x, y = q.pop(0)
            #print(x, y, cost)
            if x == m-1 and y == n-1:
                return cost
            if x > 0 and (x-1, y) not in visit:
                visit.add((x-1, y))
                if grid[x-1][y] == 0:
                    q.insert(0, (cost, x-1, y))
                else:
                    q.append((cost+1, x-1, y))
            if y > 0 and (x, y-1) not in visit:
                visit.add((x, y-1))
                if grid[x][y-1] == 0:
                    q.insert(0, (cost, x, y-1))
                else:
                    q.append((cost+1, x, y-1))
            if x < m-1 and (x+1, y) not in visit:
                visit.add((x+1, y))
                if grid[x+1][y] == 0:
                    q.insert(0, (cost, x+1, y))
                else:
                    q.append((cost+1, x+1, y))
            if y < n-1 and (x, y+1) not in visit:
                visit.add((x, y+1))
                if grid[x][y+1] == 0:
                    q.insert(0, (cost, x, y+1))
                else:
                    q.append((cost+1, x, y+1))"
min max game,"class Solution:
    def minMaxGame(self, nums: List[int]) -> int:                
        l=nums
        while len(l)>1:
            is_min=True     
            tmp=[]
            for i in range(0, len(l), 2):
                if is_min:
                    tmp.append(min(l[i:i+2]))
                else:
                    tmp.append(max(l[i:i+2]))
                is_min=not is_min            
            l=tmp            
        return l[0]"
min max game,"class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        n=len(nums)
        
        newNums=[]*n
        while(n!=1):
            n=n//2
            newNums=[]*n
            for i in range(n):
                if i%2==0:
                    newNums.append(min(nums[2 * i], nums[2 * i + 1]))
                else:
                    newNums.append(max(nums[2 * i], nums[2 * i + 1]))
            nums=newNums
        return nums[0]"
partition array such that maximum difference is k,"class Solution:
    def partitionArray(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = 1
		# To keep track of starting element of each subsequence
        start = nums[0]
        
        for i in range(1, len(nums)):
            diff = nums[i] - start
            if diff > k:
				# If difference of starting and current element of subsequence is greater
				# than K, then only start new subsequence
                ans += 1
                start = nums[i]
        
        return ans"
partition array such that maximum difference is k,"class Solution:
    def partitionArray(self, nums: List[int], k: int) -> int:
        nums.sort()
        res=1
        minm=nums[0]
        maxm=nums[0]
        for x in nums:
            if abs(x-minm)>k or abs(x-maxm)>k:
                res+=1
                minm=x
                maxm=x
            else:
                minm=min(minm,x)
                maxm=max(maxm,x)
        return res"
replace elements in an array,"class Solution:
    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
            replacements = {}
            for x, y in reversed(operations):
                replacements[x] = replacements.get(y, y)
            for idx, val in enumerate(nums):
                if val in replacements:
                    nums[idx] = replacements[val]
            return nums"
replace elements in an array,"class Solution:
    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
        d = {} 
        for i,num in enumerate(nums):
            d[num] = i #Save index of all elements in dictionary for O(1) lookup
        
        for x,r in operations:
            where = d[x] # Find location of operation from dictionary
            nums[where] = r # Complete the operation (Change number)
            del d[x]   # Update dictionary
            d[r] = where # Update dictionary
            
        return nums"
strong password checker ii,"class Solution:
    def strongPasswordCheckerII(self, pwd: str) -> bool:
        return (
            len(pwd) > 7
            and max(len(list(p[1])) for p in groupby(pwd)) == 1
            and reduce(
                lambda a, b: a | (1 if b.isdigit() else 2 if b.islower() else 4 if b.isupper() else 8), pwd, 0
            ) == 15
        )"
strong password checker ii,"class Solution:
    def strongPasswordCheckerII(self, password):
        return re.match(r'^(?!.*(.)\1)(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&amp;*()+-]).{8,}$', password)"
successful pairs of spells and potions,"class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        ans, n = [], len(potions)
        for spell in spells:
            val = success // spell
            if success % spell == 0:
                idx = bisect.bisect_left(potions, val)
            else:    
                idx = bisect.bisect_right(potions, val)
            ans.append(n - idx)
        return ans"
successful pairs of spells and potions,"class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        N = len(potions)
        return [N - bisect_left(potions, success / x) for x in spells]"
match substring after replacement,"class Solution:
    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
        s_maps = defaultdict(lambda : set())
        for x,y in mappings:
            s_maps[x].add(y)
                
        # build a sequence of set for substring match
        # eg: sub=leet, mappings = {e: 3, t:7}
        # subs = [{l}, {e, 3}, {e, 3}, {t, 7}]
        # precalculation helps to eliminate TLE
        subs = [s_maps[c] | {c} for c in sub] 
        
        for i in range(len(s)-len(sub) + 1):
            c=s[i]            
            j=i
            # Try to match substring
            while j-i<len(sub) and s[j] in subs[j-i]:                                        
                j+=1
            if j-i==len(sub): # a valid match if iterated through the whole length of substring
                return True
    
        return False"
match substring after replacement,"class Solution:
    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
        dic = {}
        for m in mappings:
            if m[0] not in dic:
                dic[m[0]] = {m[1]}
            else:
                dic[m[0]].add(m[1])
        
        for i in range(len(s)-len(sub)+1):
            j = 0
            while j < len(sub) and (s[i+j] == sub[j] or 
                                    (sub[j] in dic and s[i+j] in dic[sub[j]])):
                j += 1

            if j == len(sub): return True
        
        return False
    
# Time: O(len(s) * len(sub))
# Space: O(len(mapping))"
count subarrays with score less than k,"class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        sum, res, j = 0, 0, 0
        for i, n in enumerate(nums):
            sum += n
            while sum * (i - j + 1) >= k:
                sum -= nums[j]
                j += 1
            res += i - j + 1
        return res"
count subarrays with score less than k,"class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        nums += [k]
        slow = cur = ans = 0
        for i, num in enumerate(nums):
            cur += num
            while cur * (i - slow + 1) >= k:
                ans += i - slow 
                cur -= nums[slow]
                slow += 1
        return ans"
calculate amount paid in taxes,"class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        ans = prev = 0 
        for hi, pct in brackets: 
            hi = min(hi, income)
            ans += (hi - prev)*pct/100
            prev = hi 
        return ans"
calculate amount paid in taxes,"class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        brackets.sort(key=lambda x: x[0])
        res = 0 # Total Tax 
        prev = 0 # Prev Bracket Upperbound
        for u, p in brackets:
            if income >= u: # 
                res += ((u-prev) * p) / 100
                prev = u
            else:
                res += ((income-prev) * p) / 100
                break # As total income has been taxed at this point.
        return res"
minimum path cost in a grid,"class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        max_row, max_col = len(grid), len(grid[0])
        dp = [[-1] * max_col for _ in range(max_row)] 

        def recursion(row, col):
            if row == max_row - 1: # If last row then return nodes value
                return grid[row][col]
            if dp[row][col] == -1: # If DP for this node is not computed then we will do so now.
                current = grid[row][col] # Current Node Value
                res = float('inf') # To store best path from Current Node
                for c in range(max_col): # Traverse all path from Current Node
                    val = moveCost[current][c] + recursion(row + 1, c) # Move cost + Target Node Value
                    res = min(res, val)
                dp[row][col] = res + current # DP[current node] = Best Path + Target Node Val + Current Node Val
            return dp[row][col]

        for c in range(max_col):
            recursion(0, c) # Start recursion from all nodes in 1st row
        return min(dp[0]) # Return min value from 1st row"
minimum path cost in a grid,"class Solution:
    def minPathCost(self, grid: list[list[int]], moveCost: list[list[int]]) -> int:

        @lru_cache()
        def helper(i, j):
            if i >= len(grid) - 1:
                return grid[i][j]
            
            m_cost = 9999999999
            cost = 0

            for k in range(len(grid[0])):
                cost = grid[i][j] + moveCost[grid[i][j]][k] + helper(i + 1, k)
                m_cost = min(cost, m_cost)

            return m_cost

        cost, min_cost = 0, 999999999999
        n = len(grid[0])
        for j in range(n):
            cost = helper(0, j)
            min_cost = min(cost, min_cost)

        return min_cost"
fair distribution of cookies,"class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        l = [0]*k 
        self.s = float('inf')
        def ser(l,i):
            if i>=len(cookies):
                self.s = min(self.s,max(l))
                return 
            if max(l)>=self.s:
                return 
            for j in range(k):
                l[j]+=cookies[i]
                ser(l,i+1)
                l[j]-=cookies[i]
        
        ser(l,0)
        return self.s"
fair distribution of cookies,"class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        result = float('inf')
        children = [0] * k
        
        def backtrack(index):
            nonlocal result, children
            
            if index == len(cookies):
                result = min(result, max(children))
                return
				
			# key point to pass the TLE!
            if result <= max(children):
                return
            
            for i in range(k):
                children[i] += cookies[index]
                backtrack(index + 1)
                children[i] -= cookies[index]
                
        backtrack(0)
        
        return result"
naming a company,"class Solution:
    def distinctNames(self, ideas: List[str]) -> int:
        
        names=defaultdict(set)
        res=0  
        
        #to store first letter as key and followed suffix as val
        for i in ideas:
            names[i[0]].add(i[1:])
            
        #list of distinct first-letters available in ideas (may or may not contain all alphabets,depends upon elements in ideas)
        arr=list(names.keys())
        ans,n=0,len(arr)
        
        for i in range(n):
            for j in range(i+1,n):
                #a,b => 2 distinct first letters
                a,b=arr[i],arr[j]
                # adding the number of distinct posssible suffixes and multiplying by 2 as the new word formed might be ""newword1 newword2"" or ""newword2 newword1""
                res+=len(names[a]-names[b])*len(names[b]-names[a])*2
                
        return res"
naming a company,"class Solution:         # Suppose, as an example, 
                        #          ideas = [azz, byy, cxx, cww, bww, avv].

                        # Here's the plan:
                        #  
                        #   We construct a dict with each initial as the key and the set of 
                        #    suffixes accompanying that initial. For our example:
                        #           dct = {a:[zz,vv], b:[yy,ww], c:[xx,ww]}
                        #  
                        #   Next, for each pair of initials we figure out the number of vaiid 
                        #    names (we will worry about doubling the # of pairs at the end).
                        #    
                        #    For the pair a, b we get:
                        #        a, b -> ayy &amp; bzz, ayy &amp; bvv, aww &amp; bzz, aww &amp; bvv,
                        #    which is (2 ""a"" suffixes) x (2 ""b"" suffixes) = 4. 
                        #    
                        #    Continuing:
                        #        a, c -> axx &amp; czz, axx &amp; cvv, aww &amp; czz, aww &amp; cvv.
                        #    again, 2x2 = 4

                        #    However, the remaining pair:
                        #        b, c -> bxx &amp; cyy, {bxx &amp; cww, bww &amp; cyy, bww &amp; cww.} has
                        #    only one valid answer. The pairs in the {} are invalid. The reason 
                        #    is that ww is in both suffixes. When we remove that common suffix
                        #    from both sets, we have 1x1 = 1.
                        #
                        #   Finally, we determine the answer to return. The # of overall valid 
                        #    pairs from above is 4 + 4 + 1 = 9. Each valid pair can be reversed 
                        #    to give another. We return the answer 2 x 9 = 18.
                            
    def distinctNames(self, ideas: List[str]) -> int:
        dct, ans = defaultdict(set), 0

        for idea in ideas:                  # <-- construct the dict w/ initial:{suffixes}
            dct[idea[0]].add(idea[1:])      #     and sort the items to get a list of tuples to
        d = sorted(dct.items())             #     help do the counting

        for init1, suff1 in d:              # <-- evaluate the number for each pair of initials
            for init2, suff2 in d:
                if init2 >= init1: break
                c = len(suff1&amp;suff2)                     # <-- determine the # of suffixes in 
                ans += (len(suff1)-c) * (len(suff2)-c)   #     common, and subtract that number from
                                                         #     the each suffix # before multiplying.

        return ans * 2                      # <-- finally, return the sum times 2."
greatest english letter in upper and lower case,"class Solution:
    def greatestLetter(self, s: str) -> str:
        cnt = Counter(s)
        return next((u for u in reversed(ascii_uppercase) if cnt[u] and cnt[u.lower()]), """")"
greatest english letter in upper and lower case,"class Solution:
    def greatestLetter(self, s: str) -> str:
        s = set(s)
        upper, lower = ord('Z'), ord('z')
        for i in range(26):
            if chr(upper - i) in s and chr(lower - i) in s:
                return chr(upper - i)
        return ''"
sum of numbers with units digit k,"class Solution:
    def minimumNumbers(self, num: int, k: int) -> int:
        
        if num == 0:
            return 0
        
        if num < k:
            return -1
        
        if num == k:
            return 1
        
        ans = -1
        i = 1

        while i <= 10:
            if (num - i * k) % 10 == 0 and i * k <= num:
                return i
            i += 1

        return ans"
sum of numbers with units digit k,"class Solution:
    def minimumNumbers(self, num: int, k: int) -> int:
        if k%2 == 0 and num%2 != 0:
            return -1
        if num == 0:
            return 0
        elif k == 0 and num%10 == 0:
            return 1
        elif k == 0:
            return -1
        i = 1
        while True:
            if i*k > num:
                return -1
            if (i*k)%10 == num%10:
                return i
            i += 1"
longest binary subsequence less than or equal to k,"class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        n = len(s)
        ones = []
		# Notice how I reversed the string,
		# because the binary representation is written from greatest value of 2**n
        for i, val in enumerate(s[::-1]):
            if val == '1':
                ones.append(i)
		# Initialize ans, there are already number of zeroes (num_of_zeroes = len(nums) - len(ones)
        ans = n - len(ones)
        i = 0
		# imagine k == 5 and binary string 001011
		# ones = [0, 1, 3]
		# first loop: 5 - 2**0 -> 4, ans += 1
		# second loop: 4 - 2**1 -> 2, ans +=1
		# Third loop does not occur because 2 - 2**3 -> -6 which is less than zero
		# So the ans is 3 + 2 = 5
        while i < len(ones) and k - 2 ** ones[i] >= 0:
            ans += 1
            k -= 2 ** ones[i]
            i += 1
	
        return ans"
longest binary subsequence less than or equal to k,"class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        
        ans = 0
        n = len(s)
        
        if k > int(s, 2):
            return n
        
        for i in range(n):
            if int(s[n - 1 - i:], 2) > k:
                curr = i
                break
                
        if i == n - 1:
            return n

        ans = i + s[:n - i].count(""0"")
        
        return ans"
selling pieces of wood,"class Solution:
    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
        dp = [[0]*(n+1) for _ in range(m+1)]
        for h, w, p in prices:
            dp[h][w] = p
        for i in range(1, m+1):
            for j in range(1, n+1):
                v = max(dp[k][j] + dp[i - k][j] for k in range(1, i // 2 + 1)) if i > 1 else 0
                h = max(dp[i][k] + dp[i][j - k] for k in range(1, j // 2 + 1)) if j > 1 else 0
                dp[i][j] = max(dp[i][j], v, h)
        return dp[m][n]"
selling pieces of wood,"class Solution:
    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
        mp = {(h, w) : p for h, w, p in prices}
        
        @cache
        def fn(m, n): 
            """"""Return max money of a mxn piece of wood.""""""
            if m == 0 or n == 0: return 0
            ans = 0 
            if (m, n) in mp: ans = mp[m, n]
            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))
            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))
            return ans 
        
        return fn(m, n)"
count asterisks,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(1)
	""""""

	def countAsterisks(self, s: str) -> int:
		is_closed = True
		count = 0

		for c in s:
			count += is_closed * c == '*'
			is_closed ^= c == '|'

		return count


class Solution:
	""""""
	Time:   O(n)
	Memory: O(n)
	""""""

	def countAsterisks(self, s: str) -> int:
		return sum(chunk.count('*') for chunk in s.split('|')[0::2])"
count asterisks,"class Solution:
#     O(n) || O(1)
# Runtime: 47ms 64.61% || Memory: 13.7mb 97.39%
    def countAsterisks(self, string: str) -> int:
        if not string:
            return 0

        isBetweenBar = False

        asteriskCount = 0

        for char in string:
            if char == '|' and not isBetweenBar:
                isBetweenBar = True

            elif char == '|' and isBetweenBar:
                isBetweenBar = False

            if not isBetweenBar and char == '*':
                asteriskCount += 1

        return asteriskCount"
count unreachable pairs of nodes in an undirected graph,"class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        def dfs(graph,node,visited):
            visited.add(node)
            self.c += 1
            for child in graph[node]:
                if child not in visited:
                    dfs(graph, child, visited)
        
        #build graph
        graph = {}
        for i in range(n):
            graph[i] = []
            
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        visited = set()
        count = 0
        totalNodes = 0
        
        #run dfs in unvisited nodes
        for i in range(n):
            if i not in visited:
                self.c = 0
                dfs(graph, i, visited)
                
                count += totalNodes*self.c    # result 
                totalNodes += self.c          # total nodes visited 
        return count"
count unreachable pairs of nodes in an undirected graph,"class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        
        class dsu:
            def __init__(self,n):
                self.parent=[i for i in range(n)]
                self.size=[1]*n

            def find(self,x):
                if x!=self.parent[x]:self.parent[x]=self.find(self.parent[x])
                return self.parent[x]
            def union(self,u,v):
                u,v=self.find(u),self.find(v)
                if u!=v:
                    if self.size[u]<self.size[v]:
                        u,v=v,u
                    self.size[u]+=self.size[v]
                    self.size[v]=0
                    self.parent[v]=u
            def cout(self):
                mp=defaultdict(int)
                for i in range(n):
                    mp[self.find(i)]+=1
                return mp
        d=dsu(n)
        for u,v in edges:
            if d.find(u)!=d.find(v):
                d.union(u,v)
        mp=d.cout()
        ans=0
        for i in mp:
            ans+=(mp[i]*(n-mp[i]))
        return ans//2"
maximum xor after operations,"class Solution:
   def maximumXOR(self, nums: List[int]) -> int:
       return reduce(lambda x,y: x|y, nums)

class Solution:
   def maximumXOR(self, nums: List[int]) -> int:
       return reduce(or_, nums)

class Solution:
   def maximumXOR(self, nums: List[int]) -> int:
       
       ans = 0
       for n in nums:
           ans |= n      
       return ans"
maximum xor after operations,"class Solution:
    def maximumXOR(self, nums: List[int]) -> int:
        return reduce(or_, nums)"
number of distinct roll sequences,"class Solution:
    def distinctSequences(self, n: int) -> int:
        
        @lru_cache
        def fn(n, p0, p1): 
            """"""Return total number of distinct sequences.""""""
            if n == 0: return 1
            ans = 0
            for x in range(1, 7): 
                if x not in (p0, p1) and gcd(x, p0) == 1: ans += fn(n-1, x, p0)
            return ans % 1_000_000_007
        
        return fn(n, -1, -1)"
number of distinct roll sequences,"class Solution:
    def distinctSequences(self, n: int) -> int:
        mod = 1_000_000_007
        # edge case
        if n == 1: return 6
        # to create possible adjacent pairs
        next_option = {
            1: (2, 3, 4, 5, 6),
            2: (1, 3, 5),
            3: (1, 2, 4, 5),
            4: (1, 3, 5),
            5: (1, 2, 3, 4, 6),
            6: (1, 5)
        }
        # create dictionary where the key is allowed adjacent pairs and the value is list of third elment after the pair
        allowed_third = defaultdict(list)
        for i, j, k in product(list(range(1, 7)), repeat=3):
            if k != i and j in next_option[i] and k in next_option[j]:
                allowed_third[(i, j)] += k,
        # memoize the answers
        @cache
        def get_help(i, j, rem):
            ans = 0
            if rem == 0:
                return 1
            for k in allowed_third[(i, j)]:
                ans += get_help(j, k, rem - 1) % mod
            return ans
        ans = 0
        
        for i, j in allowed_third:
            ans += get_help(i, j, n - 2) % mod
        return ans % mod"
check if matrix is x matrix,"class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        a=0
        j=len(grid)-1
        for i in range(0,len(grid)):
            if grid[i][i]==0 or grid[i][j]==0:
                return False
            else:
                if i!=j:
                    a=grid[i][i]+grid[i][j]
                elif i==j:
                    a=grid[i][i]
            if a!=sum(grid[i]):
                return False
            j-=1
        return True"
check if matrix is x matrix,"class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        for i in range(n):
            for j in range(n):
                if i == j or i + j == n-1:
                    if grid[i][j] == 0:
                        return False
                else:
                    if grid[i][j] != 0:
                        return False
        return True"
count number of ways to place houses,"class Solution:
    def countHousePlacements(self, n: int) -> int:
        pre,ppre = 2,1
        if n==1:
            return 4
        for i in range(1,n):
            temp = pre+ppre 
            ppre = pre 
            pre = temp 
        return ((pre)**2)%((10**9) + 7)"
count number of ways to place houses,"class Solution:
    def countHousePlacements(self, n: int) -> int:
        prev, pprev = 2,1
        for i in range(1,n):
            temp = pprev+prev
            pprev= prev
            prev = temp
        return (prev**2)%(10**9+7)"
maximum score of spliced array,"class Solution:
    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        # create a difference array between nums1 and nums2
        # idea: find two subarray(elements are contiguous) in the diff
        # one is the subarray that have the minimum negative sum
        # another one is the subarray that have the maximum positive sum
        # so there are four candidates for maximum score:
        # 1. original_sum1 
        # 2. original_sum 
        # 3. original_sum1 - min_negative_sum
        # 4. original_sum2 + max_positive_sum
        
        original_sum1 = sum(nums1)
        original_sum2 = sum(nums2)
        diff = [num1 - num2 for num1, num2 in zip(nums1, nums2)]
        min_negative_sum = float('inf')
        max_positive_sum = - float('inf')
        cur_negative_sum = 0
        cur_positive_sum = 0
        
        for val in diff:
            cur_negative_sum += val

            if cur_negative_sum > 0:
                cur_negative_sum = 0
            
            cur_positive_sum += val
            
            if cur_positive_sum < 0:
                cur_positive_sum = 0
                    
            min_negative_sum = min(min_negative_sum, cur_negative_sum)
            max_positive_sum = max(max_positive_sum, cur_positive_sum)

        return max(original_sum1 - min_negative_sum, original_sum2 + max_positive_sum, original_sum2, original_sum1)"
maximum score of spliced array,"class Solution:
    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        diff = [0]*n
        for i in range(n):
            diff[i] = nums1[i]-nums2[i]
        mpos,mneg,pos,neg = 0,0,0,0
        for i in range(n):
            pos += diff[i]
            if pos < 0:
                pos = 0
            neg += diff[i]
            if neg > 0:
                neg = 0
            mpos = max(pos,mpos)
            mneg = min(neg,mneg)
        return max(sum(nums1)-mneg,sum(nums2)+mpos)"
minimum score after removals on a tree,"class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        
        n = len(nums)
        graph = [[] for _ in range(n)]
        for u, v in edges: 
            graph[u].append(v)
            graph[v].append(u)
            
        def fn(u): 
            score[u] = nums[u]
            child[u] = {u}
            for v in graph[u]: 
                if seen[v] == 0: 
                    seen[v] = 1
                    fn(v)
                    score[u] ^= score[v]
                    child[u] |= child[v]
        
        seen = [1] + [0]*(n-1)
        score = [0]*n
        child = [set() for _ in range(n)]
        fn(0)
        
        ans = inf 
        for u in range(1, n): 
            for v in range(u+1, n): 
                if u in child[v]: 
                    uu = score[u]
                    vv = score[v] ^ score[u]
                    xx = score[0] ^ score[v]
                elif v in child[u]: 
                    uu = score[u] ^ score[v]
                    vv = score[v]
                    xx = score[0] ^ score[u]
                else: 
                    uu = score[u]
                    vv = score[v]
                    xx = score[0] ^ score[u] ^ score[v]
                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))
        return ans"
minimum score after removals on a tree,"class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        
        n = len(nums)
        graph = [[] for _ in range(n)]
        for u, v in edges: 
            graph[u].append(v)
            graph[v].append(u)
            
        def fn(u, p): 
            nonlocal t
            score[u] = nums[u]
            tin[u] = (t := t+1) # time to enter
            for v in graph[u]: 
                if v != p: 
                    fn(v, u)
                    score[u] ^= score[v]
            tout[u] = t # time to exit 
        
        t = 0 
        score = [0]*n
        tin = [0]*n 
        tout = [0]*n 
        fn(0, -1)
        
        ans = inf 
        for u in range(1, n): 
            for v in range(u+1, n): 
                if tin[v] <= tin[u] and tout[v] >= tout[u]: # enter earlier &amp; exit later == parent 
                    uu = score[u]
                    vv = score[v] ^ score[u]
                    xx = score[0] ^ score[v]
                elif tin[v] >= tin[u] and tout[v] <= tout[u]: 
                    uu = score[u] ^ score[v]
                    vv = score[v]
                    xx = score[0] ^ score[u]
                else: 
                    uu = score[u]
                    vv = score[v]
                    xx = score[0] ^ score[u] ^ score[v]
                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))
        return ans"
decode the message,"class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        mapping = {' ': ' '}
        i = 0
        res = ''
        letters = 'abcdefghijklmnopqrstuvwxyz'
        
        for char in key:
            if char not in mapping:
                mapping[char] = letters[i]
                i += 1
        
        for char in message:
            res += mapping[char]
                
        return res"
decode the message,"class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        char_map = {' ': ' '}
        
        for char in key:
            if char not in char_map:
                char_map[char] = chr(ord('a') + len(char_map) - 1)
        
        return ''.join([char_map[char] for char in message])"
spiral matrix iv,"class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        
        matrix = [[-1]*n for i in range(m)]
        
        current = head
        direction = 1
        i, j = 0, -1
        
        while current:
            for _ in range(n):
                if current:
                    j += direction
                    matrix[i][j] = current.val
                    current = current.next
                    
            m -= 1
            
            for _ in range(m):
                if current:
                    i += direction
                    matrix[i][j] = current.val
                    current = current.next
            n -= 1
            
            direction *= -1
        
        return matrix"
spiral matrix iv,"class Solution:
    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        lst = []
        while head:
            lst.append(head.val)
            head = head.next
        matrix = [[-1 for _ in range(n)] for _ in range(m)]

        x, y, dx, dy = 0, 0, 1, 0
        for i in range(len(matrix) * len(matrix[0])):
            if i > len(lst) - 1:
                break
            matrix[y][x] = lst[i]

            if not 0 <= x + dx < n:
                dx, dy = -dy, dx
            elif not 0 <= y + dy < m:
                dx, dy = -dy, dx
            elif matrix[y + dy][x + dx] != -1:
                dx, dy = -dy, dx

            x, y = x + dx, y + dy
        return matrix"
number of people aware of a secret,"class Solution:
    def peopleAwareOfSecret(self, n: int, d: int, f: int) -> int:
        dp, md = [1] + [0] * (f - 1), 10**9 + 7
        for i in range(1, n):
            dp[i % f] = (md + dp[(i + f - d) % f] - dp[i % f] + (0 if i == 1 else dp[(i - 1) % f])) % md
        return sum(dp) % md"
number of people aware of a secret,"class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1
        
        for i in range(1, n+1):
            if dp[i] > 0:
                lower = i + delay # 3
                upper = i + forget
                upper_bound = min(upper, n+1)
                for j in range(lower, upper_bound):
                    dp[j] += dp[i]

                if upper <= n:
                    dp[i] = 0
        
        print(dp)
        return sum(dp) % (10**9 + 7)"
number of increasing paths in a grid,"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        dp = {}
        mod = (10 ** 9) + 7

        def dfs(r, c, prev):
            if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] <= prev:
                return 0

            if (r, c) in dp:
                return dp[(r, c)]

            pathLength = 1
            pathLength += (dfs(r + 1, c, grid[r][c]) + dfs(r - 1, c, grid[r][c]) +
                dfs(r, c + 1, grid[r][c]) + dfs(r, c - 1, grid[r][c]))
            dp[(r, c)] = pathLength
            return pathLength
            
        count = 0
        for r in range(rows):
            for c in range(cols):
                count += dfs(r, c, 0)

        return count % mod"
number of increasing paths in a grid,"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        ROWS = len(grid)
        COLS = len(grid[0])
        dir = [[1,0],[0,1],[-1,0],[0,-1]]

        dp = {}

        def dfs(r,c):
            
            if (r,c) in dp:
                return dp[(r,c)]
                
            ans = 1
            for dr,dc in dir:
                if 0<=r+dr<ROWS and 0<=c+dc<COLS and grid[r+dr][c+dc]>grid[r][c]:
                    ans += dfs(r+dr,c+dc)
            
            dp[(r,c)] = ans%1000000007

            return ans%1000000007

        res = 0
        for r in range(ROWS):
            for c in range(COLS):
                res += dfs(r,c)

        return res%1000000007"
evaluate boolean binary tree,"class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
            if root.val==0 or root.val==1:
                return root.val
            if root.val==2:
                return self.evaluateTree(root.left) or self.evaluateTree(root.right)
            if root.val==3:
                return self.evaluateTree(root.left) and self.evaluateTree(root.right)"
evaluate boolean binary tree,"class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if root.left == None:
            return root.val
        if root.val == 2:
            res = self.evaluateTree(root.left)  or self.evaluateTree(root.right)
        else:
            res = self.evaluateTree(root.left)  and self.evaluateTree(root.right)
        return res"
the latest time to catch a bus,"class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        buses.sort()
        passengers.sort()
        
        passenger = 0
        for bus in buses:
            maxed_out = False
            cap = capacity
            
            while passenger < len(passengers) and passengers[passenger] <= bus and cap != 0:
                passenger += 1
                cap -= 1
                
            if cap == 0:
                maxed_out = True
                
        if maxed_out:
            max_seat = passengers[passenger - 1]
        else:
            max_seat = buses[-1]
    
        booked = set(passengers)
        for seat in range(max_seat, 0, -1):
            if seat not in booked:
                return seat"
the latest time to catch a bus,"class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        buses.sort()
        passengers.sort()
        prev = -inf 
        queue = deque()
        prefix = i = j = 0 
        while i < len(buses) or j < len(passengers): 
            if i == len(buses) or j < len(passengers) and passengers[j] <= buses[i]: 
                if j == 0 or passengers[j-1] + 1 < passengers[j]: prev = passengers[j]-1
                prefix += 1
                if prefix and prefix % capacity == 0: queue.append(prev)
                j += 1
            else: 
                if prefix < capacity: 
                    if j == 0 or buses[i] != passengers[j-1]: ans = buses[i]
                    else: ans = prev 
                    prefix = 0 
                elif queue: 
                    ans = queue.popleft()
                    prefix -= capacity 
                i += 1
        return ans"
minimum sum of squared difference,"class Solution:
    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:
        n = len(nums1)
        k = k1+k2 # can combine k's because items can be turned negative
        diffs = sorted((abs(x - y) for x, y in zip(nums1, nums2)))
        
        # First binary search to find our new max for our diffs array
        l, r = 0, max(diffs)
        while l < r:
            mid = (l+r)//2
            
            # steps needed to reduce all nums greater than newMax
            steps = sum(max(0, num-mid) for num in diffs)
            
            if steps <= k:
                r = mid
            else:
                l = mid+1
                
        newMax = l
        k -= sum(max(0, num-newMax) for num in diffs) # remove used k

        # Second binary search to find first index to replace with max val
        l, r = 0, n-1
        while l < r:
            mid = (l+r)//2
            if diffs[mid] < newMax:
                l = mid+1
            else:
                r = mid

        # Replace items at index >= l with newMax
        diffs = diffs[:l]+[newMax]*(n-l)
        
        # Use remaining steps to reduce overall score
        for i in range(len(diffs)-1,-1,-1):
            if k == 0 or diffs[i] == 0: break
            diffs[i] -= 1
            k -= 1
            
        return sum(diff*diff for diff in diffs)"
minimum sum of squared difference,"class Solution:
    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:
        
        differences = [ abs(x - y) for x, y in zip(nums1, nums2)]
        
        if sum(differences) <= k1 + k2:
            return 0
        
        if k1 + k2 == 0:
            return sum([x**2 for x in differences])
        
        diff = defaultdict(int)
        for num in differences:
            diff[num] += 1
        
        total = k1 + k2
        maxK = max(diff.keys())
        for k in range(maxK, 0, -1):
            if diff[k] > 0:
                temp = min(total, diff[k])
                diff[k] -= temp
                diff[k - 1] += temp
                total-= temp
        
        res = 0

        for k, v in diff.items():
            res += (v * (k **2))
        
        return res"
subarray with elements greater than varying threshold,"class Solution:
    def validSubarraySize(self, nums: List[int], threshold: int) -> int:
                            # Stack elements are the array's indices idx, and montonic with respect to nums[idx].
                            # When the index of the nearest smaller value to nums[idx] comes to the top of the 
                            # stack, we check whether the threshold criterion is satisfied. If so, we are done.
                            #  If not, we continue. Return -1 if we reach the end of nums without a winner.
							
        nums.append(0)
        stack = deque()

        for idx in range(len(nums)):

            while stack and nums[idx] <= nums[stack[-1]]:           
                n = nums[stack.pop()]                               # n is the next smaller value for nums[idx]
                k = idx if not stack else idx - stack[-1] -1        
                if n > threshold //k: return k                      # threshold criterion. if n passes, all
                                                                    # elements of the interval pass
            stack.append(idx)

        return -1"
subarray with elements greater than varying threshold,"class Solution:
    def validSubarraySize(self, nums: List[int], threshold: int) -> int:
        stack = []
        for hi, x in enumerate(nums + [0]): 
            while stack and stack[-1][1] > x: 
                val = stack.pop()[1]
                lo = stack[-1][0] if stack else -1 
                if val > threshold // (hi - lo - 1): return hi - lo - 1
            stack.append((hi, x))
        return -1"
minimum amount of time to fill cups,"class Solution:
    def fillCups(self, amount: List[int]) -> int:
        pq = [-q for q in amount if q != 0]
        heapq.heapify(pq)
        ret = 0
        
        while len(pq) > 1:
            first = heapq.heappop(pq)
            second = heapq.heappop(pq)
            first += 1
            second += 1
            ret += 1
            if first:
                heapq.heappush(pq, first)
            if second:
                heapq.heappush(pq, second)

        if pq:
            return ret - pq[0]
        else:
            return ret"
minimum amount of time to fill cups,"class Solution:
                                    # Because only one of any type can be filled per second,
                                    # the min cannot be less than the max(amount)-- see Ex 1.

                                    # The min also cannot be less than ceil(sum(amount)/2)--see Ex 2.
                                    
                                    # The min cannot be greater than both of these two
                                    # quantities, so... tada

    def fillCups(self, amount: List[int]) -> int:
        return max(max(amount), ceil(sum(amount)/2))"
move pieces to obtain a string,"class Solution:
                    # Criteria for a valid transormation:

                    #   1) The # of Ls, # of Rs , and # of _s must be equal between the two strings
                    #
                    #   2) The ordering of Ls and Rs in the two strings must be the same.
                    #
                    #   3) Ls can only move left and Rs can only move right, so each L in start 
                    #      cannot be to the left of its corresponding L in target, and each R cannot
                    #      be to the right of its corresponding R in target.

    def canChange(self, start: str, target: str) -> bool:
                                                          
        if (len(start) != len(target) or 
            start.count('_') != target.count('_')): return False   #  <-- Criterion 1

        s = [(ch,i) for i, ch in enumerate(start ) if ch != '_']
        t = [(ch,i) for i, ch in enumerate(target) if ch != '_']

        for i in range(len(s)):
            (sc, si), (tc,ti) = s[i], t[i]
            if sc != tc: return False                              # <-- Criteria 1 &amp; 2
            if sc == 'L' and si < ti: return False                 # <-- Criterion 3
            if sc == 'R' and si > ti: return False                 # <--/

        return True                                                # <-- It's a winner!"
move pieces to obtain a string,"class Solution:
    def canChange(self, s: str, e: str) -> bool:
        dl = dr = 0 
        for ss, ee in zip(s, e): 
            if dl > 0 or dl < 0 and ss == 'R' or dr < 0 or dr > 0 and ss == 'L': return False 
            dl += int(ss == 'L') - int(ee == 'L')
            dr += int(ss == 'R') - int(ee == 'R')
        return dl == dr == 0"
count the number of ideal arrays,"class Solution:
    def idealArrays(self, n: int, maxValue: int) -> int:
        ans = maxValue
        freq = {x : 1 for x in range(1, maxValue+1)}
        for k in range(1, n): 
            temp = Counter()
            for x in freq: 
                for m in range(2, maxValue//x+1): 
                    ans += comb(n-1, k)*freq[x]
                    temp[m*x] += freq[x]
            freq = temp
            ans %= 1_000_000_007
        return ans"
count the number of ideal arrays,"class Solution:
    def idealArrays(self, n: int, maxValue: int) -> int:
        MOD = 10 ** 9 + 7
        ans = maxValue
        freq = {x: 1 for x in range(1, maxValue + 1)}
        for k in range(1, n):
            if not freq:
                break
            nxt = collections.defaultdict(int)
            for x in freq:
                for m in range(2, maxValue // x + 1):
                    ans += math.comb(n - 1, k) * freq[x]
                    nxt[m * x] += freq[x]
            freq = nxt
            ans %= MOD
        return ans"
maximum number of pairs in array,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(n)
	""""""

	def numberOfPairs(self, nums: List[int]) -> List[int]:
		pairs = sum(cnt // 2 for cnt in Counter(nums).values())
		return [pairs, len(nums) - 2 * pairs]"
maximum number of pairs in array,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(n)
	""""""

	def numberOfPairs(self, nums: List[int]) -> List[int]:
		pairs = 0
		single = set()

		for num in nums:
			if num in single:
				single.remove(num)
				pairs += 1
			else:
				single.add(num)

		return [pairs, len(single)]"
max sum of a pair with equal sum of digits,"class Solution:     # The plan here is to:
                    # 
                    #    sort the elements of nums into a dict of maxheaps,
                    #     according to sum-of-digits.
                    #
                    #    For each key, determine whether there are at least two 
                    #     elements in that key's values, and if so, compute the
                    #     product of the greatest two elements.
                    #
                    #    return the the greatest such product as the answer.

                    # For example:
					
                    #     nums = [6,15,13,12,24,21] > {3:[12,21], 4:[13], 6:[6,15,24]}
					
                    #     Only two keys qualify, 3 and 6, for which the greatest two elements
                    #     are 12,21 and 15,24, respectively. 12+21 = 33 and 15+24 = 39,
                    #     so the answer is 39.

    def maximumSum(self, nums: List[int]) -> int:
        d, mx = defaultdict(list), -1
        digits = lambda x: sum(map(int, list(str(x))))      # <-- sum-of-digits function
       
        for n in nums:                                      # <-- construct max-heaps
            heappush(d[digits(n)],-n)                       #     (note ""-n"") 

        for i in d:                                         # <-- pop the two greatest values off
            if len(d[i]) > 1:                               #     each maxheap (when possible) and
                mx= max(mx, -heappop(d[i])-heappop(d[i]))   #     compare with current max value.
                                                           
        return mx"
max sum of a pair with equal sum of digits,"class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        dict_map = {}
        
        res = -1
        for num in nums:
            temp = num
            new_num = 0
            while temp:
                new_num += temp % 10
                temp = temp // 10
            if new_num in dict_map:
                new_res = num + dict_map[new_num]
                res = max(res, new_res)
                dict_map[new_num] = max(num, dict_map[new_num])
            else:
                dict_map[new_num] = num
        return res"
query kth smallest trimmed number,"class Solution:
  def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:
        def countingSort(indices, pos):
            count = [0] * 10
            for idx in indices:
                count[ord(nums[idx][pos]) - ord('0')] += 1
            start_pos = list(accumulate([0] + count, add))
            result = [None] * len(indices)
            for idx in indices:
                digit = ord(nums[idx][pos]) - ord('0')
                result[start_pos[digit]] = idx
                start_pos[digit] += 1
            return result
            
        n = len(nums)
        m = len(nums[0])
        suffix_ordered = [list(range(n))]
        for i in range(m - 1, -1, -1):
            suffix_ordered.append(countingSort(suffix_ordered[-1], i))
        return [suffix_ordered[t][k-1] for k, t in queries]"
query kth smallest trimmed number,"class Solution:
    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:
        a=[]                        #to store answer of queries
        for q in queries: 
            ia=q[0]               #kth smallest value to be returned
            t=q[1]                #trim index
            temp=[]
            for n in nums:
                temp.append(int(n[-1*t:]))                  #using slicing just take last t elements
                
            temp1=[[temp[0],0]]                             #another list that will store sorted elements along with index
            for i in range(1,len(temp)):
                key=temp[i]
                j=len(temp1)-1
                while j>=0 and key<temp1[j][0]:        #using insertion sort, insert elements to new list also store index
                    j-=1
                temp1.insert(j+1,[key,i])
        
            a.append(temp1[ia-1][1])                     #append required index element 
            
        return a"
minimum deletions to make array divisible,"class Solution:
                    # From number theory, we know that an integer num divides each
                    # integer in a list if and only if num divides the list's gcd.
                    # 
                    # Our plan here is to:
                    #    find the gcd of numDivide
                    #    heapify(nums) and count the popped elements that do not
                    #     divide the gcd.
                    #    return that count when and if a popped element eventually
                    #     divides the gcd. If that never happens, return -1 
        
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
	
        g, ans = gcd(*numsDivide), 0            # <-- find gcd (using * operator)

        heapify(nums)                           # <-- create heap

        while nums:                             # <-- pop and count

            if not g%heappop(nums): return ans  # <-- found a divisor? return count
            else: ans+= 1                       # <-- if not, increment the count

        return -1                               # <-- no divisors found
		
#--------------------------------------------------
class Solution:    # version w/o heap. Seems to run slower
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
	
        g = gcd(*numsDivide)
        nums.sort()

        for i,num in enumerate(nums):
            if not g%num: return i

        return -1"
minimum deletions to make array divisible,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        counter = Counter(nums)
        setDivide = set(numsDivide)
        
        result = 0
        minimum = float(""inf"")
        
        for i in sorted(set(nums)):
            flag = True
            for k in setDivide:
                if k % i != 0:
                    flag = False
                    break
            if flag == False:
                result+=counter[i]
            else:
                return result
        
        return -1"
best poker hand,"class Solution:
    def bestHand(self, ranks: List[int], suits: List[str]) -> str:

        dictRanks = {}
        dictSuits = {}
        
        for key in ranks:
            dictRanks[key] = dictRanks.get(key, 0) + 1

        for key in suits:
            dictSuits[key] = dictSuits.get(key, 0) + 1
            
        maxRanks = max(dictRanks.values())
        maxSuits = max(dictSuits.values())
        
        if maxSuits == 5:
            return ""Flush""
        if maxRanks >= 3:
            return ""Three of a Kind""
        if maxRanks >= 2:
            return ""Pair"" 
        return ""High Card"""
best poker hand,"class Solution:
    def bestHand(self, ranks: List[int], suits: List[str]) -> str:
        s={}
        for i in suits:
            if i in s:
                s[i]+=1
                if s[i]==5:
                    return 'Flush'
            else:
                s[i]=1
        r={}
        max_ = 0
        for i in ranks:
            if i in r:
                r[i]+=1
                max_=max(max_,r[i])
            else:
                r[i]=1
        if max_>=3:
            return ""Three of a Kind""
        elif max_==2:
            return ""Pair""
        else:
            return ""High Card"""
number of zero filled subarrays,"class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        
        n = len(nums)

        ans = 0
        i, j = 0, 0
        while i <= n - 1:
            j = 0
            if nums[i] == 0:
                while i + j <= n - 1 and nums[i + j] == 0:
                    j += 1
                ans += (j + 1) * j // 2

            i = i + j + 1
        
        return ans"
number of zero filled subarrays,"class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        return reduce(lambda acc,y: (acc[0],0) if y else (sum(acc)+1,acc[1]+1), nums, (0,0))[0]"
shortest impossible sequence of rolls,"class Solution:
    def shortestSequence(self, rolls: List[int], k: int) -> int:
        ans = 0 
        seen = set()
        for x in rolls: 
            seen.add(x)
            if len(seen) == k: 
                ans += 1
                seen.clear()
        return ans+1"
shortest impossible sequence of rolls,"class Solution:
    def shortestSequence(self, rolls: List[int], k: int) -> int:
        s = set()
        res = 0
        
        for r in rolls:
            s.add(r)
            if len(s) == k:        # All possible number has appeared once.
                res += 1           # So you must ""at least"" use one more place to store it.
                s.clear()          # Clear the set.
        
        
        return res + 1"
first letter to appear twice,"class Solution:
    def repeatedCharacter(self, s: str) -> str:
        
        setS = set()

        for x in s:
            if x in setS:
                return x
            else:
                setS.add(x)"
first letter to appear twice,"class Solution:
#     O(n) || O(1)
# Runtime: 30ms 90.00% || Memory: 13.9mb 10.00%
    def repeatedCharacter(self, string: str) -> str:
        strAlphaFreq = [0] * 26

        for char in string:
            index = ord(char) - ord('a')

            strAlphaFreq[index] += 1

            if strAlphaFreq[index] > 1:
                return char"
equal row and column pairs,"class Solution:                 # Consider this grid for an example:
                                #           grid = [[1,2,1,9]
                                #                   [2,8,9,2]
                                #                   [1,2,1,9]
                                #                   [9,2,6,3]]
    
                                # Here's the plan:

                                #    Determine tpse, the transpose of grid (using zip(*grid)):
                                #           tspe = [[1,2,1,9] 
                                #                   [2,8,2,2]
                                #                   [1,9,1,6]
                                #                   [9,2,9,3]] 
                                #     The problem now is to determine the pairs of 
                                #     identical rows, one row in tpse and the other in grid.

                                #    We hash grid and tspe:
                                #
                                #           Counter(tuple(grid)):
                                #               {(1,2,1,9): 2, (2,8,9,2): 1, (9,2,6,3): 1}
                                #  
                                #           Counter(zip(*grid)):
                                #            {(1,2,1,9): 1, (2,8,2,2): 1, (1,9,1,6): 1, (9,2,9,3): 1}
                                #
                                #    We determine the number of pairs:
                                #       (1,2,1,9): 2 and (1,2,1,9): 1    => 2x1 = 2
                                
    def equalPairs(self, grid: List[List[int]]) -> int:

        tpse = Counter(zip(*grid))                  # <-- determine the transpose
                                                    #     and hash the rows

        grid = Counter(map(tuple,grid))             # <-- hash the rows of grid. (Note the tuple-map, so
                                                    #     we can compare apples w/ apples in next step.)

        return  sum(tpse[t]*grid[t] for t in tpse)  # <-- compute the number of identical pairs
		
		                                            # https://leetcode.com/submissions/detail/755717162/"
equal row and column pairs,"class Solution:
    """"""
    Time:   O(n^3)
    Memory: O(1)
    """"""

    def equalPairs(self, grid: List[List[int]]) -> int:
        n = len(grid)
        pairs = 0

        for i in range(n):
            for j in range(n):
                for k in range(n):
                    if grid[i][k] != grid[k][j]:
                        break
                else:
                    pairs += 1

        return pairs"
number of excellent pairs,"class Solution:
    def countExcellentPairs(self, nums: List[int], k: int) -> int:
        hamming = sorted([self.hammingWeight(num) for num in set(nums)])
        ans = 0
        for h in hamming:
            ans += len(hamming) - bisect.bisect_left(hamming, k - h)
        return ans
        
    def hammingWeight(self, n):
        ans = 0
        while n:
            n &amp;= (n - 1)
            ans += 1
        return ans"
number of excellent pairs,"class Solution:
    def countExcellentPairs(self, nums: List[int], k: int) -> int:
        hamming = sorted([num.bit_count() for num in set(nums)])
        ans = 0
        for h in hamming:
            ans += len(hamming) - bisect.bisect_left(hamming, k - h)
        return ans"
make array zero by subtracting equal amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        return len(set(nums) - {0})"
make array zero by subtracting equal amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        
        n = len(nums)
        
        count = 0
        while nums != [0]*n:
            count += 1
            small = min([i for i in nums if i > 0])
            for i in range(n):
                if nums[i] != 0:
                    nums[i] -= small
        return count"
maximum number of groups entering a competition,"class Solution:
    def maximumGroups(self, grades: List[int]) -> int:
        
        x = len(grades)
        n = 0.5 * ((8 * x + 1) ** 0.5 - 1)
        ans = int(n)
        
        return ans"
maximum number of groups entering a competition,"class Solution:
    def maximumGroups(self, grades: List[int]) -> int:
        
        sortedGrades = sorted(grades)

        groupNums = 0
        total = 0
        while total <= len(sortedGrades):
            groupNums += 1
            total += groupNums
        return groupNums - 1"
find closest node to given two nodes,"class Solution:
	def get_neighbors(self, start: int) -> Dict[int, int]:
		distances = defaultdict(lambda: math.inf)

		queue = deque([start])
		level = 0

		while queue:
			for _ in range(len(queue)):
				curr = queue.popleft()

				if distances[curr] <= level:    
					continue

				distances[curr] = level

				for neighbor in graph[curr]:
					queue.append(neighbor)

			level += 1        

		return distances

    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        n = len(edges)
        graph = [[] for _ in range(n)]
        
        for _from, to in enumerate(edges):
            if to != -1:
                graph[_from].append(to)
        
        a = self.get_neighbors(node1)
        b = self.get_neighbors(node2)
                
        options = []    
        
        for idx in range(n):
            if a[idx] != math.inf and b[idx] != math.inf:
                options.append((max(a[idx], b[idx]), idx))
                
        if not options:
            return -1        
        
        return min(options)[1]"
find closest node to given two nodes,"class Solution:
    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        count,ans=len(edges),float('inf')
        graph=[[] for i in range(count)]
        reach1,reach2={},{}
        vis=set()
        reach1[node1]=0
        reach2[node2]=0
        curr=float('inf')
        for u,v in enumerate(edges):
            if v!=-1:
                graph[u].append(v)
        def dfs(node,reach,dist):
            for it in graph[node]:
                if it not in vis:
                    vis.add(it)
                    reach[it]=dist+1
                    dfs(it,reach,dist+1)
                    vis.remove(it)
            return
        vis.add(node1)
        dfs(node1,reach1,0)
        vis.remove(node1)
        vis.clear()
        vis.add(node2)
        dfs(node2,reach2,0)
        vis.remove(node2)
        for node in reach2:
            if node in reach1:
                if curr>max(reach1[node],reach2[node]):
                    ans=node
                    curr=max(reach1[node],reach2[node])
                elif curr==max(reach1[node],reach2[node]) and node<ans:
                    ans=node
                    curr=max(reach1[node],reach2[node])
        if ans==float('inf'):
            return -1
        else:
            return ans"
longest cycle in a graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        in_d = set()
        out_d = set()
        for i, j in enumerate(edges):
            if j != -1:
                in_d.add(j)
                out_d.add(i)
        potential = in_d &amp; out_d
        visited = set()
        self.ans = -1
        def dfs(node, curr, v):
            visited.add(node)
            v[node] = curr
            nei = edges[node]
            if nei in v:
                self.ans = max(self.ans, curr - v[nei] + 1)
                visited.add(nei)
                return
            if nei not in visited and nei in potential:
                dfs(nei, curr + 1, v)
        for node in potential:
            dfs(node, 1, {})
        return self.ans"
longest cycle in a graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        res, seenSet = -1, set()
        for element in range(len(edges)): #traverses all possible nodes
            count, currNode = 0, element
            cycleMap = dict() #tabulates all distances
            while currNode not in seenSet and currNode != -1:
                count += 1
                seenSet.add(currNode); cycleMap[currNode] = count #adds nodes to the hashmap and the hashset
                currNode = edges[currNode] #moves on to the next node
            res = max(res, count + 1 - cycleMap.get(currNode, 200000)) #gets the max distance 
        return res"
merge similar items,"class Solution:
	def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:

		merge_item = items1 + items2

		d = defaultdict(int)

		for i in merge_item:
			value,weight = i
			d[value] = d[value] + weight

		result = []

		for j in sorted(d):
			result.append([j,d[j]])

		return result"
merge similar items,"class Solution:
    def mergeSimilarItems(self, i1: List[List[int]], i2: List[List[int]]) -> List[List[int]]:
        return sorted((Counter({i[0] : i[1] for i in i1}) + Counter({i[0] : i[1] for i in i2})).items())"
count number of bad pairs,"class Solution:
    def countBadPairs(self, nums: List[int]) -> int:
        nums_len = len(nums)
        count_dict = dict()
        for i in range(nums_len):
            nums[i] -= i
            if nums[i] not in count_dict:
                count_dict[nums[i]] = 0
            count_dict[nums[i]] += 1
        
        count = 0
        for key in count_dict:
            count += math.comb(count_dict[key], 2)
        return math.comb(nums_len, 2) - count"
count number of bad pairs,"class Solution:
    def countBadPairs(self, nums: List[int]) -> int:

        n = len(nums)
        res = []
        for i in range(n):
            res.append(nums[i] - i)

        a = Counter(res)
        ans = n * (n - 1) // 2
        for x in a:
            if a[x] > 1:
                ans -= a[x] * (a[x] - 1) // 2
        
        return ans"
task scheduler ii,"class Solution:
    def taskSchedulerII(self, tasks: List[int], space: int) -> int:
        
        ans = 0
        hashset = {}
        n = len(tasks)
        
        for x in set(tasks):
            hashset[x] = 0
            
        i = 0
        while i <= n - 1:
            flag = ans - hashset[tasks[i]]
            if flag >= 0:
                ans += 1
                hashset[tasks[i]] = ans + space
                i += 1
            else:
                ans += -flag
        
        return ans"
task scheduler ii,"class Solution:
    def taskSchedulerII(self, tasks: List[int], space: int) -> int:
        Dict = {}
        ans,l = 0,len(tasks)
        
        for i,n in enumerate(tasks):
            if n in Dict:
                ans += max(1,space-(ans-Dict[n])+1)
            else:
                ans+=1
            Dict[n] = ans
        return ans"
minimum replacements to sort the array,"class Solution:
    def minimumReplacement(self, nums: List[int]) -> int:
        
        n = len(nums)
        k = nums[n - 1]
        ans = 0
        
        for i in reversed(range(n - 1)):
            if nums[i] > k:
                l =  nums[i] / k
                if l == int(l):
                    ans += int(l) - 1
                    k = nums[i] / int(l)
                else:
                    ans += int(l)
                    k = int(nums[i] / (int(l) + 1))
            else:
                k = nums[i]

        return ans"
minimum replacements to sort the array,"class Solution:
    def minimumReplacement(self, nums: List[int]) -> int:
        ans = 0 
        prev = 1_000_000_001
        for x in reversed(nums): 
            d = ceil(x/prev)
            ans += d-1
            prev = x//d
        return ans"
number of arithmetic triplets,"class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        
        ans = 0
        n = len(nums)
        for i in range(n):
            if nums[i] + diff in nums and nums[i] + 2 * diff in nums:
                ans += 1
        
        return ans"
number of arithmetic triplets,"class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        s = set(nums)
        count = 0
        for num in nums:
            if (num + diff) in s and (num + diff + diff) in s:
                count += 1
        return count"
reachable nodes with restrictions,"class Solution:
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:
        
        restrictedSet = set(restricted)
        uf = UnionFindSet(n)
        for edge in edges:
            if edge[0] in restrictedSet or edge[1] in restrictedSet:
                continue
            else:
                uf.union(edge[0], edge[1])

        ans = 1
        rootNode = uf.find(0)
        for i in range(1, n):
            if uf.find(i) == rootNode:
                ans += 1
        return ans

class UnionFindSet:
    def __init__(self, size):
        self.root = [i for i in range(size)]
        # Use a rank array to record the height of each vertex, i.e., the ""rank"" of each vertex.
        # The initial ""rank"" of each vertex is 1, because each of them is
        # a standalone vertex with no connection to other vertices.
        self.rank = [1] * size

    # The find function here is the same as that in the disjoint set with path compression.
    def find(self, x):
        if x == self.root[x]:
            return x
        self.root[x] = self.find(self.root[x])
        return self.root[x]

    # The union function with union by rank
    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.rank[rootX] > self.rank[rootY]:
                self.root[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.root[rootX] = rootY
            else:
                self.root[rootY] = rootX"
reachable nodes with restrictions,"class Solution:
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:

        #Convert restricted list into restricted set to increase processing speed
        #Create a dictionary of non-restricted nodes 
        #Thus the key is the node and the value is the adjacency set for that node
        resSet = set(restricted)        
        nodes_dict = dict()     
        for x in range(0, n):
            if(x not in resSet):
                nodes_dict[x] = set()

        #Fill adjacency set only with non-restricted nodes
        #We can check for non-restricted nodes by using the keys of the dict
        for pair0, pair1 in edges:
            if(pair0 in nodes_dict and pair1 in nodes_dict):
                nodes_dict[pair0].add(pair1)
                nodes_dict[pair1].add(pair0)

        #We will always start at node 0, so I add 0 to the traversalQueue
        #Add 0 to counting set since we always have 0
        traversalQueue = deque([0])
        count = {0}

        #Utilize set operations
        #Starting at 0 look at 0's adjacency set
        #Use difference operation to find which of 0's neighbors are not visited to add to the traversalQueue
        #####
        #Obviously none of 0's neighbors have been visited but...
        #...for rest of the nodes, you don't want to traverse backwards and get stuck
        #The reason why you will get stuck if you don't do the difference operation is because:
        #The edge comes in pairs. So [0,1] means that 0 will have 1 in its adjacency set. However...
        #...1 will also have 0. If you do not account for this, when you get to node 1 in the dict...
        #...all of 1's neighbors INCLUDING 0 will be added to the traversalQueue. Thus an infinite loop occurs.
        #####
        #Add the neighbors to the traversalQueue
        #Add all neighbors to counting set
        #Remove node from traversalQueue FIFO style. At the start that will obviously be node 0.
        #Repeat until you have traversed all nodes
        while(len(traversalQueue) != 0):
            current = traversalQueue[0]
            diff = nodes_dict[current].difference(count)
            traversalQueue.extend(diff)
            count.update(diff)
            traversalQueue.popleft()

        return len(count)"
check if there is a valid partition for the array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        idxs = defaultdict(list)
        n = len(nums)
        
        #Find all doubles
        for idx in range(1, n):
            if nums[idx] == nums[idx - 1]:
                idxs[idx - 1].append(idx + 1)
                
        #Find all triples
        for idx in range(2, n):
            if nums[idx] == nums[idx - 1] == nums[idx - 2]:
                idxs[idx - 2].append(idx + 1)
                
        #Find all triple increments
        for idx in range(2, n):
            if nums[idx] == nums[idx - 1] + 1 == nums[idx - 2] + 2:
                idxs[idx - 2].append(idx + 1)
        
        #DFS 
        seen = set()
        stack = [0]

        while stack:
            node = stack.pop()

            if node not in seen:
                if node == n:
                    return True
                seen.add(node)

            for adj in idxs[node]:
                if adj not in seen:
                    stack.append(adj)
        
        return False"
check if there is a valid partition for the array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        f3,f2,f1 = False,False,True
        for i,v in enumerate(nums):
            f = f2 and (v==nums[i-1])
            f = f or f3 and (v==nums[i-1]==nums[i-2])
            f = f or f3 and (v==nums[i-1]+1==nums[i-2]+2)
            f3,f2,f1 = f2,f1,f
        return f1"
longest ideal subsequence,"class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        dp = [0] * 26
        for ch in s:
            i = ord(ch) - ord(""a"")
            dp[i] = 1 + max(dp[max(0, i - k) : min(26, i + k + 1)])
        return max(dp)"
longest ideal subsequence,"class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        
        # For storing the largest substring ending at that character 
        psum=[0]*26
        ans=1
        for i in range(len(s)):
            element=ord(s[i])-97
            
            # Checking for k characters left to current element i.e. 2 characters left to c will be 'a' and 'b'  
            
            j=element
            while j>-1 and j>=element-k:
                psum[element]=max(psum[element],psum[j]+1)
                j-=1
                
            # Checking for k characters right to current element i.e. 2 characters left to c will be 'd' and 'e'     
                
            j=element+1
            while j<26 and j<=element+k:
                psum[element]=max(psum[element],psum[j]+1)
                j+=1
                
            ans=max(ans,psum[element])
        return ans"
largest local values in a matrix,"class Solution:
    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        ans = [[0]*(n-2) for _ in range(n-2)]
        for i in range(n-2): 
            for j in range(n-2): 
                ans[i][j] = max(grid[ii][jj] for ii in range(i, i+3) for jj in range(j, j+3))
        return ans"
largest local values in a matrix,"class Solution:
    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:

        n = len(grid)
        ans = []

        for i in range(n - 2):
            res = []

            for j in range(n - 2):
                k = []
                k.append(grid[i][j])
                k.append(grid[i][j + 1])
                k.append(grid[i][j + 2])
                k.append(grid[i + 1][j])
                k.append(grid[i + 1][j + 1])
                k.append(grid[i + 1][j + 2])
                k.append(grid[i + 2][j])
                k.append(grid[i + 2][j + 1])
                k.append(grid[i + 2][j + 2])
                m = max(k)
                res.append(m)

            ans.append(res)
        
        return ans"
node with highest edge score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:

        n = len(edges)
        cnt = defaultdict(int)
        ans = 0
        
		// we have the key stores the node edges[i], and the value indicates the edge score.
        for i in range(n):
            cnt[edges[i]] += i

        m = max(cnt.values())

		// In the second iteration, i is also the index of the node. So the first one meets == m, is the smallest index.
        for i in range(n):
            if cnt[i] == m:
                ans = i
                break
        
        return ans"
node with highest edge score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n = len(edges)
        score = [0] * n
        
        for i, val in enumerate(edges):
            score[val] += i
        return score.index(max(score))"
construct smallest number from di string,"class Solution:
    def smallestNumber(self, pattern: str) -> str:
        ans = [1]
        for ch in pattern: 
            if ch == 'I': 
                m = ans[-1]+1
                while m in ans: m += 1
                ans.append(m)
            else: 
                ans.append(ans[-1])
                for i in range(len(ans)-1, 0, -1): 
                    if ans[i-1] == ans[i]: ans[i-1] += 1
        return ''.join(map(str, ans))"
construct smallest number from di string,"class Solution:
    def smallestNumber(self, pattern: str) -> str:
        ans = []
        stack = []
        for i in range(len(pattern)+1): 
            stack.append(str(i+1))
            if i == len(pattern) or pattern[i] == 'I': 
                while stack: ans.append(stack.pop())
        return ''.join(ans)"
count special integers,"class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        vals = list(map(int, str(n)))
        
        @cache
        def fn(i, m, on): 
            """"""Return count at index i with mask m and profile flag (True/False)""""""
            ans = 0 
            if i == len(vals): return 1
            for v in range(vals[i] if on else 10 ): 
                if m &amp; 1<<v == 0: 
                    if m or v: ans += fn(i+1, m ^ 1<<v, False)
                    else: ans += fn(i+1, m, False)
            if on and m &amp; 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)
            return ans 
        
        return fn(0, 0, True)-1"
minimum recolors to get k consecutive black blocks,"class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        
        ans = 0
        res = 0

        for i in range(len(blocks) - k + 1):
            res = blocks.count('B', i, i + k)
            ans = max(res, ans)

        ans = k - ans
        return ans"
minimum recolors to get k consecutive black blocks,"class Solution:
	""""""
	Time:   O(n)
	Memory: O(k)
	""""""

	def minimumRecolors(self, blocks: str, k: int) -> int:
		min_cost = cost = blocks[:k].count('W')

		for i in range(k, len(blocks)):
			cost = cost - (blocks[i - k] == 'W') + (blocks[i] == 'W')
			min_cost = min(min_cost, cost)

		return min_cost"
time needed to rearrange a binary string,"class Solution: 
    def secondsToRemoveOccurrences(self, s: str) -> int:
        ans = prefix = prev = 0 
        for i, ch in enumerate(s): 
            if ch == '1': 
                ans = max(prev, i - prefix)
                prefix += 1
                if ans: prev = ans+1
        return ans"
time needed to rearrange a binary string,"class Solution:
    def secondsToRemoveOccurrences(self, s: str) -> int:

        ans = 0

        while '01' in s:
            ans += 1
            s = s.replace('01', '10')
            
        return ans"
shifting letters ii,"class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        cum_shifts = [0 for _ in range(len(s)+1)]
        
        for st, end, d in shifts:
            if d == 0:
                cum_shifts[st] -= 1
                cum_shifts[end+1] += 1
            else:
                cum_shifts[st] += 1
                cum_shifts[end+1] -= 1
        
        cum_sum = 0
        for i in range(len(s)):
            cum_sum += cum_shifts[i]
            
            new_code = (((ord(s[i]) + cum_sum) - 97) % 26) + 97
            s = s[:i] + chr(new_code) + s[i+1:]
        
        return s"
shifting letters ii,"class Solution:         # Here's the plan:
                        #   1) 1a: Initiate an array offsets with length len(s)+1. 
                        #      1b: Iterate through shifts and collect the endpts and the direction
                        #          of each shift. (Note that 2*(0)-1 = -1 and 2*(1)-1 = 1.)
                        #      1c: Accumulate the elements in offsets to determine the cummulative
                        #          offset for each char in s
                        # 
                        #   2) 2a: Write the letter index (1-26) of each char of s to a list chNums. 
                        #      2b: Add to each letter index its corresponding offset and determine 
                        #          its new letter index by applying %26.
                        #      2c: Return the result string from chNums. 

    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        n = len(s)

        offsets = [0]*(n+1)                                     # <-- 1a
		
        for start, end, direction in shifts:                    # <-- 1b
            offsets[start]+= 2*direction-1
            offsets[end+1]-= 2*direction-1
			
        offsets = accumulate(offsets)                           # <-- 1c

        chNums = (ord(ch)-97 for ch in s)                       # <-- 2a
		
        chNums = ((chNum + offset)%26 for chNum,                # <-- 2b
                   offset in zip(chNums, offsets))

        return ''.join(chr(chNum+97) for chNum in chNums)       # <-- 2c"
maximum segment sum after removals,"class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        mp, cur, res = {}, 0, []
        for q in reversed(removeQueries[1:]):
            mp[q] = (nums[q], 1)
            rv, rLen = mp.get(q+1, (0, 0))
            lv, lLen = mp.get(q-1, (0, 0))
                
            total = nums[q] + rv + lv
            mp[q+rLen] = (total, lLen + rLen + 1)
            mp[q-lLen] = (total, lLen + rLen + 1)
        
            cur = max(cur, total)
            res.append(cur)
            
        return res[::-1] + [0]"
maximum segment sum after removals,"class Solution: 
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n = len(nums)
        sl = SortedList([-1, n])
        prefix = list(accumulate(nums, initial=0))
        mp = {-1 : n}
        pq = [(-prefix[-1], -1, n)]
        
        ans = []
        for q in removeQueries: 
            sl.add(q)
            i = sl.bisect_left(q)
            lo = sl[i-1]
            hi = sl[i+1]
            mp[lo] = q
            mp[q] = hi 
            heappush(pq, (-(prefix[q]-prefix[lo+1]), lo, q))
            heappush(pq, (-(prefix[hi]-prefix[q+1]), q, hi))
            
            while mp[pq[0][1]] != pq[0][2]: heappop(pq)
            ans.append(-pq[0][0])
        return ans"
minimum hours of training to win a competition,"class Solution:
    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        
        ans = 0
        n = len(energy)

        for i in range(n):
            while initialEnergy <= energy[i] or initialExperience <= experience[i]:
                if initialEnergy <= energy[i]:
                    initialEnergy += 1
                    ans += 1
                if initialExperience <= experience[i]:
                    initialExperience += 1
                    ans += 1
            initialEnergy -= energy[i]
            initialExperience += experience[i]
        
        return ans"
minimum hours of training to win a competition,"class Solution:
    """"""
    Time:   O(n)
    Memory: O(1)
    """"""

    def minNumberOfHours(self, energy: int, experience: int, energies: List[int], experiences: List[int]) -> int:
        hours = 0

        for eng, exp in zip(energies, experiences):
            # Adding the missing amount of energy
            extra_en = max(0, eng - energy + 1)
            energy += extra_en

            # Adding the missing amount of experience
            extra_ex = max(0, exp - experience + 1)
            experience += extra_ex

            energy -= eng
            experience += exp
            hours += extra_en + extra_ex

        return hours"
largest palindromic number,"class Solution:
    def largestPalindromic(self, num: str) -> str:

        ans = []
        b = [str(x) for x in range(9, -1, -1)]
        from collections import defaultdict

        a = defaultdict(int)

        for x in num:
            a[x] += 1

        for x in b:
            n = len(ans)
            if n % 2 == 0:
                if a[x] > 0:
                    ans = ans[:n // 2] + [x] * a[x] + ans[n // 2:]
            else:
                if x == '0':
                    if len(ans) != 1:
                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]
                else:
                    if a[x] >= 2:
                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]

        res = """".join(ans)
        return str(int(res))"
largest palindromic number,"class Solution:
    def largestPalindromic(self, num: str) -> str:
        freq = Counter(num)
        mid = next((ch for ch in ""9876543210"" if freq[ch]&amp;1), '')
        half = ''.join(ch*(freq[ch]//2) for ch in ""0123456789"")
        return (half[::-1] + mid + half).strip('0') or '0'"
amount of time for binary tree to be infected,"class Solution: 		
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        
        stack = [(root, None)]
        while stack: 
            n, p = stack.pop()
            if p: 
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue: 
            for _ in range(len(queue)): 
                u = queue.popleft()
                for v in graph[u]: 
                    if v not in seen: 
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans"
amount of time for binary tree to be infected,"class Solution:
    def amountOfTime(self, root, start: int) -> int:
        time_to_infect_tree, _ = self.dfs(root, start)
        return time_to_infect_tree

    def dfs(self, root, start):
        if root == None:
            return -1, -1

        left_infect_time, left_distance = self.dfs(root.left, start)
        right_infect_time, right_distance = self.dfs(root.right, start)
		
        if left_distance == -1 and right_distance == -1:
            distance = -1
            infect_time = max(right_infect_time, left_infect_time) + 1

        elif left_distance != -1:
            distance = left_distance + 1
            infect_time = max(left_infect_time, right_infect_time + left_distance + 2)
           
        else:
            distance = right_distance + 1
            infect_time = max(right_infect_time, left_infect_time + right_distance + 2)

        if root.val == start:
            distance = 0

        return infect_time, distance"
find the k sum of an array,"class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        maxSum = sum([max(0, num) for num in nums])
        absNums = sorted([abs(num) for num in nums])
        maxHeap = [(-maxSum + absNums[0], 0)]
        ans = [maxSum]
        while len(ans) < k:
            nextSum, i = heapq.heappop(maxHeap)
            heapq.heappush(ans, -nextSum)
            if i + 1 < len(absNums):
                heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))
                heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))
        return ans[0]"
find the k sum of an array,"class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        maxSum = sum([max(0, num) for num in nums])
        absNums = sorted([abs(num) for num in nums])
        maxHeap, nextSum = [(-maxSum + absNums[0], 0)], -maxSum
        for _ in range(k - 1):
            nextSum, i = heapq.heappop(maxHeap)
            if i + 1 < len(absNums):
                heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))
                heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))
        return -nextSum"
longest subsequence with limited sum,"class Solution:
    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        nums = list(accumulate(sorted(nums)))
        return [bisect_right(nums, q) for q in queries]"
longest subsequence with limited sum,"class Solution: 
    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        prefix = list(accumulate(sorted(nums)))
        return [bisect_right(prefix, q) for q in queries]"
removing stars from a string,"class Solution: 
    def removeStars(self, s: str) -> str:
        stack = []
        for ch in s: 
            if ch == '*': stack.pop()
            else: stack.append(ch)
        return ''.join(stack)"
removing stars from a string,"class Solution:
    def removeStars(self, s: str) -> str:
        c,n=0,len(s)
        t=""""
        for i in range(n-1,-1,-1):
            if s[i]=='*':
                c+=1
            else:
                if c==0:
                    t+=s[i]
                else:
                    c-=1
        return t[-1::-1]"
minimum amount of time to collect garbage,"class Solution:
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        ans = sum(map(len, garbage))
        prefix = list(accumulate(travel, initial=0))
        for ch in ""MPG"": 
            ii = 0 
            for i, s in enumerate(garbage): 
                if ch in s: ii = i 
            ans += prefix[ii]
        return ans"
minimum amount of time to collect garbage,"class Solution:
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        
        from collections import defaultdict

        ans = 0
        lastH = {}
        num = defaultdict(int)

        for i in range(len(garbage)):
            for char in garbage[i]:
                num[char] += 1
                lastH[char] = i
                
        pref = []
        res = 0
        for x in travel:
            res += x
            pref.append(res)

        ans = sum(num.values())
        for k, v in lastH.items():
            if lastH[k] != 0:
                ans += pref[lastH[k] - 1]
            
        return ans"
build a matrix with conditions,"class Solution:
    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        
        def fn(cond): 
            """"""Return topological sort""""""
            graph = [[] for _ in range(k)]
            indeg = [0]*k
            for u, v in cond: 
                graph[u-1].append(v-1)
                indeg[v-1] += 1
            queue = deque(u for u, x in enumerate(indeg) if x == 0)
            ans = []
            while queue: 
                u = queue.popleft()
                ans.append(u+1)
                for v in graph[u]: 
                    indeg[v] -= 1
                    if indeg[v] == 0: queue.append(v)
            return ans 
        
        row = fn(rowConditions)
        col = fn(colConditions)
        
        if len(row) < k or len(col) < k: return []
        ans = [[0]*k for _ in range(k)]
        row = {x : i for i, x in enumerate(row)}
        col = {x : j for j, x in enumerate(col)}
        for x in range(1, k+1): ans[row[x]][col[x]] = x
        return ans"
build a matrix with conditions,"class Solution:
    def buildMatrix(self, n: int, rowC: List[List[int]], colC: List[List[int]]) -> List[List[int]]:
		# create two graphs, one for row and one for columns
        row_adj = {i: [] for i in range(1, n + 1)}
        col_adj = {i: [] for i in range(1, n + 1)}
        for u, v in rowC:
            row_adj[u].append(v)
        for u, v in colC:
            col_adj[u].append(v)
            
        # inorder to do topological sort, we need to maintain two visit lists: one marks which node 
        # we have already processed (because not all nodes are connected to each other and we do not 
        # want to end up in a infinite loop), the other one marks nodes we are currently visiting(or in 
        # our recursion stack). If we visit a node that we are currently visiting, that means there is 
        # a loop, so we return False; if it is not in our current visit but has already been visited, we 
        # can safely travel to the next node and return True. 

        row_stack = []
        row_visit = set()
        row_visiting = set()
        col_stack = []
        col_visit = set()
        col_visiting = set()
        
        def dfs(node, stack, visit, visiting, adj):
            if node in visiting:
                return False
            if node in visit:
                return True
            visit.add(node)
            visiting.add(node)
            for child in adj[node]:
                if not dfs(child, stack, visit, visiting, adj):
                    return False
            visiting.remove(node)
            stack.append(node)
            return True
        
        # do dfs on each row/col graph
        for i in range(1, n + 1):
            if i not in row_visit:
                if not dfs(i, row_stack, row_visit, row_visiting, row_adj):
                    return []
            if i not in col_visit:
                if not dfs(i, col_stack, col_visit, col_visiting, col_adj):
                    return []

		    

        # After the dfs, we also need a stack to store which node has been entirely explored. That's why we 
        # append the current node to our stack after exploring all its neighbors. Remember we have to reverse 
        # the stack after all DFS's, because the first-explored node gets appended first. 
        row_stack, col_stack = row_stack[::-1], col_stack[::-1]
        
        
        # mark position for each element
        row_memo, col_memo = {}, {}
        for idx, num in enumerate(row_stack):
            row_memo[num] = idx
        for idx, num in enumerate(col_stack):
            col_memo[num] = idx
            
        # create an empty matrix as our ans
        ans = [[0]*n for _ in range(n)]
        
        # plug in values from what we have discovered
        for i in range(1, n + 1):
            ans[row_memo[i]][col_memo[i]] = i
        return ans"
find subarrays with equal sum,"class Solution:
    def findSubarrays(self, nums: List[int]) -> bool:
    """""" 
	Bruteforce approch
	""""""
#         for i in range(len(nums)-2):
#             summ1 = nums[i] + nums[i+1]
#             # for j in range(i+1,len(nums)):
#             for j in range(i+1,len(nums)-1):
#                 summ = nums[j] + nums[j+1]
#                 if summ == summ1:
#                     return True
#         return False
	 """"""
	 Sliding Window
	 """"""
        one ,two = len(nums)-2,len(nums)-1      // at end of list
        dic = {}
        while one >= 0:
            # print(one,two)
            summ = nums[one] + nums[two]
            if summ in dic:
                return True               // if already there then there is 2 pairs
            else:
                dic[summ] = 1        // add summ in of window in dictonary
            one -=1
            two -=1
        return False"
find subarrays with equal sum,"class Solution:
	def findSubarrays(self, nums: List[int]) -> bool:

		dictionary = {}

		for i in range(len(nums) - 1):

			subarray_sum = sum(nums[i:i+2])

			if subarray_sum not in dictionary:

				dictionary[subarray_sum] = nums[i:i+2]
			else:
				return True

		return False"
strictly palindromic number,"class Solution:
    def isStrictlyPalindromic(self, n: int) -> bool:
        def int2base(n,b):
            r=""""
            while n>0:
                r+=str(n%b)
                n//=b           
            return int(r[-1::-1])
        for i in range(2,n-1):
            if int2base(n,i)!=n:
                return False
        return True"
strictly palindromic number,"class Solution:
    def isStrictlyPalindromic(self, n: int) -> bool:
        def pald(num):
            if num == num[::-1]:
                return True
            return False
        def pw(num,q):
            res =""""
            while num > 0:
                temp = num % q
                res = str(temp) + res
                num //= q
            return res
        for i in range(2,n-1):
            one = pw(n,i)
            # print(one)
            if not pald(one):
                return False
        return True"
maximum rows covered by columns,"class Solution:
    def maximumRows(self, mat: List[List[int]], cols: int) -> int:
        n,m = len(mat),len(mat[0])
        ans = 0

        def check(state,row,rowIncludedCount):
            nonlocal ans
            if row==n:
                if sum(state)<=cols:
                    ans = max(ans,rowIncludedCount)
                return
            
            check(state[::],row+1,rowIncludedCount)
            for j in range(m):
                if mat[row][j]==1:
                    state[j] = 1
            check(state,row+1,rowIncludedCount+1)
        
        check([0]*m,0,0)
        return ans"
maximum rows covered by columns,"class Solution:
    def maximumRows(self, mat: List[List[int]], cols: int) -> int:
        res = []
        M = len(mat)
        N = len(mat[0])
        def check(seen):
            count = 0
            for row in mat:
                flag = True
                for c in range(N): 
                    if row[c] == 1:
                        if c in seen:
                            continue
                        else:
                            flag = False
                            break
                if flag:    
                    count +=1   
            res.append(count)
                     
        def solve(c,seen,cols):
            if cols == 0:
                check(seen)
                return
            if c == N:
                return
            else:
                seen.add(c)
                solve(c+1,seen,cols-1)
                seen.remove(c)
                solve(c+1,seen,cols)
        seen = set()
        solve(0,seen,cols)
        return max(res)"
maximum number of robots within budget,"class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        
        n=len(chargeTimes)
        start=0
        runningsum=0
        max_consecutive=0
        max_so_far=0
        secondmax=0
        
        for end in range(n):
            runningsum+=runningCosts[end]
            
            if max_so_far<=chargeTimes[end]:
                secondmax=max_so_far
                max_so_far=chargeTimes[end]
                
            k=end-start+1
            
            currentbudget=max_so_far+(k*runningsum)
            
            if currentbudget>budget:
                runningsum-=runningCosts[start]
                max_so_far=secondmax if chargeTimes[start]==max_so_far else max_so_far
                start+=1
				
            max_consecutive=max(max_consecutive,end-start+1)
			
        return max_consecutive"
maximum number of robots within budget,"class Solution:
		def maximumRobots(self, charge: List[int], cost: List[int], budget: int) -> int:
			res, add, start, mxheap = 0, 0, 0, []
			heapify(mxheap)
			for end in range(len(charge)):
				add += cost[end]
				heappush(mxheap, (-1*charge[end], end))
				while mxheap and -1*mxheap[0][0]+(end-start+1)*add > budget:
					add -= cost[start]
					while mxheap and mxheap[0][1] <= start:
						heappop(mxheap)
					start += 1
				res = max(res, end-start+1)
			return res"
check distances between same letters,"class Solution:   # Pretty much explains itself.
    def checkDistances(self, s: str, distance: List[int]) -> bool:
        
        d = defaultdict(list)

        for i, ch in enumerate(s):
            d[ch].append(i)

        return all(b-a-1 == distance[ord(ch)-97] for ch, (a,b) in d.items())"
check distances between same letters,"class Solution:
    def checkDistances(self, s: str, distance: List[int]) -> bool:        
        hashmap = {}
        for i in range(len(s)):
            if s[i] in hashmap and i - hashmap[s[i]] - 1 != distance[ord(s[i]) - ord('a')]:
                return False
            hashmap[s[i]] = i                           
        return True"
number of ways to reach a position after exactly k steps,"class Solution:          # A few points on the problem:
                         #    The start and end is a ""red herring."" The answer to the problem 
                         #     depends only on the distance (dist = end-start) and k.
                         #  
                         #    A little thought will convince one that theres no paths possible 
                         #     if k%2 != dist%2 or if abs(dist) > k.

                         #    The problem is equivalent to:
                         #        Determine the count of distinct lists of length k with sum = dist
                         #        and elements 1 and -1, in which the counts of 1s and -1s in each 
                         #        list differ by dist.
                         # 
                         #    The count of the lists is equal to the number of ways  the combination 
                         #     C((k, (dist+k)//2)). For example, if dist = 1 and k = 5. the count of 1s
						 #.    is (5+1)//2 = 3, and C(5,3) = 10.
                         #     (Note that if dist= -1 in this example, (5-1)//2 = 2, and C(5,2) = 10)

    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:

        dist = endPos-startPos

        if k%2 != dist%2 or abs(dist) > k: return 0

        return comb(k, (dist+k)//2) %1000000007"
number of ways to reach a position after exactly k steps,"class Solution(object):
    def numberOfWays(self, startPos, endPos, k):
        """"""
        :type startPos: int
        :type endPos: int
        :type k: int
        :rtype: int
        """"""
        MOD=1e9+7
        
        dp={}
        
        def A(currpos,k):
            if (currpos,k) in dp:
                return dp[(currpos,k)]
				
			#base case 
            if currpos==endPos and k==0:
                return 1
			#base case
            if k<=0:
                return 0
            
            
            ans1,ans2=0,0
			#move left
            ans1+=A(currpos-1,k-1)
            #move right
            ans2+=A(currpos+1,k-1)
            #sum of left + right possibilities
            dp[(currpos,k)]=(ans1+ans2)%MOD
			#return the result
            return dp[(currpos,k)]
        
        return int(A(startPos,k)%MOD)
            
            
            ```"
longest nice subarray,"class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        maximum_length = 1
        n = len(nums)
        
        current_group = 0
        left = 0
        
        for right in range(n):
			# If the number at the right point is safe to include, include it in the group and update the maximum length.
            if nums[right] &amp; current_group == 0:
                current_group |=nums[right]
                maximum_length = max(maximum_length, right - left + 1)
                continue
                
			# Shrink the window until the number at the right pointer is safe to include.
            while left < right and nums[right] &amp; current_group != 0:    
                current_group &amp;= (~nums[left]) 
                left += 1
            
			# Include the number at the right pointer in the group.
            current_group |= nums[right]
                
        return maximum_length"
longest nice subarray,"class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        l = 0
        r = 0
        n = len(nums)
        
        curr_mask = 0
        ans = 1
        while r < n:
            while l < r and curr_mask &amp; nums[r] != 0:
                curr_mask = curr_mask ^ nums[l]
                l += 1
            
            curr_mask = curr_mask | nums[r]
            r += 1
            ans = max(ans, r - l)
        return ans"
meeting rooms iii,"class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        meetings.sort() # make sure start times are sorted!!
        
        meetingCount = [0 for _ in range(n)]
        availableRooms = list(range(n)); heapify(availableRooms)
        occupiedRooms = []
        
        
        for start, end in meetings:
            while occupiedRooms and start >= occupiedRooms[0][0]:
                heappush(availableRooms, heappop(occupiedRooms)[1]) # frees room and makes it available
            
            if availableRooms:
                roomNumber = heappop(availableRooms)  # assigns next available room
            else:
                freedEnd, roomNumber = heappop(occupiedRooms)  # waits until the next room that would be available gets free
                end += freedEnd - start
            heappush(occupiedRooms, (end,roomNumber))  # make note that the ruom is occupied and when the assigned meeting ends
            meetingCount[roomNumber] += 1  # update meeting counter
            
        return sorted([(count, i) for i, count in enumerate(meetingCount)], key = lambda x: (-x[0], x[1]))[0][1]  # find room with most meetings"
meeting rooms iii,"class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        currentMeetHeap = []
        numOfMeet = n * [0]
        currentMeet = n * [False]
        meetings.sort()
        
        # Removes ended meetings from the heap.
        def clearEnded(cutoff): 
            while len(currentMeetHeap)>0 and cutoff>=currentMeetHeap[0][0]:
                ended = heapq.heappop(currentMeetHeap)
                currentMeet[ended[1]] = False
            
        def addMeeting(room, end):
            currentMeet[room] = True
            numOfMeet[room] += 1
            heapq.heappush(currentMeetHeap, [end,room])
        
        def getFirstMax():
            maxMeet = 0
            maxMeetRoom = 0
            for i in range(len(numOfMeet)): 
                meets = numOfMeet[i]
                if meets > maxMeet: 
                    maxMeet = meets
                    maxMeetRoom = i
            return maxMeetRoom
            
            
        for meeting in meetings:
            # First check if theres any empty rooms at the start of the current meeting.
            # If so, use this room.
            clearEnded(meeting[0])
            added = False
            for i in range(n):
                if not currentMeet[i]:
                    addMeeting(i, meeting[1])
                    added = True
                    break
            if (added):
                continue
				
            # If no meeting rooms initially available, pull a meeting from the heap. 
            # We need to adjust the end time to account for the wait. 
            firstAvailable = heapq.heappop(currentMeetHeap)
            addMeeting(firstAvailable[1], meeting[1]+(firstAvailable[0]-meeting[0]))
        
        return getFirstMax()"
most frequent even element,"class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        ctr = Counter(nums)
        return max([c for c in ctr if not c%2], key = lambda x:(ctr[x], -x), default = -1)"
most frequent even element,"class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        seen = {}
        for item in nums:
            if item % 2 ==0:
                seen[item] = 1 if item not in seen else seen[item] + 1
        maxx = 0    
        output = -1        
        for num, count in seen.items():
            if count > maxx:
                maxx, output = count, num
            elif count == maxx:
                output = min(num,output)
        return output"
optimal partition of string,"class Solution:
    def partitionString(self, s: str) -> int:
        cur = set()
        res = 1
        
        for c in s:
            if c in cur:
                cur = set()
                res += 1
            cur.add(c)
                
        return res"
optimal partition of string,"class Solution:
    def partitionString(self, s: str) -> int:
        sub_set, ans = set(), 1
        for c in s:
            if c in sub_set:
                ans += 1
                sub_set = {c}
            else:
                sub_set.add(c)
        return ans"
divide intervals into minimum number of groups,"class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        pq = []
        for left, right in sorted(intervals):
            if pq and pq[0] < left:
                heappop(pq)
            heappush(pq, right)
        return len(pq)"
divide intervals into minimum number of groups,"class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        pq = []
        for interval in intervals:
            if not pq or interval[0] <= pq[0]:
                heapq.heappush(pq, interval[1])
            else:
				heapq.heappop(pq)
				heapq.heappush(pq, interval[1])
        return len(pq)"
longest increasing subsequence ii,"class Solution:
    def getmax(self, st, start, end):
        maxi = 0
        
        while start < end:
            if start%2:#odd
                maxi = max(maxi, st[start])
                start += 1
            if end%2:#odd
                end -= 1
                maxi = max(maxi, st[end])
            start //= 2
            end //= 2
        return maxi
        
    def update(self, st, maxi, n):
        st[n] = maxi
        while n > 1:
            n //= 2
            st[n] = max(st[2*n], st[2*n+1])
    
    def lengthOfLIS(self, nums: List[int], k: int) -> int:
        ans = 1
        length = max(nums)
        st = [0]*length*2
        for n in nums:
            n -= 1
            maxi = self.getmax(st, max(0, n-k)+length, n+length) + 1
            self.update(st, maxi, n+length)
            ans = max(maxi, ans)
        return ans"
longest increasing subsequence ii,"class Solution:
    def lengthOfLIS(self, nums: List[int], k: int) -> int:
        """"""
        """"""
        ##############
        # Range Minimum Query using Segment Tree
        ##############
        def init(tree, value, k, left, right):
            if len(tree)<k+1:
                tree.extend([None] * (k+1-len(tree)))

            if right - left == 1:
                tree[k] = value
                return

            mid = (left + right)//2
            init(tree, value, 2*k, left, mid)
            init(tree, value, 2*k+1, mid, right)
            tree[k] = max(tree[2*k], tree[2*k+1])

        def update(tree, value, pos, k, left, right):
            if right - left == 1: # only 1 elements
                tree[k] = value
                return

            mid = (left + right)//2
            if pos<mid:
                update(tree, value, pos, 2*k, left, mid)
            else:
                update(tree, value, pos, 2*k+1, mid, right)
            tree[k] = max(tree[2*k], tree[2*k+1])

        def query(tree, l, r, k, left, right):
            if l>=r:
                return None
            elif l<=left and right<=r:
                return tree[k]

            mid = (left + right)//2
            v1 = query(tree, l, min(mid, r), 2*k, left, mid)
            v2 = query(tree, max(l, mid), r, 2*k+1, mid, right)
            v = [v for v in [v1, v2] if v is not None]
            ret = None if len(v) == 0 else max(v)
            return ret
        ##############
        
        n = len(nums)
        # print(nums, k)
        # print(len(nums), max(nums), k)

        segt = []
        sizet = max(nums) + 1
        # init(segt, float(""-inf""), 1, 0, sizet)
        segt = [float(""-inf"")] * (4 * sizet)
        
        dp = [1] * n
        update(segt, dp[0], nums[0], 1, 0, sizet)
        
        for i in range(1, n):
            dpj = query(segt, nums[i]-k, nums[i], 1, 0, sizet)
            if dpj is None:
                dp[i] = 1
            else:
                dp[i] = max(dpj + 1, 1)
            update(segt, dp[i], nums[i], 1, 0, sizet)
            pass
        
        ans = max(dp)
        # print(""ans:"", ans)
        # print(""="" * 20)
        return ans
    
# print = lambda *a, **aa: ()"
count days spent together,"class Solution:
    def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:
        months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        start = max(arAl, arBo)
        end = min(lAl, lBo)

        startDay = int(start[3:])
        startMonth = int(start[:2])
        endDay = int(end[3:])
        endMonth = int(end[:2])
        
        if start > end:
            return 0
        if startMonth == endMonth:
            return endDay-startDay+1
        elif startMonth < endMonth:
            return months[startMonth]-startDay + endDay + 1 + sum(months[m] for m in range(startMonth+1, endMonth))"
count days spent together,"class Solution:
    def calculate(self, time):
        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        return sum(days[:int(time.split('-')[0]) - 1]) + int(time.split('-')[1])

    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:
        alice = [self.calculate(arriveAlice), self.calculate(leaveAlice)]
        bob = [self.calculate(arriveBob), self.calculate(leaveBob)]
        if bob[0] <= alice[0] <= bob[1]:
            if bob[1] <= alice[1]:
                return bob[1] - alice[0] + 1
            else:
                return alice[1] - alice[0] + 1
        elif alice[0] <= bob[0] <= alice[1]:
            if alice[1] <= bob[1]:
                return alice[1] - bob[0] + 1
            else:
                return bob[1] - bob[0] + 1
        else:
            return 0"
maximum matching of players with trainers,"class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        n = len(players)
        m = len(trainers)
        players.sort()
        trainers.sort()
        dp = {}
        def helper(i,j):
            if i==n or j==m:
                return 0
            if (i,j) in dp:
                return dp[(i,j)]
            if players[i]<=trainers[j]:
                dp[(i,j)] = 1+helper(i+1,j+1)
            else:
                dp[(i,j)] = helper(i,j+1)
            return dp[(i,j)]
        return helper(0,0)"
maximum matching of players with trainers,"class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort()
        trainers.sort()
        res = 0
        i, j = 0, 0
        while i < len(players) and j < len(trainers):
            if players[i] <= trainers[j]:
                res += 1
                i += 1
            j += 1
        return res"
smallest subarrays with maximum bitwise or,"class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:

        def create(m):
            t = 0
            for n in m:
                if m[n] > 0:
                    t = t | (1 << n)
            return t
        
        def add(a,m):
            ans = bin( a )
            s = str(ans)[2:]
            for i, b in enumerate( s[::-1]):
                if b == '1':
                    m[i] += 1

        def remove(a,m):
            ans = bin( a )
            s = str(ans)[2:]
            for i, b in enumerate( s[::-1]):
                if b == '1':
                    m[i] -= 1
        
        res = []

        
        n = defaultdict(int)
        for i in nums:
            add(i,n)

        
        m = defaultdict(int)
        r = 0
        c = 0

        for i,v in enumerate(nums):
            # The last check is for if nums[i] == 0, in that case we still want to add to the map
            while r < len(nums) and (create(m) != create(n) or (c==0 and nums[i] ==0)):
                add(nums[r],m)
                r+=1
                c+=1

            res.append(c)

            remove(nums[i],m)
            remove(nums[i],n)
            c-=1

        return res"
smallest subarrays with maximum bitwise or,"class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        ans = defaultdict(deque)
        for i in range(len(nums)):
            for bit in range(31):
                if nums[i] &amp; (1 << bit):
                    ans[bit].append(i)
        res = []
        for i in range(len(nums)):
            end = i
            for _, arr in ans.items():
                if arr and i > arr[0]:
                    arr.popleft()
                if arr:
                    end = max(end, arr[0])
            res.append(end-i+1)
        return res"
minimum money required before transactions,"class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        ans = val = 0 
        for cost, cashback in transactions: 
            ans += max(0, cost - cashback)
            val = max(val, min(cost, cashback))
        return ans + val"
smallest even multiple,"class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
		# it's just asking for LCM of 2 and n
        return lcm(2, n)"
smallest even multiple,"class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
		# alternatively, we can use GCD to calculate LCM
        return (2 * n) // gcd(2, n)"
length of the longest alphabetical continuous substring,"class Solution:
    def longestContinuousSubstring(self, s: str) -> int:

        arr = ''.join(['1' if ord(s[i])-ord(s[i-1]) == 1 
                       else ' ' for i in range(1,len(s))]).split()
                       
        return max((len(ones)+1 for ones in arr), default = 1)"
length of the longest alphabetical continuous substring,"class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        start, max_len = 0, 0
        for i in range(1, len(s) + 1):  # from length 1 to len(s)
            if s[start:i] in alphabet:  # check whether slice is consecutive
                max_len = max(max_len, i - start)
            else:
                start = i - 1
        return max_len"
reverse odd levels of binary tree,"class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def dfs(n1, n2, level):
            if not n1:
                return
            
            if level % 2:
                n1.val, n2.val = n2.val, n1.val
                
            dfs(n1.left,  n2.right, level + 1)
            dfs(n1.right, n2.left,  level + 1)
            
        dfs(root.left, root.right, 1)       
        return root"
reverse odd levels of binary tree,"class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root.left:
            return root
        
        def dfs(node1, node2, rev):
            if rev:
                node1.val, node2.val = node2.val, node1.val
            
            if node1.left:
                dfs(node1.left, node2.right, not rev)
                dfs(node1.right, node2.left, not rev)
    
        dfs(root.left, root.right, True)
        return root"
sum of prefix scores of strings,"class Solution:
	def sumPrefixScores(self, words: List[str]) -> List[int]:

		d = defaultdict(int)

		for word in words:
			for index in range(1, len(word) + 1):
				d[word[:index]] += 1 

		result = []

		for word in words:
			current_sum = 0

			for index in range(1, len(word) + 1):
				current_sum = current_sum + d[word[:index]]

			result.append(current_sum)

		return result"
sum of prefix scores of strings,"class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        d = dict()
        for i in words:
            s=""""
            for j in range(len(i)):
                s+=i[j]
                if s in d:
                    d[s]+=1
                else:
                    d[s]=1
        l=[]
        for i in words:
            c = 0
            s=""""
            for j in range(len(i)):
                s+=i[j]
                c+=d[s]
            l.append(c)
        return l"
sort the people,"class Solution:                   # Ex: names = [""Larry"",""Curly"",""Moe""]   heights = [130,125,155] 

    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:

        _,names = zip(*sorted(zip(heights,names), reverse = True))   
                                  # zipped   --> [(130,""Larry""), (125,""Curly""), (155,""Moe"")  ]
                                  # sorted   --> [(155,""Moe""  ), (130,""Larry""), (125,""Curly"")]
                                  # unzipped --> _ = (155,130,125) , names = (""Moe"",""Larry"",""Curly"")
        
		return  list(names)       # list(names) = [""Moe"",""Larry"",""Curly""]"
sort the people,"class Solution:
    """"""
    Time:   O(n*log(n))
    Memory: O(n)
    """"""

    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        return [name for _, name in sorted(zip(heights, names), reverse=True)]"
longest subarray with maximum bitwise and,"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        max_n = max(nums)
        return max(len(list(it)) for n, it in groupby(nums) if n == max_n)"
longest subarray with maximum bitwise and,"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        maxim = max(nums)
        result = 1
        current = 0
        for num in nums:
            if (num == maxim):
                current = current + 1
                result = max(result, current)
            else:
                current = 0
        return result"
find all good indices,"class Solution:
    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        ### forward pass.
        forward = [False]*len(nums) ### For the forward pass, store if index i is good or not.
        stack = []
        for i in range(len(nums)):
        	### if the leangth of stack is greater or equal to k, it means this index is good.
            if len(stack)>=k:
                forward[i] = True
            ### if the stack is empty, just add the current number to it.
            if not stack:
                stack.append(nums[i])
            ### check to see if the current number is smaller or equal to the last number in stack, if it is not, put this number into the stack.
            else:
                if nums[i]<=stack[-1]:
                    stack.append(nums[i])
                else:
                    stack = [nums[i]]
        ### backward pass
        res = []
        stack = []
        for i in reversed(range(len(nums))):
        	### Check to see if the length of stack is greater or equal to k and also check if the forward pass at this index is Ture.
            if len(stack)>=k and forward[i]:
                res.append(i)
            if not stack:
                stack.append(nums[i])
            else:
                if nums[i]<=stack[-1]:
                    stack.append(nums[i])
                else:
                    stack = [nums[i]]
        return res[::-1]"
find all good indices,"class Solution:
    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        
        non_inc_prefix = [1] * n
        for i in range(1, n-1):
            if nums[i-1] >= nums[i]:
                non_inc_prefix[i] += non_inc_prefix[i-1]
                
        non_dec_suffix = [1] * n
        for i in range(n-2, 0, -1):
            if nums[i] <= nums[i+1]:
                non_dec_suffix[i] += non_dec_suffix[i+1]

        good = []
        for i in range(k, n - k):
            if non_inc_prefix[i-1] >= k <= non_dec_suffix[i+1]:
                good.append(i)
        
        return good"
number of good paths,"class Solution:
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
        n = len(vals)
        
        g = defaultdict(list)
        
        # start from node with minimum val
        for a, b in edges:
            heappush(g[a], (vals[b], b))
            heappush(g[b], (vals[a], a))

        
        loc = list(range(n))
        
        def find(x):
            if loc[x] != x:
                loc[x] = find(loc[x])
            return loc[x]
        
        def union(x, y):
            a, b = find(x), find(y)
            if a != b:
                loc[b] = a
        
        # node by val
        v = defaultdict(list)
        for i, val in enumerate(vals):
            v[val].append(i)
        
        ans = n
        
        
        for k in sorted(v):
            for node in v[k]:
                # build graph if neighboring node <= current node val
                while g[node] and g[node][0][0] <= k:
                    nei_v, nei = heappop(g[node])
                    union(node, nei)
            
            # Count unioned groups
            grp = Counter([find(x) for x in v[k]])
            
            # for each unioned group, select two nodes (order doesn't matter)
            ans += sum(math.comb(x, 2) for x in grp.values())            
        
        return ans"
number of good paths,"class Solution:
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
        def find(root, x):
            if root[x]==x:
                return x
            else:
                root[x] = find(root, root[x])
                return root[x]
            
        n = len(vals)
        
        nodes = {}
        for i in range(n):
            nodes[vals[i]] = nodes.get(vals[i], set([]))
            nodes[vals[i]].add(i)
        print(""nodes:"", nodes)
        
        adj = [[] for _ in range(n)]
        for ai, bi in edges:
            adj[ai].append(bi)
            adj[bi].append(ai)
        print(""adj:"", adj)
        
        keys = sorted(nodes.keys(), key = lambda x: x)
        
        root = list(range(n))
        ans = len(root)
        print(""Init:"", ""root:"", root, ""ans:"", ans)
        for k in keys:
            q = nodes[k]
            for u in q:
                for v in adj[u]:
                    if vals[v]<=vals[u]:
                        root_u = find(root, u)
                        root_v = find(root, v)
                        if root_u != root_v:
                            root[root_u] = root_v
            levels = {}
            for u in q:
                root_u = find(root, u)
                levels[root_u] = levels.get(root_u, 0) + 1
            cnt = sum([levels[i]*(levels[i]-1)//2 for i in levels])
            ans = ans + cnt
  
            print(""+ val"", k, root, levels, cnt)
        
        print(""ans:"", ans)
        print(""="" * 20, ""\n"")
        return ans
        pass

print = lambda *a, **aa: ()"
remove letter to equalize frequency,"class Solution:
    def equalFrequency(self, word: str) -> bool:
        cnt = Counter(Counter(word).values())
        if (len(cnt) == 1):
            return list(cnt.keys())[0] == 1 or list(cnt.values())[0] == 1
        if (len(cnt) == 2):
            f1, f2 = min(cnt.keys()), max(cnt.keys())
            return (f1 + 1 == f2 and cnt[f2] == 1) or (f1 == 1 and cnt[f1] == 1)
        return False"
remove letter to equalize frequency,"class Solution:
    def equalFrequency(self, word: str) -> bool:
        return any(len(set(Counter(word[:i]+word[i+1:]).values()))==1 for i in range(len(word)))"
bitwise xor of all pairings,"class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = map(len, (nums1, nums2))
        return (m % 2 * reduce(xor, nums2)) ^ (n % 2 * reduce(xor, nums1))"
bitwise xor of all pairings,"class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        n1 = len(nums1)%2
        n2 = len(nums2)%2

        n1xor = 0 
        n2xor = 0 
        
        if n2 == 1:
            for n in nums1:
                n1xor ^= n
        
        if n1 == 1:
            for n in nums2:
                n2xor ^= n      

        return n1xor ^ n2xor"
number of pairs satisfying inequality,"class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        n=len(nums1)
        for i in range(n):
            nums1[i]=nums1[i]-nums2[i]
        ans=0
        arr=[]
        for i in range(n):
            x=bisect_right(arr,nums1[i]+diff)
            ans+=x
            insort(arr,nums1[i])
        return ans"
number of pairs satisfying inequality,"class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:        
        q = []
        n = len(nums1)
        ans = 0
        for i in reversed(range(n)):            
            cur = nums1[i] - nums2[i] - diff
            loc = bisect.bisect_left(q, cur)
            ans += len(q) - loc
            bisect.insort(q, cur + diff)           
        return ans"
number of common factors,"class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        c=0
        mi=min(a,b)
        for i in range(1,mi+1):
            if a%i==0 and b%i==0:
                c+=1
        return c"
number of common factors,"class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        count = 0
        c, d  = max(a,b), min(a,b)
        for x in range(1,c):
            if c % x == 0:
                if d % x == 0:
                    count += 1
        if a == b:
            count += 1
        return count"
maximum sum of an hourglass,"class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        res=0
        cur=0
        
        for i in range(len(grid)-2):
            for j in range(1,len(grid[0])-1):
               
                cur=sum(grid[i][j-1:j+2]) +grid[i+1][j] + sum(grid[i+2][j-1:j+2])
                res = max(res,cur)
                                                     
        return res"
maximum sum of an hourglass,"class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        # ps is our 2D array to store prefix sum
        ps = [[0] * (n + 1) for _ in range(m + 1)]
        ps[1][1] = grid[0][0]

        # prepare prefix sum
        for i in range(2, n + 1):
            ps[1][i] = grid[0][i - 1] + ps[1][i - 1]
        for i in range(2, m + 1):
            ps[i][1] = grid[i - 1][0] + ps[i - 1][1]
        for i in range(2, m + 1):
            for j in range(2, n + 1):
                ps[i][j] = ps[i - 1][j] + ps[i][j - 1] - ps[i - 1][j - 1] + grid[i - 1][j - 1]

        # go through each square of (9 cells)
        res = 0
        for i in range(3, m + 1):
            for j in range(3, n + 1):
                curr = ps[i][j] - grid[i - 2][j - 3] - grid[i - 2][j - 1]
                curr = curr - ps[i][j - 3] - ps[i - 3][j] + ps[i - 3][j - 3]
                res = max(res, curr)
                # print(ps[i][j])
        return res"
minimize xor,"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:       
        nbit1 = 0
        while num2>0:
            nbit1 = nbit1 + (num2&amp;1)
            num2 = num2 >> 1
        # print(nbit1)
        
        chk = []
        ans = 0
        # print(bin(num1), bin(ans))
        for i in range(31, -1, -1):
            biti = (num1>>i)&amp;1
            if biti==1 and nbit1>0:
                num1 = num1 &amp; ~(1<<i)
                ans = ans | (1<<i)
                chk.append(i)
                nbit1 -= 1
        # print(bin(num1), bin(ans))
        
        if nbit1>0:
            for i in range(0, 32, 1):
                biti = (num1>>i)&amp;1
                if i not in chk and nbit1>0:
                    num1 = num1 | (1<<i)
                    ans = ans | (1<<i)
                    nbit1 -= 1
        # print(bin(num1), bin(ans))
        # print(""="" * 20)
        
        return ans"
minimize xor,"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        numBitsToSet = 0
        while num2:
            numBitsToSet += num2 &amp; 1
            num2 = num2 >> 1
        
        num1Str = bin(num1)[2:]
        num1Len = len(num1Str)
        
        outLen = max(num1Len, numBitsToSet)
        out = ['0' for i in range(outLen)]
        
        num1Str = '0'*(outLen-num1Len) + num1Str
        
        #print('numBitsToSet', numBitsToSet, 'num1Len', num1Len, 'num1Str', num1Str, 'outLen', outLen)
        
        # Match the 1s of num1
        for i in range(outLen):
            if numBitsToSet == 0:
                break
            if num1Str[i] == '1':
                out[i] = '1'
                numBitsToSet -= 1
        
        # Set minimal bits that are 0
        for i in range(outLen-1, -1, -1):
            if numBitsToSet == 0:
                break
            if out[i] == '0':
                out[i] = '1'
                numBitsToSet -= 1
        
        #print('Modified out', out)
        return int(''.join(out), 2)"
maximum deletions on a string,"class Solution:
    def deleteString(self, s: str) -> int:
        n = len(s)
        if len(set(s)) == 1:
            return n
        dp = [1] * n
        for i in range(n - 2, -1, -1):
            for l in range(1, (n - i) // 2 + 1):
                if s[i : i + l] == s[i + l : i + 2 * l]:
                    dp[i] = max(dp[i], 1 + dp[i + l])
        return dp[0]"
maximum deletions on a string,"class Solution:
    def deleteString(self, s: str) -> int:
        n = len(s)
        if len(set(s)) == 1:
            return n
        dp, M = [1] * n, [1] * n
        for i in range(n - 2, -1, -1):
            for l in range(1, (n - i) // 2 + 1):
                if dp[i] >= M[i + l] + 1:
                    break
                if s[i : i + l] == s[i + l : i + 2 * l]:
                    dp[i] = max(dp[i], 1 + dp[i + l])
            M[i] = max(dp[i], M[i + 1])
        return dp[0]"
the employee that worked on the longest task,"class Solution:
    """"""
    Time:   O(n)
    Memory: O(1)
    """"""

    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:
        best_id = best_time = start = 0

        for emp_id, end in logs:
            time = end - start
            if time > best_time or (time == best_time and best_id > emp_id):
                best_id = emp_id
                best_time = time
            start = end

        return best_id"
the employee that worked on the longest task,"class Solution:
    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:
        times = [logs[0][1]]
        max_time = times[0]
        for i in range(1, len(logs)):
            times.append(logs[i][1]-logs[i-1][1])
            max_time = max(max_time, times[i])
            
        id = 500     
        for i in range(len(times)):
            if times[i] == max_time:
                id = min(id, logs[i][0])
                
        return id"
find the original array of prefix xor,"class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        ans = [0 for i in range(len(pref))]
        ans[0] = pref[0]
        for i in range(1, len(pref)):
            ans[i] = pref[i-1]^pref[i]
        return ans"
find the original array of prefix xor,"class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        xor = 0
        ans = []
        for i in range(len(pref)):
            ans.append(pref[i]^xor)
            xor ^= ans[i]
        return ans"
using a robot to print the lexicographically smallest string,"class Solution:
    def robotWithString(self, s: str) -> str:
        cnt, lo, p, t = Counter(s), 'a', [], []
        for ch in s:
            t += ch
            cnt[ch] -= 1
            while lo < 'z' and cnt[lo] == 0:
                lo = chr(ord(lo) + 1)
            while t and t[-1] <= lo:
                p += t.pop()
        return """".join(p)"
using a robot to print the lexicographically smallest string,"class Solution:
    def robotWithString(self, s: str) -> str:
        dic, t, ans = Counter(s), [], []
        for char in s:
            t.append(char)
            if dic[char] == 1:
                del dic[char]
            else:
                dic[char] -= 1
            while dic and t and min(dic) >= t[-1]:
                ans += t.pop()
        ans += t[::-1]
        return ''.join(ans)"
paths in matrix whose sum is divisible by k,"class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        dp = [[[0 for i in range(k)] for _ in range(len(grid[0]))] for _ in range(len(grid))]
        rem = grid[0][0] % k
        dp[0][0][rem] = 1
        for i in range(1, len(grid[0])):
            dp[0][i][(rem + grid[0][i]) % k] = 1
            rem = (rem + grid[0][i]) % k
        rem = grid[0][0] % k
        for j in range(1, len(grid)):
            dp[j][0][(rem + grid[j][0]) % k] = 1
            rem = (rem + grid[j][0]) % k
        for i in range(1, len(grid)):
            for j in range(1, len(grid[0])):
                for rem in range(k):
                    dp[i][j][(rem + grid[i][j]) % k] = dp[i - 1][j][rem] + dp[i][j - 1][rem]
        return dp[-1][-1][0] % (10**9 + 7)"
paths in matrix whose sum is divisible by k,"class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        p=10**9+7
        m=len(grid)
        n=len(grid[0])
        
        lst=[([0]*k if j else [1]+[0]*(k-1)) for j in range(n)]

        for i in range(m):
            gr=grid[i]
            klst=[0]*k
            for j in range(n):
                g=gr[j]
                l=lst[j]
                klst=[(klst[(r-g)%k]+l[(r-g)%k])%p for r in range(k)]
                lst[j]=klst

        return lst[-1][0]"
number of valid clock times,"class Solution:
    def countTime(self, t: str) -> int:
        mm = (6 if t[3] == '?' else 1) * (10 if t[4] == '?' else 1)
        match [t[0], t[1]]:
            case ('?', '?'):
                return mm * 24
            case ('?', ('0' | '1' | '2' | '3')):
                return mm * 3
            case ('?', _):
                return mm * 2
            case (('0' | '1'), '?'):
                return mm * 10
            case (_, '?'):
                return mm * 4
        return mm"
number of valid clock times,"class Solution:
    def countTime(self, time: str) -> int:
        res = 1
		# split hour and minute digits
        h1, h2, _ ,  m1, m2 = time
        
        if h1 == ""?"" and h2 == ""?"":
            res*=24
        elif h1 == ""?"":
            if int(h2) >=4:
                res*=2
            else:
                res*=3
                
        elif h2 == ""?"":
            if int(h1) <= 1:
                res*=10
            elif h1 == ""2"":
                res*=4
                
        if m1 == ""?"" and m2 == ""?"":
            res*=60
        elif m1 == ""?"":
            res*=6
        elif m2 == ""?"":
            res*=10
        
        return res"
range product queries of powers,"class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        MOD = (10**9)+7
        binary = bin(n)[2:]
        powers = []
        result = []
        for index, val in enumerate(binary[::-1]):
            if val == ""1"":
                powers.append(2**index)
                
        for index in range(1, len(powers)):
            powers[index] = powers[index] * powers[index - 1]    
        
        for l,r in queries:
            if l == 0:
                result.append(powers[r]%MOD)
            else:
                result.append((powers[r]//powers[l-1])%MOD)
                
        return result"
range product queries of powers,"class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        a=bin(n)[2:]
        # print(a)
        a=a[::-1]
        arr=[1]
        p=1
        for i in range(len(a)):
            if(a[i]==""1""):
                p*=2**i
                arr.append(p)
        ans=[]
        print(arr)
        for q in queries:
            p=arr[q[1]+1]//arr[q[0]]
            ans.append(p%(10**9+7))
        return ans"
minimize maximum of array,"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        return max(ceil(n / (i + 1)) for i, n in enumerate(accumulate(nums)))"
minimize maximum of array,"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        max_ = sum_ = 0
		
        for i, num in enumerate(nums, start = 1):
            sum_ += num
            ave, modulo = divmod(sum_, i)
            if modulo: ave += 1
            max_ = max(ave, max_)

        return max_
    # end minimizeArrayValue()"
create components with same value,"class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1
        return 0"
create components with same value,"class Solution:
    def getFactors(self, x):
        factors = []
        for i in range(1, int(sqrt(x)) + 1):
            if x % i != 0: continue
            factors.append(i)
            if x // i != i: factors.append(x // i)
        return factors

    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        graph = defaultdict(list)
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        self.cntRemainZero = 0
        def dfs(u, p, sumPerComponent): # return remain of the subtree with root `u`
            remain = nums[u]
            for v in graph[u]:
                if v == p: continue
                remain += dfs(v, u, sumPerComponent)
                
            remain %= sumPerComponent
            if remain == 0:
                self.cntRemainZero += 1
                
            return remain
        
        def isGood(sumPerComponent, expectedNumOfComponents):
            self.cntRemainZero = 0
            dfs(0, -1, sumPerComponent)
            return self.cntRemainZero == expectedNumOfComponents
        
        sumAllNodes, maxNum = sum(nums), max(nums)
        for sumPerComponent in sorted(self.getFactors(sumAllNodes)):
            if sumPerComponent < maxNum: continue  # at least maxNum
            expectedNumOfComponents = sumAllNodes // sumPerComponent
            if isGood(sumPerComponent, expectedNumOfComponents):
                return expectedNumOfComponents - 1 # Need to cut `numOfComponent - 1` edges to make `numOfComponent` connected component
            
        return 0"
largest positive integer that exists with its negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums.sort()
        for i in nums[::-1]:
            if -i in nums:
                return i
        return -1"
largest positive integer that exists with its negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if 0-nums[i] in s:
                return nums[i]
        return -1"
count number of distinct integers after reverse operations,"class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        return len(set([int(str(i)[::-1]) for i in nums] + nums))"
count number of distinct integers after reverse operations,"class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        n=len(nums)
		#traversing through loop
        for i in range(n):
            nums.append(int(str(nums[i])[::-1])) #using string slicing and appending reverse of the number at end
        return len(set(nums)) #returning the length of set to get unique value count"
sum of number and its reverse,"class Solution:
    def sumOfNumberAndReverse(self, num: int) -> bool:
        digits = []
        while num > 0:
            digits.append(num % 10)
            num = num // 10

        digits.reverse()
        hi, lo = 0, len(digits) - 1
        while hi <= lo:
            if hi == lo:
                if digits[hi] % 2 == 0:
                    break
                else:
                    return False
            if digits[hi] == digits[lo]:
                hi += 1
                lo -= 1
            elif digits[hi] == 1 and digits[hi] != digits[lo]:
                digits[hi] -= 1
                digits[hi+1] += 10
                hi += 1
                if lo != hi:
                    digits[lo] += 10
                    digits[lo-1] -= 1
                    cur = lo - 1
                    while digits[cur] < 0:
                        digits[cur] = 0
                        digits[cur-1] -= 1
                        cur -= 1
                
            elif digits[hi]-1 == digits[lo] and hi + 1 < lo:
                    digits[hi]-= 1
                    digits[hi+1] += 10
                    hi += 1
                    lo -= 1
                # else:
                #     return False
            elif digits[hi] - 1 == digits[lo] + 10 and hi + 1 < lo:
                digits[hi] -= 1
                digits[hi+1] += 10
                digits[lo-1] -= 1
                cur = lo - 1
                while digits[cur] < 0:
                    digits[cur] = 0
                    digits[cur-1] -= 1
                    cur -= 1     
                digits[lo] += 10
            elif hi-1>=0 and lo+1<=len(digits)-1 and digits[hi-1] == 1 and digits[lo+1] == 1:
                digits[hi-1] -= 1
                digits[hi] += 10
                digits[lo+1] += 10
                digits[lo] -= 1
                cur = lo
                while digits[cur] < 0:
                    digits[cur] = 0
                    digits[cur-1] -= 1
                    cur -= 1
                lo += 1
            else:
                return False
        return True"
sum of number and its reverse,"class Solution:
    def sumOfNumberAndReverse(self, num: int) -> bool:
        def check(a,b):
            return b==int(str(a)[-1::-1])
        t=num
        i=0
        while i<=t:
            if i+t==num:
                if check(t,i):
                    return True
            i+=1
            t-=1
        return False"
count subarrays with fixed bounds,"class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        if minK > maxK: return 0
        
        def count(l, r):
            if l + 1 == r: return 0
            dic = Counter([nums[l]])
            ans, j = 0, l + 1
            for i in range(l + 1, r):
                dic[nums[i - 1]] -= 1
                while not dic[minK] * dic[maxK] and j < r:
                    dic[nums[j]] += 1
                    j += 1
                if dic[minK] * dic[maxK]: ans += r - j + 1
                else: break
            return ans
        
        arr = [-1] + [i for i, num in enumerate(nums) if num < minK or num > maxK] + [len(nums)]
        return sum(count(arr[i - 1], arr[i]) for i in range(1, len(arr)))"
count subarrays with fixed bounds,"class Solution:
    # Travel from left to right and if you find minK assing p1 to it and when you find maxK assing p2 to it
    # When you find p1 and p2 both with valid numbers in between all the numbers left of p1 which are valid
    # will be added to the answer. As you keep travelling right keep adding all the valid numbers from the left of p1
    # as those all will contribute to the answer! Hence wew need a variable to store leftmost id of valid number.
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        res = 0
        p1 = p2 = left = -1
        for right in range(len(nums)):
            if nums[right] == minK: p1 = right
            if nums[right] == maxK: p2 = right
            if nums[right] < minK or nums[right] > maxK: left = right
            res += max(0, (min(p1, p2) - left))
        return res"
determine if two events have conflict,"class Solution:
    """"""
    Time:   O(1)
    Memory: O(1)
    """"""

    def haveConflict(self, a: List[str], b: List[str]) -> bool:
        a_start, a_end = a
        b_start, b_end = b
        return b_start <= a_start <= b_end or \
               b_start <= a_end <= b_end or \
               a_start <= b_start <= a_end or \
               a_start <= b_end <= a_end"
determine if two events have conflict,"class Solution:
    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        e1s=int(event1[0][:2])*60 + int(event1[0][3:])
        e1e=int(event1[1][:2])*60 + int(event1[1][3:])
        e2s=int(event2[0][:2])*60 + int(event2[0][3:])
        e2e=int(event2[1][:2])*60 + int(event2[1][3:])
        if e1s<=e2s<=e1e: return True
        if e2s<=e1s<=e2e: return True
        if e1s<=e2e<=e1e: return True
        if e2s<=e1e<=e2e: return True
        else: return False"
number of subarrays with gcd equal to k,"class Solution:
    def subarrayGCD(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = 0
        for i in range(n):
            temp = nums[i]
            for j in range(i, n):
                temp = math.gcd(temp, nums[j])
                if temp == k:
                    ans += 1
                elif temp < k:
                    break
        return ans"
number of subarrays with gcd equal to k,"class Solution:
    def subarrayGCD(self, nums, k):
        n, count = len(nums), 0

        for i in range(n):
            ans = nums[i]
            for j in range(i,n):
                ans = math.gcd(ans,nums[j])
                if ans == k:
                    count += 1
                elif ans < k:
                    break

        return count"
minimum cost to make array equal,"class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        arr = sorted(zip(nums, cost))
        total, cnt = sum(cost), 0
        for num, c in arr:
            cnt += c
            if cnt > total // 2:
                target = num
                break
        return sum(c * abs(num - target) for num, c in arr)"
minimum cost to make array equal,"class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        n = len(nums)
        # Sort by nums
        arr = sorted((nums[i], cost[i]) for i in range(n))
        nums = [i[0] for i in arr]
        cost = [i[1] for i in arr]

        # Compute DP left to right
        left2right = [0] * n
        curr = cost[0]
        for i in range(1, n):
            left2right[i] = left2right[i - 1] + (nums[i] - nums[i - 1]) * curr
            curr += cost[i]

        # Compute DP right to left
        right2left = [0] * n
        curr = cost[-1]
        for i in range(n - 2, -1, -1):
            right2left[i] = right2left[i + 1] + (nums[i + 1] - nums[i]) * curr
            curr += cost[i]
            
        return min(left2right[i] + right2left[i] for i in range(n))"
minimum number of operations to make arrays similar,"class Solution:
    def makeSimilar(self, A: List[int], B: List[int]) -> int:
        if sum(A)!=sum(B): return 0
        # The first intuition is that only odd numbers can be chaged to odd numbers and even to even hence separate them
        # Now minimum steps to making the target to highest number in B is by converting max of A to max of B similarily
        # every number in A can be paired with a number in B by index hence sorting
        # now we need only the number of positives or number of negatives.
        oddA,evenA=[i for i in A if i%2],[i for i in A if i%2==0]
        oddB,evenB=[i for i in B if i%2],[i for i in B if i%2==0]        
        oddA.sort(),evenA.sort()
        oddB.sort(),evenB.sort()
        res=0
        for i,j in zip(oddA,oddB):
            if i>=j: res+=i-j
        
        for i,j in zip(evenA,evenB):
            if i>=j: res+=i-j
        
        return res//2"
minimum number of operations to make arrays similar,"class Solution:
    def makeSimilar(self, nums: List[int], target: List[int]) -> int:
        return sum(map(lambda p:abs(p[1]-p[0]), zip(list(sorted([i + 10**9 * (i%2) for i in nums])), list(sorted([j + 10**9 * (j%2) for j in target])))))>>2"
odd string difference,"class Solution:
    def oddString(self, words: List[str]) -> str:
        k=len(words[0])
        arr=[]
        for i in words:
            l=[]
            for j in range(1,k):
                diff=ord(i[j])-ord(i[j-1])
                l.append(diff)
            arr.append(l)
        for i in range(len(arr)):
            if arr.count(arr[i])==1:
                return words[i]"
odd string difference,"class Solution:
    def oddString(self, words: List[str]) -> str:
        
        # go through all of the words find and track all the diffs
        cn = collections.defaultdict(list)
        for idx, word in enumerate(words):
            
            # get the difference array
            diff_arr = Solution.difference_array(word)

            # append to the counter
            cn[diff_arr].append(idx)
        
        # get the searched element
        ele = min(cn.values(), key=len)
        return words[ele[0]]
    
    @staticmethod
    def difference_array(word: str):
        return tuple(map(lambda x: ord(word[x[0]]) - ord(x[1]), zip(range(1,len(word)), word[:-1])))"
words within two edits of dictionary,"class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        # T: ((N + M) * L^3), S: O(M * L^3)
        N, M, L = len(queries), len(dictionary), len(queries[0])
        validWords = set()
        
        for word in dictionary:
            for w in self.wordModifications(word):
                validWords.add(w)
        
        ans = []
        for word in queries:
            for w in self.wordModifications(word):
                if w in validWords:
                    ans.append(word)
                    break

        return ans
    
    def wordModifications(self, word):
        # T: O(L^3)
        L = len(word)
        for i in range(L):
            yield word[:i] + ""*"" + word[i+1:]

        for i, j in itertools.combinations(range(L), 2):
            yield word[:i] + ""*"" + word[i+1:j] + ""*"" + word[j+1:]"
words within two edits of dictionary,"class Solution:
    def twoEditWords(self, queries, dictionary):
        n, ans = len(queries[0]), []

        for i in queries:
            for j in dictionary:
                if sum(i[k] != j[k] for k in range(n)) < 3:
                    ans.append(i)
                    break

        return ans"
destroy sequential targets,"class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:
		# example:  nums = [3,7,8,1,1,5], space = 2
        groups = defaultdict(list)
        for num in nums:
            groups[num % space].append(num)
        
        # print(groups) # defaultdict(<class 'list'>, {1: [3, 7, 1, 1, 5], 0: [8]}) groups is [3, 7, 1, 1, 5] and [8] 
        """""" min of [3, 7, 1, 1, 5] can destroy all others (greedy approach) => 1 can destory 1,3,5,7 ... """"""
        performance = defaultdict(list)
        for group in groups.values():
            performance[len(group)].append(min(group))
        
        # print(performance) # defaultdict(<class 'list'>, {5: [1], 1: [8]})
		# nums that can destory 5 targets are [1], nums that can destory 1 target are [8] 
        return min(performance[max(performance)])"
destroy sequential targets,"class Solution:
    def destroyTargets(self, nums, space):
        dict1 = defaultdict(int)

        for i in nums:
            dict1[i%space] += 1

        max_val = max(dict1.values())

        return min([i for i in nums if dict1[i%space] == max_val])"
next greater element iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s, ss = [], []
        for i, x in enumerate(nums): 
            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x
            buff = []
            while s and nums[s[-1]] < x: buff.append(s.pop())
            while buff: ss.append(buff.pop())
            s.append(i)
        return ans"
next greater element iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        from sortedcontainers import SortedList as slist
        l=len(nums)
        ans=[-1]*l
        print(ans)
        lst=slist([(nums[0], 0, [])], key=lambda x:(x[0], x[1]))
        i=1
        while i<l:
            tmp=nums[i]
            j=0
            while j<len(lst) and lst[j][0]<tmp:
                lst[j][2].append(nums[i])
                if len(lst[j][2])>=2:
                    ans[lst[j][1]]=lst[j][2][1]
                    lst.discard(lst[j])
                else:
                    j+=1
            lst.add((nums[i], i, []))
            i+=1
        return ans"
average value of even numbers that are divisible by three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        l=[]
        for i in nums:
            if i%6==0:
                l.append(i)
        return sum(l)//len(l) if len(l)>0 else 0"
average value of even numbers that are divisible by three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        s=0
        k=0
        for i in nums:
            if i%6==0:
                k+=1
                s+=i
        
        if k==0:
            return 0
        else:
            return(s//k)"
most popular video creator,"class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
        memo = {}
		#tracking the max popular video count
        overall_max_popular_video_count = -1
        #looping over the creators
        for i in range(len(creators)):
            if creators[i] in memo:
                #Step 1: update number of views for the creator
                memo[creators[i]][0] += views[i]
                #Step 2: update current_popular_video_view and id_of_most_popular_video_so_far
                if memo[creators[i]][2] < views[i]:
                    memo[creators[i]][1] = ids[i]
                    memo[creators[i]][2] = views[i]
                #Step 2a: finding the lexicographically smallest id as we hit the current_popularity_video_view again!
                elif memo[creators[i]][2] == views[i]:
                    memo[creators[i]][1] = min(memo[creators[i]][1],ids[i])
            else:
			#adding new entry to our memo
			#new entry is of the format memo[creator[i]] = [total number current views for the creator, store the lexicographic id of the popular video, current popular view of the creator]
                memo[creators[i]] = [views[i],ids[i],views[i]]
			#track the max popular video count
            overall_max_popular_video_count = max(memo[creators[i]][0],overall_max_popular_video_count)
        
        result = []
        for i in memo:
            if memo[i][0] == overall_max_popular_video_count:
                result.append([i,memo[i][1]])
        return result"
most popular video creator,"class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:

        pop = defaultdict(int)

        pop_small = defaultdict(list)

        for i,creator in enumerate(creators):
            
            pop[creator] += views[i]
            
            heappush(pop_small[creator], [-views[i],ids[i]])
        
        m = max(pop.values())
        
        res = []
        for creator in pop:
            if pop[creator] == m:
                res.append([creator, pop_small[creator][0][1]])

        return res"
minimum addition to make integer beautiful,"class Solution:
    def makeIntegerBeautiful(self, n: int, target: int) -> int:
        i=n
        l=1
        while i<=10**12:
            s=0
            for j in str(i):
                s+=int(j)
            if s<=target:
                return i-n
            i//=10**l
            i+=1
            i*=10**l
            l+=1"
minimum addition to make integer beautiful,"class Solution:
    def makeIntegerBeautiful(self, n: int, target: int) -> int:

        # the sum of digits by addition only gets smaller if we
        # get zeros certain digits by going to the next power
        # of ten for that digit, which increases the previous
        # digit by one
        
        # lets get the digits of the number
        digits = [int(ch) for ch in list(str(n))]
        
        # compute the prefix sum for the digits
        digits_acc = list(itertools.accumulate(digits))

        # check the last sum to immediately break
        if digits_acc[-1] <= target:
            return 0
        
        # go through the digits and check when we are lower than
        # the target
        found = False
        for idx in range(len(digits)-1, -1, -1):
            if digits_acc[idx] < target:
                found = True
                break
        
        # now get the number
        if found:
            number = reduce(lambda x, y: x*10 + y, digits[:idx+1]) + 1
            number *= 10**(len(digits)-idx-1)
        else:
            number = 10**(len(digits))

        return number - n"
height of binary tree after subtree removal queries,"class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        depth = {}
        height = {}
        nodes_at_depth = {}

        max_height = 0

        def rec(n, d):
            nonlocal max_height
            if n is None:
                return 0
            height_below = max(rec(n.left, d+1), rec(n.right, d+1))
            v = n.val
            depth[v] = d
            h = d + 1 + height_below
            height[v] = h
            max_height = max(max_height, h)

            if d not in nodes_at_depth:
                nodes_at_depth[d] = [v]
            else:
                nodes_at_depth[d].append(v)

            return 1 + height_below


        rec(root, -1)  # subtract one because the problem reports heights weird
        ret = []


        for q in queries:
            if height[q] >= max_height:
                d = depth[q]
                for cousin in nodes_at_depth[depth[q]]:
                    if cousin != q:  # don't count self, obviously
                        d = max(d, height[cousin])
                ret.append(d)  
            else:
                ret.append(max_height)
        
        return ret"
height of binary tree after subtree removal queries,"class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        depth = {}
        height = {0 : 0}
        
        def fn(node, d): 
            if not node: return 0 
            depth[node.val] = d
            height[node.val] = 1 + max(fn(node.left, d+1), fn(node.right, d+1))
            return height[node.val]
        
        h = fn(root, 0)
        level = [[0, 0] for _ in range(h)]
        for k, v in depth.items(): 
            if height[k] >= height[level[v][0]]: level[v] = [k, level[v][0]]
            elif height[k] > height[level[v][1]]: level[v][1] = k
        ans = []
        for q in queries: 
            d = depth[q]
            if q == level[d][0]: ans.append(h-1-height[q]+height[level[d][1]])
            else: ans.append(h-1)
        return ans"
apply operations to an array,"class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)-1):
            if nums[i]==nums[i+1]:
                nums[i]*=2
                nums[i+1]=0                
        temp = []
        zeros = []
        a=nums
        for i in range(len(a)):
            if a[i] !=0:
                temp.append(a[i])
            else:
                zeros.append(a[i])
        return (temp+zeros)"
apply operations to an array,"class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        l=[]
        c=0
        for i in range(len(nums)-1):
            if(nums[i]==nums[i+1]):
                nums[i]=nums[i]*2
                nums[i+1]=0
        for i in nums:
            if i!=0:
                l.append(i)
            else:
                c+=1
        return l+[0]*c"
maximum sum of distinct subarrays with length k,"class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        
        seen = collections.Counter(nums[:k]) #from collections import Counter (elements and their respective count are stored as a dictionary)
        summ = sum(nums[:k])
        
        
        res = 0
        if len(seen) == k:
            res = summ
            
            
        for i in range(k, len(nums)):
            summ += nums[i] - nums[i-k]
            seen[nums[i]] += 1
            seen[nums[i-k]] -= 1
            
            if seen[nums[i-k]] == 0:
                del seen[nums[i-k]]
                
            if len(seen) == k:
                res = max(res, summ) 
                
        return res"
maximum sum of distinct subarrays with length k,"class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        window = Counter(nums[:k])
        size = len(window)
        n = len(nums)
        running = sum(nums[:k])
        max_total = running if size == k else 0

        for i in range(k, n):
            out, v = nums[i-k], nums[i]
            window[out] -= 1
            if window[out] == 0:
                window.pop(out)
                size -= 1
            
            if v in window:
                window[v] += 1
            else:
                window[v] = 1
                size += 1
            
            running = running + v - out
            #print(f""{i}: {nums[i]}; {running} | {window}"")
            if size == k and running > max_total:
                max_total = running

        return max_total"
total cost to hire k workers,"class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        q = costs[:candidates]
        qq = costs[max(candidates, len(costs)-candidates):]
        heapify(q)
        heapify(qq)
        ans = 0 
        i, ii = candidates, len(costs)-candidates-1
        for _ in range(k): 
            if not qq or q and q[0] <= qq[0]: 
                ans += heappop(q)
                if i <= ii: 
                    heappush(q, costs[i])
                    i += 1
            else: 
                ans += heappop(qq)
                if i <= ii: 
                    heappush(qq, costs[ii])
                    ii -= 1
        return ans"
total cost to hire k workers,"class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        from heapq import heappush, heappop

        heap = []

        p1 = 0
        p2 = len(costs)-1

        while(p1 < candidates):
            heappush(heap, (costs[p1], p1))
            p1 += 1

        while(p2 >= len(costs)-candidates and p2 >= p1):
            heappush(heap, (costs[p2], p2))
            p2 -= 1

        res = 0
        for i in range(k):
            c, idx = heappop(heap)

            res += c

            if idx < p1:
                if p1 <= p2:
                    heappush(heap, (costs[p1], p1))
                    p1 += 1
            else:
                if p1 <= p2:
                    heappush(heap, (costs[p2], p2))
                    p2 -= 1

        return res"
minimum total distance traveled,"class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        robot.sort()
        factory.sort()
        m, n = len(robot), len(factory)
        dp = [[0]*(n+1) for _ in range(m+1)] 
        for i in range(m): dp[i][-1] = inf 
        for j in range(n-1, -1, -1): 
            prefix = 0 
            qq = deque([(m, 0)])
            for i in range(m-1, -1, -1): 
                prefix += abs(robot[i] - factory[j][0])
                if qq[0][0] > i+factory[j][1]: qq.popleft()
                while qq and qq[-1][1] >= dp[i][j+1] - prefix: qq.pop()
                qq.append((i, dp[i][j+1] - prefix))
                dp[i][j] = qq[0][1] + prefix
        return dp[0][0]"
minimum total distance traveled,"class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:        
        robot.sort()
        factory.sort()
        cap = []
        for x, limit in factory:
            cap.extend([x] * limit)
        m = len(robot)
        n = len(cap)
        indices = list(range(m))
        ans = sum(abs(x - y) for x, y in zip(robot, cap))
        
        def increment(i):
            diff = 0
            while i < m:
                if indices[i] + 1 < n:
                    diff -= abs(robot[i] - cap[indices[i]])
                    diff += abs(robot[i] - cap[indices[i] + 1])
                else:
                    return math.inf, i + 1
                if i + 1 < m and indices[i] + 1 == indices[i + 1]:
                    i += 1
                else:
                    return diff, i + 1
        for i in reversed(range(m)):
            while True:
                diff, j = increment(i)
                if diff <= 0:
                    ans += diff
                    for x in range(i, j):
                        indices[x] += 1
                else:
                    break
        return ans"
number of distinct averages,"class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        av=[]
        nums.sort()
        while nums:
            av.append((nums[-1]+nums[0])/2)
            nums.pop(-1)
            nums.pop(0)
        return len(set(av))"
number of distinct averages,"class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        nums.sort()
        seen = set()
        for i in range(len(nums)//2): 
            seen.add((nums[i] + nums[~i])/2)
        return len(seen)"
count ways to build good strings,"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        def recursive(s,ans):
            if len(s)>=low and len(s)<=high:
                ans+=[s]
            if len(s)>high:
                return 
            recursive(s+""0""*zero,ans)
            recursive(s+""1""*one,ans)
            return
        ans=[]
        recursive("""",ans)
        return len(ans)"
count ways to build good strings,"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        
        ans=[0]
        def recursive(s):
            if s>high:
                return 0
            p=recursive(s+zero)+recursive(s+one)
            if s>=low and s<=high:
                p+=1
            return p
        return recursive(0)%(10**9+7)"
most profitable path in a tree,"class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        path_b = set([bob])
        lvl_b = {bob:0}
        g = defaultdict(list)
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)
        n = len(amount)
        node_lvl = [0] * n
        q = deque([0])
        
        lvl = 0
        seen = set([0])
        while q:
            size = len(q)
            for _ in range(size):
                u = q.popleft()
                node_lvl[u] = lvl
                for v in g[u]:
                    if v in seen:
                        continue
                    q.append(v)
                    seen.add(v)
            lvl += 1
        b = bob
        lvl = 1
        while b != 0:
            for v in g[b]:
                if node_lvl[v] > node_lvl[b]:
                    continue
                b = v
                cost = amount[b]
                path_b.add(b)
                lvl_b[b] = lvl
                break
            lvl += 1
        # print(f""lvl_b {lvl_b} path_b {path_b}  "")
        cost_a = []
        q = deque([(0, amount[0])])
        seen = set([0])
        lvl = 1
        while q:
            size = len(q)
            for _ in range(size):
                u, pre_cost = q.popleft()
                child_cnt = 0
                for v in g[u]:
                    if v in seen:
                        continue
                    seen.add(v)
                    child_cnt += 1
                    cost = pre_cost
                    inc = amount[v]
                    if v in path_b:
                        if lvl_b[v] == lvl:
                            cost += inc//2
                        elif lvl_b[v] > lvl:
                            cost += inc
                        else:
                            cost += 0
                    else:
                        cost += amount[v]
                    q.append((v, cost))
                if child_cnt == 0:
                    cost_a.append(pre_cost)
            lvl += 1
        ans = max(cost_a)
        return ans"
most profitable path in a tree,"class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        n = 1 + len(edges)
        tree = [[] for _ in range(n)]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        seen = [False] * n
        
        def dfs(u, d): 
            """"""Return """"""
            seen[u] = True
            ans = -inf 
            dd = 0 if u == bob else n 
            for v in tree[u]: 
                if not seen[v]: 
                    x, y = dfs(v, d+1)
                    ans = max(ans, x)
                    dd = min(dd, y)
            if ans == -inf: ans = 0
            if d == dd: ans += amount[u]//2
            if d < dd: ans += amount[u]
            return ans, dd+1
        
        return dfs(0, 0)[0]"
split message based on limit,"class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        def splitable_within(parts_limit):
            # check the message length achievable with <parts_limit> parts
            length = sum(limit - len(str(i)) - len(str(parts_limit)) - 3 for i in range(1, parts_limit + 1))
            return length >= len(message)
        
        parts_limit = 9
        if not splitable_within(parts_limit):
            parts_limit = 99
        if not splitable_within(parts_limit):
            parts_limit = 999
        if not splitable_within(parts_limit):
            parts_limit = 9999
        if not splitable_within(parts_limit):
            return []
        
        # generate the actual message parts
        parts = []
        m_index = 0  # message index
        for part_index in range(1, parts_limit + 1):
            if m_index >= len(message): break
            length = limit - len(str(part_index)) - len(str(parts_limit)) - 3
            parts.append(message[m_index:m_index + length])
            m_index += length
        
        return [f'{part}<{i + 1}/{len(parts)}>' for i, part in enumerate(parts)]"
split message based on limit,"class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        if limit <= 5: return []
        
        # Important: Determine number of digit of b. BS monotone holds for same digit-count  
        # This will fix the testcase like: message = ""abbababbbaaa aabaa a"", limit = 8
        nd = -1
        for dc in range(1, 7):
            remain = len(message)
            for d in range(1, dc+1): 
                if limit - 3 - d - dc < 0: break
                remain -= (limit - 3 - d - dc)*9*10**(d-1)
            if remain <= 0:
                nd = dc
                break
        if nd == -1: return []
        
        # binary search of b
        start, end = 10**(nd - 1), 10 ** nd
        while start != end:
            mid = (start + end) // 2
            dc = len(str(mid))
            remain = len(message) 
            for d in range(1, dc):
                remain -= (limit - 3 - d - dc)*9*10**(d-1)
            for i in range(10**(dc-1), mid + 1):
                remain -= limit - 3 - 2*dc 
                if remain < 0: break
            # print(start, end, mid, remain)
            if remain > 0: start = mid + 1
            else: end = mid

        # construct answer
        ans = []
        dc = len(str(start))
        cur = 0
        for d in range(1, dc + 1):
            for i in range(10**(d-1), 10**d):
                nxt = min(cur + limit - 3 - d - dc, len(message))
                ans.append(message[cur:nxt] + '<' + str(i) + '/' + str(start) + '>')
                cur = nxt
                if nxt >= len(message): break
                
        if cur < len(message): return []
        return ans"
convert the temperature,"class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        return [(celsius + 273.15),(celsius * 1.80 + 32.00)]"
convert the temperature,"class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        return [celsius + 273.15, celsius * 1.8 + 32]"
number of subarrays with lcm equal to k,"class Solution:
    def subarrayLCM(self, nums: List[int], k: int) -> int:
        def find_lcm(num1, num2):
            if(num1>num2):
                num = num1
                den = num2
            else:
                num = num2
                den = num1
            rem = num % den
            while(rem != 0):
                num = den
                den = rem
                rem = num % den
            gcd = den
            lcm = int(int(num1 * num2)/int(gcd))
            return lcm
        count=0
        for i in range(len(nums)):
            lcm=1
            for j in range(i,len(nums)):
                lcm=find_lcm(nums[j],lcm)
                
                if lcm==k:
                    count+=1
                if lcm>k:
                    break
        return count"
number of subarrays with lcm equal to k,"class Solution:
    def subarrayLCM(self, nums, k):
        n, count = len(nums), 0

        for i in range(n):
            temp = nums[i]
            for j in range(i,n):
                temp = math.lcm(temp,nums[j])
                if temp == k:
                    count += 1
                elif temp > k:
                    break

        return count"
minimum number of operations to sort a binary tree by level,"class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        ans = 0 
        queue = deque([root])
        while queue: 
            vals = []
            for _ in range(len(queue)): 
                node = queue.popleft()
                vals.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            mp = {x : i for i, x in enumerate(sorted(vals))}
            visited = [0]*len(vals)
            for i in range(len(vals)): 
                cnt = 0 
                while not visited[i] and i != mp[vals[i]]: 
                    visited[i] = 1
                    cnt += 1
                    i = mp[vals[i]]
                ans += max(0, cnt-1)
        return ans"
minimum number of operations to sort a binary tree by level,"class Solution:
    def cntSwap(self,arr):
        
        n = len(arr)
        cnt = 0
        a = sorted(arr)
        index = {}
        
		# store index of elements in arr
        for ind in range(n):
            index[arr[ind]] = ind

        for ind in range(n):
			
			# If element in arr is out of position we need to swap hence increase cnt
            if (arr[ind] != a[ind]):
                cnt += 1
                pos = arr[ind]
                
				# Replace it with element that should be at this ""ind"" in arr using a[ind]
                arr[ind], arr[index[a[ind]]] = arr[index[a[ind]]], arr[ind]
				
				# Update the indexes for swaped elements in ""index""
                index[pos] = index[a[ind]]
                index[a[ind]] = ind

        return cnt
    
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        
        res = 0
        q = [root]
        # Level order traversal
        while q :
            
            level = []
            values = []
            for n in q:
                
                if n.left :
                    level.append(n.left)
                    values.append(n.left.val)
                
                if n.right :
                    level.append(n.right)
                    values.append(n.right.val)
            
            res += self.cntSwap(values)
            q = level
        
        return res"
maximum number of non overlapping palindrome substrings,"class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        for i in range(k, n + 1):
            dp[i] = dp[i - 1]
            for length in range(k, k + 2):
                j = i - length
                if j < 0:
                    break
                if self.isPalindrome(s, j, i):
                    dp[i] = max(dp[i], 1 + dp[j])
        return dp[-1]
    
    
    def isPalindrome(self, s, j, i):
        left, right = j, i - 1
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True"
maximum number of non overlapping palindrome substrings,"class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n=len(s)
        def checkIfPalindrome(i,j):
            while i<j:
                if s[i]!=s[j]:
                    return False
                i+=1
                j-=1
            return True
        @lru_cache(2000)
        def dp(i,j):
            if i>=n or j>=n or (j-i)>k+1:
                return 0
            if s[i]==s[j]:
                if checkIfPalindrome(i,j):
                    return 1+dp(j+1,j+k)
            return max(dp(i,j+1),dp(i+1,j+1))
        return dp(0,k-1)"
number of unequal triplets in array,"class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        c = Counter(nums)
        res = 0
        
        left = 0
        right = len(nums)
        
        for _, freq in c.items():
            right -= freq
            res += left * freq * right
            left += freq
        
        return res"
number of unequal triplets in array,"class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        count = 0
        prev, nxt = 0, len(nums)
        for _, frequency in Counter(nums).items():
            nxt -= frequency
            count += prev * frequency * nxt
            prev += frequency
        return count"
closest nodes queries in a binary search tree,"class Solution(object):
    def closestNodes(self, root, queries):
        def dfs(root, arr):
            if not root: return
            dfs(root.left, arr)
            arr.append(root.val)
            dfs(root.right, arr)
        arr = []
        dfs(root, arr)
        ans = []
        n = len(arr)
        for key in queries:
            left, right = 0, n - 1
            while right >= left:
                mid = (right + left) // 2
                if arr[mid] == key:
                    break
                elif arr[mid] > key:
                    right = mid - 1
                else:
                    left = mid + 1
            if arr[mid] == key:
                ans.append([arr[mid], arr[mid]])
            elif arr[mid] > key:
                if (mid - 1) >= 0:
                    ans.append([arr[mid - 1], arr[mid]])
                else:
                    ans.append([-1, arr[mid]])
            else:
                if (mid + 1) < n:
                    ans.append([arr[mid], arr[mid + 1]])
                else:
                    ans.append([arr[mid], -1])
        return ans"
closest nodes queries in a binary search tree,"class Solution:
    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
        nums = []
        def dfs(node):
            if node:
                nums.append(node.val)
                if node.left:
                    dfs(node.left)
                if node.right:
                    dfs(node.right)
        
        dfs(root)
        nums.sort()
        n = len(nums)
        ans = []
        
        for i in range(len(queries)):
            left = 0
            right = n - 1
            
            while right > left:
                mid = (left + right)//2
                if nums[mid] == queries[i]:
                    left = right = mid
                elif nums[mid] > queries[i]:
                    right = mid
                elif nums[mid] < queries[i]:
                    left = mid + 1
            
            if nums[right] == queries[i]:
                sub = (nums[left], nums[right])
            elif nums[right] > queries[i]:
                sub = (nums[right-1], nums[right]) if right - 1 >= 0 else (-1, nums[right])
            elif nums[right] < queries[i]:
                sub = (nums[left], nums[left]) if left + 1 < n else (nums[left], -1)
            
            ans.append(sub)
        
        return ans"
minimum fuel cost to report to the capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        n = len(roads) + 1
        graph = defaultdict(list)
        for a, b in roads:
            graph[a].append(b)
            graph[b].append(a)
        
        def dfs(u, p):
            cnt = 1
            for v in graph[u]:
                if v == p: continue
                cnt += dfs(v, u)
            if u != 0:
                self.ans += math.ceil(cnt / seats)  # number of litters for `cnt` people to travel from node `u` to node `p`
            return cnt
                
        self.ans = 0
        dfs(0, -1)
        return self.ans"
minimum fuel cost to report to the capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        graph = defaultdict(list)
        for e in roads:
            graph[e[0]].append(e[1])
            graph[e[1]].append(e[0])
        visited = set()
        fuel = [0]
        def dfs(node):
            visited.add(node)
            people = 0
            for n in graph[node]:
                if n in visited:
                    continue
                p = dfs(n)
                people += p
                fuel[0] += ceil(p / seats)
            if not people:
                return 1
            return people + 1
        dfs(0)
        return fuel[0]"
number of beautiful partitions,"class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        n = len(s)
        MOD = 10**9 + 7

        def isPrime(c):
            return c in ['2', '3', '5', '7']

        @lru_cache(None)
        def dp(i, k):
            if k == 0 and i <= n:
                return 1
            if i >= n:
                return 0

            ans = dp(i+1, k)  # Skip
            if isPrime(s[i]) and not isPrime(s[i-1]):  # Split
                ans += dp(i+minLength, k-1)
            return ans % MOD

        if not isPrime(s[0]) or isPrime(s[-1]): return 0

        return dp(minLength, k-1)"
number of beautiful partitions,"class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        n = len(s)
        primes = ['2', '3', '5', '7']
        
        # pruning
        if k * minLength > n or s[0] not in primes or s[-1] in primes:
            return 0
        
        # posible starting indexes of a new partition
        ids = [0]
        for i in range(n-1):
            if s[i] not in primes and s[i+1] in primes:
                ids.append(i+1)
        m = len(ids)

        @cache
        # dp(i, kk) means number of ways to partition s[ids[i]:n] into kk partitions
        def dp(i, kk):
            
            # kk==1: last remaining partition, needs to have length >= l
            if kk == 1:
                return 1 if ids[i]+minLength-1 <= n-1 else 0
            res = 0
            
            # iterate possible starting index of next partition
            for j in range(i+1, m-kk+2):
                if ids[j]-ids[i] >= minLength:
                    res += dp(j, kk-1)
            
            return res % (10**9+7)
        
        return dp(0, k)"
